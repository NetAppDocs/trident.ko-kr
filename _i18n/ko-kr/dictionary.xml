<?xml version="1.0" encoding="UTF-8"?>
<blocks>
  <block id="ae8e28c37a725c4bb4a74663ac8615ea" category="summary">Astra Trident가 볼륨 액세스 그룹을 사용하는 방법에 대해 자세히 알아보십시오.</block>
  <block id="b4621305109716b02eed0cf25fabab13" category="doc">볼륨 액세스 그룹</block>
  <block id="33911b1eec54b4b5a7fbc504e6569989" category="inline-link">볼륨 액세스 그룹</block>
  <block id="649833006ff7b612c3d988173b6417d5" category="paragraph">Astra Trident가 사용하는 방법에 대해 자세히 알아보십시오<block ref="783dd6ea9e0b09c84db9ccd072a61c55" category="inline-link-rx"></block>.</block>
  <block id="e93c18adf30bc91499234d0ec7863499" category="admonition">CHAP를 사용하는 경우 이 섹션을 무시하십시오. CHAP는 관리를 단순화하고 아래 설명된 배율 제한을 피하는 것이 좋습니다. 또한 CSI 모드에서 Astra Trident를 사용하는 경우 이 섹션을 무시할 수 있습니다. Astra Trident는 향상된 CSI 구축 기능으로 설치된 경우 CHAP를 사용합니다.</block>
  <block id="3c56a859b413098b6bf2c54aff32a842" category="paragraph">Astra Trident는 볼륨 액세스 그룹을 사용하여 프로비저닝하는 볼륨에 대한 액세스를 제어할 수 있습니다. CHAP를 비활성화하면 구성에 하나 이상의 액세스 그룹 ID를 지정하지 않는 한 "트리덴트"라는 액세스 그룹을 찾을 수 있습니다.</block>
  <block id="025d19ee81e813e3ba40553cd4908638" category="paragraph">Astra Trident는 새 볼륨을 구성된 액세스 그룹에 연결하지만 액세스 그룹 자체를 생성하거나 관리하지 않습니다. 스토리지 백엔드를 Astra Trident에 추가하기 전에 액세스 그룹이 있어야 하며, 해당 백엔드에서 프로비저닝한 볼륨을 마운트할 수 있는 Kubernetes 클러스터의 모든 노드에서 iSCSI IQN을 포함해야 합니다. 대부분의 설치에서는 클러스터의 모든 작업자 노드를 포함합니다.</block>
  <block id="6c92285fa6d3e827b198d120ea3ac674" category="inline-link">여기</block>
  <block id="dff8ca466bae899e4dbc68c3a552033f" category="paragraph">64개 이상의 노드가 있는 Kubernetes 클러스터의 경우 다중 액세스 그룹을 사용해야 합니다. 각 액세스 그룹에는 최대 64개의 IQN이 포함될 수 있으며 각 볼륨은 4개의 액세스 그룹에 속할 수 있습니다. 최대 4개의 액세스 그룹이 구성되어 있는 경우, 클러스터의 모든 노드에서 최대 256개의 노드 크기로 모든 볼륨에 액세스할 수 있습니다. 볼륨 액세스 그룹에 대한 최신 제한은 를 참조하십시오<block ref="ac4000c3a85e5909daa6593f9f0617fd" category="inline-link-rx"></block>.</block>
  <block id="4f5254b466f691d7b0c50fb0d8286075" category="paragraph">기본 '트리덴트' 액세스 그룹을 사용하는 설정을 다른 액세스 그룹에도 사용하는 설정으로 수정하는 경우 목록에 '트리덴트' 액세스 그룹의 ID를 포함합니다.</block>
  <block id="4d5445eb6c70cdab8d3ad5e71367f42a" category="summary">Astra Trident가 드라이버를 위한 볼륨 스냅샷 생성을 어떻게 처리하는지 자세히 알아보십시오.</block>
  <block id="e9c3828cd06711f9036bb4ce862a32c5" category="doc">볼륨 스냅숏</block>
  <block id="98c670ffe759cc20cd8a31d49bd0b4fc" category="list-text">'ONTAP-SAN-이코노미' 드라이버의 경우 PVS는 공유된 FlexVol에 매핑됩니다. PVS의 볼륨 스냅샷은 연결된 LUN의 FlexClone을 수행하여 구현됩니다. ONTAP의 FlexClone 기술을 사용하면 최대 규모의 데이터 세트의 복사본을 거의 즉시 생성할 수 있습니다. 복사본은 데이터 블록을 부모님과 공유하므로 메타데이터에 필요한 것만 빼고 스토리지를 사용하지 않습니다.</block>
  <block id="9dbabbadda024bb7b1d0db43ab31b45f" category="list-text">'솔라이드산' 드라이버의 경우, 각 PV는 NetApp Element 소프트웨어/NetApp HCI 클러스터에서 생성된 LUN에 매핑됩니다. 볼륨 스냅샷은 기본 LUN의 요소 스냅샷으로 표시됩니다. 이러한 스냅샷은 특정 시점 복제본이며 소량의 시스템 리소스와 공간만 차지합니다.</block>
  <block id="34f731018ae783f70901b14b4950c3a7" category="list-text">ONTAP-NAS와 ONTAP-SAN 드라이버를 함께 사용할 경우 ONTAP 스냅샷은 FlexVol의 시점 복사본으로 FlexVol 자체의 공간을 사용합니다. 따라서 스냅샷이 생성/예약될 때 시간이 경과함에 따라 볼륨의 쓰기 가능한 공간이 줄어들 수 있습니다. 이 문제를 해결하는 간단한 방법 중 하나는 Kubernetes를 통해 크기를 조정하여 볼륨을 늘리는 것입니다. 또 다른 옵션은 더 이상 필요하지 않은 스냅샷을 삭제하는 것입니다. Kubernetes를 통해 생성된 VolumeSnapshot이 삭제되면 Astra Trident가 연결된 ONTAP 스냅샷을 삭제합니다. Kubernetes를 통해 생성되지 않은 ONTAP 스냅샷도 삭제할 수 있습니다.</block>
  <block id="1eb824f8d9b30b3f4e089938e719fefe" category="paragraph">Astra Trident를 사용하면 VolumeSnapshots을 사용하여 새 PVS를 생성할 수 있습니다. 이러한 스냅샷에서 PVS를 생성하는 작업은 지원되는 ONTAP 및 CVS 백엔드에 FlexClone 기술을 사용하여 수행됩니다. 스냅샷으로부터 PV를 생성할 때, 백업 볼륨은 스냅샷의 상위 볼륨의 FlexClone입니다. '솔드파이어-SAN' 드라이버는 Element 소프트웨어 볼륨 클론을 사용하여 스냅샷에서 PVS를 생성합니다. 여기서 Element 스냅샷으로부터 클론을 생성합니다.</block>
  <block id="d00888bc1409d1c598b90af117bd3551" category="summary">Astra Trident의 프로비저닝에는 두 가지 주요 단계가 있습니다. 첫 번째 단계에서는 스토리지 클래스를 적절한 백엔드 스토리지 풀 세트와 연결하고 용량 할당 전에 필요한 준비 작업으로 수행됩니다. 두 번째 단계에서는 볼륨 생성 자체를 포함하며 보류 중인 볼륨의 스토리지 클래스와 연결된 스토리지 풀에서 스토리지 풀을 선택해야 합니다.</block>
  <block id="89c3bcf0ecc1114f8d19734d9156cb40" category="doc">프로비저닝</block>
  <block id="2bd42f922a8c0b54b90557eba2071a76" category="paragraph">백엔드 스토리지 풀을 스토리지 클래스와 연결하려면 스토리지 클래스의 요청된 속성과 해당 'toragePools', 'additionalStoragePools' 및 'excludeStoragePools' 목록이 모두 필요합니다. 스토리지 클래스를 생성할 때 Trident는 각 백엔드에서 제공하는 특성과 풀을 스토리지 클래스에서 요청한 속성과 비교합니다. 스토리지 풀의 속성과 이름이 요청된 모든 속성 및 풀 이름과 일치하면 Astra Trident는 해당 스토리지 클래스에 적합한 스토리지 풀 세트에 해당 스토리지 풀을 추가합니다. 또한 Astra Trident는 "additionalStoragePools" 목록에 나열된 모든 스토리지 풀을 해당 집합에 추가합니다. 이는 특성이 스토리지 클래스의 요청된 속성 중 일부 또는 전부를 충족하지 못하는 경우에도 마찬가지입니다. 스토리지 클래스에 사용할 스토리지 풀을 재정의하고 제거하려면 'excludeStoragePools' 목록을 사용해야 합니다. Astra Trident는 새 백엔드를 추가할 때마다 유사한 프로세스를 수행하여 스토리지 풀이 기존 스토리지 클래스의 풀을 충족하는지 확인하고 제외로 표시된 항목을 제거합니다.</block>
  <block id="668ccb4dd1c284f07a3062637c57d21a" category="paragraph">그런 다음 Astra Trident는 스토리지 클래스와 스토리지 풀 간의 연결을 사용하여 볼륨을 프로비저닝할 위치를 결정합니다. 볼륨을 생성할 때 Astra Trident는 먼저 해당 볼륨의 스토리지 클래스에 대한 스토리지 풀 세트를 가져옵니다. 볼륨의 프로토콜을 지정한 경우 Astra Trident는 요청된 프로토콜을 제공할 수 없는 스토리지 풀을 제거합니다(예: NetApp HCI/SolidFire 백엔드는 파일 기반 볼륨을 제공할 수 없고 ONTAP NAS 백엔드는 블록 기반 볼륨을 제공할 수 없음). Astra Trident는 이 결과 집합의 순서를 무작위로 생성하여 볼륨을 균일하게 분산시킨 다음 이를 반복함으로써 각 스토리지 풀에서 볼륨을 차례로 프로비저닝합니다. 이 오류가 1에서 성공하면 프로세스에서 발생한 모든 오류를 로깅하여 성공적으로 반환됩니다. Astra Trident는 * 요청된 스토리지 클래스 및 프로토콜에 대해 사용 가능한 모든 * 스토리지 풀을 프로비저닝하지 못한 경우에만 실패 * 를 반환합니다.</block>
  <block id="7c738d9c13e4e5770c6b455ab345afd7" category="paragraph">또한 Astra Trident는 NetApp Astra의 기본 기술로서 스냅샷, 백업, 복제 및 복제를 위한 NetApp의 업계 최고 데이터 관리 기술을 활용하여 Kubernetes 워크로드의 데이터 보호, 재해 복구, 이동성 및 마이그레이션 사용 사례를 다룹니다.</block>
  <block id="4bd05efa612e48dd723de2bdd29f88e2" category="section-title">지원되는 Kubernetes 클러스터 아키텍처</block>
  <block id="85b179f2c10f76f0171b4d9d3f2d5171" category="paragraph">Astra Trident는 다음 Kubernetes 아키텍처에서 지원됩니다.</block>
  <block id="c91cda04d3ac5ae2da327d347d4bbefe" category="cell">Kubernetes 클러스터 아키텍처</block>
  <block id="eaa4dc5078017a5c5bebf383ab6f5124" category="cell">지원</block>
  <block id="c0057eecd4b1a67d11dc801b8992a574" category="cell">기본 설치</block>
  <block id="0c69c79a8788e0e4572d0c4838e69401" category="cell">단일 마스터, 컴퓨팅</block>
  <block id="93cba07454f06a4a960172bbd6e2a435" category="cell">예</block>
  <block id="d41d8cd98f00b204e9800998ecf8427e" category="doc"></block>
  <block id="1fc3441370ae575a64d605fcd15a05fd" category="cell">다중 마스터, 컴퓨팅</block>
  <block id="7cb2eb9488f3532834f7ef233ae894dd" category="cell">마스터, "etcd", 컴퓨팅</block>
  <block id="5e5f49db20e29f6377e57e98932dae57" category="cell">마스터, 인프라, 컴퓨팅</block>
  <block id="ae663d0d321764bd88b8d864cd3afc9e" category="section-title">아스트라(Astra)란?</block>
  <block id="dd91e88f9a6ec30684f494c41baeeee0" category="paragraph">Astra를 사용하면 퍼블릭 클라우드와 온프레미스 모두에서 Kubernetes에서 실행되는 데이터 기반의 컨테이너 워크로드를 손쉽게 관리, 보호 및 이동할 수 있습니다. Astra는 퍼블릭 클라우드 및 온프레미스에 있는 NetApp의 검증되고 광범위한 스토리지 포트폴리오의 Astra Trident를 사용하여 영구 컨테이너 스토리지를 프로비저닝하고 제공합니다. 또한, 스냅샷, 백업 및 복원, 활동 로그, 데이터 보호, 재해/데이터 복구, 데이터 감사, Kubernetes 워크로드의 마이그레이션 사용 사례를 위한 액티브 클론 복제와 같은 풍부한 고급 애플리케이션 인식 데이터 관리 기능을 제공합니다.</block>
  <block id="2a778cf7220cdde142651975e1bcd90f" category="paragraph">가상 풀 목록 외부에서 지정된 모든 측면은 백엔드에 대해 전역적이며 모든 가상 풀에 적용되지만, 각 가상 풀은 하나 이상의 측면을 개별적으로 지정할 수 있습니다(백엔드-글로벌 측면 재정의).</block>
  <block id="e1b3ec89ead7f83a9245ed5c9cacfdbf" category="cell">운영자</block>
  <block id="0a52730597fb4ffa01fc117d9e71e3a9" category="cell">예</block>
  <block id="b5a7adde1af5c87d7fd797b6245c2a39" category="cell">설명</block>
  <block id="499badcb6f450c7f46c51d873eb84286" category="cell">`='</block>
  <block id="354653142ec321459dfd6d71444e992e" category="cell">성능 = 프리미엄</block>
  <block id="5a5292b0a0d0379f0f1b12801b09b266" category="cell">`!='</block>
  <block id="eccde6822783bd75209c9b6a2d357f6c" category="cell">성능!=최고</block>
  <block id="ae2bef277194f73d24a36a78009aac1e" category="cell">"IN"입니다</block>
  <block id="f8cf8c23afb5459dbf7c24b685caf85b" category="cell">위치(동쪽, 서쪽)</block>
  <block id="1a031eecbce49366e550273b9321b909" category="cell">노신입니다</block>
  <block id="b5585f3f9b45f391fee5dd15e6516450" category="cell">성능 노트(실버, 브론즈)</block>
  <block id="48dec026afe488df8faca35c5c3a39ea" category="summary">Trident 설치에서 Element 백엔드를 만들고 사용하는 방법에 대해 알아보십시오.</block>
  <block id="f58e95baa778c9a2bd1a4597fb49d9b7" category="doc">ONTAP 드라이버</block>
  <block id="0e842f431ce1b4dfb57598e5682e3adc" category="paragraph">Astra Trident는 ONTAP 클러스터와 통신할 수 있도록 5개의 고유한 ONTAP 스토리지 드라이버를 제공합니다. 각 드라이버가 볼륨 생성, 액세스 제어 및 해당 기능을 처리하는 방법에 대해 자세히 알아보십시오.</block>
  <block id="48cf24486d9a8e65a142b25682f19949" category="cell">드라이버</block>
  <block id="888a77f5ac0748b6c8001822417df8b6" category="cell">프로토콜</block>
  <block id="1b5e109e8afd1f9b7f5bbf951eea3442" category="cell">볼륨 모드</block>
  <block id="d5e2d9f8d8f10044e38b71b49e675d2e" category="cell">액세스 모드가 지원됩니다</block>
  <block id="15971126972a002fcddb2c507534e371" category="cell">지원되는 파일 시스템</block>
  <block id="00055dac2ba112b87a95a368075b9561" category="cell">'ONTAP-NAS'</block>
  <block id="1d1a594959ec615f56516f5d0f5e8ddb" category="paragraph">NFS 를 참조하십시오</block>
  <block id="ac52cf637478f3656a1fdee5c02324fd" category="paragraph">파일 시스템</block>
  <block id="9f47e55b538b64923f2ee8c19bc6887a" category="paragraph">"", NFS</block>
  <block id="cecdaed309330a9e7dea16b2076957ee" category="cell">ONTAP-NAS-이코노미</block>
  <block id="2b8ac774302bd45e0ad531e434d8cd6d" category="cell">'ONTAP-NAS-Flexgroup'</block>
  <block id="cd17e7ed84c40a0ff5ecb8b625b1f186" category="cell">'ONTAP-SAN'</block>
  <block id="e4e1c13bb0b14f6cb7608cbecea948ef" category="paragraph">iSCSI</block>
  <block id="e1e4c8c9ccd9fc39c391da4bcd093fb2" category="paragraph">블록</block>
  <block id="aa91b58ced7ef060eb0e27ac4e1d18a8" category="paragraph">RWO, ROX, rwx</block>
  <block id="0b86d82002caac6130185da4ef1be67e" category="paragraph">RWO, ROX</block>
  <block id="a029cca698cbf05f07897f86c43cf9e8" category="paragraph">xfs, ext3, ext4</block>
  <block id="73b781a615cea2647a87ff2035e296b1" category="cell">ONTAP-SAN-이코노미</block>
  <block id="1e209c07680392db2505687941188c9f" category="summary">Astra Trident의 이전 버전으로 다운그레이드하는 데 필요한 단계에 대해 알아보십시오.</block>
  <block id="9b51b245233e60555d569a43ebaa1b8d" category="doc">Astra Trident를 다운그레이드하십시오</block>
  <block id="f58ee9343b12a3276981187a42480ba7" category="paragraph">다음과 같은 다양한 이유로 다운그레이드를 고려할 수 있습니다.</block>
  <block id="e930f1fff9365ca35f55f1e61bef69a9" category="list-text">비상 계획</block>
  <block id="235115784feaabab0df1d64a2019b176" category="list-text">업그레이드로 인해 발견된 버그를 즉시 수정합니다</block>
  <block id="41768ab308324d6b4a49e2e225427666" category="list-text">종속성 문제, 실패 및 불완전한 업그레이드</block>
  <block id="9bb6c30b6b6e3a9fbbd83b458a3556eb" category="section-title">다운그레이드 시점</block>
  <block id="cb4d3c8706ed4dd2a49a007f19e8b30a" category="section-title">다운그레이드를 하지 않는 경우</block>
  <block id="7be40d1b43eccf7d81bd7ad70a7cee5b" category="paragraph">상태를 유지하기 위해 "etcd"를 사용하는 Trident 릴리스로 다운그레이드하면 안 됩니다(19.04 이하). 현재 Astra Trident 릴리즈를 통해 수행된 모든 작업은 다운그레이드 후 반영되지 않습니다. 새로 생성된 PVS는 이전 버전으로 되돌릴 때 사용할 수 없습니다. 이전 버전으로 돌아갈 때 Astra Trident에서 백엔드, PVS, 스토리지 클래스 및 볼륨 스냅샷(생성/업데이트/삭제)과 같은 객체에 대한 변경 사항을 볼 수 없습니다. 이전 버전으로 돌아가도 업그레이드되지 않은 경우 이전 릴리즈를 사용하여 이미 생성된 PVS에 대한 액세스가 중단되지 않습니다.</block>
  <block id="716e6c4d72b03c2b5b4503d5e968e654" category="section-title">운영자를 통해 Astra Trident가 설치된 경우의 다운그레이드 프로세스</block>
  <block id="286ac65245e7b7508f3cdf1dea1c60eb" category="paragraph">Trident 연산자를 사용하여 설치한 경우 다운그레이드 프로세스가 다르며 "tridentctl"을 사용할 필요가 없습니다.</block>
  <block id="41cc548b7b7993679e555423a014ca5c" category="paragraph">Trident 연산자를 사용하여 설치한 경우 Astra Trident를 다음 중 하나로 다운그레이드할 수 있습니다.</block>
  <block id="c3d92c281c17e41ffac420b45790ecbf" category="list-text">네임스페이스 범위 연산자를 사용하여 설치된 버전(20.07-20.10).</block>
  <block id="69f5b5f7aa4a5f07267b9c758e2580e6" category="list-text">클러스터 범위 연산자(21.01 이상)를 사용하여 설치된 버전입니다.</block>
  <block id="0d8778040c29d89141a733b060314da3" category="section-title">클러스터 범위 연산자로 다운그레이드</block>
  <block id="12a3bd4ff105bed8650ca128636a078f" category="paragraph">Astra Trident를 클러스터 범위 운영자를 사용하는 릴리즈로 다운그레이드하려면 아래에 설명된 단계를 따르십시오.</block>
  <block id="f3a29486bed19a90f2da6d007818b427" category="list-title">단계</block>
  <block id="43f17763173fe230bdd78477152f5f7d" category="inline-link-macro">Astra Trident를 제거합니다</block>
  <block id="44d9737dc7f423d188a4b34663c5f06e" category="list-text">원하는 버전의 Astra Trident를 설치하여 다운그레이드를 계속합니다. 원하는 릴리스에 대한 설명서를 따릅니다.</block>
  <block id="0e792058c21e7156d25e8ae8f2d784a0" category="section-title">네임스페이스 범위 연산자로 다운그레이드합니다</block>
  <block id="8ad79c030a4ebdd2f446157ba529561e" category="paragraph">이 섹션에서는 네임스페이스 범위 연산자를 사용하여 설치되는 20.07 ~ 20.10 범위의 Astra Trident 릴리스로 다운그레이드하는 단계를 요약합니다.</block>
  <block id="a7c80f52f9be4831ca776b56dc642a45" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>. ** 기존 설치를 완전히 제거하려는 경우가 아니면 CRD를 휘두리지 마십시오. ** 트라이덴오케스트레이터(trident오케스트레이터)가 삭제되었는지 확인합니다.</block>
  <block id="2389eabedca3341193952356ec53cd0c" category="list-text">트라이덴오케스트레이터 CRD를 삭제한다.</block>
  <block id="2982be9f91f77222d75873452bfc7696" category="paragraph">Astra Trident가 제거되었습니다.</block>
  <block id="0f46a51f24c3700da8c74b9a5294a22f" category="list-text">원하는 버전을 설치하여 다운그레이드를 계속합니다. 원하는 릴리스에 대한 설명서를 따릅니다.</block>
  <block id="5f7d982e216126a476d4ca0051837e2a" category="section-title">H제어 를 사용하여 다운그레이드합니다</block>
  <block id="fe0182349853dde39c65151b592bc343" category="paragraph">다운그레이드하려면 'helm rollback' 명령을 사용합니다. 다음 예를 참조하십시오.</block>
  <block id="d1008d4e2b1eb300375d48496c96e8b0" category="paragraph">'tridentctl'을 사용하여 Astra Trident를 설치한 경우 다운그레이드 프로세스는 다음 단계를 포함합니다. 이 시퀀스는 Astra Trident 21.07에서 20.07로 이동하는 다운그레이드 프로세스를 안내합니다.</block>
  <block id="e08f959c89cb36ec887089ce4a7c1bcc" category="admonition">다운그레이드를 시작하기 전에 Kubernetes 클러스터의 "etcd"에 대한 스냅샷을 만들어야 합니다. 이를 통해 Astra Trident의 CRD의 현재 상태를 백업할 수 있습니다.</block>
  <block id="e36e921de70428b33bb0e5c22f4f1d03" category="list-text">tridentctl을 사용하여 Trident가 설치되었는지 확인합니다. Astra Trident의 설치 방법을 잘 모르는 경우 다음 간단한 테스트를 실행하십시오.</block>
  <block id="d7c7b52356c18ead4409ef4ca7e2eac8" category="list-text">Trident 네임스페이스에 있는 포드를 나열합니다.</block>
  <block id="225b7f623c2562a1ed24395fd3852b70" category="list-text">클러스터에서 실행 중인 Astra Trident의 버전을 확인합니다. tridentctl을 사용하거나 Trident 포드에 사용된 이미지를 볼 수 있습니다.</block>
  <block id="46da6852e307b4f4a0e965c9c18fe576" category="list-text">"tridentOrchestrator", (또는) "trident-operator-xxxxxxxxxx-xxxxx"라는 이름의 포드가 표시되지 않으면 * "tridentctl"과 함께 Astra Trident * 가 설치됩니다.</block>
  <block id="72b739b65841b5d903e9ec216f0c4fd1" category="list-text">기존 'tridentctl' 바이너리를 사용하여 Astra Trident를 제거합니다. 이 경우 21.07 바이너리로 를 제거합니다.</block>
  <block id="6445365d100b18e233ebf2d08d116aee" category="inline-link-macro">맞춤형 설치</block>
  <block id="03347682a0c8323a17a17933bbf4e18c" category="paragraph">다운그레이드 프로세스가 완료되었습니다.</block>
  <block id="f71fd95d4de4797557e6830c1448c945" category="summary">tridentctl을 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다.</block>
  <block id="2a21586f7990f8cb0f8951cd2ef7bc3b" category="doc">tridentctl로 업그레이드하십시오</block>
  <block id="6224e22d5a77816dd8b659c25a3f88a5" category="paragraph">Astra Trident의 최신 릴리즈로 업그레이드할 때 다음 사항을 고려하십시오.</block>
  <block id="98c7e2ecbd5f5a638272ee366b25b6a1" category="inline-link">볼륨 스냅숏</block>
  <block id="8f9f7d64f0943a9bec25cdd7b786022a" category="list-text">Trident 20.01부터 베타 릴리즈만 제공됩니다<block ref="0b290b7ed02de23dc49888d0fa4fc114" category="inline-link-rx"></block> 가 지원됩니다. Kubernetes 관리자는 알파 스냅샷 개체를 베타로 안전하게 백업하거나 변환하여 레거시 알파 스냅샷을 유지하도록 주의해야 합니다.</block>
  <block id="a4155944ba4eeb0c41401ab7bb85d3d9" category="inline-link">블로그입니다</block>
  <block id="4ff0a9f6065b24ce3d325bad3223f4e2" category="paragraph">Astra Trident를 제거하고 다시 설치하면 업그레이드 역할을 합니다. Trident를 제거할 때 Astra Trident 배포에 사용되는 영구 볼륨 클레임(PVC) 및 영구 볼륨(PV)은 삭제되지 않습니다. 이미 프로비저닝된 PVS는 Astra Trident가 오프라인 상태인 동안 계속 사용할 수 있으며, Astra Trident는 다시 온라인 상태가 되면 중간 기간 동안 생성된 모든 PVC에 대해 볼륨을 프로비저닝합니다.</block>
  <block id="398a8bf92020ed0b4edb1445d1380971" category="admonition">Astra Trident를 업그레이드할 때 업그레이드 프로세스를 중단하지 마십시오. 설치 프로그램이 완료될 때까지 실행되는지 확인합니다.</block>
  <block id="068051b0ea15e91fd236b514c8b35ffe" category="section-title">업그레이드 후 다음 단계</block>
  <block id="ba79ef627bc5ee010211ca922024f9e4" category="paragraph">새로운 Trident 릴리즈(예: 주문형 볼륨 스냅샷)에서 사용할 수 있는 다양한 기능을 사용하려면 "tridentctl upgrade" 명령을 사용하여 볼륨을 업그레이드할 수 있습니다.</block>
  <block id="1f97048c5a9c81e85e588044b15b51c8" category="paragraph">레거시 볼륨이 있는 경우 Astra Trident의 새로운 기능 세트를 모두 사용하려면 NFS/iSCSI 유형에서 CSI 유형으로 업그레이드해야 합니다. Trident에서 프로비저닝한 레거시 PV는 기존 기능 세트를 지원합니다.</block>
  <block id="aae0cab55b3d14012cfc61ef5ad46105" category="paragraph">볼륨을 CSI 유형으로 업그레이드하기로 결정할 때 다음 사항을 고려하십시오.</block>
  <block id="9407b572db9501134ce92167448428fb" category="list-text">모든 볼륨을 업그레이드할 필요는 없습니다. 이전에 생성된 볼륨은 계속 액세스할 수 있으며 정상적으로 작동합니다.</block>
  <block id="35127b2fd7c387c56305575dfafe2a97" category="list-text">업그레이드할 때 배포/StatefulSet 의 일부로 PV를 마운트할 수 있습니다. deployment/StatefulSet 을 아래로 가져올 필요는 없습니다.</block>
  <block id="260eeb1b0c4ec05a9788dc485ed03d36" category="list-text">업그레이드 시 독립 실행형 POD에 PV를 * 첨부할 수 없습니다. 볼륨을 업그레이드하기 전에 포드를 종료해야 합니다.</block>
  <block id="2d59c3aee4c9fe757980153c65e922d0" category="list-text">PVC에 바인딩된 볼륨만 업그레이드할 수 있습니다. PVC에 바인딩되지 않은 용적은 업그레이드 전에 제거 및 가져와야 합니다.</block>
  <block id="f2e9d80774fbee2a6152ad9c7db8e0ee" category="section-title">볼륨 업그레이드의 예</block>
  <block id="eff342caa8bb47fc3653d7b149aa91d4" category="paragraph">다음은 볼륨 업그레이드를 수행하는 방법을 보여 주는 예입니다.</block>
  <block id="fbc477673a43a428e429fe6902c6e36a" category="list-text">KUBectl Get PV를 실행하여 PVS를 나열합니다.</block>
  <block id="09d5f690bff68f8b4ffeeed3dac1f534" category="paragraph">현재 Trident 20.07에 의해 'NetApp.IO/트리덴트'를 사용하여 PVS를 4개 생성했습니다.</block>
  <block id="581ee670123fe76ff75275867ef06bcc" category="list-text">PV에 대한 자세한 내용을 보려면 kubeck tl t설명해 PV를 실행하십시오.</block>
  <block id="a20b570eccfacf0ac4684823643f91a1" category="paragraph">PV는 NetApp.IO/트리덴트(triment) 프로비저닝을 사용하여 생성되었으며 NFS 유형입니다. Astra Trident에서 제공하는 모든 새로운 기능을 지원하려면 이 PV를 CSI 유형으로 업그레이드해야 합니다.</block>
  <block id="c18e246999f594d4fb39c857bcdd1e09" category="list-text">kubeck tl t설명해 PV를 실행하여 볼륨이 CSI 볼륨인지 확인합니다.</block>
  <block id="fb741f44b40455e466443f8f96ace85e" category="paragraph">이러한 방식으로 Astra Trident에서 생성한 NFS/iSCSI 유형의 볼륨을 볼륨별로 CSI 유형으로 업그레이드할 수 있습니다.</block>
  <block id="3bda6d3452a50ffddd40bb74b05d6c50" category="summary">Astra Trident는 분기별 릴리스 케이던스를 따르며, 매년 4개의 주요 릴리즈를 제공합니다. 각 새로운 릴리스는 이전 릴리즈를 기반으로 하며 새로운 기능과 성능 향상, 버그 수정 및 개선 기능을 제공합니다. Astra Trident의 새로운 기능을 이용하려면 1년에 한 번 이상 업그레이드하는 것이 좋습니다.</block>
  <block id="3386987a97643481040e99019808e020" category="doc">Astra Trident를 업그레이드합니다</block>
  <block id="ff115c7087db60c699cccdb21f39ea66" category="list-text">그런 다음 19.07에서 20.07로 업그레이드합니다.</block>
  <block id="558ab0bef1894a7a726109d36632d09d" category="inline-link-macro">알려진 문제</block>
  <block id="33966eba1ed0cde6afda5a97ffaffb09" category="inline-link">보안 컨텍스트</block>
  <block id="ceb268093ddd5aa9df1769eda5d1c8cd" category="inline-link">샘플 입력</block>
  <block id="f5d517b06fc0b1af5d599776e2f6f1d6" category="inline-link">블로그입니다</block>
  <block id="756bc985c24584ee6c7338b28f771da8" category="admonition">CSI 볼륨 스냅샷은 이제 Kubernetes 1.20부터 시작되는 GA 기능입니다. Astra Trident를 업그레이드할 때 업그레이드를 수행하기 전에 이전의 모든 알파 스냅샷 CRS 및 CRD(볼륨 스냅샷 클래스, 볼륨 스냅샷 및 볼륨 스냅샷 콘텐츠)를 제거해야 합니다. 을 참조하십시오<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block> 알파 스냅샷을 베타/GA 스펙으로 마이그레이션하는 단계에 대해 이해합니다.</block>
  <block id="3814df1eaf856112f1f0b22f7f0600e5" category="admonition">"etcd" 기반의 Trident 릴리즈(19.04 이하)를 사용하는 경우 Trident를 업그레이드할 때 연산자를 사용하지 마십시오.</block>
  <block id="152a676ac450f5b96a35605dde352607" category="section-title">조작자에 대한 변경</block>
  <block id="fc7e892a21e797d0592360430a5deedd" category="paragraph">Astra Trident의 21.01 릴리스에는 다음과 같은 몇 가지 주요 아키텍처 변경 사항이 작업자에게 도입되었습니다.</block>
  <block id="4d1b9ac70f0037098e345cb389ea45d9" category="list-text">이제 연산자가 * 클러스터 범위 * 가 됩니다. Trident 연산자(버전 20.04 - 20.10)의 이전 인스턴스는 * 네임스페이스 범위 * 였습니다. 클러스터 범위의 연산자는 다음과 같은 이유로 유용합니다.</block>
  <block id="d898743d222c4e0e5e333941bee1ed57" category="list-text">리소스 책임: 이제 운영자는 클러스터 수준에서 Astra Trident 설치와 관련된 리소스를 관리합니다. Astra Trident를 설치하는 과정에서 운영자는 ownerReferences를 사용하여 여러 리소스를 생성하고 유지합니다. 클러스터 범위 리소스의 ownerReferences를 유지하면 OpenShift와 같은 Kubernetes 일부 배포판에서 오류가 발생할 수 있습니다. 이 문제는 클러스터 범위 운영자를 통해 완화됩니다. Trident 리소스의 자동 복구 및 패칭은 필수 요구사항입니다.</block>
  <block id="375aa3155c54339a366f23cdb01301e5" category="list-text">제거 중 정리: Astra Trident를 완전히 제거하려면 모든 관련 리소스를 삭제해야 합니다. 네임스페이스 범위 연산자는 클러스터 범위 리소스(예: clusterRole, ClusterRoleBinding 및 PodSecurityPolicy)를 제거하는 데 문제가 있을 수 있으며 불완전한 정리 작업을 초래할 수 있습니다. 클러스터 범위 연산자로 인해 이 문제가 발생하지 않습니다. 사용자는 Astra Trident를 완전히 제거하고 필요한 경우 새로 설치할 수 있습니다.</block>
  <block id="6d68e880fd5e5254e122e99a78417abd" category="list-text">아스트라 트리덴트(Astra Trident)를 설치 및 관리하는 데 사용되는 맞춤형 리소스인 트리젠테시너(트리젠오케스트레이터)가 교체됐습니다. 또 트리엔오케스트레이터 사양에 새로운 필드가 도입된다. 사용자는 'pec.namespace` 필드를 사용하여 네임스페이스 Trident를 설치/업그레이드하도록 지정할 수 있습니다. 예를 들어 보겠습니다<block ref="2890210b17eb9668a60ececdebcd5910" category="inline-link-rx"></block>.</block>
  <block id="9c83e144e5481ac6766f4055e566594d" category="section-title">자세한 내용을 확인하십시오</block>
  <block id="dec54888538ac86f51d29a3d043e6bf6" category="summary">운영자를 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다.</block>
  <block id="5ff3faebb0ff710340bdbee89a4667ad" category="doc">운영자와 함께 업그레이드하십시오</block>
  <block id="ba45a58fb6371fc5a91fb8a5d399becd" category="list-text">CSI Trident를 제거한 후 설치 시 메타데이터가 지속되는 경우 연산자를 사용하여 업그레이드할 수 있습니다.</block>
  <block id="33deedceb6eaeb2f124b7ce830e212a8" category="list-text">주어진 Kubernetes 클러스터의 모든 네임스페이스에 하나의 Astra Trident 설치만 존재해야 합니다.</block>
  <block id="093e1971a4b17fce7e3e4d94854a46ba" category="list-text">알파 스냅샷 CRD가 있는 경우 'tridentctl oblividate alpha-snapshot-CRD'로 제거해야 합니다. 그러면 알파 스냅샷 사양에 대한 CRD가 삭제됩니다. 삭제/마이그레이션해야 하는 기존 스냅샷의 경우 를 참조하십시오<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block>.</block>
  <block id="199ed8c975e8bb544d18428ba17adbc3" category="inline-link">GitHub에 대한 발행 세부 정보</block>
  <block id="d06b5297af318d2581021098f6b0d44d" category="section-title">네임스페이스 범위 연산자 설치를 업그레이드합니다</block>
  <block id="edf5c542759186ded2c7eeaae6b340a5" category="list-text">기존 Trident 설치의 상태를 확인합니다. 이렇게 하려면 '트리펜Provisioner'의 * 상태 * 를 확인하십시오. 상태는 '설치됨'이어야 합니다.</block>
  <block id="f14a1d8e56a0cbd2826edd38778371f7" category="admonition">상태가 '업데이트 중'으로 표시되면 계속하기 전에 이를 해결해야 합니다. 가능한 상태 값 목록은 를 참조하십시오<block ref="6aefd1c9ce8e43313a8c7c92e2fac4f3" category="inline-link-rx"></block>.</block>
  <block id="683d018a2f7c70469fd74ba0eeae2a79" category="list-text">Trident 설치 프로그램과 함께 제공된 매니페스트를 사용하여 'Trident Orchestrator' CRD를 만듭니다.</block>
  <block id="5fbede7820945c99130183fd2fd0f4b3" category="paragraph">이 단계에서 트리덴트 - operator - xxxxxxxxxx - xxxxx'POD가 삭제됩니다.</block>
  <block id="86463d362af5835ff8c3fd6587fbd24f" category="list-text">(선택 사항) 설치 매개변수를 수정해야 하는 경우 ' TERentProvisioner' 사양을 업데이트합니다. 컨테이너 이미지를 가져올 전용 이미지 레지스트리를 수정하거나, 디버그 로그를 사용하거나, 이미지 풀 비밀을 지정하는 등의 변경 사항이 있을 수 있습니다.</block>
  <block id="61d74cfa0c3f53abef0b4694fba0522f" category="section-title">제어 기반 작업자 설치를 업그레이드합니다</block>
  <block id="7734dd866cc8c135256bad90520fa719" category="paragraph">제어 기반 운영자 설치를 업그레이드하려면 다음 단계를 수행하십시오.</block>
  <block id="3002cfcea36b7fb4d87da4d413730851" category="list-text">최신 Astra Trident 릴리스를 다운로드하십시오.</block>
  <block id="4a6b869a481b52472aa62cfa4d9d255e" category="paragraph">예를 들어, 기본값인 tridentDebug를 변경하려면 다음 명령을 실행합니다.</block>
  <block id="5c83dd886f5edc620e809e7800bc225f" category="section-title">비운영자 설치에서 업그레이드</block>
  <block id="4ab464bddccdcbc36fab4cea802025f9" category="list-text">매니페스트에서 트라이디오케스트레이터 CRD를 만듭니다.</block>
  <block id="835fd860290737b70acf870a253c3549" category="list-text">연산자를 전개합니다.</block>
  <block id="06da281bf5e01c3c59892dc886cd0067" category="list-text">Astra Trident를 설치할 '트리젠오케스트레이터' CR을 만듭니다.</block>
  <block id="f420eb91a420c03f1792a6504b30277b" category="paragraph">기존 백엔드 및 PVC는 자동으로 사용할 수 있습니다.</block>
  <block id="3a90bea856daf0616bcbdde1b9d9ad0b" category="summary">Astra Trident의 설치 방식에 따라 여러 옵션을 사용하여 제거할 수 있습니다.</block>
  <block id="bdcf993f8f3d91925d60754cd864f3c0" category="section-title">Helm을 사용하여 제거합니다</block>
  <block id="8656f6a3d04342ff6248bd7d32949c2a" category="paragraph">Helm을 사용하여 Astra Trident를 설치한 경우 'helm uninstall'을 사용하여 제거할 수 있습니다.</block>
  <block id="e2a3593a8e9900eadda10d47bc2ff47c" category="section-title">Trident 연산자를 사용하여 제거합니다</block>
  <block id="c416a70504ae36e8cfbf555ad0d13ab9" category="paragraph">운영자를 사용하여 Astra Trident를 설치한 경우 다음 중 하나를 수행하여 제거할 수 있습니다.</block>
  <block id="1159b3a6f6975215eaff7b18f9fdbe8e" category="list-text">** 제거 플래그를 설정하려면 '트리젠터레이터'를 편집하여 '트리젠터레이터'를 편집하고 'Spec.uninstall=true'를 설정할 수 있습니다. 다음 그림과 같이 '트리엔오케스트레이터' CR을 편집하고 '제거' 플래그를 설정합니다.</block>
  <block id="245e84de93b9b41f643f9e737c17e702" category="paragraph">'uninstall' 플래그가 'true'로 설정되어 있으면 Trident 운영자가 Trident를 제거하지만 Trident 자체 자체를 제거하지 않습니다. Trident를 다시 설치하려면 해당 Trident를 정리하고 새 AgentOrchestrator를 생성해야 합니다.</block>
  <block id="a5e00cb8c456b8892f7af2349fe6e10a" category="list-text">** "트리펜터레이터" 삭제: ** Astra Trident를 배포하는 데 사용된 '트리엔오케스트레이터' CR을 제거하여 운영자에게 Trident를 제거하도록 지시합니다. 운영자는 '트리펜터레이터'의 제거를 처리하고 Astra Trident 구축 및 디포드를 제거하여 설치의 일부로 생성한 Trident 포드를 삭제합니다. Astra Trident(CRD 생성 포함)를 완전히 제거하고 슬레이트 클린을 효과적으로 닦기 위해 '트리펜터레이터'를 편집하여 '와이프아웃' 옵션을 통과할 수 있습니다. 다음 예를 참조하십시오.</block>
  <block id="8aaaff274ba10c527c6bf8facd1c9092" category="paragraph">그러면 Astra Trident가 완전히 설치 제거되며, 백엔드 및 관리하는 볼륨과 관련된 모든 메타데이터가 지워집니다. 이후 설치는 새로 설치하는 것으로 처리됩니다.</block>
  <block id="1f119048e6c0b2f219b28b7efae30285" category="admonition">전체 제거를 수행할 때에만 CRD를 지우는 것을 고려해야 합니다. 이 작업은 취소할 수 없습니다. ** 처음부터 새로 Astra Trident 설치를 생성하기 위해 사용하지 않는 한 CRD를 지우지 마십시오**.</block>
  <block id="20402206432f6b6e75899e8f585ae984" category="paragraph">다음과 같이 tridentctl에서 'uninstall' 명령을 실행하면 CRD 및 관련 객체를 제외한 Astra Trident와 관련된 모든 리소스가 제거되므로 설치 프로그램을 다시 쉽게 실행하여 최신 버전으로 업데이트할 수 있습니다.</block>
  <block id="1b600643682d5a3280681ef82d7e6ae4" category="paragraph">Astra Trident를 완전히 제거하려면 Astra Trident에서 생성한 CRD의 종료자를 제거하고 CRD를 삭제해야 합니다.</block>
  <block id="34c4dac14496e9c45d92f345d9392fc8" category="summary">최신 버전을 실행하지 않는 경우 Astra Trident의 이전 릴리스에 대한 문서를 사용할 수 있습니다.</block>
  <block id="ba09ee47d11962c1ccd13d7e1f10e6c5" category="doc">이전 버전의 문서</block>
  <block id="0c141ec81d4107f4c63fb0deb2531c0d" category="inline-link">Astra Trident 21.04</block>
  <block id="193bfae1ebda99fb7289c66fa69395a0" category="list-text"><block ref="193bfae1ebda99fb7289c66fa69395a0" category="inline-link-rx"></block></block>
  <block id="cba2c660d905f83e39a0d1771286c9e7" category="inline-link">Astra Trident 21.01</block>
  <block id="97f32ab1a5165dc49105dca53b9f4de7" category="list-text"><block ref="97f32ab1a5165dc49105dca53b9f4de7" category="inline-link-rx"></block></block>
  <block id="727d2d1e15a5c7260e90c50b1c250a4c" category="inline-link">Astra Trident 20.10</block>
  <block id="8a0315074645cbbab67a7445dcdf42f2" category="list-text"><block ref="8a0315074645cbbab67a7445dcdf42f2" category="inline-link-rx"></block></block>
  <block id="bad2b8fa41c05085668e48d7c14968dc" category="inline-link">Astra Trident 20.07</block>
  <block id="449d7e957347de63ee3d9841c40b4e7f" category="list-text"><block ref="449d7e957347de63ee3d9841c40b4e7f" category="inline-link-rx"></block></block>
  <block id="7c0a09ca9ea4472728e4661755a43c6b" category="inline-link">Astra Trident 20.04</block>
  <block id="8a72b28486832ed8c725617460afbdcb" category="list-text"><block ref="8a72b28486832ed8c725617460afbdcb" category="inline-link-rx"></block></block>
  <block id="1dc5429c6c86712d7628beb5652a0e2e" category="inline-link">Astra Trident 20.01</block>
  <block id="23204facdc38bad335a6afce81db0827" category="list-text"><block ref="23204facdc38bad335a6afce81db0827" category="inline-link-rx"></block></block>
  <block id="5b2d210bf907d26b59abbaa0e22fbbe6" category="inline-link">아스트라 트리덴트 19.10</block>
  <block id="3377906a52734323c44c8f31b2d29e63" category="list-text"><block ref="3377906a52734323c44c8f31b2d29e63" category="inline-link-rx"></block></block>
  <block id="f1d7fe87216a18ff3ffcfa98d6065689" category="inline-link">Astra Trident 19.07</block>
  <block id="12e29d431cea2700aa9d89e0c89e67bc" category="list-text"><block ref="12e29d431cea2700aa9d89e0c89e67bc" category="inline-link-rx"></block></block>
  <block id="fe4bdabecc64b786523a3d86bb1f9cfd" category="inline-link">아스트라 트리덴트 19.04</block>
  <block id="e43783d5a51a10670edf444f0b58b6af" category="list-text"><block ref="e43783d5a51a10670edf444f0b58b6af" category="inline-link-rx"></block></block>
  <block id="5e152ff33f3262612abc4b942db27ad1" category="inline-link">아스트라 트리덴트 19.01</block>
  <block id="977636e26059252def0425dca74811ef" category="list-text"><block ref="977636e26059252def0425dca74811ef" category="inline-link-rx"></block></block>
  <block id="d59b86d1714966230da7a00672e40912" category="summary">여기에 나열된 권장 사항을 사용하여 Astra Trident 설치가 안전한지 확인합니다.</block>
  <block id="2fae32629d4ef4fc6341f1751b405e45" category="doc">보안</block>
  <block id="44a736677691eaca5e5d3d6b5c770b22" category="section-title">자체 네임스페이스에서 Astra Trident를 실행합니다</block>
  <block id="347d4c35796a862cf20cdcdebfe59e57" category="paragraph">애플리케이션, 애플리케이션 관리자, 사용자 및 관리 애플리케이션에서 Astra Trident 객체 정의 또는 Pod에 액세스하여 안정적인 스토리지를 보장하고 잠재적인 악성 활동을 차단하는 것이 중요합니다.</block>
  <block id="47d7f9fac441e60d9523d256d02aa8ba" category="paragraph">다른 애플리케이션과 사용자를 Astra Trident에서 분리하려면 항상 고유한 Kubernetes 네임스페이스('트리덴트')에 Astra Trident를 설치하십시오. Astra Trident를 자체 네임스페이스에 두면 Kubernetes 관리 담당자만 Astra Trident POD와 이름이 같은 CRD 객체에 저장된 아티팩트(예: 백엔드 및 CHAP 암호)에 액세스할 수 있습니다. 관리자만이 Astra Trident 네임스페이스에 액세스할 수 있도록 하고 "tridentctl" 응용 프로그램에 액세스할 수 있도록 해야 합니다.</block>
  <block id="f40aef657c875e42158050f63dcfbb6f" category="section-title">ONTAP SAN 백엔드에 CHAP 인증을 사용합니다</block>
  <block id="2738c60dc60977d9eb6af2bf2a98c193" category="paragraph">Astra Trident는 ONTAP SAN 워크로드에 대한 CHAP 기반 인증(ONTAP-SAN과 ONTAP-SAN 절약 드라이버 사용)을 지원합니다. 호스트와 스토리지 백엔드 간의 인증을 위해 Astra Trident와 양방향 CHAP를 사용하는 것이 좋습니다.</block>
  <block id="97f83fd51c89f4f9d3fc271b9f7291ab" category="admonition">ONTAP 백엔드에 대한 CHAP 지원은 Trident 20.04 이상에서 사용할 수 있습니다.</block>
  <block id="d4e0ad8fd8e11d87eb431051692db344" category="section-title">NetApp HCI 및 SolidFire 백엔드에서 CHAP 인증을 사용합니다</block>
  <block id="b6a8ac29724d88dfaec657edda424d98" category="paragraph">양방향 CHAP를 구축하여 호스트와 NetApp HCI 및 SolidFire 백엔드 간의 인증을 보장하는 것이 좋습니다. Astra Trident는 테넌트당 2개의 CHAP 암호를 포함하는 비밀 객체를 사용합니다. Trident를 CSI 구축 담당자로 설치하면 CHAP 암호를 관리하고 해당 PV의 "tridentvolume" CR 객체로 저장합니다. PV를 생성할 때 CSI Astra Trident는 CHAP 암호를 사용하여 iSCSI 세션을 시작하고 CHAP를 통해 NetApp HCI 및 SolidFire 시스템과 통신합니다.</block>
  <block id="19cde2e69238c98382d677e2583cbc46" category="admonition">CSI Trident에서 생성한 볼륨은 볼륨 액세스 그룹과 연결되지 않습니다.</block>
  <block id="3179d8563cd49690a141c34c045dfab8" category="paragraph">CSI가 아닌 프런트엔드에서는 작업자 노드의 디바이스로 볼륨을 연결하는 작업을 Kubernetes에서 처리합니다. 볼륨 생성 후 Astra Trident는 NetApp HCI/SolidFire 시스템에 API 호출을 통해 해당 테넌트의 암호가 아직 없는 경우 비밀을 검색합니다. 그런 다음 Astra Trident가 Kubernetes에 비밀을 전달합니다. 각 노드에 위치한 kubelet은 Kubernetes API를 통해 기밀에 액세스하고 이를 사용하여 볼륨에 액세스하는 각 노드와 볼륨이 있는 NetApp HCI/SolidFire 시스템 간에 CHAP를 실행/사용하도록 설정합니다.</block>
  <block id="698aa9df4c2c5470599821c3d10620dd" category="summary">Kubernetes 클러스터는 일반적으로 두 가지 유형의 노드로 구성되며, 각 노드는 다양한 기능의 측면을 담당합니다.</block>
  <block id="748c130a6179b02d614cf9a027294302" category="doc">Astra Trident 통합</block>
  <block id="1fdc23c8579638d050b7b219da011f2b" category="section-title">운전자 선택 및 전개</block>
  <block id="815a377da65ae5b66c84438c43416d82" category="paragraph">상위 레벨에서는 애플리케이션에 공유 스토리지가 필요한 구성 요소(동일한 PVC에 액세스하는 여러 Pod)가 있는 경우 NAS 기반 드라이버가 기본 선택이고 블록 기반 iSCSI 드라이버는 비공유 스토리지의 요구를 충족합니다. 애플리케이션의 요구사항 및 스토리지 및 인프라 팀의 편안함 수준을 기준으로 프로토콜을 선택합니다. 일반적으로 대부분의 애플리케이션에서 두 서버 간에 차이가 거의 없기 때문에 공유 스토리지(둘 이상의 POD에 동시 액세스가 필요한 경우)가 필요한지 여부에 따라 결정하는 경우가 많습니다.</block>
  <block id="c2c889ded63fbe94cf7f1d5fe4747b2d" category="list-text">ONTAP-NAS: 프로비저닝되는 각 PV는 ONTAP FlexVolume입니다.</block>
  <block id="9418583a1b7e700d24bcc735aa4682b5" category="list-text">ONTAP-NAS-이코노미: 각 PV 프로비저닝은 qtree이며 FlexVolume당 qtree(기본값 200)를 구성할 수 있습니다.</block>
  <block id="bc8f11db54909209ba09d55ee0b46990" category="list-text">ONTAP-NAS-flexgroup: 각 PV는 전체 ONTAP FlexGroup로 프로비저닝되고 SVM에 할당된 모든 애그리게이트가 사용됩니다.</block>
  <block id="5e587346b7a212ee6429303276a1578b" category="list-text">ONTAP-SAN: 각 PV는 자체 FlexVolume 내의 LUN입니다.</block>
  <block id="85f6f5093b037b5bde3201d8136ee585" category="list-text">ONTAP-SAN-이코노미: 각 PV는 LUN으로 프로비저닝되며 FlexVolume당 구성 가능한 LUN 수(기본값 100)가 있습니다.</block>
  <block id="f1d8371af632688748db007c98766ded" category="paragraph">세 개의 NAS 드라이버 중 하나를 선택할 경우 해당 기능에 약간의 영향을 줍니다. 이 기능은 응용 프로그램에서 사용할 수 있습니다.</block>
  <block id="8a1187760a2c55e422a454a64e160291" category="paragraph">아래 표에서 모든 기능이 Astra Trident를 통해 표시되는 것은 아닙니다. 용량 할당 후 기능을 적용하려면 스토리지 관리자가 일부 기능을 적용해야 합니다. 위 첨자 각주는 기능 및 드라이버별 기능을 구별합니다.</block>
  <block id="6252699c8e049f40eaf187092727a531" category="cell">ONTAP NAS 드라이버</block>
  <block id="9147e5e61a7b9260dec09f3a6eb3e5be" category="cell">스냅샷 수</block>
  <block id="999cc42b236c7aee1157ff02d6f1bcd5" category="cell">복제</block>
  <block id="13bc190bfed9f972b3e33e3656737cdd" category="cell">동적 엑스포트 정책</block>
  <block id="ab0c646b4c5e36d9bcf8239d97fd1843" category="cell">다중 연결</block>
  <block id="8f2db90dd4a6fbd95ba8f0bc54fd6b27" category="cell">QoS를 참조하십시오</block>
  <block id="9d723d04c40bfd81835c0766a698cf63" category="cell">크기 조정</block>
  <block id="8c340dc334134096f68b880b42a8692c" category="cell">복제</block>
  <block id="6bfc395e3d384b30d9f43ca45b1eeff7" category="cell">Yesfootnote: 5[]</block>
  <block id="7c078cb746c3dd22969c07747fd7f3fc" category="cell">Yesfootnote: 1[]</block>
  <block id="e4e9da2a7bd5e2b5b29c51299a1b787f" category="cell">Yesfootnote: 3[]</block>
  <block id="bafd7322c6e97d25b6299b5d6fe8920b" category="cell">아니요</block>
  <block id="15861eb7768c6587d321b6010008930e" category="paragraph">Astra Trident는 ONTAP용 SAN 드라이버 2개를 제공하며 해당 기능은 아래에 나와 있습니다.</block>
  <block id="f916141465c67326e5d7d980bff2880b" category="cell">ONTAP SAN 드라이버</block>
  <block id="4f546cdc5f90f7d264cde89d14c6e015" category="cell">양방향 CHAP</block>
  <block id="e78e01b4457814be0584f80618e4659a" category="cell">Yesfootnote: 4[]</block>
  <block id="708ee6a923f9b4b3f2213d57632eaadc" category="verse-content-simple">위 표의 각주: Yesfootnote:1[]: Astra Trident에서 관리하지 않음 Yesfootnote:2[]: Astra Trident에서 관리하지만 PV 세분화되지는 않음 Yesfootnote:3[]: Astra Trident에서 관리하지 않음, PV 세분화됨 Yesfootnote:4[]: 원시 블록 볼륨에서 지원됨 Yesfootnote:5[]: CSI Trident에서 지원</block>
  <block id="74b4b41be17ac9897921032dfd4e94a8" category="paragraph">PV 세분화되지 않은 기능은 전체 FlexVolume에 적용되고 모든 PVS(즉, 공유 FlexVol의 qtree 또는 LUN)는 공통 스케줄을 공유합니다.</block>
  <block id="b483d59c54aea739f0806cf2f30c057e" category="paragraph">위 표에서 볼 수 있듯이, ONTAP-NAS와 ONTAP-NAS-이코노미 간의 기능 대부분은 동일합니다. 그러나 ONTAP-NAS-이코노미 드라이버는 PV 단위의 일정 제어 기능을 제한하므로 특히 재해 복구 및 백업 계획에 영향을 줄 수 있습니다. ONTAP 스토리지에서 PVC 클론 기능을 활용하고자 하는 개발팀은 ONTAP-NAS, ONTAP-SAN 또는 ONTAP-SAN 절약 드라이버를 사용할 때만 가능합니다.</block>
  <block id="45f7f2e55c0930a28d1a9e481e602a09" category="admonition">졸idfire-san의 드라이버도 PVC를 클로닝할 수 있습니다.</block>
  <block id="168b96624733268bb4b4ebfbebea0449" category="paragraph">ONTAP용 Amazon FSx를 사용하면 고객이 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에, AWS에 데이터를 저장하는 간편성, 민첩성, 보안, 확장성을 활용할 수 있습니다. ONTAP용 FSX는 ONTAP의 다양한 파일 시스템 기능과 관리 API를 지원합니다. Cloud Volume ONTAP와 호환되는 드라이버는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN입니다.</block>
  <block id="e040ac9827d856d3ad8ae9ac0da92295" category="paragraph">NetApp HCI/SolidFire 플랫폼과 함께 사용되는 'olidfire-SAN' 드라이버는 관리자가 QoS 제한을 기반으로 Trident에 대한 Element 백엔드를 구성하는 데 도움이 됩니다. Trident에서 프로비저닝한 볼륨에 대한 특정 QoS 제한을 설정하기 위해 백엔드를 설계하려면 백엔드 파일에 'type' 매개 변수를 사용하십시오. 또한 관리자는 'limitVolumeSize' 매개 변수를 사용하여 스토리지에 생성할 수 있는 볼륨 크기를 제한할 수 있습니다. 현재 볼륨 크기 조정 및 볼륨 복제와 같은 Element 스토리지 기능은 'olidfire-SAN' 드라이버를 통해 지원되지 않습니다. 이러한 작업은 Element 소프트웨어 웹 UI를 통해 수동으로 수행해야 합니다.</block>
  <block id="77e9d6f249e4626d5b5c3aec863459d3" category="cell">SolidFire 드라이버</block>
  <block id="9ef2bbb12ff72558472202561a25058d" category="cell">CHAP</block>
  <block id="57ee8ed0b2796ea5f35b10f9ae5d68cd" category="cell">'솔더불-산'</block>
  <block id="0929973a1c9993903f6193add75b3fcf" category="cell">Yesfootnote:2[]</block>
  <block id="bccbad684880808562152ac1d82d7b73" category="verse-content-simple">각주: Yesfootnote: 1 [ ]: Astra Trident Yesfootnote: 2 [ ]: 원시 블록 볼륨에서 지원됩니다</block>
  <block id="7450cfde7058dc5e1f7909d0280fd7ae" category="inline-link-macro">Azure NetApp Files</block>
  <block id="657e0fa57d574227dd7520919f55ff92" category="paragraph">Astra Trident는 'Azure-NetApp-files' 드라이버를 사용하여 를 관리합니다 <block ref="d617d79fbb5ee3bc8bd280353eeb1349" category="inline-link-macro-rx"></block> 서비스.</block>
  <block id="1f65578a7accdff5ca6ff9f8dc42d9c6" category="inline-link-macro">Azure NetApp Files를 위한 Astra Trident 백엔드 구성입니다</block>
  <block id="e4eb3683baaad2a9ce9e264a37fb519e" category="paragraph">이 드라이버 및 구성 방법에 대한 자세한 내용은 에서 찾을 수 있습니다 <block ref="452e5754c64fc2b52b13e03114bfeff6" category="inline-link-macro-rx"></block>.</block>
  <block id="4da613089cbda3d7c19cb4b3f67c1f5d" category="cell">Azure NetApp Files 드라이버</block>
  <block id="8098b34f582537833b36b58273c3545b" category="cell">비즈니스</block>
  <block id="e228843381960c06d1035c4219901307" category="cell">'Azure-NetApp-파일'</block>
  <block id="2fdc8a66565228c15d355a7849997337" category="verse-content-simple">각주: Yesfootnote: 1 [ ]: Astra Trident에서 관리하지 않습니다</block>
  <block id="1d326a2a7f267c800fe3eafb89e5c7cd" category="inline-link-macro">서비스 유형</block>
  <block id="949a374fc5a78d436e3067ee2de19cbe" category="cell">GCP-CV</block>
  <block id="3af6198d49c40c18f13c73c5ce15cf34" category="section-title">스토리지 클래스 설계</block>
  <block id="388bdf78cbb5b6bf4248ddf5613f7cc3" category="paragraph">Kubernetes Storage Class 객체를 생성하려면 개별 스토리지 클래스를 구성 및 적용해야 합니다. 이 섹션에서는 애플리케이션에 대한 스토리지 클래스를 설계하는 방법에 대해 설명합니다.</block>
  <block id="a09acd5f665bdf96b6dce47f8d4265e3" category="paragraph">특정 스토리지 클래스 객체 내에서 필터링을 사용하여 해당 스토리지 클래스에 사용할 스토리지 풀 또는 풀 세트를 결정할 수 있습니다. Storage Class에서 'toragePools', 'additionalStoragePools', 'excludeStoragePools' 등의 세 가지 필터를 설정할 수 있습니다.</block>
  <block id="fc01760e8c283c2f128543ae8b8a67cc" category="paragraph">'toragePools' 매개 변수는 지정된 속성과 일치하는 풀 세트로 스토리지를 제한하는 데 도움이 됩니다. 추가 StoragePools 매개변수는 Astra Trident가 프로비저닝에 사용할 풀 세트를 속성 및 'toragePools' 매개 변수로 선택한 풀 세트와 함께 확장하는 데 사용됩니다. 매개 변수만 사용하거나 둘 모두를 함께 사용하여 적절한 스토리지 풀 세트가 선택되었는지 확인할 수 있습니다.</block>
  <block id="74476e892d2681775eb41ec00a11e8da" category="paragraph">excludeStoragePools 매개 변수는 속성과 일치하는 나열된 풀 세트를 명시적으로 제외하는 데 사용됩니다.</block>
  <block id="ab807e6bd2f9cb9872eed98161bdd4e1" category="paragraph">서비스 품질 정책을 에뮬레이트하기 위해 스토리지 클래스를 설계하려면 '미디어' 속성을 HDD 또는 'SSD'로 사용하여 스토리지 클래스를 생성합니다. 스토리지 클래스에 언급된 미디어 특성에 따라, Trident는 미디어 속성과 일치하도록 HDD 또는 SSD 애그리게이트를 제공하는 적절한 백엔드를 선택한 다음 볼륨 프로비저닝을 특정 애그리게이트로 전달합니다. 따라서 프리미엄 QoS 정책으로 분류될 수 있는 '미디어' 속성이 'SD'로 설정된 스토리지 클래스 Premium을 생성할 수 있습니다. 표준 QoS 정책으로 분류될 수 있는 미디어 속성을 'HDD'로 설정하는 또 다른 스토리지 클래스 표준을 생성할 수 있습니다. 또한 스토리지 클래스에서 ""IOPS"" 속성을 사용하여 QoS 정책으로 정의할 수 있는 Element 어플라이언스로 프로비저닝을 리디렉션할 수도 있습니다.</block>
  <block id="0bc0e72aefbf8f8ec0b28cc0486f98a2" category="paragraph">스토리지 클래스는 씬 및 일반 프로비저닝, 스냅샷, 클론 및 암호화와 같은 기능이 설정된 특정 백엔드에서 볼륨 프로비저닝을 수행하도록 설계되었습니다. 사용할 스토리지를 지정하려면 필요한 기능이 설정된 적절한 백엔드를 지정하는 스토리지 클래스를 생성합니다.</block>
  <block id="421f7dd5bb37a6401aa6326ad33dae20" category="section-title">스토리지 프로비저닝에 영향을 미치는 PVC 특성</block>
  <block id="5ab83f35784f154d55ea7ab58c8e503b" category="section-title">액세스 모드</block>
  <block id="f3882c83b41b76a9fac2c57407f3ac2b" category="paragraph">PVC를 통한 저장 요청 시 필수 필드 중 하나가 액세스 모드입니다. 원하는 모드는 스토리지 요청을 호스팅하기 위해 선택한 백엔드에 영향을 줄 수 있습니다.</block>
  <block id="b72ab56468fdf0df298a89c3339b82c0" category="paragraph">Astra Trident는 다음 매트릭스에 따라 지정된 액세스 방법과 사용된 스토리지 프로토콜을 일치시키려고 시도합니다. 이는 기본 스토리지 플랫폼과 무관합니다.</block>
  <block id="cac415feda213697b27d3b6fce10d33a" category="cell">ReadWriteOnce 를 참조하십시오</block>
  <block id="c24ad3d99a666c95edd149419c958ee0" category="cell">ReadOnlyMany 를 참조하십시오</block>
  <block id="caa8dc1f4bb28d2d11226494cd05a123" category="cell">ReadWriteMany 를 참조하십시오</block>
  <block id="cefb8ccdebef1940174b22e9d0ab530b" category="cell">예(원시 블록)</block>
  <block id="823f2153adc2211a0777560eafdcbad6" category="paragraph">NFS 백엔드가 구성되지 않은 상태로 Trident 배포에 제출된 ReadWriteMany PVC에 대한 요청은 볼륨이 프로비저닝되지 않습니다. 이러한 이유로 요청자는 자신의 응용 프로그램에 적합한 액세스 모드를 사용해야 합니다.</block>
  <block id="5a51acb2538e54805c54d37ebb49c75d" category="section-title">볼륨 작업입니다</block>
  <block id="26fad327e23b6b08dcc94300bfe1ed04" category="section-title">영구 볼륨 수정</block>
  <block id="3b69d471bb98837ae6e267593bb38882" category="paragraph">영구 볼륨은 Kubernetes에서 두 가지 예외, 영구적 객체입니다. 생성된 후에는 부가세 반환 청구액 정책 및 크기를 수정할 수 있습니다. 그러나 이렇게 해서 Kubernetes 외부에서 볼륨의 일부 측면이 수정되지 않도록 할 수는 없습니다. 특정 애플리케이션에 맞게 볼륨을 사용자 지정하거나, 실수로 용량이 소비되지 않도록 하거나, 어떠한 이유로든 볼륨을 다른 스토리지 컨트롤러로 이동하는 것이 좋을 수 있습니다.</block>
  <block id="f82b5505d8def4abda0bec52275bd411" category="admonition">현재 Kubernetes 트리 프로비저닝 시 NFS 또는 iSCSI PVS의 볼륨 크기 조정 작업은 지원되지 않습니다. Astra Trident는 NFS 및 iSCSI 볼륨 확장을 지원합니다.</block>
  <block id="b1d1874782626fe3f391628ea493e6ef" category="paragraph">PV의 접속 세부 정보는 생성 후 수정할 수 없습니다.</block>
  <block id="e68591655c8031177206e1e75728853f" category="section-title">주문형 볼륨 스냅샷을 생성합니다</block>
  <block id="f557ce2b38683c13c1c1a070ce58a33d" category="paragraph">Astra Trident는 CSI 프레임워크를 사용하여 필요 시 볼륨 스냅샷 생성 및 스냅샷에서 PVC 생성을 지원합니다. 스냅샷은 편리한 데이터 시점 복사본을 유지 관리하는 방법을 제공하며 Kubernetes의 소스 PV와 독립적인 라이프사이클을 갖고 있습니다. 이러한 스냅샷을 사용하여 PVC를 복제할 수 있습니다.</block>
  <block id="f007c56a8eb121e8a696105e69aefa68" category="section-title">스냅샷으로부터 볼륨을 생성합니다</block>
  <block id="e005d448313cdc2848d923f4c754e467" category="paragraph">Astra Trident는 볼륨 스냅샷으로부터 PersistentVolumes 생성을 지원합니다. 이를 위해 PersistentVolumeClaim을 생성하고 볼륨을 생성해야 하는 필수 스냅샷으로 "소스"를 언급하기만 하면 됩니다. Astra Trident는 스냅샷에 데이터가 있는 볼륨을 생성하여 이 PVC를 처리합니다. 이 기능을 사용하면 지역 간에 데이터를 복제하거나 테스트 환경을 생성하거나 손상되거나 손상된 운영 볼륨을 전체적으로 교체하거나 특정 파일 및 디렉토리를 검색하여 연결된 다른 볼륨으로 전송할 수 있습니다.</block>
  <block id="55a3309b0b6646e0ea6b47195bd3d4bd" category="section-title">클러스터에서 볼륨 이동</block>
  <block id="925b814524908630c07d45fc5a80028a" category="paragraph">스토리지 관리자는 ONTAP 클러스터의 Aggregate와 컨트롤러 간에 볼륨을 스토리지 소비자로 중단 없이 이동할 수 있습니다. 대상 애그리게이트는 Astra Trident가 사용하는 SVM이 액세스할 수 있는 경우, 이 작업은 Astra Trident 또는 Kubernetes 클러스터에 영향을 주지 않습니다. 여기서 중요한 점은 애그리게이트를 SVM에 새로 추가한 경우, Astra Trident에 다시 추가하여 백엔드를 새로 고쳐야 한다는 것입니다. 그러면 Astra Trident가 SVM의 인벤토리를 다시 만들어 새 애그리게이트를 인식할 수 있습니다.</block>
  <block id="033dcaefcc578c987d32d4bdb6f6b1e2" category="paragraph">그러나 Astra Trident는 백엔드에서 볼륨을 이동하는 기능을 자동으로 지원하지 않습니다. 여기에는 동일한 클러스터, 클러스터 간 또는 다른 스토리지 플랫폼(스토리지 시스템이 Astra Trident에 연결된 SVM인 경우에도 해당 스토리지 플랫폼)에 있는 SVM이 포함됩니다.</block>
  <block id="302be77289f337115411c01846d9a489" category="paragraph">볼륨이 다른 위치에 복사되면 볼륨 가져오기 기능을 사용하여 현재 볼륨을 Astra Trident로 가져올 수 있습니다.</block>
  <block id="2243e252be826d6ec5e767668d9f961d" category="section-title">볼륨 확장</block>
  <block id="40a28a40c11a193f8911cf4143a6ae6a" category="section-title">기존 볼륨을 Kubernetes로 임포트</block>
  <block id="5d9f64103cac7a58da69304bc3320e98" category="paragraph">ONTAP 및 'solidfire-san' 드라이버를 사용하는 경우, 'tridentctl import volume &lt;backend-name&gt;&lt;volume-name&gt; -f/path/PVC.YAML' 명령을 사용하여 Astra Trident에서 관리할 기존 볼륨을 Kubernetes로 가져옵니다. 볼륨 가져오기 명령에 사용되는 PVC YAML 또는 JSON 파일은 Astra Trident를 프로비저닝자로 식별하는 스토리지 클래스를 가리킵니다. NetApp HCI/SolidFire 백엔드를 사용할 경우 볼륨 이름이 고유한지 확인합니다. 볼륨 이름이 중복되면 볼륨을 고유한 이름으로 복제하여 볼륨 가져오기 기능에서 볼륨 이름을 구분할 수 있도록 합니다.</block>
  <block id="cb619cd0109686b5f82562b63e44a107" category="paragraph">위 명령을 실행하면 Astra Trident가 백엔드에서 볼륨을 찾고 해당 크기를 읽습니다. 구성된 PVC의 볼륨 크기를 자동으로 추가(필요한 경우 덮어쓰기)합니다. 그런 다음 Astra Trident가 새로운 PV를 생성하고 Kubernetes가 PVC를 PV에 결합합니다.</block>
  <block id="3a8b25f50e2dcc298175abc8f6a71f82" category="paragraph">특정 가져온 PVC가 필요한 컨테이너를 배포한 경우 PVC/PV 쌍이 볼륨 가져오기 프로세스를 통해 바인딩될 때까지 보류 상태로 유지됩니다. PVC/PV 쌍이 바인딩되면 다른 문제가 없는 한 컨테이너가 나타나야 합니다.</block>
  <block id="41603705958b86c3ec4ff21cfce13a5b" category="section-title">OpenShift 서비스를 배포합니다</block>
  <block id="7e3c623b48b608f4c6380c2994ae5aa9" category="paragraph">OpenShift 부가 가치 클러스터 서비스는 클러스터 관리자와 호스팅 중인 애플리케이션에 중요한 기능을 제공합니다. 이러한 서비스가 사용되는 스토리지는 노드 로컬 리소스를 사용하여 프로비저닝할 수 있지만, 이로 인해 서비스의 용량, 성능, 복구 가능성 및 지속 가능성이 제한되기도 합니다. 엔터프라이즈 스토리지 어레이를 활용하여 이러한 서비스에 필요한 용량을 제공하면 서비스를 대폭 향상시킬 수 있습니다. 그러나 모든 애플리케이션과 마찬가지로 OpenShift와 스토리지 관리자는 긴밀하게 협력하여 각 애플리케이션에 가장 적합한 옵션을 결정해야 합니다. Red Hat 문서는 요구 사항을 결정하고 사이징 및 성능 요구 사항을 충족할 수 있도록 적극 활용해야 합니다.</block>
  <block id="6dd8f6c286b8e1a8c96c6309099f0003" category="section-title">레지스트리 서비스</block>
  <block id="68ee1c4c0da20bfd1e946df20351d4b9" category="inline-link-macro">NetApp.IO를 참조하십시오</block>
  <block id="126ac9f6149081eb0e97c2e939eaad52" category="inline-link-macro">블로그</block>
  <block id="34d357a7f8cc47e860d5fb0a317cf22d" category="paragraph">레지스트리의 스토리지 배포 및 관리는 에 설명되어 있습니다 <block ref="d5e1883ebd095c0eda96c44469e8197d" category="inline-link-macro-rx"></block> 에 있습니다 <block ref="ceb73d0582d40281d79011a1e5343e89" category="inline-link-macro-rx"></block>.</block>
  <block id="62ac236856a5a6aefd15133e967514c6" category="section-title">로깅 서비스</block>
  <block id="2f3052b6a2858bec8355ec56150f6a38" category="paragraph">다른 OpenShift 서비스와 마찬가지로 로깅 서비스는 Ansible을 사용하여 인벤토리 파일에서 제공하는 구성 매개 변수로 배포됩니다 호스트가 플레이북에 제공됩니다. OpenShift를 설치한 후 초기 OpenShift 설치 중에 로깅을 배포하고 로깅을 배포하는 두 가지 설치 방법이 제공됩니다.</block>
  <block id="541c717d8d2998609c0970b5e43c7401" category="admonition">Red Hat OpenShift 버전 3.9를 기준으로 공식 문서는 데이터 손상 관련 우려 때문에 로깅 서비스에 NFS를 사용할 것을 권장합니다. 이는 제품에 대한 Red Hat 테스트를 기반으로 합니다. ONTAP의 NFS 서버에는 이러한 문제가 없으며 로깅 구축을 쉽게 되돌릴 수 있습니다. 궁극적으로, 로깅 서비스를 위한 프로토콜을 선택할 수 있습니다. 두 가지 모두 NetApp 플랫폼을 사용할 때 효과가 있으며 원할 경우 NFS를 피할 이유가 없습니다.</block>
  <block id="57cad4852c9c2e439f61728e0391fe7b" category="paragraph">로깅 서비스에서 NFS를 사용하도록 선택한 경우 설치 관리자의 실패를 방지하려면 Ansible 변수 "openshift_enable_unsupported_configurations"를 "true"로 설정해야 합니다.</block>
  <block id="be11c74c1dd7f307bb80183a90dc2067" category="section-title">시작하십시오</block>
  <block id="16e90b2336fdfec64b19194247422194" category="paragraph">로깅 서비스는 필요에 따라 두 애플리케이션 및 OpenShift 클러스터 자체의 핵심 운영에 구축할 수 있습니다. 작업 로깅을 배포하려는 경우 변수 "openshift_logging_use_ops"를 "true"로 지정하면 서비스의 인스턴스 두 개가 만들어집니다. 작업에 대한 로깅 인스턴스를 제어하는 변수에는 "ops"가 포함되어 있지만 응용 프로그램의 인스턴스는 그렇지 않습니다.</block>
  <block id="a9ccaa810b97a00e75bb1ea4100d0a9f" category="paragraph">기본 서비스에서 올바른 스토리지를 활용할 수 있도록 구축 방법에 따라 Ansible 변수를 구성하는 것이 중요합니다. 각 배포 방법에 대한 옵션을 살펴보겠습니다.</block>
  <block id="c5c09113a6a6ae4b75868a9e96ea3cc3" category="inline-link-macro">RedHat OpenShift 로깅 설명서</block>
  <block id="bc468c28ba57dbcb58de37265cd02436" category="admonition">아래 표에는 로깅 서비스와 관련된 스토리지 구성과 관련된 변수만 포함되어 있습니다. 에서 다른 옵션을 찾을 수 있습니다 <block ref="e81826ec3b15492352776daada114990" category="inline-link-macro-rx"></block> 배포 내용에 따라 검토, 구성 및 사용해야 합니다.</block>
  <block id="02098b11f876fe10c40b6106bd9864da" category="paragraph">아래 표의 변수는 제공된 세부 정보를 사용하여 로깅 서비스에 대한 PV 및 PVC를 생성하는 Ansible 플레이북을 만듭니다. 이 방법은 OpenShift 설치 후 구성 요소 설치 플레이북을 사용하는 것보다 훨씬 덜 유연하지만, 기존 볼륨을 사용할 수 있는 경우 옵션으로 제공됩니다.</block>
  <block id="47c14840d8e15331fa420b9b2f757cd9" category="cell">변수</block>
  <block id="3ec365dd533ddb7ef3d1c111186ce872" category="cell">세부 정보</block>
  <block id="9aa2fd43742cd5ed36b406b3f4b0fd8c" category="cell">"openshift_logging_storage_kind"</block>
  <block id="3260b06ea72e4931f5fb5106001fcc28" category="cell">설치 프로그램이 로깅 서비스에 대한 NFS PV를 생성하도록 'NFS'로 설정합니다.</block>
  <block id="e95f43173c69a9ca544d4aaef28a4d90" category="cell">"openshift_logging_storage_host"를 선택합니다</block>
  <block id="3a262c1d9bdec02b241c16b2c5f6dbbe" category="cell">NFS 호스트의 호스트 이름 또는 IP 주소입니다. 이 경우 가상 머신의 데이터 LIF로 설정해야 합니다.</block>
  <block id="41aae586bb7044d7741fe9412aa81e03" category="cell">'openshift_logging_storage_nfs_directory</block>
  <block id="bf2d137d8c669b07aae26040c7e5c0e0" category="cell">NFS 내보내기의 마운트 경로입니다. 예를 들어 볼륨이 '/openshift_logging'으로 가정되는 경우 이 변수에 해당 경로를 사용합니다.</block>
  <block id="88a9f7d18fabb82d63ac43c64ae6e735" category="cell">'openshift_logging_storage_volume_name'</block>
  <block id="6f8782c23f3cb958d0de4fad76dabaed" category="cell">생성할 PV의 이름(예: PV_ose_logs)입니다.</block>
  <block id="789e0dc4bfc00f5c885a698d6ab34dff" category="cell">"openshift_logging_storage_volume_size"</block>
  <block id="b68f05ea52c8c80c07e6a4c0671c75bf" category="cell">NFS 내보내기의 크기(예: 100Gi)입니다.</block>
  <block id="2ab80b6965298dc6a178995bbedebe88" category="paragraph">OpenShift 클러스터가 이미 실행 중이고 Trident가 배포 및 구성된 경우 설치 관리자는 동적 프로비저닝을 사용하여 볼륨을 생성할 수 있습니다. 다음 변수를 구성해야 합니다.</block>
  <block id="c2aecf833d743cbc47969cd85c67101e" category="cell">"openshift_logging_es_pvc_dynamic"</block>
  <block id="540ad9a52084720ddb7f364fa8b304c6" category="cell">동적으로 프로비저닝된 볼륨을 사용하려면 true로 설정합니다.</block>
  <block id="45a481a75749c5331e7e9fd7d89e473d" category="cell">'openshift_logging_es_pvc_storage_class_name'</block>
  <block id="837ffa1e281409660ed25582c5b1963f" category="cell">PVC에 사용될 스토리지 클래스의 이름입니다.</block>
  <block id="cd3daa927272b5624e96d283365d5500" category="cell">"openshift_logging_es_pvc_size"를 선택합니다</block>
  <block id="8f80d278a79cbc84b80a091713006022" category="cell">PVC에서 요청된 체적의 크기입니다.</block>
  <block id="1bb0c7eeef4bbbefae080a294fd554b0" category="cell">"openshift_logging_es_pvc_prefix"</block>
  <block id="f870ec92e294a018a17afe7a614fb5bb" category="cell">로깅 서비스에서 사용하는 PVC의 접두사입니다.</block>
  <block id="e8c62e1f0f0773ae5ba6a7acad696b2d" category="cell">"openshift_logging_es_ops_pvc_dynamic"</block>
  <block id="46e65a11ac398c02b8fce45a7cd5cf36" category="cell">작업 로깅 인스턴스에 동적으로 프로비저닝된 볼륨을 사용하려면 "true"로 설정합니다.</block>
  <block id="8792c7234e14325cb68c493d20ab5154" category="cell">'openshift_logging_es_ops_pvc_storage_class_name'</block>
  <block id="d016f79f0ee104f3805d61e6a379fb9b" category="cell">작업 로깅 인스턴스에 대한 스토리지 클래스의 이름입니다.</block>
  <block id="048e768365962d7d520567f92aea8355" category="cell">"openshift_logging_es_ops_pvc_size"를 선택합니다</block>
  <block id="bc367f89ac597585e52d0eb58a5929ae" category="cell">작업 인스턴스에 대한 볼륨 요청의 크기입니다.</block>
  <block id="155871626071d69cb283985a9f36bad2" category="cell">"openshift_logging_es_ops_pvc_prefix"</block>
  <block id="2a8f254749a466654f556c6466051133" category="cell">ops instance PVCs(ops 인스턴스 PVC)의 접두사입니다.</block>
  <block id="e1b2d0d3228c29c069bcd139de306709" category="section-title">로깅 스택을 배포합니다</block>
  <block id="0409a0cfdfa4f3b3033503b8309442ff" category="paragraph">초기 OpenShift 설치 프로세스의 일부로 로깅을 배포하는 경우 표준 배포 프로세스만 따르면 됩니다. Ansible이 완료되는 즉시 서비스를 이용할 수 있도록 필요한 서비스와 OpenShift 개체를 구성 및 배포합니다.</block>
  <block id="210ecadaccb6088b0dfbd2e6a0b5d0a0" category="inline-link-macro">RedHat OpenShift Container Platform 3.11 설명서</block>
  <block id="67f3e99678cc7c568f4ed29074cdc41c" category="paragraph">하지만 초기 설치 후에 구축할 경우 구성 요소 플레이북을 Ansible에서 사용해야 합니다. 이 프로세스는 다른 버전의 OpenShift에서 약간 변경될 수 있으므로 반드시 읽고 따라야 합니다 <block ref="a2226808e95b8487c66dd3b8cbea118e" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="3dbf527ac3caf41ab150ec99a1737217" category="section-title">메트릭 서비스</block>
  <block id="d0ed828e153e9bad2da040ddf6ad8f45" category="paragraph">로깅 서비스 및 OpenShift와 마찬가지로 Ansible을 사용하여 메트릭 서비스를 배포합니다. 또한 로깅 서비스와 마찬가지로 메트릭 서비스는 클러스터의 초기 설정 중에 또는 구성 요소 설치 방법을 사용하여 작동 후에 배포될 수 있습니다. 다음 표에는 메트릭 서비스에 대한 영구 스토리지를 구성할 때 중요한 변수가 나와 있습니다.</block>
  <block id="69aa4440020e49c654aeb910f38c6bb9" category="admonition">아래 표에는 메트릭 서비스와 관련된 스토리지 구성과 관련된 변수만 포함되어 있습니다. 문서에 나와 있는 다른 많은 옵션은 배포 내용에 따라 검토, 구성 및 사용해야 합니다.</block>
  <block id="4f692d78f978a73b157571022c1d1ba7" category="cell">"openshift_metrics_storage_kind"</block>
  <block id="30da7e263c0cffc34933d24a07fb097a" category="cell">'openshift_metrics_storage_host</block>
  <block id="adba8dd7dd2b027405b815c03a05dbf1" category="cell">NFS 호스트의 호스트 이름 또는 IP 주소입니다. SVM을 위한 데이터 LIF로 설정해야 합니다.</block>
  <block id="3bafc264ad2a901d3be052a7f1cf2e44" category="cell">'openshift_metrics_storage_nfs_directory</block>
  <block id="459859e54ba90bc4145c54d1f1deecff" category="cell">NFS 내보내기의 마운트 경로입니다. 예를 들어, 볼륨이 '/openshift_metrics'로 가정되는 경우 이 변수에 해당 경로를 사용합니다.</block>
  <block id="ca0f0d82f9c7cbc36df652cddd4b2f35" category="cell">'openshift_metrics_storage_volume_name'</block>
  <block id="eb10d02b22b02d7f543f867b8d31e7b0" category="cell">생성할 PV의 이름(예: PV_ose_metrics).</block>
  <block id="a3eeeafe923ac73e75b3bf33cdadb603" category="cell">'openshift_metrics_storage_volume_size</block>
  <block id="a56c731cfe96d228c7c0bcc57bc80d3d" category="cell">'openshift_metrics_cassandra_pvc_prefix'</block>
  <block id="0da919d4045e4f38d294aaec73f5d57f" category="cell">지표 PVC에 사용할 접두사입니다.</block>
  <block id="15bb3eef0b42a93e324977c289f2fd85" category="cell">'openshift_metrics_cassandra_pvc_size</block>
  <block id="75929c9d67f1407282b5618fca4589e7" category="cell">요청할 볼륨의 크기입니다.</block>
  <block id="8ebb493e0ffdf7c1e850c67bc22f15c7" category="cell">'openshift_metrics_cassandra_storage_type'</block>
  <block id="aab0ec84a4da1dfd2b63896453f1e05d" category="cell">메트릭에 사용할 스토리지 유형으로, 적절한 스토리지 클래스로 PVC를 생성하려면 Ansible에서 이를 동적 으로 설정해야 합니다.</block>
  <block id="460aaf3805271ec2e5dc35755fe317b1" category="cell">'openshift_metrics_cassanda_pvc_storage_class_name'</block>
  <block id="0c55ca33e89539cd67eb0be3796547c5" category="cell">사용할 스토리지 클래스의 이름입니다.</block>
  <block id="6c13e62eb53f29e7794d3807369299d2" category="section-title">메트릭 서비스를 구축합니다</block>
  <block id="3e75d51468f5a99fdb50b75dafea32e8" category="paragraph">호스트/인벤토리 파일에 정의된 적절한 Ansible 변수를 사용하여 서비스를 구축하십시오. OpenShift 설치 시 배포하는 경우 PV가 자동으로 생성되고 사용됩니다. OpenShift를 설치한 후 구성 요소 플레이북을 사용하여 배포하는 경우, Ansible이 필요한 PVC를 만들고 Astra Trident가 PVC를 위한 스토리지를 프로비저닝하면 서비스를 배포합니다.</block>
  <block id="bf1cadd7aa4e541e255df26af5451d85" category="inline-link-macro">RedHat의 OpenShift 배포 가이드</block>
  <block id="eb502d6483a644e9b6f61ca4719276d8" category="paragraph">위의 변수와 배포 프로세스는 각 OpenShift 버전에 따라 변경될 수 있습니다. 검토 후 준수해야 합니다 <block ref="5ad72ffc1eda2c257c8947a0ad66dddb" category="inline-link-macro-rx"></block> 사용자 환경에 맞게 구성되도록 사용자의 버전에 대해.</block>
  <block id="6e8775bd755a8835ce86806d669677ea" category="doc">스토리지 구성</block>
  <block id="ac5112696fd64ee051846c666ebebebe" category="paragraph">활용 중인 프로토콜을 사용하여 호스트 운영 체제의 기준 모범 사례를 따라야 합니다. 필요에 따라 특정 애플리케이션에 맞게 스토리지를 최적화할 수 있도록 백엔드, 스토리지 클래스 및 PVC 설정과 함께 사용 가능한 경우 애플리케이션 Best Practice를 통합하는 것을 고려할 수 있습니다.</block>
  <block id="efc9d085ca2f3a152c786357e9359c03" category="section-title">ONTAP 및 Cloud Volumes ONTAP 모범 사례</block>
  <block id="a3f99d5d44515cf922e6b525de736173" category="paragraph">Trident를 위한 ONTAP 및 Cloud Volumes ONTAP를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="76d50c7d0f100e6264e0d57727d099f1" category="paragraph">다음 권장 사항은 Trident에서 동적으로 프로비저닝되는 볼륨을 사용하는 컨테이너식 워크로드에 대한 ONTAP 구성 지침입니다. 각 항목을 고려하여 작업 환경의 적절성을 판단해야 합니다.</block>
  <block id="3fb21976d2729216782dd61ffed84a54" category="section-title">Trident 전용 SVM을 사용하십시오</block>
  <block id="fa4e21d3612a3f737c7a4ac7ebf24950" category="paragraph">SVM(스토리지 가상 시스템)은 ONTAP 시스템의 테넌트 간에 격리하고 관리를 제공합니다. SVM을 애플리케이션 전용으로 사용하면 권한을 위임하고 리소스 사용을 제한하는 모범 사례를 적용할 수 있습니다.</block>
  <block id="3dc5510a67688b81f0d6d0db440da909" category="paragraph">SVM 관리를 위해 몇 가지 옵션을 사용할 수 있습니다.</block>
  <block id="fe425a9419fa4d05d42131c26306e4f1" category="list-text">백엔드 구성에서 클러스터 관리 인터페이스를 적절한 자격 증명과 함께 제공하고 SVM 이름을 지정합니다.</block>
  <block id="e2160df70bcda0ee43cb3c66dc22c719" category="list-text">ONTAP System Manager 또는 CLI를 사용하여 SVM을 위한 전용 관리 인터페이스를 생성합니다.</block>
  <block id="2bf2fa2c1c3a6e10095db72759cc9983" category="list-text">관리 역할을 NFS 데이터 인터페이스와 공유합니다.</block>
  <block id="5cf4c2e89b362842d77f4e4209c4ef99" category="paragraph">각 경우 인터페이스가 DNS에 있어야 하며, Trident를 구성할 때 DNS 이름을 사용해야 합니다. 이렇게 하면 네트워크 ID 보존을 사용하지 않고 SVM-DR과 같은 일부 DR 시나리오를 간편하게 수행할 수 있습니다.</block>
  <block id="6a392b5e005fffe32231c94dc96a1605" category="inline-link">SVM-DR</block>
  <block id="2b4a6ee2db063653d6076884295a3854" category="paragraph">SVM에 전용 또는 공유 관리 LIF를 사용하는 것이 더 이상 선호되지 않지만, 선택한 접근 방식에 맞게 네트워크 보안 정책을 조정해야 합니다. 관리 LIF는 DNS를 통해 액세스할 수 있어야 하며, 유연성을 극대화해야 합니다<block ref="f5e9502989ce78934689806ebb69606a" category="inline-link-rx"></block> Trident와 함께 사용합니다.</block>
  <block id="4a0ee008d3379206a925ade3a9e707dd" category="section-title">최대 볼륨 수를 제한합니다</block>
  <block id="e5e09031843479ef9ef8cbbd4c2f404c" category="inline-link">NetApp Hardware Universe를 참조하십시오</block>
  <block id="400a5d259a812effb5b7df506bf020ef" category="paragraph">ONTAP 스토리지 시스템의 최대 볼륨 수는 소프트웨어 버전과 하드웨어 플랫폼에 따라 다릅니다. 을 참조하십시오<block ref="bb9c67b5a4c15a85b5e6aa6c9afd0285" category="inline-link-rx"></block> 정확한 제한을 결정하는 특정 플랫폼 및 ONTAP 버전. 볼륨 수가 소진되면 프로비저닝 작업이 Trident뿐 아니라 모든 스토리지 요청에 대해 실패합니다.</block>
  <block id="39da19b7dd55941b6cdabf34befc0b4c" category="paragraph">Trident의 'ONTAP-NAS' 및 'ONTAP-SAN' 드라이버는 생성되는 각 Kubernetes 영구 볼륨(PV)에 대해 FlexVolume을 프로비저닝합니다. 'ONTAP-NAS-이코노미' 드라이버는 200개의 PVS에 대해 약 1개의 FlexVolume을 생성합니다(50개에서 300개로 구성 가능). 'ONTAP-SAN-이코노미' 드라이버는 PVS 100대당 약 1개의 FlexVolume을 생성합니다(50개에서 200개로 구성 가능). Trident가 스토리지 시스템에서 사용 가능한 모든 볼륨을 사용하지 않도록 하려면 SVM에 제한을 설정해야 합니다. 이 작업은 명령줄에서 수행할 수 있습니다.</block>
  <block id="f36680e3d3cb96c74d2f1a54c3c4a0fa" category="paragraph">'최대 볼륨'의 값은 환경에 따라 몇 가지 기준에 따라 달라집니다.</block>
  <block id="5f6d1abb6889904ee0375b2fc6c8f078" category="list-text">ONTAP 클러스터에 있는 기존 볼륨의 수입니다</block>
  <block id="029383c13d9ad2c5ba18a16f8fbe2002" category="list-text">다른 애플리케이션에 대해 Trident 외부에 프로비저닝할 것으로 예상되는 볼륨 수입니다</block>
  <block id="02f4ac473b944a63551d51d727b5bb49" category="list-text">Kubernetes 애플리케이션에서 사용할 것으로 예상되는 영구 볼륨의 수입니다</block>
  <block id="1d3555f20ac0a2897a1596631b5fb27a" category="paragraph">max-volumes 값은 개별 ONTAP 노드가 아닌 ONTAP 클러스터의 모든 노드에 프로비저닝된 총 볼륨입니다. 결과적으로, ONTAP 클러스터 노드에 다른 노드보다 훨씬 더 많은 Trident 프로비저닝 볼륨이 있을 수 있는 몇 가지 조건이 발생할 수 있습니다.</block>
  <block id="46710fe77f663864a23e02a880a9ae53" category="inline-link">애그리게이트</block>
  <block id="8eb27359ed8f69eb07c318fcd224ba66" category="paragraph">예를 들어, 2노드 ONTAP 클러스터에는 최대 2000개의 FlexVolumes를 호스팅할 수 있는 기능이 있습니다. 최대 볼륨 수를 1250으로 설정하면 매우 적절합니다. 그러나, 단 인 경우<block ref="acf6cbef6ee0ef07ee3fe13269233be8" category="inline-link-rx"></block> 한 노드에서 SVM에 할당하거나, 한 노드에서 할당된 애그리게이트는 용량 등으로 인해 프로비저닝할 수 없는 경우, 다른 노드는 프로비저닝된 모든 Trident 볼륨의 타겟이 됩니다. 즉, '최대 볼륨' 값에 도달하기 전에 해당 노드에 대한 볼륨 제한에 도달하여 Trident와 해당 노드를 사용하는 다른 볼륨 작업에 영향을 줄 수 있습니다. * 클러스터의 각 노드에서 애그리게이트가 동일한 수의 Trident가 사용하는 SVM에 할당되도록 하면 이러한 상황을 방지할 수 있습니다. *</block>
  <block id="7ef3217c984ef7f973d389e434be312c" category="section-title">Trident에서 생성한 볼륨의 최대 크기를 제한합니다</block>
  <block id="031b203330c3abb94f6fa406ff721de4" category="paragraph">Trident에서 생성할 수 있는 볼륨의 최대 크기를 구성하려면 'backend.json' 정의에 있는 'limitVolumeSize' 매개 변수를 사용하십시오.</block>
  <block id="1c19414de17c9992b25b0a1b02a52715" category="paragraph">스토리지 어레이에서 볼륨 크기를 제어하는 것 외에도 Kubernetes 기능을 활용해야 합니다.</block>
  <block id="85c0f9773e01224a56713ea4e6d83b86" category="section-title">양방향 CHAP를 사용하도록 Trident를 구성합니다</block>
  <block id="8b7c80a4394c7e64aa891100d57a755f" category="paragraph">백엔드 정의에 CHAP 이니시에이터와 타겟 사용자 이름 및 암호를 지정하고 SVM에서 Trident가 CHAP를 사용하도록 설정할 수 있습니다. 백엔드 구성의 "useCHAP" 매개 변수를 사용하여 Trident는 CHAP로 ONTAP 백엔드에 대한 iSCSI 연결을 인증합니다. 양방향 CHAP 지원은 Trident 20.04 이상에서 사용할 수 있습니다.</block>
  <block id="2596e59ce5cd0d1b0066656f191365d0" category="section-title">SVM QoS 정책을 생성하고 사용합니다</block>
  <block id="560417d4f795b7e1176a40db8e4ccca8" category="inline-link">괴롭힘을 방지합니다</block>
  <block id="4870168b0713fe3089cf587858fc3b40" category="paragraph">SVM에 적용되는 ONTAP QoS 정책을 활용하여 Trident에서 프로비저닝된 볼륨에서 사용할 수 있는 IOPS 수를 제한합니다. 그러면 에 도움이 됩니다<block ref="1b59d76842e8b78d6111d3e73e9cd404" category="inline-link-rx"></block> 또는 Trident SVM 외부의 워크로드에 영향을 주지 않는 제어 컨테이너</block>
  <block id="d6ab867679686745d96bea839929a6de" category="paragraph">몇 가지 단계로 SVM에 대한 QoS 정책을 생성할 수 있습니다. 가장 정확한 정보는 사용 중인 ONTAP 버전 설명서를 참조하십시오. 아래 예는 SVM에 사용 가능한 총 IOPS를 5000으로 제한하는 QoS 정책을 생성합니다.</block>
  <block id="c790de304b7ca0097f2133cf9da4e657" category="paragraph">또한 사용하는 ONTAP 버전에서 지원하는 경우에는 최소 QoS를 사용하여 컨테이너화된 워크로드에 대한 처리량을 보장하는 것을 고려할 수 있습니다. 적응형 QoS는 SVM 레벨 정책과 호환되지 않습니다.</block>
  <block id="38c0b69f6b2ee691e1ba568134513414" category="paragraph">컨테이너화된 워크로드 전용 IOPS 수는 다양한 측면에 따라 다릅니다. 그 밖의 다른 사항으로는 다음과 같은 것들이 있습니다.</block>
  <block id="ddbd18591c9b7378c6187dbd9179e1f0" category="list-text">기타 워크로드는 스토리지 어레이를 사용합니다. 스토리지 리소스를 활용하여 Kubernetes 구축과 관련되지 않은 다른 워크로드가 있는 경우, 해당 워크로드가 실수로 영향을 받지 않도록 주의해야 합니다.</block>
  <block id="5da5727b396cee5b024364d989fe253b" category="list-text">컨테이너에서 실행 중인 예상 워크로드 IOPS 요구사항이 높은 워크로드를 컨테이너에서 실행할 경우 QoS 정책이 낮으면 잘못된 경험이 될 수 있습니다.</block>
  <block id="e6f229b5d5d2421c4306920759828212" category="paragraph">SVM 레벨에서 할당된 QoS 정책을 사용하면 동일한 IOPS 풀을 공유하는 SVM에 프로비저닝된 모든 볼륨이 생성된다는 점을 기억해야 합니다. 컨테이너화된 애플리케이션 중 하나 또는 그 수가 적은 경우 높은 IOPS 요구사항이 있으면 다른 컨테이너화된 워크로드에 문제가 될 수 있습니다. 이 경우 외부 자동화를 사용하여 볼륨당 QoS 정책을 할당하는 것을 고려할 수 있습니다.</block>
  <block id="ac2167b1e02d575eb6ddfe4e58f5cdcf" category="admonition">ONTAP 버전이 9.8 이전인 경우 SVM * 에만 QoS 정책 그룹을 할당해야 합니다.</block>
  <block id="9992cae6c17055c750a849c5f6135eb2" category="section-title">Trident에 대한 QoS 정책 그룹을 생성합니다</block>
  <block id="76a3e54f72b3a7224429f111e58f836c" category="inline-link">QoS를 통해 처리량 보장</block>
  <block id="edb2313b52b4c42008f0531bd6a05e49" category="paragraph">QoS(서비스 품질)는 경쟁 워크로드로부터 주요 워크로드의 성능이 저하되지 않도록 보장합니다. ONTAP QoS 정책 그룹은 볼륨에 대한 QoS 옵션을 제공하고 사용자가 하나 이상의 워크로드에 대한 처리량 한도를 정의할 수 있도록 지원합니다. QoS에 대한 자세한 내용은 를 참조하십시오<block ref="721a1778a2025ec5868484b3888c0186" category="inline-link-rx"></block>. 백엔드에서 또는 스토리지 풀에 QoS 정책 그룹을 지정할 수 있으며, 이러한 그룹은 해당 풀 또는 백엔드에서 생성된 각 볼륨에 적용됩니다.</block>
  <block id="0394fb1288eac4cd3d40bcd991e079e9" category="paragraph">ONTAP에는 기존 QoS 정책과 적응형 서비스 두 가지 QoS 정책 그룹이 있습니다. 기존 정책 그룹은 IOPS 단위로 최대 또는 최소 단위의 고정 처리량을 제공합니다. 적응형 QoS는 워크로드 크기에 따라 처리량을 자동으로 확장하므로 워크로드 크기에 따라 IOPS와 TB|GB의 비율을 유지합니다. 따라서 대규모 구축 환경에서 수백 또는 수천 개의 워크로드를 관리할 경우 상당한 이점이 있습니다.</block>
  <block id="f5acc65a21daed9bb8e91cb5cdd0ae52" category="paragraph">QoS 정책 그룹을 생성할 때는 다음 사항을 고려하십시오.</block>
  <block id="6d5fcf300cd9e9239c26ce37b0919fca" category="list-text">백엔드 구성의 "deefaults" 블록에 qosPolicy 키를 설정해야 합니다. 다음 백엔드 구성 예를 참조하십시오.</block>
  <block id="32160c2368452bf7d86bcffae7f142be" category="list-text">각 볼륨이 정책 그룹에서 지정한 전체 처리량을 얻을 수 있도록 볼륨별로 정책 그룹을 적용해야 합니다. 공유 정책 그룹은 지원되지 않습니다.</block>
  <block id="b2365e059850d5e32885189655bf469c" category="inline-link">ONTAP 9.8 QoS 명령</block>
  <block id="23225608cf33a6c6a4aec9126514b0e1" category="paragraph">QoS 정책 그룹에 대한 자세한 내용은 을 참조하십시오<block ref="40468e984a92fba9003857701268163a" category="inline-link-rx"></block>.</block>
  <block id="d5d2a5bc92eea85a4dd11a642ed8a170" category="section-title">스토리지 리소스에 대한 액세스 권한을 Kubernetes 클러스터 구성원으로 제한합니다</block>
  <block id="0f2b74d1b972675eb3d4efe7d8c3ed16" category="paragraph">Trident에서 생성한 NFS 볼륨 및 iSCSI LUN에 대한 액세스를 제한하는 것은 Kubernetes 구축을 위한 보안 환경의 중요한 구성요소입니다. 이렇게 하면 Kubernetes 클러스터의 일부가 아닌 호스트가 볼륨에 액세스하고 예기치 않게 데이터를 수정하는 것을 방지할 수 있습니다.</block>
  <block id="9602ec8691c1a564016f9fd8086139f1" category="paragraph">네임스페이스가 Kubernetes의 리소스에 대한 논리적 경계라는 것을 이해하는 것이 중요합니다. 동일한 네임스페이스의 리소스를 공유할 수 있다고 가정하지만, 특히 상호 네임스페이스 기능이 없다는 것이 중요합니다. 즉, PVS는 글로벌 객체이지만 PVC에 바인딩되면 동일한 네임스페이스에 있는 Pod에서만 액세스할 수 있습니다. * 적절한 경우 네임스페이스를 사용하여 구분을 제공하는 것이 중요합니다. *</block>
  <block id="13d28e8dfc702e3456e0767dff9a128a" category="inline-link">네임스페이스</block>
  <block id="1162be0546226cff2cbd973cd2140d33" category="paragraph">Kubernetes 컨텍스트에서 데이터 보안과 관련하여 대부분의 조직은 컨테이너 내의 프로세스가 호스트에 마운트된 스토리지에 액세스할 수 있지만 컨테이너용 프로세스는 아닙니다. <block ref="962cfea7b49ca7b2d398d891b4313cb5" category="inline-link-rx"></block> 이러한 유형의 손상을 방지하도록 설계되었습니다. 그러나 권한 있는 컨테이너에는 한 가지 예외가 있습니다.</block>
  <block id="7b10e929cc2e0061dfb50042a0203c79" category="inline-link">POD 보안 정책</block>
  <block id="76db1afb772160283f7f86cdd67c35f8" category="paragraph">권한 있는 컨테이너는 일반적인 것보다 훨씬 더 많은 호스트 수준 권한으로 실행되는 컨테이너입니다. 이러한 기능은 기본적으로 거부되지 않으므로 을 사용하여 기능을 사용하지 않도록 설정해야 합니다<block ref="e5ab4ede40a4a6a5f5684247585b5fb0" category="inline-link-rx"></block>.</block>
  <block id="5fabba1d91abcfb09b6049897727e91c" category="paragraph">Kubernetes 및 외부 호스트 모두에서 액세스가 필요한 볼륨의 경우, Trident에서 관리하지 않고 관리자가 PV를 도입한 상태로 스토리지를 기존 방식으로 관리해야 합니다. 이렇게 하면 Kubernetes 및 외부 호스트의 연결이 모두 끊기고 볼륨을 더 이상 사용하지 않는 경우에만 스토리지 볼륨이 폐기됩니다. 또한, 맞춤형 엑스포트 정책을 적용하여 Kubernetes 클러스터 노드 및 Kubernetes 클러스터 외부의 타겟 서버에서 액세스할 수 있습니다.</block>
  <block id="e38f5be5ff6a8a362870a032acdf5d2f" category="section-title">전용 엑스포트 정책을 사용하십시오</block>
  <block id="2f05855ad489343ae535c8f17eaa6f34" category="paragraph">Kubernetes 클러스터에 있는 노드에만 액세스할 수 있도록 각 백엔드에 대한 엑스포트 정책이 있어야 합니다. Trident는 20.04 릴리스부터 내보내기 정책을 자동으로 생성하고 관리할 수 있습니다. 이러한 방법으로 Trident는 Kubernetes 클러스터의 노드에 프로비저닝되는 볼륨에 대한 액세스를 제한하고 노드 추가/삭제를 단순화합니다.</block>
  <block id="28af9e32119f59018dd5d887ad93ccd4" category="paragraph">또는 수동으로 엑스포트 정책을 생성하여 각 노드 액세스 요청을 처리하는 하나 이상의 엑스포트 규칙으로 채울 수도 있습니다.</block>
  <block id="4ae1e64986504dce6897746ebc9d2786" category="list-text">vserver export-policy create ONTAP CLI 명령을 사용하여 엑스포트 정책을 생성합니다.</block>
  <block id="cd0a9fca1fb3ba0fcdd98d0e87cb78a9" category="list-text">vserver export-policy rule create ONTAP CLI 명령을 사용하여 엑스포트 정책에 규칙을 추가합니다.</block>
  <block id="bc3a2f6421da1e870583cfb0b9cf4a91" category="paragraph">이러한 명령을 실행하면 데이터에 액세스할 수 있는 Kubernetes 노드를 제한할 수 있습니다.</block>
  <block id="613655fb3db9bdbe0f795ee9424fc1fe" category="paragraph">'howmount' 기능을 사용하면 NFS 클라이언트가 SVM을 쿼리하여 사용 가능한 NFS 내보내기 목록을 확인할 수 있습니다. Kubernetes 클러스터에 구축된 POD는 데이터 LIF에 대해 'howmount -e' 명령을 실행하여 액세스할 수 없는 마운트를 비롯한 사용 가능한 마운트 목록을 받을 수 있습니다. 이는 그 자체로 보안 문제가 아니라, 권한이 없는 사용자가 NFS 내보내기에 연결하는 데 도움이 될 수 있는 불필요한 정보를 제공합니다.</block>
  <block id="08f1d9a2f49f56965b640bc15796cd61" category="paragraph">SVM 레벨의 ONTAP CLI 명령을 사용하여 'howmount'를 비활성화해야 합니다.</block>
  <block id="648e0e1a6a98e76bdfe9780c42dacb6b" category="section-title">SolidFire 모범 사례</block>
  <block id="89f93e411a40f5c6365a4703e004f15b" category="paragraph">Trident를 위한 SolidFire 스토리지를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="52f311b56fcd9d4fb074918af9b7c7f9" category="section-title">SolidFire 계정을 만듭니다</block>
  <block id="b0dd2707e9f12b5e1fda314748ffa386" category="paragraph">각 SolidFire 계정은 고유한 볼륨 소유자를 나타내며 자체 CHAP(Challenge-Handshake 인증 프로토콜) 자격 증명을 받습니다. 계정 이름 및 상대 CHAP 자격 증명을 사용하거나 볼륨 액세스 그룹을 통해 계정에 할당된 볼륨에 액세스할 수 있습니다. 계정에는 최대 2천 개의 볼륨이 할당될 수 있지만 볼륨은 하나의 계정에만 속할 수 있습니다.</block>
  <block id="eaf4b71058f7db58997dfe694c62a96a" category="section-title">QoS 정책을 생성합니다</block>
  <block id="fd640dfd679c3a7e40aa99c3e08c8294" category="paragraph">여러 볼륨에 적용할 수 있는 표준화된 서비스 품질 설정을 만들어 저장하려면 SolidFire 서비스 품질(QoS) 정책을 사용하십시오.</block>
  <block id="41be5238fc563c2aac0a0e6ee4cf6e96" category="paragraph">볼륨별로 QoS 매개 변수를 설정할 수 있습니다. QoS를 정의하는 세 가지 구성 가능한 매개 변수, 즉 Min IOPS, Max IOPS, Burst IOPS를 설정하여 각 볼륨의 성능을 보장할 수 있습니다.</block>
  <block id="48e4bd34fd7a9e1233ea82bc818a3161" category="paragraph">4KB 블록 크기에 대해 가능한 최소, 최대 및 버스트 IOPS 값입니다.</block>
  <block id="8e4988a1e5f387efce6f20e4f25a8e40" category="cell">IOPS 매개 변수입니다</block>
  <block id="0b890b1926b90387673882e6ccae7fdc" category="cell">정의</block>
  <block id="96a22bf638896c990d26e043087fb6b0" category="cell">최소 값</block>
  <block id="31ce3cdcd67850870b616f75b555bbc5" category="cell">기본값</block>
  <block id="c9fb55be94277b8390352c215f32d44c" category="cell">최대 가치(4KB)</block>
  <block id="b05f9ccd772b396ac1f5a05345a9d4f8" category="paragraph">최소 IOPS</block>
  <block id="2b30c179facf62f8a2bdbd1b09b37b96" category="paragraph">볼륨에 대한 보장된 성능 수준.</block>
  <block id="c0c7c76d30bd3dcaefc96f40275bdc0a" category="cell">50</block>
  <block id="3f74a886c7f841699690962c497d4f30" category="paragraph">15000</block>
  <block id="4f5a6f8b41826526724ba294b8e056bd" category="paragraph">최대 IOPS</block>
  <block id="4e41c5ccaf1affa697729ea4d1e88554" category="paragraph">성능은 이 제한을 초과하지 않습니다.</block>
  <block id="e05695d29cb4a9339534e5a9c273fa14" category="paragraph">200,000</block>
  <block id="affd4aba1c5f696e972368c9eb698c65" category="paragraph">버스트 IOPS</block>
  <block id="2734923c054f38d8ca66133414af4469" category="paragraph">짧은 버스트 시나리오에서 허용되는 최대 IOPS입니다.</block>
  <block id="e2eb05f1ef7720127ac371ceddc6f433" category="admonition">최대 IOPS와 버스트 IOPS는 최대 200,000으로 설정할 수 있지만, 실제 볼륨의 최대 성능은 클러스터 사용량 및 노드당 성능에 의해 제한됩니다.</block>
  <block id="fa9b1a3006e0ba9ad904c059c0b9add6" category="inline-link">SolidFire 서비스 품질</block>
  <block id="7363485d4653963c22d3ed43afd0003a" category="paragraph">블록 크기와 대역폭은 IOPS 수에 직접적인 영향을 미칩니다. 블록 크기가 증가함에 따라 시스템에서 더 큰 블록 크기를 처리하는 데 필요한 수준까지 대역폭을 높일 수 있습니다. 대역폭이 증가할수록 시스템에서 달성할 수 있는 IOPS의 수가 감소합니다. 을 참조하십시오<block ref="c8976c50ed9f016849fdce232777cd31" category="inline-link-rx"></block> QoS 및 성능에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="b4657825f74ed622384dddf3a1d7d3b7" category="section-title">SolidFire 인증</block>
  <block id="9d3b5ff1cde828a63203f0465a34a967" category="paragraph">요소는 CHAP 및 vag(볼륨 액세스 그룹)의 두 가지 인증 방법을 지원합니다. CHAP는 CHAP 프로토콜을 사용하여 호스트를 백엔드에 인증합니다. 볼륨 액세스 그룹은 프로비전되는 볼륨에 대한 액세스를 제어합니다. NetApp은 CHAP를 사용하여 인증을 수행하는 것이 더 간단하고 확장 제한이 없기 때문에 CHAP를 사용하는 것이 좋습니다.</block>
  <block id="fc9e812321a3f9b0eab1b702a08bab4e" category="admonition">CSI 프로비저닝이 강화된 Trident는 CHAP 인증 사용을 지원합니다. VAG는 일반적인 비 CSI 작동 모드에서만 사용해야 합니다.</block>
  <block id="d23eaa75b7bd1405526da0e18b7290ac" category="paragraph">CHAP 인증(이니시에이터가 대상 볼륨 사용자인지 확인)은 계정 기반 액세스 제어에서만 지원됩니다. CHAP를 인증에 사용하는 경우 단방향 CHAP 및 양방향 CHAP의 두 가지 옵션을 사용할 수 있습니다. 단방향 CHAP는 SolidFire 계정 이름 및 이니시에이터 암호를 사용하여 볼륨 액세스를 인증합니다. 양방향 CHAP 옵션은 볼륨이 계정 이름과 이니시에이터 암호를 통해 호스트를 인증한 다음 호스트가 계정 이름과 타겟 암호를 통해 볼륨을 인증하기 때문에 볼륨을 인증하는 가장 안전한 방법을 제공합니다.</block>
  <block id="42d135bea104c1079cebd1543c89e970" category="paragraph">그러나 CHAP를 설정할 수 없고 VAG가 필요한 경우 액세스 그룹을 생성하고 호스트 이니시에이터 및 볼륨을 액세스 그룹에 추가합니다. 액세스 그룹에 추가하는 각 IQN은 CHAP 인증을 사용하거나 사용하지 않고 그룹의 각 볼륨에 액세스할 수 있습니다. iSCSI 이니시에이터가 CHAP 인증을 사용하도록 구성된 경우 계정 기반 액세스 제어가 사용됩니다. iSCSI 초기자가 CHAP 인증을 사용하도록 구성되지 않은 경우 볼륨 액세스 그룹 액세스 제어가 사용됩니다.</block>
  <block id="b4931a42b69dbf4e721e7b97873b1ebb" category="section-title">자세한 정보는 어디서 찾을 수 있습니까?</block>
  <block id="2c3a4d5c923121574c10ea22c0474a01" category="inline-link">NetApp 라이브러리</block>
  <block id="65840df7365892d2abe1280cb6cdb1d2" category="paragraph">다음은 몇 가지 모범 사례 문서입니다. 를 검색합니다<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 최신 버전의 경우.</block>
  <block id="d911b17f4f4cdcca62a04ad77aa9403d" category="paragraph">* ONTAP *</block>
  <block id="f9dd52d280693dc59e53b6e1fb7bd801" category="inline-link">NFS Best Practice and Implementation Guide를 참조하십시오</block>
  <block id="40bb23d54df7f59219c18f15a346d9e5" category="list-text"><block ref="40bb23d54df7f59219c18f15a346d9e5" category="inline-link-rx"></block></block>
  <block id="a76193f5d9397d9c49ca283a20ccf649" category="inline-link">SAN 관리 가이드를 참조하십시오</block>
  <block id="5bc9b097037d45aff954bf9bd632d4a4" category="list-text"><block ref="c745f55eb0c9991966e63f0608541bb1" category="inline-link-rx"></block> (iSCSI의 경우)</block>
  <block id="5ca34d6ffc2a555b689542e3fbeeb7af" category="inline-link">RHEL용 iSCSI Express 구성</block>
  <block id="36588ac65dcdb9b93916fb0ab708edb3" category="list-text"><block ref="36588ac65dcdb9b93916fb0ab708edb3" category="inline-link-rx"></block></block>
  <block id="ca7ab5ec4cba84fbef55956bb38759ce" category="paragraph">Element 소프트웨어 *</block>
  <block id="e809d9f88c2933195c4d2ab379c1b5dc" category="inline-link">Linux용 SolidFire 구성</block>
  <block id="ce0470e08aa854a8f93fa119434e8422" category="list-text"><block ref="ce0470e08aa854a8f93fa119434e8422" category="inline-link-rx"></block></block>
  <block id="d64280eb12d42bb67976ffba6d268e7b" category="paragraph">* NetApp HCI *</block>
  <block id="3bc72bedcc42d144356d4f933c48485d" category="inline-link">NetApp HCI 구축 사전 요구 사항</block>
  <block id="85bfffc1a1f7aaabd6cf58841640c308" category="list-text"><block ref="85bfffc1a1f7aaabd6cf58841640c308" category="inline-link-rx"></block></block>
  <block id="b52e411998b7d3a95ad5bd8a320bf271" category="inline-link">NetApp 배포 엔진에 액세스합니다</block>
  <block id="9d0da73b02655dd7861121905db229e2" category="list-text"><block ref="9d0da73b02655dd7861121905db229e2" category="inline-link-rx"></block></block>
  <block id="9aaca8cfd79770bc4944ccc477e37141" category="paragraph">* 응용 프로그램 모범 사례 정보 *</block>
  <block id="27a5e02bc2fadee43ace94805739a0c8" category="inline-link">ONTAP 기반 MySQL의 모범 사례</block>
  <block id="40d2eaf9adabe99a601c57eabf49e4d3" category="list-text"><block ref="40d2eaf9adabe99a601c57eabf49e4d3" category="inline-link-rx"></block></block>
  <block id="17efdd7d210511985714be299d595292" category="inline-link">SolidFire 기반 MySQL의 모범 사례</block>
  <block id="d03b53d8ec563c37e16ee8c900a75b96" category="list-text"><block ref="d03b53d8ec563c37e16ee8c900a75b96" category="inline-link-rx"></block></block>
  <block id="3aefe1a041af945f1fe8673bf775057b" category="inline-link">NetApp SolidFire 및 Cassandra</block>
  <block id="7e2b19f6f6bd1332efe1f7a698984670" category="list-text"><block ref="7e2b19f6f6bd1332efe1f7a698984670" category="inline-link-rx"></block></block>
  <block id="6e580111d3a8c12cdcd9522a4d3484c6" category="inline-link">SolidFire에 대한 Oracle 모범 사례</block>
  <block id="6db96715cefe9c4950ef722865494128" category="list-text"><block ref="6db96715cefe9c4950ef722865494128" category="inline-link-rx"></block></block>
  <block id="6448cf37496207be126495e5b05851de" category="inline-link">SolidFire에 대한 PostgreSQL Best Practice</block>
  <block id="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="list-text"><block ref="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="inline-link-rx"></block></block>
  <block id="b062996d6ca590abe798d3db75561f79" category="paragraph">모든 애플리케이션에 구체적인 지침이 있는 것은 아니며 NetApp 팀과 함께 을 사용하는 것이 중요합니다<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 최신 설명서를 참조하십시오.</block>
  <block id="d03f8f06d8317baa619ceba8c71e0be3" category="summary">NetApp 스토리지 플랫폼이 제공하는 데이터 보호 및 복구 성능 옵션에 대해 알아보십시오. Astra Trident는 이러한 기능 중 일부를 활용할 수 있는 볼륨을 프로비저닝할 수 있습니다. 지속성 요구사항이 있는 각 애플리케이션에 대해 완전한 데이터 보호 및 복구 전략을 가져야 합니다.</block>
  <block id="7e7397a7b79323762c61941fc0e6b5f9" category="doc">데이터 보호</block>
  <block id="26beed33bbef26c53a76c2b450d8092c" category="paragraph">Astra Trident는 Kubernetes 클러스터의 "etcd" 데이터베이스에 메타데이터를 저장합니다. 재해 시나리오에서 Kubernetes 클러스터를 복구하려면 주기적으로 "etcd" 클러스터 데이터를 백업하는 것이 중요합니다.</block>
  <block id="6b8252dd799aef1e72351975d4d39231" category="list-text">"etcctl snapshot save" 명령을 사용하면 "etcd" 클러스터의 시점 스냅샷을 만들 수 있습니다.</block>
  <block id="54466a78f910aa9c206047e0a2afdae1" category="paragraph">이 명령은 etcd 컨테이너를 스핀업하여 etcd 스냅샷을 생성하고 이를 '/backup' 디렉토리에 저장합니다.</block>
  <block id="1475db623f0eaa95e737c3463bae738f" category="list-text">재해가 발생할 경우 etcd 스냅샷을 사용하여 Kubernetes 클러스터를 사용할 수 있습니다. "etcctl snapshot restore" 명령을 사용하여 "/var/lib/etcd" 폴더에 생성된 특정 스냅샷을 복구합니다. 복원 후 '/var/lib/etcd' 폴더가 'ember' 폴더로 채워졌는지 확인합니다. 다음은 'etcctl snapshot restore' 명령의 예입니다.</block>
  <block id="79ddedac8d398dd5b0c07d4319dcc009" category="list-text">Kubernetes 클러스터를 초기화하기 전에 필요한 인증서를 모두 복사합니다.</block>
  <block id="bdad273c35514cf4ff054dc686b32002" category="list-text">''--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 클러스터를 생성합니다.</block>
  <block id="6305ecb03aa7de9ef25f8415e859ea4b" category="list-text">클러스터가 완료되면 kubbe-system 포드가 시작되었는지 확인합니다.</block>
  <block id="8c416419987890cfcc65ea9e92da3cfa" category="list-text">Trident에서 만든 사용자 지정 리소스가 있는지 확인하고 Trident 개체를 검색하여 모든 데이터를 사용할 수 있는지 확인하려면 "kubbeck get CRD" 명령을 사용합니다.</block>
  <block id="e5356885fecc2a90a54498a26b14b810" category="section-title">ONTAP 스냅샷을 사용하여 날짜를 복구합니다</block>
  <block id="c311aef86a7cd24a1d8755988091889b" category="paragraph">스냅샷은 애플리케이션 데이터에 대한 시점 복구 옵션을 제공하여 중요한 역할을 합니다. 그러나 스냅샷은 자체적으로 백업되는 것이 아니며, 스토리지 시스템 장애나 기타 재난으로부터 데이터를 보호하지 않습니다. 그러나 대부분의 경우 데이터를 쉽고 빠르고 쉽게 복구할 수 있습니다. ONTAP 스냅샷 기술을 사용하여 볼륨을 백업하는 방법과 복원하는 방법에 대해 알아보십시오.</block>
  <block id="f0587fe4869074d7cfefe4e8bf02eaeb" category="list-text">백엔드에 스냅샷 정책이 정의되지 않은 경우 기본적으로 "없음" 정책을 사용합니다. 이로 인해 ONTAP에서 자동 스냅샷이 생성되지 않습니다. 그러나 스토리지 관리자는 ONTAP 관리 인터페이스를 통해 수동 스냅샷을 생성하거나 스냅샷 정책을 변경할 수 있습니다. Trident 작업에는 영향을 주지 않습니다.</block>
  <block id="a5198a3ff669782d450e222946ec0482" category="list-text">스냅샷 디렉토리는 기본적으로 숨겨져 있습니다. 이를 통해 ONTAP-NAS와 ONTAP-NAS-이코노미 드라이버를 사용하여 프로비저닝된 볼륨의 호환성을 극대화할 수 있습니다. ONTAP-NAS 및 ONTAP-NAS-이코노미 드라이버를 사용할 경우 애플리케이션에서 스냅샷의 데이터를 직접 복구할 수 있도록 `.snapshot' 디렉터리를 활성화합니다.</block>
  <block id="d34d16e8f00776a7cc63851ebd4e9395" category="list-text">'volume snapshot restore' ONTAP CLI 명령을 사용하여 이전 스냅샷에 기록된 상태로 볼륨을 복원합니다. 스냅샷 복사본을 복구할 때 복구 작업은 기존 볼륨 구성을 덮어씁니다. 스냅샷 복사본이 생성된 후 볼륨의 데이터에 대한 모든 변경 사항은 손실됩니다.</block>
  <block id="3225a41cc13787a78ef89153b870bffe" category="section-title">ONTAP를 사용하여 데이터 복제</block>
  <block id="5bec6ef5bd67015d1da2f04dc2a24b80" category="paragraph">스토리지 시스템 장애로 인한 데이터 손실로부터 데이터를 복제하는 것은 중요한 역할을 할 수 있습니다.</block>
  <block id="eb75aeb3b4b2b9734ba3e52f5483f0b2" category="inline-link">ONTAP 설명서</block>
  <block id="40491088e02d790071b9ddbc3f95f983" category="admonition">ONTAP 복제 기술에 대한 자세한 내용은 를 참조하십시오<block ref="dd7cb2553dd5eb568b9a23ce332fc9a4" category="inline-link-rx"></block>.</block>
  <block id="541959f741a3180066a37aee2adf7d01" category="section-title">SnapMirror SVM(Storage Virtual Machines) 복제</block>
  <block id="794cb725c5631ad99b5b7c000307f0df" category="inline-link">SnapMirror를 참조하십시오</block>
  <block id="15bf9c06ed0c503c4ee904bf4b3a85a9" category="paragraph">을 사용할 수 있습니다<block ref="a2a4907c93db22784422a1bc7047ac73" category="inline-link-rx"></block> 전체 SVM을 복제하며, 여기에는 구성 설정 및 볼륨이 포함됩니다. 재해가 발생할 경우 SnapMirror 대상 SVM을 활성화하여 데이터 제공을 시작할 수 있습니다. 시스템이 복원되면 기본 시스템으로 다시 전환할 수 있습니다.</block>
  <block id="8657190fa7a98fbc200c5c90a08cac65" category="paragraph">Astra Trident는 복제 관계 자체를 구성할 수 없기 때문에 스토리지 관리자는 ONTAP의 SnapMirror SVM 복제 기능을 사용하여 DR(재해 복구) 대상에 볼륨을 자동으로 복제할 수 있습니다.</block>
  <block id="bdb161b363522f5fc614f70c10792020" category="paragraph">SnapMirror SVM 복제 기능을 사용할 계획이거나 현재 기능을 사용 중인 경우 다음을 고려하십시오.</block>
  <block id="34fb9af35ab36a2cead16ad98b140441" category="list-text">SVM-DR이 활성화된 각 SVM에 대해 별개의 백엔드를 생성해야 합니다.</block>
  <block id="1c0b44a5294fd1ebbc8e78476cf29358" category="list-text">필요한 경우를 제외하고 복제된 백엔드를 선택하지 않도록 스토리지 클래스를 구성해야 합니다. 이는 SVM-DR을 지원하는 백엔드에 복제 관계를 프로비저닝하지 않아도 되는 볼륨이 생기지 않도록 하는 데 중요합니다.</block>
  <block id="21f180602301e7ac5b6cce6b6b7399e9" category="list-text">애플리케이션 관리자는 데이터 복제와 관련된 추가 비용 및 복잡성을 이해하고 데이터 복제를 활용하기 전에 복구 계획을 결정해야 합니다.</block>
  <block id="59b50d3d22a40bf39d0e648e2d49092c" category="list-text">SnapMirror 대상 SVM을 활성화하기 전에 예약된 SnapMirror 전송을 모두 중지하고, 진행 중인 SnapMirror 전송을 모두 중단하고, 복제 관계를 중지하고, 소스 SVM을 중지한 다음, SnapMirror 대상 SVM을 시작하십시오.</block>
  <block id="7cf7bfd0b57a375894c362efd521d4a6" category="list-text">Astra Trident는 SVM 장애를 자동으로 감지하지 않습니다. 따라서 장애가 발생하면 관리자는 'tridentctl backend update' 명령을 실행하여 Trident가 새 백엔드로 장애 조치를 트리거해야 합니다.</block>
  <block id="1904adbabdda29d7a5ab43352f36c6ed" category="paragraph">다음은 SVM 설정 단계에 대한 개요입니다.</block>
  <block id="3c2f5fc4909af1c1359e564eb6db48b0" category="list-text">소스 클러스터와 타겟 클러스터 및 SVM 간 피어링을 설정합니다.</block>
  <block id="3b1329fc73441b5a106271d6f3497f1e" category="list-text">'-subtype DP-destination' 옵션을 사용하여 대상 SVM을 생성합니다.</block>
  <block id="2ce677015d60734da686668ee7962dd0" category="list-text">필요한 간격으로 복제가 수행되도록 복제 작업 스케줄을 생성합니다.</block>
  <block id="e9eeea68d62192550b641463a212f6f7" category="list-text">소스 SVM 구성과 소스 SVM 인터페이스가 타겟으로 복제되도록 '-identity-preserve true' 옵션을 사용하여 타겟 SVM에서 소스 SVM으로 SnapMirror 복제를 생성합니다. 대상 SVM에서 SnapMirror SVM 복제 관계를 초기화합니다.</block>
  <block id="fb45980442af5aaba98c4d47ae4d3bfd" category="image-alt">에는 SVM 설정과 관련된 단계가 나와 있습니다.</block>
  <block id="1e4e7c145198bb50a238b75b451a761f" category="section-title">Trident를 위한 재해 복구 워크플로우</block>
  <block id="b955e2b8063ba57e27a4ab2b5317f40c" category="paragraph">Astra Trident 19.07 이상 Kubernetes CRD를 사용하여 자체 상태를 저장 및 관리합니다. 이 경우 Kubernetes 클러스터의 etcd를 사용하여 메타데이터를 저장합니다. 여기에서는 Kubernetes "etcd" 데이터 파일과 인증서가 NetApp FlexVolume에 저장되어 있다고 가정합니다. 이 FlexVolume은 SVM에 상주하며 보조 사이트의 대상 SVM과 SnapMirror SVM-DR 관계가 있습니다.</block>
  <block id="cc457da166ae89d5689724340cb13732" category="paragraph">다음 단계에서는 재해 발생 시 Astra Trident를 사용하여 단일 마스터 Kubernetes 클러스터를 복구하는 방법을 설명합니다.</block>
  <block id="53ac5e7226086e14e63a8c160480dc72" category="list-text">소스 SVM에 장애가 발생하면 SnapMirror 타겟 SVM을 활성화합니다. 이렇게 하려면 예약된 SnapMirror 전송을 중지하고, 지속적인 SnapMirror 전송을 중단하고, 복제 관계를 중단하고, 소스 SVM을 중지하고, 타겟 SVM을 시작해야 합니다.</block>
  <block id="2e22b90c5468159621965197ed565e28" category="list-text">대상 SVM에서 Kubernetes "etcd" 데이터 파일 및 인증서가 포함된 볼륨을 마스터 노드로 설정할 호스트에 마운트합니다.</block>
  <block id="40d502a83976e38daa5473f7aa22abae" category="list-text">/etc/Kubernetes/pki 아래에 있는 Kubernetes 클러스터와 관련된 모든 필수 인증서를 복사하고, '/var/lib/etcd' 아래에 있는 etcd member 파일을 복사합니다.</block>
  <block id="ca8fc386b365ae9b5a3b4bbadae7d7f3" category="list-text">'--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 kubeadm init 명령을 사용하여 Kubernetes 클러스터를 생성합니다. Kubernetes 노드에 사용되는 호스트 이름은 소스 Kubernetes 클러스터와 동일해야 합니다.</block>
  <block id="e0e99766128c0aba0f0aa6c04f32348c" category="list-text">'kubeck get CRD' 명령을 실행하여 모든 Trident 사용자 지정 리소스가 표시되는지 확인하고 Trident 객체를 검색하여 모든 데이터를 사용할 수 있는지 확인합니다.</block>
  <block id="5a869093fda46649157b8eb12219a2f2" category="list-text">'./tridentctl update backend &lt;backend-name&gt; -f &lt;backend-json-file&gt; -n &lt;namespace&gt;' 명령을 실행하여 새 대상 SVM 이름을 반영하도록 필요한 모든 백엔드를 업데이트합니다.</block>
  <block id="dbd1e2ae426afc58b4818d42ea354b74" category="admonition">애플리케이션의 영구 볼륨의 경우, 대상 SVM이 활성화될 때 Trident가 프로비저닝한 모든 볼륨이 데이터 제공을 시작합니다. 위에서 설명한 단계를 사용하여 대상 측에 Kubernetes 클러스터를 설정한 후에는 모든 구축과 포드가 시작되고 패키지 애플리케이션은 문제 없이 실행되어야 합니다.</block>
  <block id="d384359ca03c8d46191c719c57744679" category="section-title">SnapMirror 볼륨 복제</block>
  <block id="118fa9a7e0f8d0db1e27394b81880427" category="paragraph">ONTAP SnapMirror 볼륨 복제는 재해 복구 기능으로, 볼륨 레벨의 운영 스토리지에서 대상 스토리지로 페일오버할 수 있도록 지원합니다. SnapMirror는 스냅샷을 동기화하여 보조 스토리지에 운영 스토리지의 볼륨 복제본 또는 미러를 생성합니다.</block>
  <block id="19f60a36276037e5b82b5096d2ba7a5c" category="paragraph">다음은 ONTAP SnapMirror 볼륨 복제 설정 단계에 대한 개요입니다.</block>
  <block id="c4e9d0a10c58301ad78e9e9bf74f9229" category="list-text">볼륨이 상주하는 클러스터와 볼륨의 데이터를 제공하는 SVM 간에 피어링을 설정합니다.</block>
  <block id="b1c132fa6284fd6d42f93781032cd962" category="list-text">관계의 동작을 제어하고 해당 관계에 대한 구성 특성을 지정하는 SnapMirror 정책을 생성합니다.</block>
  <block id="0a30bcd5b223c18be449821765a8ec07" category="list-text">를 사용하여 타겟 볼륨과 소스 볼륨 사이에 SnapMirror 관계를 생성합니다<block ref="bfbfdbcdb00ddafcc3e3ca740d1d316b" category="inline-link-rx"></block> 적절한 SnapMirror 정책을 할당합니다.</block>
  <block id="20872623d19783e0dbe00afcdcb9ba46" category="list-text">SnapMirror 관계가 생성된 후 소스 볼륨에서 타겟 볼륨으로의 기본 전송이 완료되도록 관계를 초기화합니다.</block>
  <block id="af1fe101ed84f2b2bc465f0a9e92a35f" category="image-alt">에는 SnapMirror 볼륨 복제 설정이 나와 있습니다.</block>
  <block id="1d3ec4cce0f34c07e814ebbd88f5edd8" category="section-title">Trident를 위한 SnapMirror 볼륨 재해 복구 워크플로우</block>
  <block id="83e05258883cd6b92e2fe5b113f1ebc6" category="paragraph">다음 단계에서는 Astra Trident를 사용하여 단일 마스터 Kubernetes 클러스터를 복구하는 방법을 설명합니다.</block>
  <block id="b950aff3484c4c998d3b7a36ff1d6553" category="list-text">재해가 발생할 경우 예약된 SnapMirror 전송을 모두 중지하고 진행 중인 SnapMirror 전송을 모두 중단하십시오. 대상 볼륨이 읽기/쓰기가 되도록 대상 볼륨과 소스 볼륨 간의 복제 관계를 중단하십시오.</block>
  <block id="521637d2f234b6223688c168d29f6b72" category="list-text">대상 SVM에서 Kubernetes "etcd" 데이터 파일 및 인증서가 포함된 볼륨을 호스트에 마운트하고 마스터 노드로 설정됩니다.</block>
  <block id="d911c905c09c9615d35c97f404dd2884" category="list-text">'--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 "kubeadm init" 명령을 실행하여 Kubernetes 클러스터를 생성합니다. 호스트 이름은 소스 Kubernetes 클러스터와 같아야 합니다.</block>
  <block id="4b4d4e6a1634d2560e81a9a1821e2818" category="list-text">'kubeck get CRD' 명령을 실행하여 모든 Trident 사용자 지정 리소스가 검색되었는지 확인하고 Trident 객체를 검색하여 모든 데이터를 사용할 수 있는지 확인합니다.</block>
  <block id="f4a5d35c2f46c3a6ee69fd6aa2d1ed16" category="section-title">애플리케이션의 영구 볼륨에 대한 재해 복구 워크플로우</block>
  <block id="77983829e737f00a29b43edacbba355e" category="paragraph">다음 단계에서는 재해 발생 시 컨테이너화된 워크로드에 SnapMirror 대상 볼륨을 제공하는 방법을 설명합니다.</block>
  <block id="aefd7239e178b3ae439ae7004435bd18" category="list-text">예약된 모든 SnapMirror 전송을 중지하고 진행 중인 모든 SnapMirror 전송을 중단합니다. 대상 볼륨이 읽기/쓰기가 되도록 대상 볼륨과 소스 볼륨 간의 복제 관계를 중단하십시오. 소스 SVM의 볼륨에 연결된 PVC를 사용하는 구축을 정리합니다.</block>
  <block id="c64f364f814f31948e0882b74d5ddfe1" category="list-text">위에서 설명한 단계를 사용하여 대상 측에 Kubernetes 클러스터를 설정한 후 Kubernetes 클러스터에서 배포, PVC 및 PV를 정리합니다.</block>
  <block id="6973ba748ea89f06ab3640118969d780" category="list-text">Trident에서 새로운 관리 및 데이터 LIF, 새 SVM 이름 및 대상 SVM의 암호를 지정하여 새 백엔드를 생성합니다.</block>
  <block id="1fd415590fff525d8e3562951ed79081" category="list-text">Trident 가져오기 기능을 사용하여 새 PVC에 바인딩된 PV로 필요한 볼륨을 가져옵니다.</block>
  <block id="99a01026c124f91b08d854efa31d450b" category="list-text">새로 생성된 PVC와 함께 애플리케이션 배포를 재배포합니다.</block>
  <block id="7a183359334a99fc80b796244313284c" category="section-title">Element 스냅샷을 사용하여 데이터 복구</block>
  <block id="2d51cea50aa816e6be9c663c2ad2686a" category="paragraph">볼륨에 대한 스냅샷 스케줄을 설정하고 필요한 간격으로 스냅샷을 생성하도록 하여 Element 볼륨의 데이터를 백업합니다. Element UI 또는 API를 사용하여 스냅샷 스케줄을 설정해야 합니다. 현재 '솔드파이어-SAN' 드라이버를 통해 스냅샷 스케줄을 볼륨으로 설정할 수 없습니다.</block>
  <block id="c42cc84c1560600f6f5986a958de0735" category="paragraph">데이터가 손상된 경우 Element UI 또는 API를 사용하여 특정 스냅샷을 선택하고 볼륨을 스냅숏으로 수동으로 롤백할 수 있습니다. 이렇게 하면 스냅샷이 생성된 이후 볼륨에 대한 모든 변경 사항이 복구됩니다.</block>
  <block id="75f3d382f074f14c775efb5cf2f23c30" category="summary">Astra Trident를 배포할 때 여기에 나열된 권장 사항을 사용하십시오.</block>
  <block id="ea355214fd4bc7c57f471bd92918879b" category="doc">구축</block>
  <block id="d89d3b3161292ef0c65342cbe80e883f" category="section-title">전용 네임스페이스에 구축</block>
  <block id="79a77cdda2a2513aee654190c73f15ab" category="paragraph"><block ref="c41296e544cd0faaa4fe4e8b22535287" category="inline-link-rx"></block> 서로 다른 애플리케이션 간의 관리 분리를 제공하며 리소스 공유의 장벽입니다. 예를 들어, 한 네임스페이스의 PVC는 다른 네임스페이스에서 사용할 수 없습니다. Astra Trident는 Kubernetes 클러스터의 모든 네임스페이스에 PV 리소스를 제공하고, 결과적으로 권한이 상승된 서비스 계정을 활용합니다.</block>
  <block id="853cf568613b7eec1486421468e18b9b" category="paragraph">또한 Trident Pod에 액세스하면 사용자가 스토리지 시스템 자격 증명 및 기타 중요한 정보에 액세스할 수 있습니다. 애플리케이션 사용자 및 관리 애플리케이션에서 Trident 객체 정의 또는 POD 자체에 액세스할 수 없도록 하는 것이 중요합니다.</block>
  <block id="2c8e89de5c6bf68b180cff5fea545167" category="section-title">할당량 및 범위 제한을 사용하여 스토리지 사용량을 제어할 수 있습니다</block>
  <block id="74444eaf90c31d151645e59dcab0468d" category="inline-link">스토리지 할당량 메커니즘</block>
  <block id="1d81c150d54eae0c49d9cfeb8d493b0f" category="inline-link">범위 제한</block>
  <block id="94104e476fe547cf6237480cacae5ed5" category="paragraph">Kubernetes에는 2가지 기능이 있으며, 이 기능을 조합하여 애플리케이션의 리소스 사용을 제한하는 강력한 메커니즘을 제공합니다. 를 클릭합니다<block ref="bff513af91e6751aca3d34ef714e3b91" category="inline-link-rx"></block> 관리자가 네임스페이스별로 글로벌 및 스토리지 클래스별, 용량 및 오브젝트 수 사용 제한을 구현할 수 있도록 지원 또한 를 사용합니다<block ref="dbe9770513b0f7245f1fe016d20ebb70" category="inline-link-rx"></block> 요청이 프로비저닝 사용자에게 전달되기 전에 PVC 요청이 최소값 및 최대값 내에 있는지 확인합니다.</block>
  <block id="4f9253eda0573e387f86d7777aafff03" category="inline-link">할당량을 활용하는 방법</block>
  <block id="923169151e05d28a3474b2a033666297" category="paragraph">이러한 값은 네임스페이스 단위로 정의됩니다. 즉, 각 네임스페이스에는 리소스 요구 사항에 맞는 값이 정의되어 있어야 합니다. 에 대한 자세한 내용은 여기 를 참조하십시오<block ref="5b289b2ffde01314d8b0d038aabd709b" category="inline-link-rx"></block>.</block>
  <block id="c9534512c045771d255bf1068862beec" category="paragraph">'트리엔오케스트레이터'가 업데이트된 후, 운용자는 기존 설치 시 업데이트 및 패치를 처리한다. 이렇게 하면 새 포드가 생성되어 설치를 적절하게 수정할 수 있습니다.</block>
  <block id="f456a413d0506028374e871768a5f176" category="paragraph">클러스터의 Kubernetes 버전이 지원되는 버전으로 업그레이드되면 운영자는 기존 Astra Trident 설치를 자동으로 업데이트하고 Kubernetes 버전 요구사항을 충족하도록 변경합니다.</block>
  <block id="d1aae6ea63eb5e7fe6a9fcea5f671406" category="admonition">클러스터가 지원되지 않는 버전으로 업그레이드되면 운영자는 Astra Trident를 설치할 수 없습니다. Astra Trident가 운영자와 함께 이미 설치된 경우 Astra Trident가 지원되지 않는 Kubernetes 버전에 설치되었음을 나타내는 경고가 표시됩니다.</block>
  <block id="37dbca6cb8ca55a471ebc072575c0a46" category="list-text">Astra Trident를 구축하려는 원격 머신에 적절한 버전의 kubeck tl을 배포합니다.</block>
  <block id="02ed10abbc71334918b1acb54df6e3f3" category="list-text">Kubernetes 클러스터에서 구성 파일을 복사하고 원격 시스템에서 'KUBECONFIG' 환경 변수를 설정합니다.</block>
  <block id="da693b77cde91654c6296abe8f901988" category="list-text">필요한 Kubernetes 클러스터에 연결할 수 있는지 확인하려면 "kubbtl get nodes" 명령을 시작합니다.</block>
  <block id="df65ec31c6f96e95301e3c6ff8863335" category="list-text">표준 설치 단계를 사용하여 원격 컴퓨터에서 배포를 완료합니다.</block>
  <block id="bbe2bfefd5797bb567e3da92f68ce8d1" category="doc">tridentctl 배포를 사용자 지정합니다</block>
  <block id="8355509d170c8a61d236e927a5fcc6e2" category="paragraph">kubelet이 평소 하던 /var/lib/kubelet가 아닌 다른 경로에 데이터를 보관하는 Kubernetes 배포를 사용하는 경우 -kubelet-dir을 사용하여 대체 경로를 지정할 수 있습니다.</block>
  <block id="47cd697cf3c9dcf916f70a0007956c1d" category="paragraph">설치 관리자의 인수 이외에 설치를 사용자 지정해야 하는 경우 배포 파일을 사용자 지정할 수도 있습니다. '--generate-custom-YAML' 파라미터를 사용하면 설치 프로그램의 '셋업' 디렉토리에 다음과 같은 YAML 파일이 생성됩니다.</block>
  <block id="0858f0ee003d52951161848adffe1b31" category="list-text">트리덴트-클러스터롤리바인딩.YAML</block>
  <block id="af73689aedfa47bd2a7cf144917b0642" category="list-text">'트라이덴트 배포.YAML'</block>
  <block id="1d53fd876245951bb003eb47849ff39d" category="list-text">트리덴트-CRD.YAML</block>
  <block id="b17dbe8acaeca82c72d25948de03eefc" category="list-text">트리덴트-클러스터역할.YAML</block>
  <block id="ecb2b56a094cc1cbd3ac263b23d91f8b" category="list-text">트리덴트-디멘트발병 YAML</block>
  <block id="c5e462ae653234d0ea0e98a000e62a97" category="list-text">'삼류 서비스.YAML'</block>
  <block id="f1347677de6873f8ddce6d736cba9a63" category="list-text">'삼중인대.YAML'</block>
  <block id="2539c7e25ada2a2cdae0eb4c4633b893" category="list-text">트라이덴트-서비스계정.YAML</block>
  <block id="385d099ed91e83dbe20ea05fbed68e22" category="paragraph">이러한 파일을 생성한 후 필요에 따라 수정한 다음 '--use-custom-YAML'을 사용하여 사용자 지정 배포를 설치할 수 있습니다.</block>
  <block id="e0e3d7f1aacdf4a8196132549709430c" category="doc">tridentctl을 사용하여 배포합니다</block>
  <block id="4a052772dca278b7be31d54ca9f21831" category="inline-link-macro">기본 개념</block>
  <block id="dd3de2609b612d76ef4c71b97b8d6100" category="inline-link">다음 단계에 따라 CLI 액세스를 설정합니다</block>
  <block id="c585967fa32d82c5e3c24bd63926c6a0" category="list-text">Docker Enterprise와 함께 Kubernetes를 사용하는 경우,<block ref="57562caf1c76e1a261b7e2f8c3d113f9" category="inline-link-rx"></block>.</block>
  <block id="ea8cda06a0e70ad34c1b9ab1b7135105" category="inline-link-macro">지원되는 Kubernetes 클러스터</block>
  <block id="7358b1fd077fa65f88fff87888fd2547" category="inline-link">Trident 설치 프로그램 번들</block>
  <block id="13c852fce58f7c6981fa0a952dcd76af" category="summary">Trident 연산자를 사용하면 ' Trident' 사양의 특성을 사용하여 Astra Trident가 설치되는 방식을 사용자 지정할 수 있습니다.</block>
  <block id="83f499a540b1323009c200d6f8cc9396" category="cell">매개 변수</block>
  <block id="7a1920d61156abc05a60135aefe8bc67" category="cell">기본값</block>
  <block id="f3f30d479f6e3b393d917a3b2f88c770" category="cell">'네임스페이스'</block>
  <block id="c9db68ea6cff44f42ac5acbbfccec399" category="cell">Astra Trident를 설치할 네임스페이스입니다</block>
  <block id="9aa82da0cffe247b84587c1cc8e32746" category="cell">"기본값"</block>
  <block id="a67cf6b087ff88dbfacec8375928995c" category="cell">"버그"</block>
  <block id="4f72bc786a1a01d5a1a8bc09d33334cc" category="cell">Astra Trident에 대한 디버깅을 활성화합니다</block>
  <block id="68934a3e9455fa72420237eb05902327" category="cell">거짓</block>
  <block id="3dd791c4864e77ae6cf11572e2d7b374" category="cell">IPv6를 통해 Astra Trident를 설치합니다</block>
  <block id="077e99fe42ced522b462656cffffe09c" category="cell">k8sTimeout</block>
  <block id="4448b73eac083e33b7142f0e5790fac5" category="cell">Kubernetes 작업 시간이 초과되었습니다</block>
  <block id="e4d71bf2abad047425f4463e27bb83b0" category="cell">30초</block>
  <block id="42cf123e93ecc5c0297652edbc547fc0" category="cell">이제 자동 지원입니다</block>
  <block id="4a213b7c3b997ffb0794b25909381d16" category="cell">AutoSupport 번들을 NetApp에 자동으로 보내지 않습니다</block>
  <block id="34d0f4a447cd1d7f59000d3be2c39320" category="cell">"enableNodePrep"입니다</block>
  <block id="2472256a6487b0917d32f6a044a4e0ac" category="cell">작업자 노드 종속성 자동 관리(* beta*)</block>
  <block id="2bccac20e55391730a985f9819e1cc41" category="cell">자동 지원 이미지</block>
  <block id="84448c234dfdfd2a7367341fd4b56a80" category="cell">AutoSupport 텔레메트리 컨테이너 이미지입니다</block>
  <block id="f4a6821b04b9ce6b90148068341347b6" category="cell">자동 지원 프록시</block>
  <block id="7f54ca385f028308d19e228ce0534a47" category="cell">AutoSupport 텔레메트리 전송을 위한 프록시의 주소/포트입니다</block>
  <block id="256acfe307251e7444859851d87d5735" category="cell"><block ref="256acfe307251e7444859851d87d5735" category="inline-link-rx"></block></block>
  <block id="e9f06180af644cfa6e5d20bd67c03bc5" category="cell">"제거"를 선택합니다</block>
  <block id="076bc379a24183ce77834bac007ca852" category="cell">Astra Trident를 제거하는 데 사용되는 플래그입니다</block>
  <block id="cad060d2f14dbf08315c20014ed31daa" category="cell">로그포맷</block>
  <block id="acfc4a8e6d53bad27d4e2d393bfff61e" category="cell">사용할 Astra Trident 로깅 형식[text,json]</block>
  <block id="20cd815523e5806aec29a57282b0d49f" category="cell">"텍스트"</block>
  <block id="7610c5cc7910022402c4fbd450d889ce" category="cell">트리덴티이미지</block>
  <block id="20f408a3276af1f7f1bf02ba374786ca" category="cell">설치할 Astra Trident 이미지</block>
  <block id="896185b87765c519346253a5f54ecbe4" category="cell">"NetApp/트리덴트: 21.04"</block>
  <block id="8088435dc0e1c8b85217d850d3e7a602" category="cell">'imageRegistry'입니다</block>
  <block id="4f25f4cca5c1939f4a728d2678e719f7" category="cell">'&lt;registry FQDN&gt;[:port][/subpath]' 형식의 내부 레지스트리 경로입니다</block>
  <block id="e6b96cbb467923e86672bb25db5ecebb" category="cell">쿠벨레트디렉토리</block>
  <block id="31aad37dce0c28e12908582a0d63736a" category="cell">호스트의 kubelet 디렉토리에 대한 경로입니다</block>
  <block id="5b9febd4bd647dae5abfddaf99b9c540" category="cell">“/var/lib/kubelet”</block>
  <block id="b6e0e2c4168573f0ed61c842470342ba" category="cell">"위피"</block>
  <block id="4e33345575b5a443dec89767624a1ee8" category="cell">Astra Trident를 완전히 제거하기 위해 삭제할 리소스 목록입니다</block>
  <block id="2d30d1348c4d2533a165827a22516caa" category="cell">'imagePullSecrets'</block>
  <block id="f73bb4a0bc9913e7fc6db5f9e5f2afeb" category="cell">내부 레지스트리에서 이미지를 가져올 수 있는 비밀</block>
  <block id="2e1b3f44683eee188be985693c4af5e1" category="list-text">Helm 버전 3</block>
  <block id="e366a20246a41520da551be510c1d658" category="paragraph">설치 중에 구성 데이터를 전달하는 방법에는 두 가지가 있습니다.</block>
  <block id="24da04b0777d00c6fe43de99895058bd" category="paragraph">제어 차트의 일부인 Values.YAML 파일은 키 목록과 기본값을 제공합니다.</block>
  <block id="e420b75ec3bc014e3f69c43b2383768b" category="admonition">OpenShift에서는 뒤에 나오는 모든 예시에서 kubtl 대신 OC를 사용하고, OC login-u system:admin 또는 OC login-u kubbe-admin을 실행하여 먼저 * system:admin * 으로 로그인합니다.</block>
  <block id="337d79852891a37d41285c9101c3fff4" category="paragraph">다음 명령을 실행합니다.</block>
  <block id="dbbf8c6ec95775d28c3c6da1878bf8c3" category="list-text">작업자 자체</block>
  <block id="a770ca95121cc795b602f9af6af024fb" category="admonition">Kubernetes 클러스터에는 운영자의 인스턴스 * 하나가 있어야 합니다. Trident 연산자의 여러 배포를 생성하지 마십시오.</block>
  <block id="ec53a8c4f07baed5d8825072c89799be" category="cell">상태</block>
  <block id="2763f33c904a183bd0ef06f9c4fb4403" category="cell">설치 중</block>
  <block id="64162845794ff7262e665deec58a84f5" category="cell">운영자는 이 '트리엔오케스트레이터' CR을 사용하여 Astra Trident를 설치하고 있습니다.</block>
  <block id="98dd43dfae05b11befe1f140e0ec787a" category="cell">설치되어 있습니다</block>
  <block id="2fe2cc0adf9b69a871d33ba220695cd4" category="cell">Astra Trident가 성공적으로 설치되었습니다.</block>
  <block id="c2aaea4dacecce78b34302e41fcef75e" category="cell">제거 중</block>
  <block id="c27ff0e050a671f2eab32a372c9636bd" category="cell">이 경우, 'pec.uninstall=true'로 인해 운용자가 Astra Trident를 설치 제거 중입니다.</block>
  <block id="b78846123fdd78d5ab62451b855194e3" category="cell">제거되었습니다</block>
  <block id="f8a32612e33c768b5fa0dd033d91ce8d" category="cell">Astra Trident가 제거되었습니다.</block>
  <block id="d7c8c85bf79bbe1b7188497c32c3b0ca" category="cell">실패했습니다</block>
  <block id="273b9a9e933220f1963cbac7a7a46645" category="cell">운영자가 Astra Trident를 설치, 패치, 업데이트 또는 제거할 수 없습니다. 이 상태에서 자동으로 복구를 시도합니다. 이 상태가 지속되면 문제 해결이 필요합니다.</block>
  <block id="6909beea5b50605780e3411f879fe916" category="cell">업데이트 중</block>
  <block id="3201d58137fab497dea740d761a9733b" category="cell">운영자가 기존 설치를 업데이트하고 있습니다.</block>
  <block id="902b0d55fddef6f8d651fe1035b7d4bd" category="cell">오류</block>
  <block id="efaeca66375c8663b6d1d64f4886f267" category="cell">트리젠터레이터(트리젠터레이터)는 사용하지 않는다. 다른 파일이 이미 있습니다.</block>
  <block id="5a2ebfb8baa378cfcfcba58bbb1380c2" category="doc">요구 사항</block>
  <block id="c777be7f669397b0a376fe32ca5cd9c3" category="section-title">지원되는 프런트엔드(오케스트레이터)</block>
  <block id="74aefc05d193afd5c50a0df882997656" category="paragraph">Astra Trident는 다음을 비롯한 여러 컨테이너 엔진과 오케스트레이터가 지원됩니다.</block>
  <block id="201eb37826a33e35adff9119f25946bd" category="paragraph">Trident 연산자는 다음 릴리즈에서 지원됩니다.</block>
  <block id="f787cd4b6963b13f12fa53131f58ef6c" category="section-title">지원되는 백엔드(스토리지)</block>
  <block id="843e2f0c722d25903a6010b62ac4f13b" category="paragraph">Astra Trident를 사용하려면 다음 중 하나 이상의 지원되는 백엔드가 필요합니다.</block>
  <block id="4d82a1ec1af02725042c8c785564ee7a" category="list-text">NetApp ONTAP용 Amazon FSx</block>
  <block id="117bdbda976fe8b3212bc3b6327a0a1b" category="list-text">Cloud Volumes ONTAP</block>
  <block id="a3c559e0541e9bb860178ce6fe414224" category="list-text">GCP용 Cloud Volumes Service</block>
  <block id="1d3d126b8a5bad69c46ed03734beed47" category="list-text">NetApp All SAN 어레이(ASA)</block>
  <block id="c7c7a6a5641f33e348244f9c43010e16" category="section-title">피처 요구 사항</block>
  <block id="21021ea0e52be8e9c599f4dff41e5be0" category="cell">피처</block>
  <block id="80afba45eb055fc9bdc48c90d1debd06" category="cell">Kubernetes 버전</block>
  <block id="10f295a61d2a793ac8936a69cf458654" category="cell">기능 게이트가 필요합니까?</block>
  <block id="f336592ca417cff322b935bc0eeaff8f" category="cell">CSI Trident</block>
  <block id="e830b7e4d1fb7f84600876af87cb4381" category="cell">볼륨 스냅샷</block>
  <block id="ea8ed249117e76cb53766e218fe2b7c7" category="cell">체적 스냅샷의 PVC</block>
  <block id="28dcded20f550dcad1bd9bb03a5bbe73" category="cell">iSCSI PV 크기 조정</block>
  <block id="1673543ed032e46f3572ba65bc070693" category="cell">ONTAP 양방향 CHAP</block>
  <block id="176e16df4faab1a1e06e9585c813d5fe" category="cell">동적 내보내기 정책</block>
  <block id="1f7219b07d5bce7feec002a9f4dc2201" category="cell">Trident 연산자</block>
  <block id="443432948b68bb63d707ce7ecc4a021a" category="cell">CSI 토폴로지</block>
  <block id="11ea58814ce429c3e3254a63f8cde7a4" category="paragraph">트리덴트틀(tridentctl) 유틸리티도 이 리눅스 배포판에서 실행됩니다.</block>
  <block id="13d80777c8fd43e555c1f5b1b72d7ef0" category="section-title">호스트 구성</block>
  <block id="2139fe384d5ae165545994dff01961d9" category="section-title">스토리지 시스템 구성</block>
  <block id="923680056b0f0258907f498670b4ead1" category="section-title">컨테이너 이미지 및 해당 Kubernetes 버전</block>
  <block id="aa92c4c233bc01609d957e469736b699" category="cell">컨테이너 이미지</block>
  <block id="6f0b081bef5e745ef2429ef74472d9bd" category="cell">v1.21.0</block>
  <block id="a60c2f57df655a9ac5fcaa0750886195" category="summary">Kubernetes를 시작하는 경우 지침에 따라 Kubernetes를 설치하여 사용해 보십시오. 다음 지침은 Trident에서 시연을 위해 통합할 수 있는 베어본 단일 노드 클러스터를 제공합니다.</block>
  <block id="62bdbe048d174b559cb770f9ebaf0895" category="doc">시도해 보십시오</block>
  <block id="e8dadc588901af436e2c6036acf23973" category="inline-link-macro">NetApp 시험 구동</block>
  <block id="8685ac2061f9dca7ab48f41e0871f7af" category="inline-link-macro">kubeadm 설치 가이드</block>
  <block id="37bdb0f602c1d2a2a6f285533e4ce5c8" category="paragraph">또 다른 옵션은 을 보는 것입니다 <block ref="c7dbb75618a5e106a360075f923cb87f" category="inline-link-macro-rx"></block> Kubernetes에서 제공:</block>
  <block id="2cf0c4e99dd3c0b2e7e0f63af3531622" category="admonition">이러한 지침을 운영 환경에 사용하여 구축한 Kubernetes 클러스터를 사용해서는 안 됩니다. 배포 시 제공되는 운영 구축 가이드를 사용하여 즉시 프로덕션할 수 있는 클러스터를 생성할 수 있습니다.</block>
  <block id="e3ecede511471cf67c294e427e2f012e" category="paragraph">Kubernetes를 처음 사용하는 경우 개념 및 툴에 대해 자세히 알아보십시오 <block ref="22f850f308b2d2016502017a1dcd1044" category="inline-link-macro-rx"></block>.</block>
  <block id="55847a7d73d44b84804f47ee7863b80f" category="summary">Astra Trident를 구축한 후 백엔드 생성, 스토리지 클래스 생성, 볼륨 프로비저닝 및 POD에 볼륨 마운팅으로 진행할 수 있습니다.</block>
  <block id="3f297ef15cde0668e93b35f2752fd4fd" category="doc">다음 단계</block>
  <block id="0b0ca016c0d99a4845777aeeebb032ac" category="section-title">1단계: 백엔드를 생성합니다</block>
  <block id="4f374e8dd911d1e70f7b7a53fdac1f2a" category="paragraph">이제 Astra Trident에서 볼륨을 프로비저닝하는 데 사용할 백엔드를 만들 수 있습니다. 이렇게 하려면 필요한 매개 변수가 포함된 백엔드 .json 파일을 만듭니다. 서로 다른 백엔드 유형에 대한 샘플 구성 파일은 'ample-input' 디렉토리에서 찾을 수 있습니다.</block>
  <block id="8b389d7be97d6c697a4e775ff8338905" category="paragraph">을 참조하십시오 <block ref="49641f5ab61d7a6ce07b1b6ba31204f8" category="inline-link-macro-rx"></block> 백엔드 유형에 맞게 파일을 구성하는 방법에 대한 자세한 내용은 을 참조하십시오.</block>
  <block id="af445e1d9a0a481ba7f9b5f01df23a3d" category="paragraph">생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="00715976efdc0cc3b7c5a8512fb0e08d" category="inline-link-macro">문제 해결</block>
  <block id="936067ad00da88d877acb024c96f3129" category="paragraph">문제를 해결한 후 이 단계의 처음으로 돌아가서 다시 시도하십시오. 자세한 문제 해결 팁은 를 참조하십시오 <block ref="fa8c952f2dea85664a3e3e5dc210aa4c" category="inline-link-macro-rx"></block> 섹션을 참조하십시오.</block>
  <block id="0cf7ce61dd48f9396923c05ab8f5e302" category="section-title">2단계: 스토리지 클래스를 생성합니다</block>
  <block id="8c566ff50efde64c700b1188e862c328" category="inline-link">스토리지 클래스</block>
  <block id="c44e939795fbf61079e70122d3e77735" category="paragraph">Kubernetes 사용자는 가 지정된 영구 PVC(Volume Claim)를 사용하여 볼륨을 프로비저닝합니다<block ref="bc70014ff50467618a31ef39142ab151" category="inline-link-rx"></block> 이름별. 세부 정보는 사용자로부터 숨겨지지만 스토리지 클래스는 해당 클래스에 사용되는 공급자(이 경우 Trident)와 해당 클래스가 프로비저닝자로부터 의미하는 바를 식별합니다.</block>
  <block id="56cc6184a3bc4387f839993b204e4c5f" category="paragraph">Kubernetes 스토리지 클래스를 생성할 때 볼륨을 지정할 시기를 지정하십시오. 수업 구성에서는 이전 단계에서 생성한 백엔드를 모델링해야 하므로 Astra Trident가 이를 사용하여 새 볼륨을 프로비저닝합니다.</block>
  <block id="45a1f9131ca1bec07f47f45a194d9d58" category="paragraph">가장 간단한 스토리지 클래스는 설치 프로그램과 함께 제공되는 'ample-input/storage-class-csi.yAML.Templ' 파일을 기반으로 하는 것으로, 스토리지 드라이버 이름으로 __backend_type_'을(를) 대체합니다.</block>
  <block id="b4987be37083b7196f23d63ddd5d56df" category="paragraph">Kubernetes 오브젝트이므로 쿠버틀에서 생성되도록 kubtl을 사용하십시오.</block>
  <block id="a191af7083288f9d9556f3ebcd821a34" category="paragraph">이제 Kubernetes 및 Astra Trident에 * basic-CSI * 스토리지 클래스가 표시됩니다. Astra Trident는 백엔드에서 풀을 검색했습니다.</block>
  <block id="3bdc1ec6969d1615bb58d7f0443bf1c2" category="section-title">3단계: 첫 번째 볼륨을 프로비저닝합니다</block>
  <block id="a58b17a231318aa42ed47bfe0be43447" category="inline-link">영구적 볼륨 클레임</block>
  <block id="512b66e66e82ba09d70c3e9f784aa8af" category="paragraph">이제 첫 번째 볼륨을 동적으로 프로비저닝할 준비가 되었습니다. 이 작업은 Kubernetes를 생성하여 수행합니다<block ref="95c09f225fe48abca705fd090f5f4c89" category="inline-link-rx"></block> (PVC) 개체.</block>
  <block id="61e8eac65ddef26d4c4230d88cae8498" category="paragraph">방금 만든 저장소 클래스를 사용하는 볼륨에 대해 PVC를 생성합니다.</block>
  <block id="b357acbdc339437d16e4e967ecc6d0c2" category="paragraph">예를 들면 'Sample-input/PVC-basic-CSI.YAML'을 참조한다. 스토리지 클래스 이름이 생성한 이름과 일치하는지 확인합니다.</block>
  <block id="2fe8954464ccf22d2d06423b358f38a7" category="section-title">4단계: POD에 볼륨을 마운트합니다</block>
  <block id="366556d176e685870d134b7fc6e9ca3c" category="paragraph">이제 볼륨을 마운트하겠습니다. PV를 "/usr/share/nginx/html"에 장착하는 nginx 포드를 시작합니다.</block>
  <block id="6f5eca6ad9143d35bb33a1a17df3a848" category="paragraph">이때 POD(애플리케이션)는 더 이상 존재하지 않지만 볼륨은 여전히 존재합니다. 원하는 경우 다른 포드에서 사용할 수 있습니다.</block>
  <block id="3ba419ecccf23f33a6bae5d23f206fdd" category="paragraph">볼륨을 삭제하려면 클레임을 삭제합니다.</block>
  <block id="1a00c9156117d9ec9fa3e45d5a757d04" category="paragraph">이제 다음과 같은 추가 작업을 수행할 수 있습니다.</block>
  <block id="ce2c6a300f520205e891fc45009ec4c3" category="inline-link-macro">추가 백엔드를 구성합니다.</block>
  <block id="642bfa81920103d4177bb3fdf6f9186f" category="list-text"><block ref="642bfa81920103d4177bb3fdf6f9186f" category="inline-link-macro-rx"></block></block>
  <block id="93e8ba41e1ebcadc1338cc7f75109210" category="inline-link-macro">추가 스토리지 클래스를 생성합니다.</block>
  <block id="daa40449d28fbb16d2bcd8a8434d05e6" category="list-text"><block ref="daa40449d28fbb16d2bcd8a8434d05e6" category="inline-link-macro-rx"></block></block>
  <block id="3d522b99ca94333433532daa23e7ceab" category="summary">Astra Trident의 설치, 구성, 업그레이드 및 문제 해결에 대해 자주 묻는 질문에 대한 답변을 찾아보십시오.</block>
  <block id="af2a4d2810d86aa0169c117f82682f9a" category="doc">자주 묻는 질문</block>
  <block id="96ab491ef73d5db0cd15f55e1552cc22" category="section-title">일반적인 질문</block>
  <block id="b34c3d20de0f1b2c7a69bdc59002ad47" category="section-title">Astra Trident는 얼마나 자주 출시됩니까?</block>
  <block id="2f55088c7d055eb361252b15d5d7af10" category="paragraph">Astra Trident는 1월, 4월, 7월, 10월에 3개월마다 출시됩니다. Kubernetes 릴리스 한 달 후입니다.</block>
  <block id="15602d1e4b699ebca549a3d953672d8c" category="section-title">Astra Trident가 특정 버전의 Kubernetes에서 릴리스된 모든 기능을 지원합니까?</block>
  <block id="d860923e20119473e7f7d50683cb0559" category="paragraph">Astra Trident는 일반적으로 Kubernetes의 알파 기능을 지원하지 않습니다. Trident는 Kubernetes 베타 릴리즈를 따르는 두 Trident 릴리스 내에서 베타 기능을 지원할 수 있습니다.</block>
  <block id="52ffcf336df0055235949cf324a8624b" category="section-title">Astra Trident가 작동을 위해 다른 NetApp 제품에 종속되어 있습니까?</block>
  <block id="9a10bc69a2553cd055c7b66932fd3864" category="paragraph">Astra Trident는 다른 NetApp 소프트웨어 제품에 종속되어 있지 않으며 독립 실행형 애플리케이션으로 작동합니다. 그러나 NetApp 백엔드 스토리지 디바이스가 있어야 합니다.</block>
  <block id="bda04f64eaa9613cb4923cf43e24954c" category="section-title">Astra Trident 구성 세부 정보를 모두 얻으려면 어떻게 해야 합니까?</block>
  <block id="6d6d1fbb6191413b3262aed487048f1e" category="paragraph">"tridentctl get" 명령을 사용하여 Astra Trident 구성에 대한 자세한 정보를 얻을 수 있습니다.</block>
  <block id="d8634bcd1659c9cdf6f1a7a92ec00c30" category="section-title">Astra Trident에서 스토리지를 프로비저닝하는 방법에 대한 메트릭을 얻을 수 있습니까?</block>
  <block id="1435574cfec44734b2bfc2b94327b118" category="paragraph">예. Trident 20.01에는 관리되는 백엔드 수, 프로비저닝된 볼륨 수, 사용된 바이트 수 등 Astra Trident의 작업에 대한 정보를 수집하는 데 사용할 수 있는 Prometheus 엔드포인트가 도입되었습니다. Cloud Insights를 사용하여 모니터링 및 분석할 수도 있습니다.</block>
  <block id="3e9ebf4af3f0b9d1852396d46171ef99" category="section-title">CSI Provisioner로 Astra Trident를 사용할 때 사용자 환경이 달라집니까?</block>
  <block id="05f95d89af1ccd9b986014406a4b1fc8" category="paragraph">아니요 사용자 환경과 기능에 관한 한 변경 사항은 없습니다. 사용된 공급자 이름은 csi.trident.netapp.io` 입니다. 현재 및 향후 릴리즈에서 제공하는 모든 새로운 기능을 사용하려는 경우 이 Astra Trident 설치 방법을 사용하는 것이 좋습니다.</block>
  <block id="0a7e87df44869b8d60a83f35d1e2747b" category="section-title">Kubernetes 클러스터에 Astra Trident를 설치 및 사용합니다</block>
  <block id="6a3ad0d68dcfe0164611dadb7f7656f9" category="paragraph">아스트라 트리덴트(Astra Trident)는 더 이상 '에트cd'를 필요로 하지 않습니다. CRD를 사용하여 상태를 유지합니다.</block>
  <block id="bde6cb03741f92107c63aeebe62d3278" category="section-title">Astra Trident가 개인 레지스트리에서 오프라인 설치를 지원합니까?</block>
  <block id="1c51806b370d428d5779dbcacd940174" category="section-title">Astra Trident를 원격으로 설치할 수 있습니까?</block>
  <block id="bf858450c271da75a3df3a15ca761330" category="paragraph">예. Astra Trident 18.10 이상은 클러스터에 대한 "kudctl" 액세스 권한이 있는 모든 시스템에서 원격 설치 기능을 지원합니다. "kubbtl" 액세스를 확인한 후(예: 원격 시스템에서 kubeck get nodes 명령을 시작하여 확인) 설치 지침을 따릅니다.</block>
  <block id="12694c2de4575e39a6f7e81d55e35de9" category="section-title">Astra Trident를 사용하여 고가용성을 구성할 수 있습니까?</block>
  <block id="f1cf2ca3af6ca7c374ad2104f570c790" category="paragraph">Astra Trident는 하나의 인스턴스로 Kubernetes 배포(ReplicaSet)로 설치되었으므로 HA가 내장되어 있습니다. 구축 시 복제본 수를 늘이지 않아야 합니다. Astra Trident가 설치된 노드가 손실되거나 POD에 액세스할 수 없는 경우 Kubernetes가 자동으로 Pod를 클러스터의 정상 노드에 다시 배포합니다. Astra Trident는 컨트롤 플레인만 지원하므로 Astra Trident를 다시 구축할 경우 현재 마운트된 Pod는 영향을 받지 않습니다.</block>
  <block id="1656e4b34abdb6d497b40cac65366767" category="section-title">Astra Trident에서 kube-system 네임스페이스에 액세스해야 합니까?</block>
  <block id="6f67e1edfd4aa5b0e695528a9c7d8898" category="paragraph">Astra Trident가 Kubernetes API Server에서 읽어 애플리케이션에서 새로운 PVC를 요청할 시기를 결정하므로 kubbe-system에 액세스해야 합니다.</block>
  <block id="16cdb35003b5bcf0f30556e0bc477511" category="section-title">Astra Trident에서 사용하는 역할 및 권한은 무엇입니까?</block>
  <block id="8ff39a39871cc30228035bc0580a6af4" category="section-title">설치에 Astra Trident가 사용하는 정확한 매니페스트 파일을 로컬로 생성할 수 있습니까?</block>
  <block id="e6af67b71bd46d7588b50f28e1414f9b" category="section-title">두 개의 개별 Kubernetes 클러스터를 위한 두 개의 개별 Astra Trident 인스턴스에 동일한 ONTAP 백엔드 SVM을 공유할 수 있습니까?</block>
  <block id="7bbf9b47e035f0f9bb7c46098e78fb4d" category="paragraph">권장되지 않지만 두 개의 Astra Trident 인스턴스에 동일한 백엔드 SVM을 사용할 수 있습니다. 설치 시 각 인스턴스의 고유한 볼륨 이름을 지정하거나 셋업/백엔드 .json 파일에 고유한 'toragePrefix' 매개변수를 지정하십시오. 이는 동일한 FlexVol가 두 인스턴스에 모두 사용되지 않도록 하기 위한 것입니다.</block>
  <block id="9840a5bb6278469ed550bcdcc92c29c5" category="section-title">ContainerLinux(이전의 CoreOS) 아래에 Astra Trident를 설치할 수 있습니까?</block>
  <block id="7a35680d9db247612b732ae47144f030" category="paragraph">Astra Trident는 Kubernetes Pod로, Kubernetes를 실행 중인 모든 위치에 설치할 수 있습니다.</block>
  <block id="5fc6de1b535ebb2a5380b6aa607e4cca" category="section-title">NetApp Cloud Volumes ONTAP에서 Astra Trident를 사용할 수 있습니까?</block>
  <block id="5d1cff73e26dc54ef52bdca5a29b319c" category="paragraph">예. Astra Trident는 AWS, Google Cloud 및 Azure에서 지원됩니다.</block>
  <block id="2ddee53d5c18f6e78f18dad82851303e" category="section-title">Astra Trident가 Cloud Volumes Services와 작동합니까?</block>
  <block id="92d1656d06303733c5e1398fb273a17e" category="section-title">문제 해결 및 지원</block>
  <block id="9985a592486717ae388709b9267da4f9" category="section-title">NetApp은 Astra Trident를 지원합니까?</block>
  <block id="cc56e0da96ceaf708545923f1094815b" category="paragraph">Astra Trident는 오픈 소스이며 무료로 제공되지만, NetApp 백엔드가 지원되는 경우 NetApp은 이를 완벽하게 지원합니다.</block>
  <block id="a3d907947129a58ee6f9e23074840c8f" category="section-title">지원 케이스를 어떻게 제기합니까?</block>
  <block id="0265687df6c09d532b03477776c6d075" category="paragraph">지원 케이스를 제기하려면 다음 중 하나를 수행합니다.</block>
  <block id="5dab8cca21a0ff4e72d4e2a1ee5156ea" category="list-text">지원 어카운트 매니저에게 연락하여 티켓을 발급하는 데 도움을 받으십시오.</block>
  <block id="09ea0908fbfc4cde85bf416e35dc55c8" category="inline-link">NetApp 지원</block>
  <block id="a13956d424374973d31e5883b8bf8b6a" category="list-text">에 연락하여 지원 케이스를 제출하십시오<block ref="116f7ad90a3c7441981f82d8f8fba4d5" category="inline-link-rx"></block>.</block>
  <block id="3e77e87e5ee8fb4f6f910f4cf0594fc2" category="section-title">지원 로그 번들을 생성하려면 어떻게 해야 합니까?</block>
  <block id="7938aed248d09a5120eaf414e6c1d574" category="paragraph">tridentctl logs-a를 실행하여 지원 번들을 생성할 수 있습니다. 번들에 캡처된 로그 외에 kubelet 로그를 캡처하여 Kubernetes 측의 마운트 문제를 진단합니다. 쿠벨렛 로그를 얻는 지침은 Kubernetes 설치 방법에 따라 다릅니다.</block>
  <block id="2c3543f339dc749a508ed5e5e5aaae23" category="section-title">새 기능에 대한 요청을 제기해야 하는 경우 어떻게 해야 합니까?</block>
  <block id="0aa1d7a95d75c0faa8302a803356b7b7" category="section-title">결함은 어디에서 제기합니까?</block>
  <block id="4c1d312c39e7048d2c634824e243fdba" category="inline-link">Astra Trident GitHub를 참조하십시오</block>
  <block id="a814c59a6fef2fb64a2a32dedcf6f82e" category="paragraph">에서 문제를 만듭니다<block ref="e71a8230f1c77ee7d957187295b859e4" category="inline-link-rx"></block>. 문제와 관련된 모든 필수 정보와 로그를 포함해야 합니다.</block>
  <block id="fd0759571f12527967b660b5b327c65b" category="section-title">Astra Trident에 대한 간단한 질문을 하면 어떻게 됩니까? 커뮤니티나 포럼이 있습니까?</block>
  <block id="264c3819b5a8fdae87f1dc9af1988a90" category="section-title">스토리지 시스템의 암호가 변경되었고 Astra Trident가 더 이상 작동하지 않습니다. 어떻게 복구합니까?</block>
  <block id="061ec2ab4d383b8f20e15eda656db8f7" category="paragraph">'tridentctl update backend mybackend -f&lt;/path/to_new_backend.json&gt; -n triment'로 백엔드 암호를 업데이트합니다. 이 예에서 'mybackend'를 백엔드 이름으로, '/path/to_new_backend.json'을 올바른 백엔드 .json 파일 경로로 바꿉니다.</block>
  <block id="6100f37d544e87e462129f21e52bae7f" category="section-title">Astra Trident에서 내 Kubernetes 노드를 찾을 수 없습니다. 이 문제를 해결하려면 어떻게 합니까?</block>
  <block id="d5cf5c734786394c838bacc6597594c6" category="paragraph">Astra Trident가 Kubernetes 노드를 찾을 수 없는 두 가지 시나리오가 있을 수 있습니다. Kubernetes의 네트워킹 문제 또는 DNS 문제 때문일 수 있습니다. 각 Kubernetes 노드에서 실행되는 Trident 노드 데모는 Trident 컨트롤러와 통신하여 노드를 Trident에 등록할 수 있어야 합니다. Astra Trident를 설치한 후 네트워킹 변경이 발생하면 클러스터에 추가된 새 Kubernetes 노드에서만 이 문제가 발생합니다.</block>
  <block id="bcd549c9f0199c5b8d0b55f782bff9e8" category="section-title">Trident POD가 제거되면 데이터를 손실합니까?</block>
  <block id="136fed1edd42bf8ca22358da037d17fa" category="paragraph">Trident POD를 제거할 경우 데이터가 손실되지 않습니다. Trident의 메타데이터는 CRD 객체에 저장됩니다. Trident에서 프로비저닝한 모든 PVS가 정상적으로 작동합니다.</block>
  <block id="3de05f78e401869f4630ec8cabf339df" category="section-title">이전 버전에서 새 버전으로 직접 업그레이드할 수 있습니까(일부 버전을 건너뛰는 경우)?</block>
  <block id="ce44cbbc54839f39b351c091b0e3caa5" category="paragraph">NetApp은 하나의 주요 릴리즈에서 바로 다음 주요 릴리즈로 Astra Trident를 업그레이드할 수 있도록 지원합니다. 버전 18.xx에서 19.xx, 19.xx에서 20.xx로 업그레이드할 수 있습니다. 운영 구축 전에 연구소에서 업그레이드를 테스트해야 합니다.</block>
  <block id="0399b9e6348e554937a4d65efc97a1b8" category="section-title">Trident를 이전 릴리즈로 다운그레이드할 수 있습니까?</block>
  <block id="d307563c01953bd90a41ddd049f96d51" category="inline-link-macro">다운그레이드 섹션을 참조하십시오</block>
  <block id="ba9c59aa9d07b25e124dcf6ca88d689a" category="section-title">백엔드 및 볼륨 관리</block>
  <block id="ffe72215dff9a93d62ee68905212025e" category="section-title">ONTAP 백엔드 정의 파일에서 관리 및 데이터 LIF를 모두 정의해야 합니까?</block>
  <block id="f3997f0b9446951754e665cfe7591cef" category="section-title">Astra Trident에서 ONTAP 백엔드에 대한 CHAP를 구성할 수 있습니까?</block>
  <block id="805f73dde029c6c119993b4496bbdc9e" category="paragraph">예. 20.04부터 Astra Trident는 ONTAP 백엔드에 대한 양방향 CHAP를 지원합니다. 이를 위해서는 백엔드 구성에서 'useCHAP=true'를 설정해야 합니다.</block>
  <block id="952cc22022a80bb8079f6dd7afb289d2" category="section-title">Astra Trident를 사용하여 엑스포트 정책을 관리하려면 어떻게 해야 합니까?</block>
  <block id="700815d44ae9a359311f64dbebbd8d42" category="paragraph">Astra Trident는 버전 20.04 이상에서 내보내기 정책을 동적으로 생성하고 관리할 수 있습니다. 따라서 스토리지 관리자는 백엔드 구성에서 하나 이상의 CIDR 블록을 제공할 수 있으며, 이러한 범위에 속하는 Trident 추가 노드 IP를 생성한 엑스포트 정책에 추가할 수 있습니다. 이러한 방식으로 Astra Trident는 주어진 CIDR 내에 IP가 있는 노드의 규칙 추가 및 삭제를 자동으로 관리합니다. 이 기능을 사용하려면 CSI Trident가 필요합니다.</block>
  <block id="ddd61a9bf73a6cb2a2375bcdfbecbe15" category="section-title">DataLIF에 포트를 지정할 수 있습니까?</block>
  <block id="c7449c080f216d9be59d8ff995985d39" category="paragraph">Astra Trident 19.01 이후 버전에서는 DataLIF에 포트를 지정할 수 있습니다. backend.json 파일에 ""management LIF":&lt;ip address&gt;:&lt;port&gt;""로 설정한다. 예를 들어, 관리 LIF의 IP 주소가 192.0.2.1이고 포트가 1000이면 """관리 LIF":"192.0.2.1:1000""을 구성합니다.</block>
  <block id="1d08384060bd88a7801faae4fe346d06" category="section-title">관리 및 데이터 LIF에 IPv6 주소를 사용할 수 있습니까?</block>
  <block id="4c0e813a0bfed033d75bbfd8b18f556c" category="section-title">백엔드에서 관리 LIF를 업데이트할 수 있습니까?</block>
  <block id="66d8fee83a94421ca416a2bdb33703b4" category="paragraph">예. 'tridentctl update backend' 명령을 사용하여 백엔드 관리 LIF를 업데이트할 수 있습니다.</block>
  <block id="c56cd7a01da4acc4fc86aa498cabfd99" category="section-title">백엔드에서 데이터 LIF를 업데이트할 수 있습니까?</block>
  <block id="1e0e6fcec605e6450ba12b95969c8959" category="section-title">Kubernetes용 Astra Trident에서 여러 개의 백엔드를 생성할 수 있습니까?</block>
  <block id="fb3cb30bfe23466a98407256c8b5164f" category="paragraph">Astra Trident는 동일한 드라이버나 다른 드라이버를 사용하여 동시에 많은 백엔드를 지원할 수 있습니다.</block>
  <block id="6454319cc2398418b67f5b2df5aa5cd3" category="section-title">Astra Trident는 백엔드 자격 증명을 어떻게 저장합니까?</block>
  <block id="1d406f7ac7268b602da0989a4675480e" category="paragraph">Astra Trident는 백엔드 자격 증명을 Kubernetes Secrets로 저장합니다.</block>
  <block id="64a610ffaa66abeebc73d8159b9f73ec" category="section-title">Astra Trident는 특정 백엔드를 어떻게 선택합니까?</block>
  <block id="c6e9fbb586ad55ddf4bbda9814c6adc9" category="paragraph">백엔드 속성을 사용하여 클래스에 맞는 풀을 자동으로 선택할 수 없는 경우 특정 풀 세트를 선택하는 데 'toragePools' 및 'additionalStoragePools' 매개 변수가 사용됩니다.</block>
  <block id="3beefa69a05dde01d93a438a943a5a7a" category="section-title">Astra Trident가 특정 백엔드에서 프로비저닝하지 않도록 하려면 어떻게 해야 합니까?</block>
  <block id="b5c265487a1fed6a3367664ccab664bb" category="paragraph">excludeStoragePools 매개 변수는 Astra Trident가 프로비저닝에 사용할 풀 세트를 필터링하고 일치하는 풀을 제거하는 데 사용됩니다.</block>
  <block id="e124ac30adf3eea60a13cd5f93980e7e" category="section-title">동일한 종류의 백엔드가 여러 개 있는 경우 Astra Trident는 어떤 백엔드를 사용할 것인지 어떻게 선택할 수 있습니까?</block>
  <block id="c02ba3e7f8a02e0d1e29e2190a86e352" category="paragraph">동일한 유형의 백엔드가 여러 개 구성되어 있는 경우 Astra Trident는 'torageClass' 및 'PersistentVolumeClaim'에 있는 매개 변수를 기반으로 적절한 백엔드를 선택합니다. 예를 들어, 여러 ONTAP-NAS 드라이버 백엔드가 있는 경우 Astra Trident는 'torageClass' 및 'PersistentVolumeClaim'의 매개 변수를 조합하여 'torageClass' 및 'PersistVolumeentClaim'에 나열된 요구 사항을 전달할 수 있는 백엔드와 일치시킵니다. 요청과 일치하는 백엔드가 여러 개 있는 경우, Astra Trident는 임의의 백엔드 중 하나를 선택합니다.</block>
  <block id="7a2fd62f4a63259a7f94543a0ae01e76" category="section-title">Astra Trident가 Element/SolidFire를 사용하는 양방향 CHAP를 지원합니까?</block>
  <block id="b127099c71415d532da3a26ed73eb041" category="paragraph">예.</block>
  <block id="7880810a250adc4ccf5108fe88325055" category="section-title">Astra Trident는 ONTAP 볼륨에 qtree를 어떻게 배포합니까? 단일 볼륨에 몇 개의 qtree를 구축할 수 있습니까?</block>
  <block id="657cbdac1a85665b0b38b37c9a306925" category="paragraph">'ONTAP-NAS-이코노미' 드라이버는 동일한 FlexVol에서 최대 200개의 qtree(50~300 구성 가능), 클러스터 노드당 100,000 qtree, 클러스터당 2.4M qtree를 지원합니다. 이코노미 드라이버가 서비스하는 새 "PersistentVolumeClaim"을 입력하면 운전자는 새 Qtree를 처리할 수 있는 FlexVol가 이미 있는지 확인합니다. Qtree를 처리할 수 있는 FlexVol가 없으면 새 FlexVol가 생성됩니다.</block>
  <block id="abbdd4298bb3e525fd172b2bbe5a451c" category="section-title">ONTAP NAS에 프로비저닝된 볼륨에 대해 Unix 권한을 설정하려면 어떻게 해야 합니까?</block>
  <block id="a535e502931280dfaa539ecd1cbdfc0c" category="paragraph">백엔드 정의 파일에 매개 변수를 설정하여 Astra Trident가 프로비저닝한 볼륨에 대해 Unix 권한을 설정할 수 있습니다.</block>
  <block id="094ef47e6456d60b656401b0f2bbfcbd" category="section-title">볼륨을 프로비저닝하는 동안 명시적 ONTAP NFS 마운트 옵션 세트를 구성하려면 어떻게 합니까?</block>
  <block id="84ae0d345d4b749efbbc8103b0770e68" category="paragraph">기본적으로 Astra Trident는 Kubernetes의 마운트 옵션을 아무 값으로도 설정하지 않습니다. Kubernetes 스토리지 클래스에서 마운트 옵션을 지정하려면 지정된 예제를 따르십시오<block ref="cd55c45fce745b7032050d3a7a9ec326" category="inline-link-rx"></block>.</block>
  <block id="ae6bc3659bb0be0a7d9f98a63775b7c2" category="section-title">프로비저닝된 볼륨을 특정 엑스포트 정책으로 설정하려면 어떻게 해야 합니까?</block>
  <block id="700a2008fea63d02c24b85f2f75d357e" category="paragraph">적절한 호스트가 볼륨에 액세스할 수 있도록 하려면 백엔드 정의 파일에 구성된 "exportPolicy" 매개 변수를 사용합니다.</block>
  <block id="9d5813dee71bcbf3d3a03c62354c3e55" category="section-title">ONTAP가 있는 Astra Trident를 통해 볼륨 암호화를 설정하려면 어떻게 해야 합니까?</block>
  <block id="ef1581716b653c4364dd5005dbe9e40a" category="section-title">Astra Trident를 통해 ONTAP에 대한 QoS를 구축하는 가장 좋은 방법은 무엇입니까?</block>
  <block id="f412d672b51ea3c57812ebf3be0ddccb" category="paragraph">ONTAP용 QoS를 구현하려면 'torageClaes'를 사용합니다.</block>
  <block id="1c771b761835123a135e64f70567d768" category="section-title">Astra Trident를 통해 씬 또는 일반 프로비저닝을 지정하려면 어떻게 해야 합니까?</block>
  <block id="0d97afe7a571dc39db1c810013844332" category="paragraph">ONTAP 드라이버는 씬 또는 일반 프로비저닝을 지원합니다. ONTAP 드라이버는 기본적으로 씬 프로비저닝입니다. 일반 프로비저닝이 필요한 경우 백엔드 정의 파일 또는 'torageClass'를 구성해야 합니다. 둘 다 구성된 경우 'torageClass'가 우선합니다. ONTAP에 대해 다음을 구성합니다.</block>
  <block id="2d0384de8b72e53c3476a478a5d4ec53" category="list-text">'torageClass'에서 'vorioningType' 속성을 굵게로 설정합니다.</block>
  <block id="3764067c4b14276efb241c511c8b0cc2" category="list-text">백엔드 정의 파일에서 'Backend spaceReserve Parameter'를 볼륨으로 설정하여 일반 볼륨을 활성화합니다.</block>
  <block id="d4391b26a81fead46afc74243c4029aa" category="section-title">실수로 PVC를 삭제한 경우에도 사용 중인 볼륨이 삭제되지 않도록 하려면 어떻게 해야 합니까?</block>
  <block id="e58a684cd1a44d4879defbb2ec06b9a4" category="paragraph">PVC 보호는 버전 1.10부터 Kubernetes에서 자동으로 활성화됩니다.</block>
  <block id="8d766c7d692523686b8954d72ee86ea4" category="section-title">Astra Trident에서 만든 NFS PVC를 늘릴 수 있습니까?</block>
  <block id="328e34871ba32779f27f3e8a8e78499a" category="paragraph">예. Astra Trident에서 만든 PVC를 확장할 수 있습니다. 볼륨 자동 증가 기능은 Trident에 적용되지 않는 ONTAP 기능입니다.</block>
  <block id="f2f324d5d940b44cd307b613c6990e0c" category="section-title">Astra Trident 외부에서 생성된 볼륨이 있는 경우 Astra Trident로 가져올 수 있습니까?</block>
  <block id="c894ce628e51d8d9d062a1e83cda37c8" category="paragraph">19.04부터는 볼륨 가져오기 기능을 사용하여 Kubernetes에 볼륨을 가져올 수 있습니다.</block>
  <block id="3319194e0ba07a6aa327aefa1ab1e41f" category="section-title">SnapMirror 데이터 보호(DP) 또는 오프라인 모드일 때 볼륨을 가져올 수 있습니까?</block>
  <block id="0b10afe39923054016a71caf423fdec6" category="paragraph">외부 볼륨이 DP 모드이거나 오프라인인 경우 볼륨 가져오기가 실패합니다. 다음과 같은 오류 메시지가 나타납니다.</block>
  <block id="9fd7d017b60cc366b6bc3b6e55213abe" category="section-title">Astra Trident에서 만든 iSCSI PVC를 확장할 수 있습니까?</block>
  <block id="29e2faaced65d1dd4c920c60e854e550" category="paragraph">Trident 19.10은 CSI Provisioner를 사용하여 iSCSI PVS를 확장할 수 있도록 지원합니다.</block>
  <block id="eed67b2d196c61d9c6cf4a50878ba446" category="section-title">리소스 할당량은 NetApp 클러스터로 어떻게 변환됩니까?</block>
  <block id="45f78013e46c8f3e884ed0f7becbd5ab" category="paragraph">NetApp 스토리지의 용량이 있는 경우 Kubernetes 스토리지 리소스 할당량이 작동합니다. 용량 부족으로 인해 NetApp 스토리지가 Kubernetes 할당량 설정을 적용할 수 없을 경우 Astra Trident가 프로비저닝하려고 하지만 오류를 해결합니다.</block>
  <block id="491a93842f7a65b8cbe82aca71db0d3f" category="section-title">Astra Trident를 사용하여 볼륨 스냅샷을 생성할 수 있습니까?</block>
  <block id="9792ac41ce6f91861f84548e1b4a2b1c" category="paragraph">예. Astra Trident는 스냅샷에서 필요 시 볼륨 스냅샷 및 영구 볼륨 생성을 지원합니다. 스냅샷에서 PVS를 생성하려면 'VolumeSnapshotDataSource' 기능 게이트가 활성화되어 있는지 확인합니다.</block>
  <block id="1eedb8a6574b0c07ea61689a7e3ec8d4" category="section-title">Astra Trident 볼륨 스냅샷을 지원하는 드라이버는 무엇입니까?</block>
  <block id="24c649a639a2c31810a4dfc6ed0190da" category="section-title">ONTAP를 사용하여 Astra Trident가 프로비저닝한 볼륨의 스냅샷 백업을 어떻게 생성합니까?</block>
  <block id="0bdcd128fab544a7df404bc496a4126e" category="paragraph">ONTAP-NAS, ONTAP-SAN, ONTAP-NAS-Flexgroup 드라이버에서 지원됩니다. FlexVol 레벨에서 ONTAP-SAN-이코노미 드라이버에 대한 스냅샷 정책을 지정할 수도 있습니다.</block>
  <block id="933b520ff6d70262ddb482995c684d57" category="paragraph">이는 'ONTAP-NAS-이코노미' 드라이버에서도 사용할 수 있지만 qtree 레벨의 세분화가 아니라 FlexVol 레벨의 세분화 수준에서 확인할 수 있습니다. Astra Trident에서 프로비저닝한 볼륨을 스냅샷하는 기능을 사용하려면 백엔드 매개 변수 옵션 '스냅샷 정책'을 ONTAP 백엔드에 정의된 대로 원하는 스냅샷 정책으로 설정하십시오. 스토리지 컨트롤러에서 생성한 스냅샷은 Astra Trident에서 알 수 없습니다.</block>
  <block id="594e8a352537de25938bdd663d6211b5" category="section-title">Astra Trident를 통해 프로비저닝된 볼륨에 대한 스냅샷 예약 비율을 설정할 수 있습니까?</block>
  <block id="8db5662205f3a6430af4bea6f08e7d45" category="paragraph">예. 백엔드 정의 파일에 '스냅샷 예약' 속성을 설정하여 Astra Trident를 통해 스냅샷 복사본을 저장할 디스크 공간의 특정 비율을 예약할 수 있습니다. 백엔드 정의 파일에 '스냅샷 정책'과 '스냅샷 예약'을 구성한 경우 백엔드 파일에 명시된 '스냅샷 예약 공간' 비율에 따라 스냅샷 예약 비율이 설정됩니다. '스냅샷 예약' 백분율 값이 언급되지 않은 경우 ONTAP는 기본적으로 스냅샷 예약 비율을 5로 설정합니다. '스냅샷 정책' 옵션이 없음으로 설정되어 있으면 스냅샷 예약 비율은 0으로 설정됩니다.</block>
  <block id="6b0d34d8a0749198a6b80eec69479c86" category="section-title">볼륨 스냅샷 디렉토리에 직접 액세스하고 파일을 복사할 수 있습니까?</block>
  <block id="eb3a2d1eb3c4022269f4c6837332311a" category="paragraph">예. 백엔드 정의 파일에서 '스냅샷 디렉토리' 매개 변수를 설정하여 Trident에서 프로비저닝한 볼륨의 스냅샷 디렉토리에 액세스할 수 있습니다.</block>
  <block id="81dbf5e91cc69bfcf6477128389d8a25" category="section-title">Astra Trident를 통해 볼륨에 대해 SnapMirror를 설정할 수 있습니까?</block>
  <block id="64dd4ea74b402889a9c341da491f4933" category="paragraph">현재 ONTAP CLI 또는 OnCommand System Manager를 사용하여 외부에서 SnapMirror를 설정해야 합니다.</block>
  <block id="e321bf6d54ded18df56a41ea51223a2a" category="section-title">영구 볼륨을 특정 ONTAP 스냅샷으로 복원하려면 어떻게 합니까?</block>
  <block id="5325f5d2cf63aaaa6610f09e8aa4dc35" category="paragraph">ONTAP 스냅숏에 볼륨을 복원하려면 다음 단계를 수행하십시오.</block>
  <block id="4e789db936072df2058e9f271a9b8db8" category="list-text">영구 볼륨을 사용하는 응용 프로그램 포드를 중지합니다.</block>
  <block id="b34baa75f4f799a23b19de9b94e86868" category="list-text">ONTAP CLI 또는 OnCommand System Manager를 통해 필요한 스냅샷으로 되돌립니다.</block>
  <block id="08754f2800804f1fe3673c858b4b56e0" category="list-text">응용 프로그램 포드를 다시 시작합니다.</block>
  <block id="0d3ef54a4cc337b5d907b6639e51c6d4" category="section-title">각 고객/테넌트에 대해 스토리지 클래스 사용을 어떻게 분리할 수 있습니까?</block>
  <block id="fda1b35892cb6f61447f0e49415937d9" category="paragraph">Kubernetes에서는 네임스페이스의 스토리지 클래스를 허용하지 않습니다. 그러나 Kubernetes를 사용하여 네임스페이스당 사용되는 스토리지 리소스 할당량을 사용하여 네임스페이스당 특정 스토리지 클래스의 사용을 제한할 수 있습니다. 특정 스토리지에 대한 특정 네임스페이스 액세스를 거부하려면 해당 스토리지 클래스에 대한 리소스 할당량을 0으로 설정합니다.</block>
  <block id="30d965eef5ba25c6b9998ae38270b43e" category="doc">법적 고지</block>
  <block id="db5eb84117d06047c97c9a0191b5fffe" category="doc">지원</block>
  <block id="14340f3a4eb25a54f8446036d807d7c8" category="paragraph">Astra Trident는 공식적으로 지원되는 NetApp 프로젝트입니다. 표준 메커니즘을 사용하여 NetApp에 연락하면 필요한 엔터프라이즈급 지원을 받을 수 있습니다.</block>
  <block id="ef1161058705470bb877fbce688eea9e" category="summary">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="9a5f09cf66e692efdae493ce4c9aa64f" category="inline-link-macro">준비</block>
  <block id="6c728e8788471413351ba9fcd26ca76e" category="list-text"><block ref="6c728e8788471413351ba9fcd26ca76e" category="inline-link-macro-rx"></block></block>
  <block id="e5fc4f2bd89271cfb112e8b768f74dde" category="inline-link-macro">구성 및 예</block>
  <block id="874216718c1d50bbd2aa417449058e46" category="list-text"><block ref="874216718c1d50bbd2aa417449058e46" category="inline-link-macro-rx"></block></block>
  <block id="ce8828fc10a926c196951c9bdd0d534d" category="section-title">사용자 권한</block>
  <block id="96c17dbe45e7351fb2a4f71956c25e0c" category="paragraph">Astra Trident는 일반적으로 "admin" 클러스터 사용자 또는 "vsadmin" SVM 사용자를 사용하거나 동일한 역할을 가진 다른 이름을 가진 사용자를 사용하여 ONTAP 또는 SVM 관리자로 실행될 것으로 예상합니다. NetApp ONTAP 구축을 위한 Amazon FSx의 경우 Astra Trident는 클러스터 'fsxadmin' 사용자 또는 'vsadmin' SVM 사용자 또는 동일한 역할을 가진 다른 이름의 사용자를 사용하여 ONTAP 또는 SVM 관리자로 실행될 것으로 예상합니다. 'fsxadmin' 사용자는 클러스터 관리자 사용자에게 제한된 교체품입니다.</block>
  <block id="4937b52eb2cb058f225b69b2caafaf29" category="admonition">'limitAggregateUsage' 매개 변수를 사용하는 경우 클러스터 관리자 권한이 필요합니다. Astra Trident와 함께 NetApp ONTAP용 Amazon FSx를 사용하는 경우 "limitAggregateUsage" 매개 변수는 "vsadmin" 및 "fsxadmin" 사용자 계정과 작동하지 않습니다. 이 매개 변수를 지정하면 구성 작업이 실패합니다.</block>
  <block id="8f828c7344e7fe65d66237a25193068b" category="summary">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="b5c795328aa98beaf5bdc15b54a533c1" category="paragraph">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오. 모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="5475028f502d04bc17cdfdf613d28cbf" category="paragraph">또한 둘 이상의 드라이버를 실행하고 둘 중 하나를 가리키는 스토리지 클래스를 생성할 수도 있습니다. 예를 들어, ONTAP-SAN 드라이버와 ONTAP-SAN-이코노미 클래스를 사용하는 '기본 클래스'를 사용하는 'san-dev' 클래스를 구성할 수 있습니다.</block>
  <block id="c75f7811d70d17dbcd88e9d03752cbed" category="section-title">인증</block>
  <block id="51e35cec1e001fb8abfbe474a18dd282" category="paragraph">Astra Trident는 ONTAP 백엔드를 인증하는 두 가지 모드를 제공합니다.</block>
  <block id="00cbc0e7ed0014813b07fc8452f60df1" category="list-text">자격 증명 기반: 필요한 권한이 있는 ONTAP 사용자의 사용자 이름 및 암호입니다. ONTAP 버전과의 호환성을 최대한 보장하기 위해 admin 또는 vsadmin과 같은 미리 정의된 보안 로그인 역할을 사용하는 것이 좋습니다.</block>
  <block id="e2cd9c84c3ebf14f3c81be4692848e5b" category="list-text">인증서 기반: Astra Trident는 백엔드에 설치된 인증서를 사용하여 ONTAP 클러스터와 통신할 수도 있습니다. 이 경우 백엔드 정의에는 클라이언트 인증서, 키 및 사용할 경우 신뢰할 수 있는 CA 인증서의 Base64로 인코딩된 값이 있어야 합니다(권장).</block>
  <block id="a2f8f419bf420960ef8cca73e1999e09" category="section-title">자격 증명 기반 인증을 사용합니다</block>
  <block id="ceae351bc6b26100a9b1685a5d477c0a" category="paragraph">Astra Trident는 SVM 범위/클러스터 범위 관리자에게 ONTAP 백엔드와 통신하기 위한 자격 증명을 요구합니다. admin 또는 vsadmin과 같이 미리 정의된 표준 역할을 사용하는 것이 좋습니다. 이를 통해 향후 Astra Trident 릴리스에서 사용할 기능 API를 노출할 수 있는 향후 ONTAP 릴리스와 향후 호환성이 보장됩니다. 사용자 지정 보안 로그인 역할은 Astra Trident와 함께 생성 및 사용할 수 있지만 권장되지 않습니다.</block>
  <block id="2312b8f77f99c346269b67308afc3649" category="paragraph">백엔드 정의의 예는 다음과 같습니다.</block>
  <block id="2a2ef6dcf08a8789a55301af5f71304c" category="paragraph">백엔드 정의는 자격 증명이 일반 텍스트로 저장되는 유일한 위치라는 점에 유의하십시오. 백엔드가 생성된 후 사용자 이름/암호는 Base64로 인코딩되어 Kubernetes 암호로 저장됩니다. 백엔드의 생성/업딩은 자격 증명에 대한 지식이 필요한 유일한 단계입니다. 따라서 Kubernetes/스토리지 관리자가 수행할 수 있는 관리 전용 작업입니다.</block>
  <block id="052f76b486189a7b01340d5134eb7985" category="section-title">인증서 기반 인증을 사용합니다</block>
  <block id="0778b06c5ea9fded4fd7b586b248dd86" category="paragraph">신규 및 기존 백엔드는 인증서를 사용하여 ONTAP 백엔드와 통신할 수 있습니다. 백엔드 정의에는 세 가지 매개 변수가 필요합니다.</block>
  <block id="d5b9c9db262b1927d7914504f3587adb" category="list-text">clientCertificate: Base64로 인코딩된 클라이언트 인증서 값입니다.</block>
  <block id="8f2b750dd6a57864f0e36828c248ddfc" category="list-text">clientPrivateKey: Base64 - 연결된 개인 키의 인코딩된 값입니다.</block>
  <block id="200c2d2a44dec6455fa1c947f9c1f534" category="list-text">TrustedCACertificate: 신뢰할 수 있는 CA 인증서의 Base64 인코딩 값입니다. 신뢰할 수 있는 CA를 사용하는 경우 이 매개 변수를 제공해야 합니다. 신뢰할 수 있는 CA가 사용되지 않으면 이 작업을 무시할 수 있습니다.</block>
  <block id="6b634823c19ebc37c9e4fdbf08de1fff" category="paragraph">일반적인 워크플로에는 다음 단계가 포함됩니다.</block>
  <block id="c92e58d7dd251e6e6cdb16291a6dec90" category="list-text">클라이언트 인증서 및 키를 생성합니다. 생성 시 CN(일반 이름)을 ONTAP 사용자로 설정하여 인증하십시오.</block>
  <block id="69b521cddbc52a2d14539e349e2930f0" category="list-text">신뢰할 수 있는 CA 인증서를 ONTAP 클러스터에 추가합니다. 이는 스토리지 관리자가 이미 처리한 것일 수 있습니다. 트러스트된 CA가 사용되지 않으면 무시합니다.</block>
  <block id="2f3945695e5ca88abb46af80d87c6972" category="list-text">ONTAP 클러스터에 클라이언트 인증서 및 키(1단계)를 설치합니다.</block>
  <block id="e81810c4035ad015ad3f0d8c4f2c6454" category="list-text">ONTAP 보안 로그인 역할이 인증서 인증 방법을 지원하는지 확인합니다.</block>
  <block id="ea3bf76b270384627e7bcfb197ddb17b" category="list-text">생성된 인증서를 사용하여 인증을 테스트합니다. ONTAP 관리 LIF&gt; 및 &lt;SVM 이름&gt;을 관리 LIF IP 및 SVM 이름으로 바꿉니다.</block>
  <block id="83f2adf143dc8f5fbbb9d924f840c1ce" category="list-text">Base64로 인증서, 키 및 신뢰할 수 있는 CA 인증서를 인코딩합니다.</block>
  <block id="8d36e570f1edac5ae19e6733e3fbb4d5" category="list-text">이전 단계에서 얻은 값을 사용하여 백엔드를 생성합니다.</block>
  <block id="2ab8ad0fce083cd02635b9126cf4353c" category="section-title">인증 방법을 업데이트하거나 자격 증명을 회전합니다</block>
  <block id="5e36c3d66bd47ae551071244dc48df17" category="admonition">암호를 회전할 때 스토리지 관리자는 먼저 ONTAP에서 사용자의 암호를 업데이트해야 합니다. 그 다음에는 백엔드 업데이트가 있습니다. 인증서를 회전할 때 여러 인증서를 사용자에게 추가할 수 있습니다. 그런 다음 백엔드가 업데이트되어 새 인증서를 사용합니다. 그러면 ONTAP 클러스터에서 이전 인증서를 삭제할 수 있습니다.</block>
  <block id="6819218365fe3a3d66752f663feecddb" category="paragraph">백엔드를 업데이트해도 이미 생성된 볼륨에 대한 액세스가 중단되거나 이후에 생성된 볼륨 연결에 영향을 미치지 않습니다. 백엔드 업데이트가 성공적이면 Astra Trident가 ONTAP 백엔드와 통신하고 향후 볼륨 작업을 처리할 수 있음을 나타냅니다.</block>
  <block id="93a4f17ec735c794a2d38eb0d9dc736b" category="section-title">Igroup을 지정합니다</block>
  <block id="f66329c2f28d3aade033dade4fa02359" category="paragraph">Astra Trident에서 igroup을 사용하여 프로비저닝하는 볼륨(LUN)에 대한 액세스를 제어합니다. 관리자는 백엔드에 대한 igroup을 지정할 때 다음 두 가지 옵션을 사용할 수 있습니다.</block>
  <block id="caf7ba3262c90c77b09b7d53946b7be4" category="list-text">Astra Trident는 백엔드에 따라 igroup을 자동으로 생성하고 관리할 수 있습니다. 만약 'triviName'이 백엔드 정의에 포함되지 않으면, Astra Trident는 SVM에 'trident-&lt;backend-UUID&gt;'라는 igroup을 생성합니다. 그러면 각 백엔드에 전용 igroup이 있고 Kubernetes 노드 IQN의 자동 추가/삭제를 처리합니다.</block>
  <block id="b325b5680680ba28771d11978100bf3a" category="list-text">또는 미리 생성된 igroup을 백엔드 정의로 제공할 수도 있습니다. 이 작업은 'show'(이름) config 매개 변수를 사용하여 수행할 수 있습니다. Astra Trident가 기존 igroup에 Kubernetes 노드 IQN을 추가/삭제합니다.</block>
  <block id="ccdb9f53393401f058dcfc9c1de74547" category="paragraph">'인명이름'이 정의된 백엔드의 경우, '인명이름'을 '트리멘틀백엔드 업데이트'를 사용하여 삭제하고 Astra Trident에서 Igroup을 자동 처리할 수 있습니다. 이 경우 워크로드에 이미 연결된 볼륨에 대한 액세스가 중단되지 않습니다. 생성된 igroup Astra Trident를 사용하여 향후 연결을 처리할 것입니다.</block>
  <block id="8841675f2e0dbba5719034b41ac52435" category="admonition">Astra Trident의 각 고유 인스턴스에 대해 igroup을 할당하는 것은 Kubernetes 관리자 및 스토리지 관리자에게 유용한 모범 사례입니다. CSI Trident는 클러스터 노드 IQN을 igroup에 추가 및 제거하여 관리를 크게 단순화합니다. 전용 igroup을 사용하여 Kubernetes 환경(및 Astra Trident 설치)에서 동일한 SVM을 사용할 경우 한 Kubernetes 클러스터의 변경 사항이 다른 Kubernetes 클러스터와 관련된 igroup에 영향을 미치지 않도록 합니다. 또한 Kubernetes 클러스터의 각 노드에 고유한 IQN이 있는지 확인하는 것도 중요합니다. 위에 언급한 바와 같이, Astra Trident는 IQN의 추가 및 제거를 자동으로 처리합니다. 호스트 간에 IQN을 재사용하면 호스트가 서로 잘못 인식되어 LUN에 대한 액세스가 거부되는 바람직하지 않은 시나리오가 발생할 수 있습니다.</block>
  <block id="3882232e20d620974a87db190a124fe7" category="paragraph">Astra Trident가 CSI Provisioner로 실행되지 않을 경우, Kubernetes 클러스터의 모든 작업자 노드에서 iSCSI IQN을 포함하도록 igroup을 수동으로 업데이트해야 합니다. Kubernetes 클러스터에 참여하는 노드의 IQN을 igroup에 추가해야 합니다. 마찬가지로, Kubernetes 클러스터에서 제거된 노드의 IQN을 igroup에서 제거해야 합니다.</block>
  <block id="42f93278b0d15c8d0f6613813bf586d5" category="section-title">양방향 CHAP를 사용하여 연결을 인증합니다</block>
  <block id="5d34ca21e19aa85f2e3cbc5bc90702fb" category="paragraph">Astra Trident는 ONTAP-SAN과 ONTAP-SAN 절약 드라이버에 양방향 CHAP를 사용하여 iSCSI 세션을 인증할 수 있습니다. 이를 위해서는 백엔드 정의에서 'useCHAP' 옵션을 사용해야 합니다. "true"로 설정하면 Astra Trident가 SVM의 기본 이니시에이터 보안을 양방향 CHAP로 구성하고 백엔드 파일의 사용자 이름과 암호를 설정합니다. 양방향 CHAP를 사용하여 연결을 인증하는 것이 좋습니다. 다음 샘플 구성을 참조하십시오.</block>
  <block id="12dd7bfa072b5a1eecf975f6a5a6eaa7" category="admonition">useCHAP는 한 번만 설정할 수 있는 Boolean 옵션이다. 기본적으로 false로 설정되어 있습니다. true 로 설정한 후에는 false 로 설정할 수 없습니다.</block>
  <block id="bc601528678aeeb582101ed205a054bc" category="paragraph">useCHAP=true 외에, chapInitatorSecret, chapTargetInitialatorSecret, chapchTargetUsername, chapUsername 필드가 백엔드 정의에 포함되어야 합니다. tridentctl update를 실행하여 백엔드를 생성한 후 비밀을 변경할 수 있다.</block>
  <block id="9ffdb95250e26c7a6b468126ac7c75b0" category="section-title">작동 방식</block>
  <block id="adbaa30840aebfe537058f72e0989326" category="paragraph">스토리지 관리자는 useCHAP를 true로 설정하여 스토리지 백엔드에서 CHAP를 구성하도록 Astra Trident에 지시합니다. 여기에는 다음이 포함됩니다.</block>
  <block id="29b4db879e4cc96a6b71bc763367624b" category="list-text">SVM에서 CHAP 설정:</block>
  <block id="951e8b45bc49a5475337a1b55e3e3dc4" category="list-text">SVM의 기본 이니시에이터 보안 유형이 없음(기본값으로 설정) * 이고 * 볼륨에 이미 기존 LUN이 없는 경우 Astra Trident는 기본 보안 유형을 "CHAP"로 설정하고 CHAP 이니시에이터 및 대상 사용자 이름 및 암호 구성을 진행합니다.</block>
  <block id="313818ab0cd3579429d5bd6e5faab8ff" category="list-text">SVM에 LUN이 포함된 경우 Astra Trident는 SVM에서 CHAP를 활성화하지 않습니다. 따라서 SVM에 이미 있는 LUN에 대한 액세스가 제한되지 않습니다.</block>
  <block id="13e0c564d5e1fbd33279fb276166653d" category="list-text">CHAP 이니시에이터 및 타겟 사용자 이름과 암호를 구성합니다. 이러한 옵션은 백엔드 구성에 지정해야 합니다(위 참조).</block>
  <block id="2c7856e86a0cd46cb4fb48fa0886745e" category="paragraph">백엔드가 생성된 후 Astra Trident는 해당 'tridentbackend' CRD를 생성하고 CHAP 비밀과 사용자 이름을 Kubernetes 비밀로 저장합니다. 이 백엔드에서 Astra Trident에 의해 생성된 모든 PVS는 CHAP를 통해 마운트되고 연결됩니다.</block>
  <block id="81f2df0265026a1a04bda5484798a10d" category="section-title">자격 증명을 회전하고 백엔드를 업데이트합니다</block>
  <block id="a7fe005c9f49619f4438aac8932fb361" category="paragraph">backend.json 파일에서 CHAP 파라미터를 업데이트하여 CHAP 자격 증명을 업데이트할 수 있다. 이렇게 하려면 CHAP 암호를 업데이트하고 "tridentctl update" 명령을 사용하여 이러한 변경 사항을 반영해야 합니다.</block>
  <block id="8959ac16a58b09dc5a158e86ab02cb53" category="admonition">백엔드의 CHAP 암호를 업데이트할 때 "tridentctl"을 사용하여 백엔드를 업데이트해야 합니다. Astra Trident에서 변경 사항을 선택할 수 없으므로 CLI/ONTAP UI를 통해 스토리지 클러스터의 자격 증명을 업데이트하지 마십시오.</block>
  <block id="1a59d0d7850406f157c314978eb3b821" category="paragraph">기존 연결은 영향을 받지 않습니다. SVM에서 Astra Trident가 자격 증명을 업데이트하면 활성 상태로 유지됩니다. 새 연결은 업데이트된 자격 증명을 사용하며 기존 연결은 계속 활성 상태로 유지됩니다. 기존 PVS를 연결 해제하고 다시 연결하면 업데이트된 자격 증명을 사용하게 됩니다.</block>
  <block id="4cc2b9916e7383e5fa29dc6188159e32" category="summary">백엔드는 Astra Trident와 스토리지 시스템 간의 관계를 정의합니다. Astra Trident가 스토리지 시스템과 통신하는 방법과 Astra Trident가 스토리지 시스템에서 볼륨을 프로비저닝하는 방법을 알려줍니다. Astra Trident를 설치한 후 다음 단계는 백엔드를 생성하는 것입니다. '트리펜엔드구성' 사용자 정의 리소스 정의(CRD)를 사용하면 Kubernetes 인터페이스를 통해 Trident 백엔드를 직접 생성하고 관리할 수 있습니다. 쿠베틀이나 이와 동등한 CLI 툴을 사용하여 Kubernetes를 배포할 수 있습니다.</block>
  <block id="a8e174c63ac21920b8405ffddc39214a" category="doc">kubectl로 백엔드를 만듭니다</block>
  <block id="d2031a5a319b9363cf98da6b1509598a" category="paragraph">트리젠벤디Config('tbc', 'tbconfig', 'tbackendconfig')는 쿠벡틀로 아스트라 트리덴트 백엔드를 관리할 수 있는 프론트이자 이름있는 CRD입니다. 이제 Kubernetes 및 스토리지 관리자는 전용 명령줄 유틸리티('tridentctl')를 사용하지 않고 Kubernetes CLI를 통해 직접 백엔드를 생성 및 관리할 수 있습니다.</block>
  <block id="b44c2fd5cefc815abed7e31c0fa8c8ac" category="paragraph">'트리펜엔드구성' 객체가 생성되면 다음과 같은 현상이 발생합니다.</block>
  <block id="858fafdff7fa27f202ae0eb981c6dff0" category="list-text">백엔드는 사용자가 제공하는 구성에 따라 Astra Trident에서 자동으로 생성합니다. 이는 내부적으로 트리덴백엔드(트리덴백엔드) CR로 표현된다.</block>
  <block id="40640dd98ca175d098c1c765b1e148d9" category="list-text">트리젠트백엔드구성은 아스트라 트리덴트(Astra Trident)가 만든 트리젠백엔드(트리젠백엔드)에 고유하게 바인딩됩니다.</block>
  <block id="1efc3a14ca6dc7c90db79e02f3abe7d5" category="paragraph">각각의 트리젠백엔드구성은 트리젠백엔드(트리젠백엔드)를 통해 일대일 매핑을 유지합니다. 전자는 백엔드를 설계 및 구성하기 위해 사용자에게 제공되는 인터페이스이며, 후자는 Trident가 실제 백엔드 객체를 나타내는 방법입니다.</block>
  <block id="c9038f47fe0df535b6bf5619c9ff629e" category="admonition">트리젠백엔드 CRS는 아스트라 트리덴트(Astra Trident)에 의해 자동으로 생성됩니다. 수정할 수 없습니다. 백엔드에 대한 업데이트를 하려면 '트리엔백구성' 개체를 수정하여 이 작업을 수행하십시오.</block>
  <block id="9c3385530cf6e460576e5f6e7cc1b912" category="paragraph">'트리엔백엔드구성' CR의 형식은 다음 예를 참조하십시오.</block>
  <block id="c84ef67352bb6783ff2881f9f2821c2a" category="inline-link">Trident - 장착 공구</block>
  <block id="f13a06ff6eab87969a9f96765f31ed9c" category="paragraph">의 예를 살펴볼 수도 있습니다<block ref="6511e50af21389f9e77db56e03f6dd72" category="inline-link-rx"></block> 원하는 스토리지 플랫폼/서비스의 샘플 구성을 위한 디렉토리입니다.</block>
  <block id="06df669f3ef6f929e9b58c9f47b65310" category="inline-link-macro">스토리지 드라이버에 대한 백엔드 구성 정보입니다</block>
  <block id="182839d8f6b2bdde60e1d972422cf3a2" category="paragraph">이 'pec'은 백엔드 구성 매개 변수를 사용합니다. 이 예에서는 백엔드에서 'ONTAP-SAN' 스토리지 드라이버를 사용하고 여기에 표로 제공된 구성 매개 변수를 사용합니다. 원하는 스토리지 드라이버에 대한 구성 옵션 목록은 를 참조하십시오 <block ref="5f2d139eefa7c36061f4d97161be02ea" category="inline-link-macro-rx"></block>.</block>
  <block id="92051c832f01d9070a7ed71d1ce523c5" category="paragraph">이번 시기에는 트리젠백엔드Config CR에 새로 도입된 자격 증명과 delitionPolicy 필드가 포함되어 있습니다.</block>
  <block id="5ab961de690e071f0dc1c0dabac7fd89" category="list-text">"credentials": 이 매개변수는 필수 필드이며 스토리지 시스템/서비스를 인증하는 데 사용되는 자격 증명을 포함합니다. 사용자 생성 Kubernetes Secret으로 설정됩니다. 자격 증명을 일반 텍스트로 전달할 수 없으며 오류가 발생합니다.</block>
  <block id="9f11e03722a7b912083c63fc68f4dd7b" category="list-text">"설명 정책": 이 필드는 트리젠BackendConfig가 삭제될 때 발생하는 동작을 정의합니다. 다음 두 가지 값 중 하나를 사용할 수 있습니다.</block>
  <block id="d09d50d3f84f9c585492818f491a2497" category="list-text">삭제(Delete): 이 경우 트리엔백엔드Config CR과 관련 백엔드가 모두 삭제됩니다. 이 값이 기본값입니다.</block>
  <block id="f0c89ce27bf4c43949ad8f26a4f586bb" category="list-text">[Tain]: 트리덴트Config CR이 삭제되면 백엔드 정의가 계속 존재하고 tridentctl로 관리될 수 있다. 삭제 정책을 "보존"으로 설정하면 사용자는 이전 릴리스(21.04 이전)로 다운그레이드하고 생성된 백엔드를 유지할 수 있습니다. 이 필드의 값은 '트리엔백엔드구성'이 생성된 후에 업데이트할 수 있습니다.</block>
  <block id="7f2208582df334d090d35357eb5d6901" category="admonition">백엔드 이름은 'pec.backendName'을 사용하여 설정됩니다. 지정하지 않으면 백엔드 이름이 '트리엔백엔드구성' 객체(metadata.name 지정합니다. 'pec.backendName'을 사용하여 백엔드 이름을 명시적으로 설정하는 것이 좋습니다.</block>
  <block id="317e77f416ffd109037a657fffa1e7f7" category="admonition">tridentctl로 만든 백엔드에는 관련된 트리젠BackendConfig 객체가 없습니다. 트리젠백엔드Config CR을 만들어 kubctl로 백엔드를 관리할 수 있습니다. 동일한 구성 매개 변수(예: 'pec.backendName', 'pec.storagePrefix', 'pec.storageDriverName' 등)를 지정할 때는 주의해야 합니다. Astra Trident는 새로 생성된 '트리젠백엔드구성'을 기존 백엔드와 자동으로 바인딩합니다.</block>
  <block id="625cc9b8ccc34496dc2b3fcffb7e384a" category="section-title">단계 개요</block>
  <block id="a867c4bbc8d632a517f22b7377b9b8ed" category="paragraph">kubbeck을 사용하여 새 백엔드를 생성하려면 다음을 수행해야 합니다.</block>
  <block id="4db4699aa0126dfb06878d7e07c0abdf" category="inline-link">쿠버네티스 비밀</block>
  <block id="7e5e1bb39eefe4eec7a88b845126d41d" category="list-text">을 생성합니다<block ref="fcce7b7bd05b6b012eabe3df8de04808" category="inline-link-rx"></block>. 비밀에는 Astra Trident가 스토리지 클러스터/서비스와 통신하는 데 필요한 자격 증명이 포함되어 있습니다.</block>
  <block id="c39d193a9cc4084cc6c7964e1bb5efd8" category="list-text">'트리멘백엔드구성' 객체를 만듭니다. 스토리지 클러스터/서비스에 대한 자세한 내용과 이전 단계에서 생성한 암호를 참조하십시오.</block>
  <block id="286b0035cf59742ffe54696b798f2368" category="paragraph">백엔드를 생성한 후 "kubbtl get tbc&lt;tbc-name&gt;-n&lt;trident-namespace&gt;"를 사용하여 해당 상태를 관찰하고 추가 세부 정보를 수집할 수 있습니다.</block>
  <block id="494cb787cd1c1f78123323c1006f2081" category="section-title">1단계: Kubernetes Secret 생성</block>
  <block id="a8c4d0cb53af2c6e334f5c58890021d6" category="paragraph">백엔드에 대한 액세스 자격 증명이 포함된 암호를 생성합니다. 이는 각 스토리지 서비스/플랫폼마다 다릅니다. 예를 들면 다음과 같습니다.</block>
  <block id="04402bf69acac56c72a55c0e4ac2165c" category="paragraph">이 표에는 각 스토리지 플랫폼의 비밀에 포함되어야 하는 필드가 요약되어 있습니다.</block>
  <block id="94cec86c6eef229009007e6d00d54ef1" category="cell">스토리지 플랫폼 암호 필드 설명입니다</block>
  <block id="1e6947ac7fb3a9529a9726eb692c8cc5" category="cell">비밀</block>
  <block id="c11257eff6563de2c05e353770c514ca" category="cell">필드 설명입니다</block>
  <block id="93c5bebdea9c94a0740fe6fd9bb250f0" category="paragraph">클라이언트 ID입니다</block>
  <block id="012e85295e2f1f744cfb8757f8dd4830" category="paragraph">앱 등록에서 클라이언트 ID</block>
  <block id="ee64ef6c307cfcfe5c0f085471cd61fa" category="paragraph">private_key_id</block>
  <block id="1e31c22f827d25c5973eee697baace79" category="paragraph">개인 키의 ID입니다. CVS 관리자 역할을 가진 GCP 서비스 계정에 대한 API 키의 일부</block>
  <block id="156a17333e77a3c504018cae5ada8c3b" category="paragraph">개인 키</block>
  <block id="8e0708b67ba6ce0f70a948152e7e7895" category="paragraph">개인 키. CVS 관리자 역할을 가진 GCP 서비스 계정에 대한 API 키의 일부</block>
  <block id="25de05ab7f10e99b499db62e0b89ad33" category="cell">요소(NetApp HCI/SolidFire)</block>
  <block id="2a6ba72e93aa7fa676d07973ed2716bb" category="paragraph">엔드포인트</block>
  <block id="41eba2d95ecaf35c8bd3a972c263ffe4" category="paragraph">테넌트 자격 증명이 있는 SolidFire 클러스터의 MVIP입니다</block>
  <block id="253b40ae359ba25b56231803430c4873" category="cell">ONTAP</block>
  <block id="14c4b06b824ec593239362517f538b29" category="paragraph">사용자 이름</block>
  <block id="6e1b40351708d93ce8c387f6f8ca7533" category="paragraph">클러스터/SVM에 연결할 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다</block>
  <block id="5f4dcc3b5aa765d61d8327deb882cf99" category="paragraph">암호</block>
  <block id="4d3fd9a7ab4c84b857fc26b2633237d0" category="paragraph">클러스터/SVM에 연결하는 암호 자격 증명 기반 인증에 사용됩니다</block>
  <block id="19dce7ac7f5290fc8fa218ad0c858df5" category="paragraph">clientPrivateKey를 선택합니다</block>
  <block id="8c5e8d4f9acf9295e1a96feef0c0b516" category="paragraph">Base64 - 클라이언트 개인 키의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="039e9d80fa53ba861c06b590ba3f9d34" category="paragraph">챕터 사용자 이름</block>
  <block id="a7128cd45d4a277fe5c6ed6f6c4238f7" category="paragraph">인바운드 사용자 이름입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="f9d0dc78b203f2c1106dc0c7d58a5397" category="paragraph">챕터시토시크릿</block>
  <block id="2f573af61fb37b4f1c5e2def2341b7c4" category="paragraph">CHAP 이니시에이터 암호입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="2ebe107bb3bc9551fbb0e5033046931c" category="paragraph">chapTargetUsername 을 선택합니다</block>
  <block id="e945f079b3e50bd5722f056b72282608" category="paragraph">대상 사용자 이름입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="4ab84a55744951d967033db9b64f6b27" category="paragraph">챕터타겟이니터시크릿</block>
  <block id="61b50fba255c10a4a2b5f7cf8276849a" category="paragraph">CHAP 타겟 이니시에이터 암호입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="73d583a1445e1497ec3adaa011e2724c" category="paragraph">이 단계에서 만든 암호는 다음 단계에서 만든 트리젠백엔드Config 개체의 '증명서' 필드에 참조됩니다.</block>
  <block id="3394622f88ed2c82c85e92e908879095" category="paragraph">이제 '트리엔백구성' CR을 만들 준비가 되었습니다. 이 예에서 'ONTAP-SAN' 드라이버를 사용하는 백엔드는 아래에 나와 있는 ' TridentBackendConfig ' 객체를 사용하여 생성합니다.</block>
  <block id="967688089cfc07a6c8e893bce5186445" category="paragraph">이제 '트리펜엔드구성' CR을 생성했으므로 상태를 확인할 수 있습니다. 다음 예를 참조하십시오.</block>
  <block id="edc9d2e179d9bd8effd5277699967aff" category="paragraph">백엔드가 성공적으로 생성되어 '트리엔백엔드구성' CR에 바인딩되었습니다.</block>
  <block id="ecb5320e6f020f2c2dcad7a6268111ed" category="paragraph">위상은 다음 값 중 하나를 사용할 수 있습니다.</block>
  <block id="35ef366711dba4820492cd153e2bc30d" category="list-text">바운드: 트리젠백엔드Config CR은 백엔드와 연결되며 백엔드에는 트리젠백엔드Config CR의 uid로 설정된 configRef가 포함되어 있습니다.</block>
  <block id="f2edf590deb30828e48e7290aa78e788" category="list-text">'Unbound': ''로 표현됨. 트리젠백엔드Config 객체가 백엔드에 바인딩되지 않습니다. 새로 만든 트리젠백엔드Config CRS는 기본적으로 이 단계에 있습니다. 단계가 변경된 후에는 다시 바인딩되지 않은 상태로 되돌릴 수 없습니다.</block>
  <block id="895ba30a6f39f0691ad851fe26560431" category="list-text">"트리엔테구성" CR의 "설명 정책"이 삭제되도록 설정되었습니다. 트리젠백엔드Config CR이 삭제되면 삭제 상태로 전환됩니다.</block>
  <block id="0550ab6955adf5805cf2d00b7c592718" category="list-text">백엔드에 영구 볼륨 클레임(PVCs)이 없는 경우, 트리엔백엔드구성을 삭제하면 Astra Trident가 백엔드를 삭제하고 '트리엔백구성' CR을 삭제합니다.</block>
  <block id="ffd02eb489e62222a00391567d0bad81" category="list-text">백엔드에 PVC가 하나 이상 있는 경우 삭제 상태로 전환됩니다. 이후 트리젠백엔드Config CR도 삭제 단계로 진입한다. 모든 PVC가 삭제된 후에만 백엔드 및 트리젠백엔드구성이 삭제됩니다.</block>
  <block id="39d978e14d4d8c9f19589af0d4e72661" category="list-text">손실: 트리젠백엔드Config CR과 관련된 백엔드가 실수로 또는 고의적으로 삭제되었고, 트리젠백엔드Config CR에는 삭제된 백엔드에 대한 참조가 여전히 있습니다. 이 경우에도 '항목 정책' 값에 관계없이 '트리멘백엔드구성' CR은 삭제할 수 있습니다.</block>
  <block id="8375bdbfbc291bcedc60e7555e3dc43a" category="list-text">알 수 없음: Astra Trident가 ' Trident' CR과 연관된 백엔드의 상태 또는 존재를 확인할 수 없습니다. 예를 들어, API 서버가 응답하지 않거나 'tridentbackends.trident.netapp.io` CRD가 없는 경우 이 경우 사용자의 개입이 필요할 수 있습니다.</block>
  <block id="fdf3d4560a801cb64c255cc2790fe9cc" category="inline-link-macro">백엔드 업데이트 및 백엔드 삭제</block>
  <block id="57867491a75119ccf33f6ed8a434ff8e" category="paragraph">이 단계에서는 백엔드가 성공적으로 생성됩니다! 다음과 같은 몇 가지 작업을 추가로 처리할 수 있습니다 <block ref="9f5a7b55f1a44b55d5336cefd3bf688e" category="inline-link-macro-rx"></block>.</block>
  <block id="4dca0b80562cc590644c1acfada17219" category="section-title">(선택 사항) 4단계: 자세한 내용을 확인하십시오</block>
  <block id="22f66c61dd35abb0ae1840a7e38ae1b9" category="paragraph">다음 명령을 실행하여 백엔드에 대한 자세한 정보를 얻을 수 있습니다.</block>
  <block id="aab3a73056ee2962dff0130da0538454" category="paragraph">또한 '트리엔백구성'의 YAML/JSON 덤프를 얻을 수도 있습니다.</block>
  <block id="9fae9b8b2e8f0d5b91654165a5dacc1f" category="paragraph">'backendInfo'에는 '트리젠BackendConfig' CR에 대응하여 만든 백엔드의 'backendName'과 'backendUUID'가 포함되어 있습니다. 'lastOperationStatus' 필드는 사용자 트리거(예: 사용자가 'spec'에서 무언가를 변경한 경우) 또는 Astra Trident(예: Astra Trident 재시작 시)에 의해 트리거될 수 있는 '트리엔백엔드 Config' CR의 마지막 작업 상태를 나타냅니다. 성공 또는 실패일 수 있습니다. 단계 는 트리젠백엔드Config CR과 백엔드 간의 관계를 나타냅니다. 위의 예에서 'phase'는 값이 바인딩되어 있어 '트리젠백엔드구성' CR이 백엔드와 연결되어 있음을 의미합니다.</block>
  <block id="7b7587593fc7d381339d450faa35dfa9" category="paragraph">"kubbctl -n trident tbc &lt;tbc-cr-name&gt;" 명령을 실행하여 이벤트 로그의 세부 정보를 확인할 수 있습니다.</block>
  <block id="6dc07da7e54d697726bb349fb693fa8b" category="inline-link-macro">여기 를 참조하십시오</block>
  <block id="c732962a4a01ea5f406ec66e50e98903" category="admonition">tridentctl을 사용하여 연결된 'TrientBackendConfig' 객체가 포함된 백엔드는 업데이트하거나 삭제할 수 없습니다. tridentctl과 트리멘BackendConfig의 전환 단계를 이해하려면 <block ref="8d6bc70a41f48e3f72c3f5ea8752090b" category="inline-link-macro-rx"></block>.</block>
  <block id="bc960ce53bb0d62c44b5a3f212c279d3" category="summary">스토리지 클래스를 생성하고, 스토리지 클래스를 삭제하고, 기존 스토리지 클래스를 볼 수 있습니다.</block>
  <block id="e8b9c3a9859a62e9a58431c3b61f75d5" category="doc">스토리지 클래스를 관리합니다</block>
  <block id="5802c976ee5f858f76699af5294812e6" category="paragraph">스토리지 클래스 생성, 스토리지 클래스 삭제 및 기존 스토리지 클래스 보기에 대한 정보를 찾을 수 있습니다.</block>
  <block id="e123173acd76721f31496874fd778eca" category="section-title">스토리지 클래스를 설계합니다</block>
  <block id="a9a4b52c93b141ba28676afe58a5900d" category="paragraph">을 참조하십시오 <block ref="5a81d2db77288939223c6a591fc3991d" category="inline-link-macro-rx"></block> 스토리지 클래스의 정의 및 구성 방법에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="14f4c7abe09c4481722f1fa6563f2604" category="section-title">스토리지 클래스를 생성합니다</block>
  <block id="99b068c418b4a658f64806517e8567ac" category="paragraph">스토리지 클래스 파일이 있으면 다음 명령을 실행합니다.</block>
  <block id="fac03ff7d61c420a4caeeb44355cb2be" category="paragraph">'&lt;storage-class-file&gt;'을(를) 스토리지 클래스 파일 이름으로 바꿔야 합니다.</block>
  <block id="0fe0aa7b9b7529f66030afb1629507bb" category="section-title">스토리지 클래스를 삭제합니다</block>
  <block id="4bf50148821c75f616a96daca9255e6f" category="paragraph">Kubernetes에서 스토리지 클래스를 삭제하려면 다음 명령을 실행합니다.</block>
  <block id="65494a0b3404ce637afd88bcb7c82998" category="paragraph">'&lt;storage-class&gt;'은(는) 스토리지 클래스로 교체해야 합니다.</block>
  <block id="a5f526f5d63d827ce2c0146a20cd2ff7" category="paragraph">이 스토리지 클래스를 통해 생성된 영구 볼륨은 변경되지 않으며 Astra Trident는 계속 관리합니다.</block>
  <block id="e606165355271961ba07945766fbf83a" category="section-title">기존 스토리지 클래스를 봅니다</block>
  <block id="7c237bc6c124137d25df2dec1cb3e528" category="list-text">기존 Kubernetes 스토리지 클래스를 보려면 다음 명령을 실행합니다.</block>
  <block id="4aae22fbb9c0d354d0a9c15c6c126d89" category="list-text">Kubernetes 스토리지 클래스 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="bed443a9c5577e1043c277e8ebbb542f" category="list-text">Astra Trident의 동기화된 스토리지 클래스를 보려면 다음 명령을 실행합니다.</block>
  <block id="db66cf4d314ab7a719a76ed3af1b0173" category="list-text">Astra Trident의 동기화된 스토리지 클래스 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="ce32eb748bd7452bd6ee6d1d7ad6d3a7" category="section-title">기본 스토리지 클래스를 설정합니다</block>
  <block id="f30a1542c01c3c493f3c01c88dfe5fcd" category="paragraph">Kubernetes 1.6에는 기본 스토리지 클래스를 설정하는 기능이 추가되었습니다. 사용자가 영구 볼륨 클레임(PVC)에 영구 볼륨을 지정하지 않는 경우 영구 볼륨을 프로비저닝하는 데 사용되는 스토리지 클래스입니다.</block>
  <block id="7c435ae4763642458286cb691812ea55" category="list-text">스토리지 클래스 정의에서 주석 'torageclass.Kubernetes.io/is-default-class'를 true로 설정하여 기본 스토리지 클래스를 정의합니다. 사양에 따라 다른 값이나 주석 부재는 FALSE로 해석됩니다.</block>
  <block id="61fd76f55d29aaceb4a6ee09a318dc45" category="list-text">다음 명령을 사용하여 기존 스토리지 클래스를 기본 스토리지 클래스로 구성할 수 있습니다.</block>
  <block id="800477137444bec636483de85335cbb5" category="list-text">마찬가지로 다음 명령을 사용하여 기본 스토리지 클래스 주석을 제거할 수 있습니다.</block>
  <block id="2d2f31c3012657fd7b38b41312d1a0b8" category="paragraph">또한 Trident 설치 프로그램 번들에는 이 주석을 포함하는 예제도 있습니다.</block>
  <block id="94d8ac3a8d98f2232d3dc735878a5bc3" category="admonition">언제든지 클러스터에는 기본 스토리지 클래스가 하나만 있어야 합니다. Kubernetes에서 둘 이상의 작업을 수행하는 것을 기술적으로 금지하지는 않지만 기본 스토리지 클래스가 없는 것처럼 동작합니다.</block>
  <block id="6c36cb9c072dc4cb9e163c44568f6a91" category="section-title">스토리지 클래스에 대한 백엔드를 식별합니다</block>
  <block id="dc0742ede78913414129866d60898f67" category="paragraph">이 예는 Astra Trident 백엔드 객체에 대해 tridentctl이 출력하는 JSON으로 답할 수 있는 질문의 예입니다. 먼저 설치해야 할 JQ 유틸리티가 사용됩니다.</block>
  <block id="bee1e2306bc7054ee443dc651eae90de" category="summary">Astra Trident는 Astra Trident의 성능을 모니터링하는 데 사용할 수 있는 Prometheus 메트릭 엔드포인트 세트를 제공합니다.</block>
  <block id="44a004cad6eb7ea8839aaa8754ead178" category="doc">Astra Trident를 모니터링합니다</block>
  <block id="3f8e7343fbab71427901476dc4eb0cf3" category="paragraph">Astra Trident는 Astra Trident의 성능을 모니터링하는 데 사용할 수 있는 Prometheus 메트릭 엔드포인트 세트를 제공합니다.</block>
  <block id="c827f266cf12e05adc1fe95215415abf" category="paragraph">Astra Trident에서 제공하는 메트릭을 통해 다음을 수행할 수 있습니다.</block>
  <block id="6111d709595b0a106ff313a249eb9d92" category="list-text">Astra Trident의 상태 및 구성을 계속 확인하십시오. 성공적인 작업이 어떻게 이루어지는지, 예상대로 백엔드와 통신할 수 있는지 확인할 수 있습니다.</block>
  <block id="64dbac0ca36d9b1f6a8cf1e8a0123261" category="list-text">백엔드 사용 정보를 검토하고 백엔드에서 프로비저닝되는 볼륨 수와 사용된 공간 등을 파악합니다.</block>
  <block id="7f6516030964b624d9c71fd9ec7f83dd" category="list-text">사용 가능한 백엔드에 프로비저닝된 볼륨 양의 매핑을 유지합니다.</block>
  <block id="e436794bccbe602731bbde7766c1fa49" category="list-text">성과 추적. Astra Trident가 백엔드 및 작업을 수행하는 데 걸리는 시간을 확인할 수 있습니다.</block>
  <block id="efe0d75090a22534acabc936f8669994" category="admonition">기본적으로 Trident의 메트릭은 '/metrics' 끝점의 타겟 포트 8001에 표시됩니다. Trident가 설치된 경우 이러한 메트릭은 기본적으로 * 활성화됩니다.</block>
  <block id="1ed994b9754ad078cfc46aaf3dbf3a5d" category="list-text">Astra Trident가 설치된 Kubernetes 클러스터</block>
  <block id="eb8bfd69bb88378a6f4d987811890ce6" category="inline-link">컨테이너형 Prometheus 구축</block>
  <block id="42ae2e91a939ffa9bbda53c10bf5f89f" category="inline-link">네이티브 애플리케이션</block>
  <block id="050899631250104f17d24b27cc8a12e5" category="list-text">프로메테우스(Prometheus) 인스턴스. 이것은 일 수 있습니다<block ref="bd5b9e4bd7b88b90afb221fb760a777c" category="inline-link-rx"></block> 또는 Prometheus를 로 실행하도록 선택할 수 있습니다<block ref="3f1d5beaea78c0fd8cb397fbeb1c88bd" category="inline-link-rx"></block>.</block>
  <block id="68276ca40dfbfd36de911402152fa452" category="section-title">1단계: Prometheus 목표를 정의합니다</block>
  <block id="84c49e3c77b51ea186020145ae78103f" category="paragraph">메트릭을 수집하고 백엔드 Astra Trident가 관리하는, 생성하는 볼륨 등에 대한 정보를 얻으려면 Prometheus 타겟을 정의해야 합니다. 여기<block ref="dc7964965bf1b3af43b28caf6231e550" category="inline-link-rx"></block> Prometheus 및 Grafana를 Astra Trident와 함께 사용하여 메트릭을 검색하는 방법에 대해 설명합니다. 이 블로그에서는 Kubernetes 클러스터에서 운영자로 Prometheus를 실행하고 Astra Trident의 메트릭을 얻기 위해 ServiceMonitor를 생성하는 방법을 설명합니다.</block>
  <block id="c33638e0de87536b08eeb94264671d0f" category="section-title">2단계: Prometheus ServiceMonitor를 만듭니다</block>
  <block id="81a21a88b42cd5c83d149a080a627bad" category="paragraph">Trident 메트릭을 소비하려면 트리덴트 CSI 서비스를 감시하고 메티우스 포트에서 수신 대기하는 프로메테우스 서비스 모니터를 만들어야 합니다. 샘플 ServiceMonitor의 모양은 다음과 같습니다.</block>
  <block id="bfc1ad0fa725ea87ea056b2f2e8b6fe8" category="paragraph">이 ServiceMonitor 정의는 '삼중상 CSI' 서비스에서 반환된 지표를 검색하고 특히 서비스의 산부인과를 찾습니다. 따라서 이제 Prometheus가 Astra Trident의 메트릭을 이해하도록 구성되었습니다.</block>
  <block id="07338294bd70ea1e7710a574d7c8e2ce" category="paragraph">kubelet은 Astra Trident에서 직접 제공하는 측정 지표 외에도 자사의 측정 지표를 통해 많은 "kubelet_volume_ *" 측정 지표를 노출합니다. Kubelet는 연결된 볼륨, Pod 및 처리하는 기타 내부 작업에 대한 정보를 제공할 수 있습니다. 을 참조하십시오<block ref="3f1f0977d0df3e8b343e403140284021" category="inline-link-rx"></block>.</block>
  <block id="1db2022a8a8de5d612eda8e3be0e1065" category="section-title">3단계: PromQL을 사용하여 Trident 메트릭 쿼리</block>
  <block id="f5142e19a3b1edf809fce9d3b6aefc05" category="paragraph">PromQL은 시계열 또는 표 형식 데이터를 반환하는 식을 만드는 데 적합합니다.</block>
  <block id="8c6fb1be2521fd16337c11c626672678" category="paragraph">다음은 사용할 수 있는 몇 가지 PromQL 쿼리입니다.</block>
  <block id="b214fd0009b3929347f097bd843f0bfd" category="section-title">Trident 상태 정보를 가져옵니다</block>
  <block id="69fc54b5fac064131422d41948eb77ed" category="list-text">Astra Trident** 의 HTTP 2XX 응답률</block>
  <block id="f43362a8efc950ece8c14d4e5faddfa4" category="list-text">Astra Trident에서 상태 코드를 통해 얻은 REST 응답의 비율**</block>
  <block id="e69d9a06025140f38adabb6f709f6e5b" category="list-text">** Astra Trident **에 의해 수행된 작업의 평균 지속 시간(ms)</block>
  <block id="0505e17dec1e849391ad96f558fa613a" category="section-title">Astra Trident 사용 정보를 확인하십시오</block>
  <block id="f160a52d617adf6e6c5d379a9b8bca89" category="list-text">** 평균 볼륨 크기**</block>
  <block id="eb978bfe01ec0c72ad231f3953e304a2" category="list-text">** 각 백엔드에서 프로비저닝된 총 볼륨 공간**</block>
  <block id="5f735ae12eafbe476178928f4645475b" category="section-title">개별 볼륨 사용량을 가져옵니다</block>
  <block id="ee0898e9f0caa503f3eaa39c919f4c53" category="admonition">이 기능은 kubelet 메트릭도 수집한 경우에만 사용할 수 있습니다.</block>
  <block id="0bc301d2423b2ffaa38a5e275e4ec6f9" category="list-text">각 볼륨에 사용된 공간의** 비율**</block>
  <block id="8516d75df966e595bd1b5491acd01515" category="section-title">Astra Trident AutoSupport 텔레메트리 에 대해 자세히 알아보십시오</block>
  <block id="6f4ddec0f501988d2b0315a77c87eeaa" category="paragraph">기본적으로 Astra Trident는 Prometheus 메트릭 및 기본 백엔드 정보를 매일 NetApp에 보냅니다.</block>
  <block id="5276683815b670b0addfb8c8a45bbb41" category="list-text">Astra Trident가 Prometheus 메트릭 및 기본 백엔드 정보를 NetApp에 전송하지 않도록 하려면 Astra Trident 설치 중에 '--st침묵-autosupport' 플래그를 전달하십시오.</block>
  <block id="ca0f9a86ca33f1d6baa9051bd7f4ed21" category="inline-link">개인 정보 보호 정책</block>
  <block id="5b58783cbe6d85941bac008d83d3f5c8" category="list-text">Astra Trident는 또한 "tridentctl Send AutoSupport"를 통해 요청 시 NetApp 지원으로 컨테이너 로그를 보낼 수 있습니다. 로그를 업로드하려면 Astra Trident를 트리거해야 합니다. 로그를 제출하기 전에 NetApp의 내용에 동의해야 합니다<block ref="91b6c0438017ba5fa21c286a96d5acb4" category="inline-link-rx"></block>.</block>
  <block id="63b95d84cf55d169b2592f3ac621055f" category="list-text">지정되지 않은 경우 Astra Trident는 지난 24시간 동안 로그를 가져옵니다.</block>
  <block id="5224919a4ae5ccf610fb0ee74e4e7a94" category="inline-link">Trident AutoSupport를 누릅니다</block>
  <block id="53084cad3d11df800502598c11e2d10b" category="inline-link">EULA</block>
  <block id="b9a52e8d1e9b14b8825c6ea01c0ce6d6" category="list-text">Trident AutoSupport는 개인 식별 정보(PII) 또는 개인 정보를 수집하거나 전송하지 않습니다. 이 제품은 와 함께 제공됩니다<block ref="173a360b412944768c2ab13e6c8fd1c7" category="inline-link-rx"></block> Trident 컨테이너 이미지 자체에는 적용되지 않습니다. 데이터 보안 및 신뢰에 대한 NetApp의 노력에 대해 자세히 알아볼 수 있습니다<block ref="8470ff535916bda3f4ea4723647a7135" category="inline-link-rx"></block>.</block>
  <block id="89f0f2832f60f480805faf638848c5b7" category="paragraph">Astra Trident에서 보낸 페이로드의 예는 다음과 같습니다.</block>
  <block id="d2ec86f126f845e79aff07e70bf89472" category="list-text">AutoSupport 메시지는 NetApp의 AutoSupport 엔드포인트로 전송됩니다. 개인 레지스트리를 사용하여 컨테이너 이미지를 저장하는 경우 '--image-registry' 플래그를 사용할 수 있습니다.</block>
  <block id="86c5a11fba83815412aec79f67f2d276" category="list-text">또한 설치 YAML 파일을 생성하여 프록시 URL을 구성할 수도 있습니다. 이는 트라이덴트ctl install --generate-custom-YAML을 이용해 YAML 파일을 생성하고 트리덴트 배포(trident-deployment)의 트리덴트 자동 지원 컨테이너에 대한 '--proxy-url' 주장을 추가하는 방식으로 가능하다.</block>
  <block id="46ab735110312d196d5265e534453cba" category="section-title">Astra Trident 메트릭을 비활성화합니다</block>
  <block id="8ec47dab227d183e0d3ad0cd529d289b" category="paragraph">** 메트릭을 보고하지 않으려면 ('--generate-custom-YAML' 플래그를 사용하여) 사용자 지정 YAML을 생성하고 이를 편집하여 삼중류-main' 컨테이너에 대해 호출되는 '--metrics' 플래그를 제거해야 합니다.</block>
  <block id="e5879288a130fbd8d0b8682cfc375c4f" category="doc">스냅샷 작업</block>
  <block id="4744d2c82c1c470ab40280b2ebba0c08" category="paragraph">이 강물은 아스트라 트라이던트 CSI 드라이버를 가리킵니다. 정책이란 '삭제'나 '유지'가 될 수 있습니다. "유지"로 설정하면 "VolumeSnapshot" 객체가 삭제되더라도 스토리지 클러스터의 기본 물리적 스냅샷이 보존됩니다.</block>
  <block id="0ab6380edce0d0e7b8538ebf3215ebbd" category="section-title">2단계: 기존 PVC의 스냅샷을 생성합니다</block>
  <block id="501470eb266ff6637de993e3f193ba40" category="paragraph">이로 인해 'VolumeSnapshot' 객체가 생성되었습니다. VolumeSnapshot은 PVC와 유사하며 실제 스냅샷을 나타내는 'VolumeSnapshotContent' 객체와 연결됩니다.</block>
  <block id="320e7c242b569ab5bbdaa490b3df817e" category="paragraph">pvc1-snap VolumeSnapshot에 대한 VolumeSnapshotContent 객체를 설명하여 식별할 수 있다.</block>
  <block id="b3841b02d7da01fde480332e3295a08e" category="paragraph">'스냅샷 컨텐츠 이름'은 이 스냅샷을 제공하는 VolumeSnapshotContent 객체를 식별합니다. Ready to Use 매개변수는 스냅샷이 새 PVC를 생성하는 데 사용될 수 있음을 나타냅니다.</block>
  <block id="7957320b126678e9b713ef146b3ac009" category="section-title">3단계: VolumeSnapshots에서 PVC를 생성합니다</block>
  <block id="2592284f87bba60e4c05337a134ef047" category="paragraph">"다소스"는 데이터 소스로 "pvc1-snap"이라는 VolumeSnapshot을 사용하여 PVC를 생성해야 함을 나타냅니다. 이렇게 하면 Astra Trident가 스냅샷에서 PVC를 생성하도록 지시합니다. PVC가 생성된 후 POD에 부착하여 다른 PVC와 마찬가지로 사용할 수 있습니다.</block>
  <block id="bda01e3aa44c411129a6fbf29445bfb4" category="admonition">연결된 스냅샷이 있는 영구 볼륨을 삭제하면 해당 Trident 볼륨이 "삭제 상태"로 업데이트됩니다. Astra Trident 볼륨을 삭제하려면 볼륨의 스냅샷을 제거해야 합니다.</block>
  <block id="72a5926b7fb086fe87e93771f6620556" category="summary">tridentctl을 사용하여 백엔드 관리 작업을 수행하는 방법에 대해 알아보십시오.</block>
  <block id="748a22b5f1312291ad55429ba4b809a0" category="doc">tridentctl을 사용하여 백엔드 관리를 수행합니다</block>
  <block id="aeeb03235358f0f4bf3be628bed08721" category="section-title">백엔드를 생성합니다</block>
  <block id="34746f7a1d24170eeebf5510a045d43d" category="inline-link-macro">백엔드 구성 파일</block>
  <block id="99b7232073a67a8c82304f979e3dc83f" category="paragraph">을 만든 후 <block ref="03c0b6ed8698193668e92f56e9be3efa" category="inline-link-macro-rx"></block>에서 다음 명령을 실행합니다.</block>
  <block id="1cabe44c722167581b1e219de6c58341" category="paragraph">백엔드 생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="b5f9999463782f0c36ecc89573a90a49" category="paragraph">구성 파일의 문제를 확인하고 수정한 후에는 간단히 'create' 명령을 다시 실행할 수 있습니다.</block>
  <block id="634b471e6af84767e06324552492b533" category="section-title">백엔드를 삭제합니다</block>
  <block id="412228c370a388e25ee06e8ad7a1da3f" category="paragraph">Astra Trident에서 백엔드를 삭제하려면 다음을 수행합니다.</block>
  <block id="f6816a6570e6b6097177f9adc1f4805b" category="list-text">백엔드 이름 검색:</block>
  <block id="11f4ccb46eb9afc4b1187c376b53123f" category="list-text">백엔드를 삭제합니다.</block>
  <block id="c87f53b53d179c2b5dcd5fad1efba831" category="admonition">Astra Trident가 백엔드에서 여전히 존재하는 볼륨 및 스냅샷을 프로비저닝한 경우 백엔드를 삭제하면 새 볼륨이 백엔드에서 프로비저닝되지 않습니다. 백엔드는 계속해서 "삭제" 상태에 있으며, Trident는 삭제될 때까지 해당 볼륨 및 스냅샷을 계속 관리합니다.</block>
  <block id="d694c8966214ec6d0068c0ab2951b65c" category="section-title">기존 백엔드를 봅니다</block>
  <block id="a6345aca446812b9124c47b385b33f43" category="paragraph">Trident가 알고 있는 백엔드를 보려면 다음을 실행합니다.</block>
  <block id="cb325bc4dded2aa4744b594966262a99" category="list-text">요약을 보려면 다음 명령을 실행합니다.</block>
  <block id="9f073deeee70a1418443c3b8379c5c02" category="list-text">모든 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="93dbcf0189ff94d39230d2e3726969ab" category="section-title">백엔드를 업데이트합니다</block>
  <block id="27709162cf6b8ffced7bb1da6dd49df3" category="paragraph">새 백엔드 구성 파일을 생성한 후 다음 명령을 실행합니다.</block>
  <block id="4ca005817e9c882d0ef15d451a97dbf0" category="paragraph">백엔드 업데이트에 실패하면 백엔드 구성에 문제가 있거나 잘못된 업데이트를 시도했습니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="20b5ebaa2558437206eb6d1d47577805" category="paragraph">구성 파일의 문제를 확인하고 수정한 후에는 간단히 'update' 명령을 다시 실행할 수 있습니다.</block>
  <block id="d47f84a3cda326babf841866ad2326ab" category="section-title">백엔드를 사용하는 스토리지 클래스를 식별합니다</block>
  <block id="02fe9d429af25b46c16a1172d735124f" category="paragraph">이것은 JSON으로 백엔드 객체에 대해 tridentctl이 출력하는 질문의 예입니다. 이 유틸리티는 설치해야 하는 JQ 유틸리티를 사용합니다.</block>
  <block id="e00013adda7b5901ea3e44ae300fd73d" category="paragraph">이는 ' 재젠백엔드구성'을 사용하여 만든 백엔드에도 적용됩니다.</block>
  <block id="15b7c7ffe264d7b8c61915ff2a6ef96c" category="section-title">백엔드 구성 옵션</block>
  <block id="9d370350f8d0178b5dfbec9def10d13a" category="paragraph">백엔드 구성 옵션은 다음 표를 참조하십시오.</block>
  <block id="7877022c956918624cc0373ff564cad4" category="cell">'내전'</block>
  <block id="40e27006e7b709772172391a3d17b331" category="cell">항상 1</block>
  <block id="868dff7060d78b6417dc8e065eca8374" category="cell">'torageDriverName'입니다</block>
  <block id="5aae2c40b50d296edbd4ba9cfb462b49" category="cell">스토리지 드라이버의 이름입니다</block>
  <block id="f5b55596d3f53b1857a4980dac9db979" category="cell">백엔드이름</block>
  <block id="5afd6479855e8d63f324b6ec2fa787b4" category="cell">사용자 지정 이름 또는 스토리지 백엔드</block>
  <block id="f476273c71e20fc5a845a5345a620117" category="cell">드라이버 이름 + "_" + API 키의 일부</block>
  <block id="2086191016950a784040f7d22ab27f60" category="cell">아피지역</block>
  <block id="a34d72a685d5e27eb6bc18f54a7bab1d" category="cell">아피키</block>
  <block id="af18429250667f805769a7755a008c1f" category="cell">proxyURL</block>
  <block id="2b45af5c768d7b2495ef631c991ecd78" category="cell">nfsMountOptions를 선택합니다</block>
  <block id="b9cc8276829a756e7a22476617204267" category="cell">NFS 마운트 옵션에 대한 세밀한 제어</block>
  <block id="2d1474e8b52ef42851337fb3fef4e1a1" category="cell">"nfsvers=3"</block>
  <block id="91590ee78f1b4751284f4f9ea80cfe86" category="cell">LimitVolumeSize</block>
  <block id="2288620b3dc019c6359bcc7f50b72ab3" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다</block>
  <block id="567c7f0eca746ed7513764be5ecf6d03" category="cell">""(기본적으로 적용되지 않음)</block>
  <block id="0322003a3502f221fdb74b059dfff46e" category="cell">'저급'</block>
  <block id="f2f2c7c3c767da610bd95934104674f6" category="cell">debugTraceFlags를 선택합니다</block>
  <block id="37a6259cc0c1dae299a7866489dff0bd" category="cell">null입니다</block>
  <block id="9c64942fe493cb70c474ff447429d8a4" category="cell">엑포트 규칙</block>
  <block id="1274e36c193ec0ce8b5c49d5e78ffd7b" category="cell">"0.0.0.0/0"</block>
  <block id="ce8f82152151ae2aadaec166eca744a9" category="cell">나프산디렉토리</block>
  <block id="c07fbc0b2a1a865fe9e3a55c05b4f690" category="cell">"거짓"</block>
  <block id="7556d5a1b0c5f68b7cb5aedaa3156008" category="cell">안산예비역</block>
  <block id="31ed61cc3c85d0bb697cd12b77f37fd1" category="cell">스냅숏용으로 예약된 볼륨의 백분율입니다</block>
  <block id="e76dcf1d6497658a2994b5f1f65b7a83" category="cell">""(CVS 기본값 0 허용)</block>
  <block id="a48a8458539e489328f4d6d3fc0ee288" category="cell">'크기'입니다</block>
  <block id="ef81b740be2293b7e3c41047afe98764" category="cell">"100G"</block>
  <block id="25f4894ddaab3c1182f12732d3bcf889" category="section-title">예 1: 최소 구성</block>
  <block id="3ad256eea0abb551eaab63c84aa3d1f9" category="paragraph">백엔드 구성 파일을 생성한 후 다음 명령을 실행합니다.</block>
  <block id="a61ed3c1ecae587dbee1f2c0ace81e3b" category="paragraph">백엔드 생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="8427b84145b88f048d5caa532324cd11" category="paragraph">구성 파일의 문제를 확인하고 수정한 후 create 명령을 다시 실행할 수 있습니다.</block>
  <block id="e4f61797b38c111b04c612b285a06659" category="summary">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="9bc537b16cee9c42d1e2aa0048a2c426" category="paragraph">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오. 모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="00b8b321c68facfb94b31690cbd23e00" category="paragraph">모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="c6cd2f38be30f5256f7116692ab56edd" category="paragraph">또한 둘 이상의 드라이버를 실행하고 둘 중 하나를 가리키는 스토리지 클래스를 생성할 수도 있습니다. 예를 들어, 'ONTAP-NAS' 드라이버와 'ONTAP-NAS-이코노미'을 사용하는 Bronze 클래스를 사용하는 Gold 클래스를 구성할 수 있습니다.</block>
  <block id="07b434b23f63ca6490df33b213599320" category="section-title">NFS 엑스포트 정책을 관리합니다</block>
  <block id="9d66483f8378ffe30cde84e1b6dbf484" category="paragraph">Astra Trident는 NFS 엑스포트 정책을 사용하여 프로비저닝하는 볼륨에 대한 액세스를 제어합니다.</block>
  <block id="a297d9b7dbc393d5e8a5b3f98bcc9337" category="paragraph">Astra Trident는 엑스포트 정책을 사용할 때 다음 두 가지 옵션을 제공합니다.</block>
  <block id="0c87d42e666bbc299da2143379484281" category="list-text">Astra Trident는 엑스포트 정책 자체를 동적으로 관리할 수 있습니다. 이 운영 모드에서 스토리지 관리자는 허용할 수 있는 IP 주소를 나타내는 CIDR 블록 목록을 지정합니다. Astra Trident는 이러한 범위에 속하는 노드 IP를 엑스포트 정책에 자동으로 추가합니다. 또는 CIDR을 지정하지 않으면 노드에서 발견된 글로벌 범위의 유니캐스트 IP가 내보내기 정책에 추가됩니다.</block>
  <block id="e6add289c2b1cd5da45e00f3098b35de" category="list-text">스토리지 관리자는 엑스포트 정책을 생성하고 규칙을 수동으로 추가할 수 있습니다. Astra Trident는 구성에 다른 엑스포트 정책 이름을 지정하지 않는 한 기본 엑스포트 정책을 사용합니다.</block>
  <block id="4603f08ad837f4108ff2fe7665b0b1e3" category="section-title">엑스포트 정책을 동적으로 관리</block>
  <block id="8b78bee43bfa1617b12c311f0ad26e81" category="admonition">CSI Trident에만 내보내기 정책의 동적 관리를 사용할 수 있습니다. 작업자 노드가 NATED가 아닌지 확인하는 것이 중요합니다.</block>
  <block id="44568b7468885ca198a66bb088b9e3b5" category="paragraph">두 가지 구성 옵션을 사용해야 합니다. 다음은 백엔드 정의의 예입니다.</block>
  <block id="4975fc485ff51ca8f82c6ea96f927287" category="paragraph">다음은 위의 예를 사용하여 이 기능이 작동하는 방식에 대한 설명입니다.</block>
  <block id="acdca8a11423c4bc209db0a1a4909294" category="list-text">자동내보내기정책은 참으로 설정된다. 이는 Astra Trident가 'vm1' SVM에 대한 수출 정책을 만들고 'autoExportCIDR' 주소 블록을 사용하여 규칙 추가 및 삭제를 처리한다는 것을 의미합니다. 예를 들어 UUID 403b5326-8482-40dB-96d0-d83fb3f4daec 및 "true"로 설정된 autoExportPolicy가 있는 백엔드는 SVM에 trident-403b5326-8482-40db-96d0-d83fb3f4daec라는 이름의 엑스포트 정책을 생성합니다.</block>
  <block id="1bdcc9b4be16b7ad2f1b54c892491a43" category="list-text">autoExportCIDR에는 주소 블록 목록이 포함되어 있습니다. 이 필드는 선택 사항이며 기본적으로 ["0.0.0.0/0", ":/0"]입니다. 정의되지 않은 경우 Astra Trident는 작업자 노드에 있는 모든 전역 범위의 유니캐스트 주소를 추가합니다.</block>
  <block id="96d8905e0d42a0d3573c71fd4ecce0b8" category="paragraph">이 예에서는 192.168.0.0/24 주소 공간을 제공한다. 이 주소 범위에 속하는 Kubernetes 노드 IP가 Astra Trident가 생성하는 엑스포트 정책에 추가됨을 나타냅니다. Astra Trident가 실행 중인 노드를 등록하면 해당 노드의 IP 주소를 조회하여 autoExportCIDR에서 제공하는 주소 블록과 대조합니다. IP를 필터링한 후 Astra Trident는 검색된 클라이언트 IP에 대한 엑스포트 정책 규칙을 생성하며, 식별하는 각 노드에 대해 하나의 규칙을 사용합니다.</block>
  <block id="4646f167a1fb9819f41f28d5ab11c1fa" category="paragraph">백엔드를 생성한 후 백엔드에 대한 자동 내보내기 정책 및 자동 내보내기 CIDR을 업데이트할 수 있습니다. 기존 CIDR을 자동으로 관리하거나 삭제하는 백엔드에 새 CIDR을 추가할 수 있습니다. CIDR을 삭제할 때는 기존 연결이 끊어지지 않도록 주의해야 합니다. 백엔드에 대해 'autoExportPolicy'를 사용하지 않도록 설정하고 수동으로 생성된 내보내기 정책으로 돌아갈 수도 있습니다. 이렇게 하려면 백엔드 구성에서 'exportPolicy' 매개 변수를 설정해야 합니다.</block>
  <block id="18deff64a140a603bdb6070abed4eed4" category="paragraph">Astra Trident가 백엔드를 생성하거나 업데이트한 후 'tridentctl' 또는 해당 'tridentbackend' CRD:</block>
  <block id="83af513d9b9d50c1dc648bfea29797cb" category="paragraph">노드가 Kubernetes 클러스터에 추가되고 Astra Trident 컨트롤러에 등록되면 기존 백엔드의 내보내기 정책이 업데이트됩니다(백엔드의 "autoExportCIDR"에 지정된 주소 범위에 속하는 경우).</block>
  <block id="fd85ad7b0ce4e83937cbc1012086b9b3" category="paragraph">노드가 제거되면 Astra Trident는 온라인 상태인 모든 백엔드를 검사하여 노드에 대한 액세스 규칙을 제거합니다. Astra Trident는 관리되는 백엔드의 내보내기 정책에서 이 노드 IP를 제거하여 불량 마운트를 방지합니다. 단, 클러스터의 새 노드에서 이 IP를 다시 사용하지 않는 한 마찬가지입니다.</block>
  <block id="cda5977f42a72ef440d3b6233b9970bf" category="paragraph">기존 백엔드의 경우 백엔드를 "tridentctl update backend"로 업데이트하면 Astra Trident가 자동으로 내보내기 정책을 관리합니다. 그러면 백엔드의 UUID 뒤에 이름이 지정된 새 내보내기 정책이 생성되고 백엔드에 있는 볼륨은 새로 생성된 내보내기 정책을 다시 마운트할 때 사용합니다.</block>
  <block id="de1d1f6b64a5c5b6890c313888b290b7" category="admonition">자동 관리되는 내보내기 정책이 있는 백엔드를 삭제하면 동적으로 생성된 내보내기 정책이 삭제됩니다. 백엔드가 다시 생성되면 백엔드가 새 백엔드로 처리되어 새 엑스포트 정책이 생성됩니다.</block>
  <block id="920708f6d71767dcff22f9e43b4ec0c0" category="paragraph">라이브 노드의 IP 주소가 업데이트되면 노드에서 Astra Trident POD를 다시 시작해야 합니다. 그런 다음 Astra Trident가 이 IP 변경 사항을 반영하도록 관리하는 백엔드에 대한 엑스포트 정책을 업데이트합니다.</block>
  <block id="b0cee72642f5457a71ddd0b49efb6d93" category="inline-link">Google Cloud용 Cloud Volumes Service</block>
  <block id="da195e41c537042ae77405110c4512ff" category="paragraph">를 구성하고 사용합니다<block ref="5129d3f1116e9c5221bfcf965a1ede35" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="2c00ff9c7700dc3529c57f0a5281bbe2" category="list-text">Google Cloud 계정의 프로젝트 번호입니다</block>
  <block id="43752d169c5729fffa3a6557a0978cb8" category="list-text">Google Cloud 서비스 계정에는 netcloudvolumes.admin 역할이 포함되어 있습니다</block>
  <block id="07cc9934740ba3dd46a0d7d2c9502d39" category="cell">"GCP-CV"</block>
  <block id="6eb82a822b962404b9694b93f2967679" category="cell">'원어클래스'</block>
  <block id="c96383270cbab23de47b4f0961f64929" category="cell">'프로젝트 번호'</block>
  <block id="4dd7128ceae058946c44bbbb0985ec6f" category="paragraph">각 백엔드는 단일 Google Cloud 지역에 볼륨을 프로비저닝합니다. 다른 영역에 볼륨을 생성하려면 추가 백엔드를 정의할 수 있습니다.</block>
  <block id="51b2015e6da8653f4041b71312ad43fe" category="cell">'.snapshot' 디렉토리에 액세스합니다</block>
  <block id="cf13ba16f33b5f6772614929649be6c2" category="summary">tridentctl import를 사용하여 기존 스토리지 볼륨을 Kubernetes PV로 가져올 수 있습니다.</block>
  <block id="5f48c343984786005c9830d96c6fca87" category="doc">볼륨 가져오기</block>
  <block id="3cf3b5626cbcac07ab0c5304e90870e8" category="section-title">볼륨 가져오기를 지원하는 드라이버입니다</block>
  <block id="be8c8810fd80d5e84acf47d57d4e0dbc" category="paragraph">이 표에는 볼륨 가져오기를 지원하는 드라이버와 볼륨 가져오기가 도입된 릴리스가 나와 있습니다.</block>
  <block id="b8e7b465df7c5979dc731d06e84ce2cf" category="cell">놓습니다</block>
  <block id="b7a56ff81a861dd454ce0ee6725a66c2" category="paragraph">19.04</block>
  <block id="cb4e2f5c0cf3e43444774c2af2ada914" category="section-title">볼륨을 가져와야 하는 이유는 무엇입니까?</block>
  <block id="b347f0936a6b1f232605f50447a930de" category="paragraph">Trident로 볼륨을 가져오는 데는 다음과 같은 몇 가지 사용 사례가 있습니다.</block>
  <block id="cbccddedba4ba9a336f83d60dd1454f0" category="list-text">응용 프로그램을 Containerizing 하고 기존 데이터 집합을 다시 사용합니다</block>
  <block id="f0dd3bee13b8c14005d98bfbb9a48bf3" category="list-text">수명이 짧은 애플리케이션에 대한 데이터 세트 클론 사용</block>
  <block id="97161389816216aabbaffd954ef4a1f4" category="list-text">오류가 발생한 Kubernetes 클러스터를 리빌드합니다</block>
  <block id="fd045b8743b2b7018e0480bc9a2dd4c5" category="list-text">재해 복구 중에 애플리케이션 데이터 마이그레이션</block>
  <block id="92f0642c89b416c59d914adfb1e33828" category="section-title">가져오기는 어떻게 작동합니까?</block>
  <block id="902881a0ede032887467576928b25fe0" category="paragraph">영구 볼륨 클레임(PVC) 파일은 볼륨 가져오기 프로세스에서 PVC를 생성하는 데 사용됩니다. 최소한 PVC 파일에는 다음 예제와 같이 이름, 네임스페이스, accessModes 및 storageClassName 필드가 포함되어야 합니다.</block>
  <block id="be25b6ff84fa0d015f05f46bbbb6abd1" category="paragraph">tridentctl 클라이언트는 기존 스토리지 볼륨을 가져오는 데 사용됩니다. Trident는 볼륨 메타데이터를 유지하고 PVC 및 PV를 생성하여 볼륨을 가져옵니다.</block>
  <block id="bcf64a12adc519c7d409f80e5cccbe24" category="paragraph">스토리지 볼륨을 가져오려면 볼륨을 포함하는 Astra Trident 백엔드의 이름과 스토리지에서 볼륨을 고유하게 식별하는 이름을 지정합니다(예: ONTAP FlexVol, Element Volume, CVS 볼륨 경로). 스토리지 볼륨은 읽기/쓰기 액세스를 허용해야 하며 지정된 Astra Trident 백엔드에서 액세스할 수 있어야 합니다. '-f' 문자열 인수가 필요하며 YAML 또는 JSON PVC 파일의 경로를 지정합니다.</block>
  <block id="021814b63472d2b6dab37ce7d62c3ea2" category="paragraph">Astra Trident가 볼륨 가져오기 요청을 받으면 기존 볼륨 크기를 결정하고 PVC에 설정합니다. 스토리지 드라이버에서 볼륨을 가져온 후 PV는 PVC에 대한 ClaimRef를 사용하여 생성됩니다. 부가세 반환 청구액 정책은 당초 PV에서 '유지'로 설정되어 있습니다. Kubernetes에서 PVC 및 PV를 성공적으로 바인딩하면 스토리지 클래스의 부가세 반환 청구액 정책에 맞게 부가세 반환 청구액 정책이 업데이트됩니다. Storage Class의 Reclaim 정책이 'Delete'인 경우, PV 삭제 시 스토리지 볼륨이 삭제된다.</block>
  <block id="9d0bcc94449080a9fef1873acd638fb3" category="paragraph">'--no-manage' 인수를 사용하여 볼륨을 가져올 때 Trident는 개체의 수명 주기 동안 PVC 또는 PV에 대한 추가 작업을 수행하지 않습니다. Trident는 `--no-manage' 객체의 PV 및 PVC 이벤트를 무시하므로 PV가 삭제되어도 스토리지 볼륨은 삭제되지 않습니다. 볼륨 클론 및 볼륨 크기 조정과 같은 다른 작업도 무시됩니다. 이 옵션은 컨테이너화된 워크로드에 Kubernetes를 사용하고, 그렇지 않고 Kubernetes 외부 스토리지 볼륨의 라이프사이클을 관리하려는 경우에 유용합니다.</block>
  <block id="76057e180d7b3edcebaa935c7ccab687" category="paragraph">PVC 및 PV에 주석이 추가되어 용적을 가져온 후 PVC와 PV가 관리되었는지 여부를 나타내는 두 가지 목적으로 사용됩니다. 이 주석은 수정하거나 제거할 수 없습니다.</block>
  <block id="b20cebeefba038b396f3fe0494dad01b" category="paragraph">Trident 19.07 이상 버전에서는 PVS 연결을 처리하고 볼륨을 가져오는 과정에서 볼륨을 마운트합니다. 이전 버전의 Astra Trident를 사용하여 가져오는 경우 데이터 경로에 작업이 없으며 볼륨 가져오기에서 볼륨을 마운트할 수 있는지 여부를 확인하지 않습니다. 볼륨 가져오기에서 오류가 발생한 경우(예: StorageClass가 올바르지 않은 경우) PV에 대한 부가세 반환 청구액 정책을 '유지'로 변경하고 PVC 및 PV를 삭제한 후 볼륨 가져오기 명령을 다시 시도하면 복구할 수 있습니다.</block>
  <block id="1b539ba5a07e124e582b2e4bfc489200" category="paragraph">ONTAP-NAS 드라이버로 생성된 각 볼륨은 ONTAP 클러스터의 FlexVol입니다. ONTAP-NAS 드라이버를 사용하여 FlexVol을 가져오는 작업은 동일합니다. ONTAP 클러스터에 이미 존재하는 FlexVol은 ONTAP-NAS PVC로 수입할 수 있다. 마찬가지로 FlexGroup vols는 ONTAP-NAS-Flexgroup PVC로 가져올 수 있습니다.</block>
  <block id="62a991a68d1e323e147c11deeaecdad2" category="admonition">ONTAP 볼륨을 Trident에서 가져오려면 RW 유형이어야 합니다. 볼륨이 DP 유형인 경우 SnapMirror 대상 볼륨이므로 볼륨을 Trident로 가져오기 전에 미러 관계를 끊어야 합니다.</block>
  <block id="b368a23170f18969c0c51a21bc3e2754" category="admonition">ONTAP-NAS 드라이버는 qtree를 가져오고 관리할 수 없습니다. ONTAP-NAS와 ONTAP-NAS-Flexgroup 드라이버는 중복 볼륨 이름을 허용하지 않습니다.</block>
  <block id="20a208be23a9e8a96ac28258acb9daa4" category="paragraph">예를 들어, 이름이 "ONTAP_NAS"인 백엔드에서 이름이 managed_volume"인 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="deba327c80a83b34abd4ba640b21e454" category="paragraph">Trident에서 관리하지 않을 'unmanaged_volume'('ONTAP_NAS 백엔드')이라는 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="9be12be7e9d5bb9faa5c9a952feafe07" category="paragraph">Trident는 '--no-manage' 인수를 사용할 때 볼륨의 이름을 바꾸거나 볼륨이 마운트되어 있는지 확인하지 않습니다. 볼륨이 수동으로 마운트되지 않은 경우 볼륨 가져오기 작업이 실패합니다.</block>
  <block id="4004cfbd69335a9d1ba9357ea0dfb079" category="admonition">사용자 지정 UnixPermissions를 사용하여 볼륨을 가져오는 기존 버그가 수정되었습니다. PVC 정의 또는 백엔드 구성에서 unixPermissions를 지정하고 Astra Trident에 볼륨을 가져오도록 지시할 수 있습니다.</block>
  <block id="d995f4307341e76349912869caa5e2fb" category="paragraph">Astra Trident는 단일 LUN이 포함된 ONTAP SAN FlexVol도 가져올 수 있습니다. 이는 FlexVol 내 각 PVC와 LUN에 대해 FlexVol를 생성하는 ONTAP-SAN 드라이버와 일치합니다. 다른 경우와 마찬가지로 'tridentctl import' 명령을 사용할 수 있습니다.</block>
  <block id="1dd2cc952267be6c2cc8e5cff2b5aab1" category="list-text">ONTAP-SAN 백엔드 이름을 포함합니다.</block>
  <block id="e395471eab1d4c8fbc8452e98a95d0c5" category="list-text">가져올 FlexVol의 이름을 입력합니다. 이 FlexVol에는 가져와야 하는 LUN이 하나만 포함되어 있습니다.</block>
  <block id="9e6bd670c6fd6b2808fae744834b7675" category="list-text">'-f' 플래그와 함께 사용해야 하는 PVC 정의 경로를 제공합니다.</block>
  <block id="36b577af0f959f68e5e66336695e816c" category="list-text">PVC 관리 또는 비관리형 중에서 선택합니다. 기본적으로 Trident는 PVC를 관리하고 백엔드에서 FlexVol 및 LUN의 이름을 바꿉니다. 관리되지 않는 볼륨으로 가져오려면 '--no-manage' 플래그를 전달합니다.</block>
  <block id="f898748ff73fc5faf70687cbb0051311" category="admonition">관리되지 않는 'ONTAP-SAN' 볼륨을 가져올 때는 FlexVol의 LUN이 'LUN0'으로 명명되고 원하는 이니시에이터가 있는 igroup에 매핑되어 있는지 확인해야 합니다. Astra Trident에서 관리되는 가져오기를 위해 이 작업을 자동으로 처리합니다.</block>
  <block id="66f7455d3b73d0f9938704ee67b1f38a" category="paragraph">그러면 Astra Trident가 FlexVol를 가져와 PVC 정의와 연결합니다. Astra Trident는 FlexVol의 이름을 PVC-&lt;uuid&gt; 형식으로 바꾸고 FlexVol 내의 LUN은 LUN0으로 바꿉니다.</block>
  <block id="2d37ad5bcf7d115e10de14a38db72232" category="admonition">기존 활성 연결이 없는 볼륨을 가져오는 것이 좋습니다. 사용 중인 볼륨을 가져오려는 경우 먼저 볼륨을 클론한 다음 가져오기를 수행합니다.</block>
  <block id="72b3664e6e381ccc62031c13f7ad6df9" category="paragraph">ONTAP_SAN_DEFAULT 백엔드에 존재하는 ONTAP-SAN-MANDATED FlexVol를 가져오려면 tridentctl import 명령을 다음과 같이 실행합니다.</block>
  <block id="26d61ca2331eea0b3aca6c534f2dfcc7" category="admonition">Astra Trident에서 가져오려면 ONTAP 볼륨이 RW 유형이어야 합니다. 볼륨이 DP 유형인 경우 SnapMirror 대상 볼륨이므로 볼륨을 Astra Trident로 가져오기 전에 미러 관계를 끊어야 합니다.</block>
  <block id="b00215e0583bb02c2474fa62f51462fa" category="paragraph">Trident를 사용하여 NetApp Element 소프트웨어/NetApp HCI 볼륨을 Kubernetes 클러스터로 가져올 수 있습니다. "tridentctl import" 명령의 인수로 Astra Trident 백엔드의 이름과 볼륨의 고유 이름 및 PVC 파일이 필요합니다.</block>
  <block id="c517a1b34541565def824e8e9aeb0524" category="admonition">Element 드라이버는 중복 볼륨 이름을 지원합니다. 중복된 볼륨 이름이 있는 경우 Trident의 볼륨 가져오기 프로세스에서 오류가 반환됩니다. 이 문제를 해결하려면 볼륨을 복제하여 고유한 볼륨 이름을 제공합니다. 그런 다음 복제된 볼륨을 가져옵니다.</block>
  <block id="87e30ad820e5b10036bd18284c1f25ad" category="admonition">볼륨 경로는 / 이후의 볼륨 내보내기 경로 부분입니다. 예를 들어, 내보내기 경로가 10.0.0.1:/adroit-jolly-swift인 경우 볼륨 경로는 매우 교묘한 -jolly-swift입니다.</block>
  <block id="e8945ce1398c6d24aa1d518bca08034c" category="paragraph">볼륨 경로 importvol1을 사용하여 백엔드에서 azurenetappfiles_40517이라는 Azure-NetApp-files 볼륨을 가져오려면 다음 명령을 실행합니다.</block>
  <block id="c3417eb755bee1658ae5b42ff2115193" category="admonition">ANF 볼륨의 볼륨 경로는 다음:/ 이후의 마운트 경로에 있습니다. 예를 들어, 마운트 경로가 10.0.0.2:/importvol1 인 경우 볼륨 경로는 importvol1 입니다.</block>
  <block id="2941c38dbb7c39c325787067c0540247" category="summary">kubbtl을 사용하여 백엔드 관리 작업을 수행하는 방법에 대해 알아보십시오.</block>
  <block id="bffb766af67c15f14cae35f03dd6f4a9" category="doc">kubeck을 사용하여 백엔드 관리 수행</block>
  <block id="20309eb77b701e6c49ca6b99a8f93f90" category="paragraph">'트리멘BackendConfig'를 삭제하면 Astra Trident가 백엔드 삭제/보존('정책' 기준)을 수행하도록 지시합니다. 백엔드를 삭제하려면 deletionPolicy가 delete로 설정되어 있는지 확인합니다. 트리젠백엔드구성만 삭제하려면, '정책'이 '유지'로 설정되어 있는지 확인하십시오. 이렇게 하면 백엔드가 계속 존재하고 'tridentctl'을 사용하여 관리할 수 있습니다.</block>
  <block id="3fa37f688874143cd423aabca8075ffb" category="paragraph">Astra Trident는 트리엔엔드구성에서 사용 중인 Kubernetes 비밀을 삭제하지 않습니다. Kubernetes 사용자는 기밀을 정해야 합니다. 비밀 정보를 삭제할 때는 주의해야 합니다. 암호는 백엔드에서 사용하지 않는 경우에만 삭제해야 합니다.</block>
  <block id="265ab4809f08d248e5045a8638ac7afa" category="paragraph">또한 'tridentctl get backend-n trident' 또는 'tridentctl get backend-o YAML-n trident'를 실행하여 존재하는 모든 백엔드 목록을 확인할 수 있습니다. 이 목록에는 tridentctl로 만든 백엔드 또한 포함됩니다.</block>
  <block id="93700a3ea9dc6d858638cd66cd2f2bfa" category="paragraph">백엔드를 업데이트해야 하는 이유는 여러 가지가 있을 수 있습니다.</block>
  <block id="56cdd71a65518838d73e00276ed6fab1" category="list-text">스토리지 시스템에 대한 자격 증명이 변경되었습니다. 자격 증명을 업데이트하려면 '트리펜엔드구성' 객체에 사용되는 Kubernetes Secret를 업데이트해야 합니다. Astra Trident가 자동으로 백엔드를 제공된 최신 자격 증명으로 업데이트합니다. 다음 명령을 실행하여 Kubernetes Secret를 업데이트하십시오.</block>
  <block id="6ef0ccb954a07e30d4ff894b5256ae30" category="list-text">매개 변수(예: 사용 중인 ONTAP SVM의 이름)를 업데이트해야 합니다. 이 경우 Kubernetes를 통해 '트리펜엔드구성' 객체를 직접 업데이트할 수 있습니다.</block>
  <block id="d4609cbe039ed7019e7151718c417bec" category="paragraph">또는 다음 명령을 실행하여 기존 '트리엔백엔드구성' CR을 변경합니다.</block>
  <block id="d38f034e9aa082af3ec19c23caff4b0f" category="paragraph">백엔드 업데이트에 실패하면 백엔드는 마지막으로 알려진 구성으로 계속 유지됩니다. 'kubtl get tbc&lt;tbc-name&gt;-o YAML-n trident' 또는 'kubtl t설명해 tbc&lt;tbc-name&gt;-n trident'를 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="5878b59fb3a8430928026b63b5ca336f" category="paragraph">구성 파일의 문제를 확인하고 수정한 후 update 명령을 다시 실행할 수 있습니다.</block>
  <block id="821b0ad941ad2559ef18eb8de56a470e" category="summary">Kubernetes 클러스터의 모든 작업자 노드는 Pod용으로 프로비저닝된 볼륨을 마운트할 수 있어야 합니다. 백엔드 중 하나에 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup 드라이버를 사용하는 경우 작업자 노드에 NFS 툴이 필요합니다. 그렇지 않으면 iSCSI 도구가 필요합니다.</block>
  <block id="89d83ec6e8ec0c087fbc4aedc555b362" category="doc">작업자 노드를 준비합니다</block>
  <block id="b7a66d04a41292979004906785008ca9" category="section-title">NFS 볼륨</block>
  <block id="696c660ff8d9323e55146a6dbd4e4088" category="cell">운영 체제</block>
  <block id="c441ee50c88f6e5e3a7c69fc69dad8b8" category="cell">명령</block>
  <block id="e0b19bed1baf46134f4079471e193b01" category="paragraph">'SUDO yum install -y nfs-utils'</block>
  <block id="1054b270f1635a3dd940e995cbc7ed78" category="paragraph">'UDO apt-get install-y nfs-common'을 선택합니다</block>
  <block id="29ba980a9e9adedc9414ea868c74ebd5" category="section-title">iSCSI 볼륨</block>
  <block id="12fe03bf2457cc4e4e90af10a2f7092f" category="list-text">Kubernetes 클러스터의 각 노드에는 고유한 IQN이 있어야 합니다. * 이것은 필수 전제 조건입니다 *.</block>
  <block id="0bad70dcf33f40dcc0d528d58b9eac76" category="inline-link">RedHat 설명서</block>
  <block id="8cd5b262d8d9950185128d052d55f7c8" category="list-text">다음 시스템 패키지를 설치합니다.</block>
  <block id="6bbf3284462dc8b9b90cb1adcd1c0ff4" category="paragraph">'SUDO yum install -y lsscsi iscsi -initiator-utils sg3_utils device-mapper-multipath'</block>
  <block id="1a5157a00ea5806f553766d5b3b114fd" category="list-text">iscsi-initiator-utils 버전이 6.2.0.874-2.el7 이상인지 확인합니다.</block>
  <block id="55c13faac514053f94cef55eb316c9a4" category="paragraph">rpm -q iscsi-initiator-utils</block>
  <block id="19955b3c2d2c1cfc1c82c2fe0347a065" category="list-text">스캔을 수동으로 설정합니다.</block>
  <block id="d2db641a196e6107eecf8c32f7cd7a4e" category="paragraph">'SUDO SED-I's/^\(node.session.scan\).*/\1 = manual/'/etc/iscsi/iscsid.conf'</block>
  <block id="d0b02d407fd5c75d0e7eac549a852191" category="list-text">다중 경로 설정:</block>
  <block id="8bec0eea71974a9138ccfa96983ddcfc" category="list-text">iscsid와 multipathd가 실행 중인지 확인합니다.</block>
  <block id="90a9d2e9b1b4ae58a957ff989f0732ba" category="paragraph">'SUDO systemctl enable -- now iscsid multipathd'</block>
  <block id="8018f5d6ddc4e67678d1659757828deb" category="list-text">"iSCSI" 활성화 및 시작:</block>
  <block id="0f905161e16c2cfa712f1fb7640afee4" category="paragraph">'SUDO systemctl enable -- now iscsi'</block>
  <block id="28ea88befb3a7f6a8e98e7ea7a4fd35f" category="paragraph">'SUDO apt-get install-y open-iscsi lsscsg3-utils multipath-tools scitools'</block>
  <block id="a53508e75911225e5de8b5febc82cf12" category="list-text">open-iscsi 버전이 2.0.874-5ubuntu2.10 이상(bionic) 또는 2.0.874-7.1uubuttu6.1 이상(focal)인지 확인합니다.</block>
  <block id="f6802be29c6bca93d8f44768b0347ac9" category="paragraph">d패키지-l open-iscsi</block>
  <block id="b163c84ad8a4e55a17b51aad8074093e" category="list-text">'open-iscsi'와 'multirpath-tools'가 활성화되어 실행되고 있는지 확인합니다.</block>
  <block id="8741473f7a80f4dd83071161b2c95301" category="paragraph">'SUDO systemctl status multipath -tools''SUDO systemctl enable -- now open-iscsi.service`'SUDO systemctl status open-iscsi'</block>
  <block id="1b757fe9c8a149de349a32b8d21feb54" category="admonition">Ubuntu 18.04의 경우 iSCSI 데몬이 시작되도록 "open-iscsi"를 시작하기 전에 iscsiadm"이 있는 타겟 포트를 검색해야 합니다. 또는 iSCSI 서비스를 수정하여 iscsid를 자동으로 시작할 수 있습니다.</block>
  <block id="28b0abcecaf7a63edb46e4e137337018" category="doc">Azure NetApp Files 백엔드를 구성합니다</block>
  <block id="07e7004c50a67a3e4e366b4ca1c28e3d" category="paragraph">를 구성하고 사용합니다<block ref="24a785881ff1cdf191a2239811dc9597" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="66d640a9a050b05e6a914cbcd88a1e2e" category="list-text">Azure NetApp Files가 활성화된 Azure 구독의 'SubscriptionID'입니다.</block>
  <block id="b12fb354025b3dfa01277964eb72c060" category="inline-link">앱 등록</block>
  <block id="f494e4df0fff53e809d6563f8ec1782f" category="inline-link">위임된 서브넷</block>
  <block id="3e566c45584d66d2ab94c2108f7c3488" category="cell">"Azure-NetApp-파일"</block>
  <block id="9dd18f393b35bf22098cf53e9c1c7fa6" category="cell">드라이버 이름 + "_" + 임의 문자</block>
  <block id="665120e71659a6a32f990a3181688d1b" category="cell">'스크립트 ID'입니다</block>
  <block id="b2ad290b003ccdce2a538f49a795f281" category="cell">Azure 구독의 구독 ID입니다</block>
  <block id="e07778d10cef90430253876cba7157e4" category="cell">텐antID</block>
  <block id="2975d48342e428a3b18123f85ed0ecb5" category="cell">앱 등록에서 테넌트 ID입니다</block>
  <block id="949ba1045db0d48bd189044e672d8097" category="cell">'클라이언트 ID'</block>
  <block id="2c07e9234f0df0d4c8887a04f7e641fe" category="cell">앱 등록의 클라이언트 ID입니다</block>
  <block id="56ef18e84ab36c2bdc4546e6a2756673" category="cell">'clientSecret</block>
  <block id="85f484f0892a96287b6224ddd3c5fbb2" category="cell">앱 등록에서 클라이언트 암호</block>
  <block id="fc7dd5b65d21ee7272a067c9404a8498" category="cell">위치</block>
  <block id="8fce436e09a08bd124727374d3e1d1d5" category="cell">새 볼륨을 생성할 Azure 위치의 이름입니다</block>
  <block id="1c65f12b4d30114593cc01384938cb5f" category="cell">'초표준', '프리미엄', '울트라' 중 하나</block>
  <block id="b21b08bb55acd409e40e9b45edd3bb34" category="cell">""(임의)</block>
  <block id="32ef1af5ccda7c2f6d85e55f5034f105" category="cell">가상네트워크</block>
  <block id="10afd0959cfa4a53bce9c8d395c40c48" category="cell">위임된 서브넷이 있는 가상 네트워크의 이름입니다</block>
  <block id="ec045173f4df65e5e8951c3ca9579945" category="cell">'우방'</block>
  <block id="0b8deda0ecc5080e8c0ed0b475e983ba" category="cell">Microsoft.Netapp/volumes` 에 위임된 서브넷의 이름입니다</block>
  <block id="a1fa27779242b4902f7ae3bdd5c6d508" category="cell">유형</block>
  <block id="e5ac299cc3b14e1fac29518569ca9bb1" category="cell">새 볼륨의 기본 크기입니다</block>
  <block id="ce46e8f3fc6eaddbe03115e0d62090ac" category="cell">유니크권한</block>
  <block id="e43b3577dd4b74a4cfa994a56e8138b8" category="paragraph">이 구성은 ANF를 사용하여 지금 막 시작하는 데 이상적이지만, 실제로 용량 할당을 수행하는 볼륨에 대한 추가적인 범위 지정을 제공하려는 경우에 적합합니다.</block>
  <block id="725ae241ec74eed978f0b099030236b8" category="section-title">예 3: 고급 구성</block>
  <block id="a83f4a534ccef7ac1d209fb0015cd907" category="paragraph">이 백엔드 구성은 단일 서브넷에 대한 볼륨 배치 범위를 더욱 줄여주고 일부 볼륨 프로비저닝 기본값도 수정합니다.</block>
  <block id="08c4bc4ac4edd9b12963c0596478d746" category="summary">Astra Trident는 CSI 토폴로지 기능을 사용하여 Kubernetes 클러스터에 있는 노드를 선택적으로 생성하고 연결할 수 있습니다.</block>
  <block id="3d4635d3cf4f27b0e87f3fe86a84744d" category="doc">CSI 토폴로지를 사용합니다</block>
  <block id="4abea6bac3b0b48d11dd8dcd02a11bf9" category="inline-link">CSI 토폴로지 기능</block>
  <block id="592af423a2f6a51f57c639ec7f7b245e" category="admonition">CSI 토폴로지 기능에 대해 자세히 알아보십시오<block ref="ff042e7f24bd2adcec09d78466034177" category="inline-link-rx"></block>.</block>
  <block id="bbdcaf9b704dc7a7cf73e6000101b65a" category="paragraph">Kubernetes는 두 가지 고유한 볼륨 바인딩 모드를 제공합니다.</block>
  <block id="93590d63acbb4fa6864a4665157fbcea" category="list-text">'VolumeBindingMode'를 'Immediate'로 설정하면 Astra Trident는 토폴로지 인식 없이 볼륨을 생성합니다. 볼륨 바인딩 및 동적 프로비저닝은 PVC가 생성될 때 처리됩니다. 이는 기본 'VolumeBindingMode'이며 토폴로지 제약 조건을 적용하지 않는 클러스터에 적합합니다. 영구 볼륨은 요청 포드의 예약 요구 사항에 의존하지 않고 생성됩니다.</block>
  <block id="5fca24470d51aa51b0fb2d0f27c25c68" category="list-text">VolumeBindingMode를 WaitForFirstConsumer로 설정하면 PVC를 사용하는 POD가 예약 및 생성될 때까지 PVC에 대한 영구 볼륨의 생성 및 바인딩이 지연됩니다. 이렇게 하면 토폴로지 요구 사항에 따라 적용되는 일정 제한을 충족하기 위해 볼륨이 생성됩니다.</block>
  <block id="3bbc2da928dcf77a048cdd745fe7d208" category="admonition">WaitForFirstConsumer의 바인딩 모드에는 토폴로지 레이블이 필요하지 않습니다. 이 기능은 CSI 토폴로지 기능과 독립적으로 사용할 수 있습니다.</block>
  <block id="edff21c44983aaa85506a3dfe467c494" category="paragraph">CSI 토폴로지를 사용하려면 다음이 필요합니다.</block>
  <block id="f9213d77978aabdafac36d2b0a184e56" category="list-text">클러스터의 노드에는 토폴로지 인식( topology.Kubernetes.io/region' 및 topology.Kubernetes.io/zone')을 소개하는 레이블이 있어야 합니다. Astra Trident가 토폴로지 인식을 위해 설치되기 전에 클러스터의 노드에 이러한 레이블 * 이 있어야 합니다.</block>
  <block id="0bd58c9826639ac2db106c3b277a7e0f" category="section-title">1단계: 토폴로지 인식 백엔드 생성</block>
  <block id="c7d3751a47274aaa616d77a14f2e2722" category="paragraph">Astra Trident 스토리지 백엔드는 가용성 영역에 따라 볼륨을 선택적으로 프로비저닝하도록 설계할 수 있습니다. 각 백엔드는 지원해야 하는 영역과 영역의 목록을 나타내는 선택적 'SupportedTopologies' 블록을 전달할 수 있습니다. 이러한 백엔드를 사용하는 StorageClasses의 경우 지원되는 영역/영역에서 예약된 애플리케이션에서 요청하는 경우에만 볼륨이 생성됩니다.</block>
  <block id="168d311a918475a654f296f89a7da983" category="paragraph">다음은 백엔드 정의의 예입니다.</block>
  <block id="3e778236fe8f94ccc453f52d827e3719" category="admonition">'SupportedTopologies'는 백엔드 당 지역 및 영역 목록을 제공하는 데 사용됩니다. 이러한 영역 및 영역은 StorageClass 에서 제공할 수 있는 허용 가능한 값의 목록을 나타냅니다. 백엔드에서 제공되는 지역 및 영역의 하위 집합이 포함된 StorageClasses의 경우 Astra Trident는 백엔드에 볼륨을 생성합니다.</block>
  <block id="217d95247b26701da7fd823884d84723" category="paragraph">스토리지 풀별로 'SupportedTopologies'를 정의할 수도 있습니다. 다음 예를 참조하십시오.</block>
  <block id="c6c80256ac468b3d88d7b62d8753f192" category="paragraph">이 예에서는 "reGion" 및 "zone" 레이블이 스토리지 풀의 위치를 나타냅니다. "topology.Kubernetes.io/region" 및 "topology.Kubernetes.io/zone"은 스토리지 풀을 사용할 수 있는 위치를 지정합니다.</block>
  <block id="54e204e8e05b6eb24d965741eb977e69" category="section-title">2단계: 토폴로지를 인식하는 StorageClasses를 정의합니다</block>
  <block id="090f70d385b4a21aa6c8f2a0ca558616" category="paragraph">클러스터의 노드에 제공되는 토폴로지 레이블을 기반으로 StorageClasses를 정의하여 토폴로지 정보를 포함할 수 있습니다. 이렇게 하면 PVC 요청에 대한 후보 역할을 하는 스토리지 풀과 Trident에서 제공하는 볼륨을 사용할 수 있는 노드의 하위 세트가 결정됩니다.</block>
  <block id="ecb383148a1bc974cba3ac735a79f4c6" category="paragraph">다음 예를 참조하십시오.</block>
  <block id="ab0c7ec9411ede93aa545fbc095c0e75" category="paragraph">위에서 제공한 StorageClass 정의에서 volumeBindingMode는 WaitForFirstConsumer로 설정됩니다. 이 StorageClass에 요청된 PVC는 POD에서 참조될 때까지 작동하지 않습니다. 그리고, “allowedTopologies”는 사용할 지역과 지역을 제공한다. NetApp-SAN-us-east1 StorageClass는 위에 정의된 'AN-BACKEND-Us-east1' 백엔드에서 PVC를 생성합니다.</block>
  <block id="df340fb31051c975afb3518dfd32e07c" category="section-title">3단계: PVC 생성 및 사용</block>
  <block id="f98be29d352e7c38a6502e76bbfaf34c" category="paragraph">StorageClass가 생성되어 백엔드에 매핑되면 PVC를 생성할 수 있습니다.</block>
  <block id="c4b17c8733f9f36fdc682242d2b64ab2" category="paragraph">아래의 '샘플'을 참조하십시오.</block>
  <block id="427e01a8fca484c85a1e8e3a672b999a" category="paragraph">이 매니페스트를 사용하여 PVC를 만들면 다음과 같은 결과가 발생합니다.</block>
  <block id="e65f170821e3417d48579a28989a9260" category="paragraph">Trident에서 볼륨을 생성하여 PVC에 바인딩하려면 POD에서 PVC를 사용합니다. 다음 예를 참조하십시오.</block>
  <block id="9b8ff27bceb4601d1f866c4cf39fe449" category="paragraph">이 podSpec은 us-east1 지역에 존재하는 노드에서 pPod를 예약하고 us-east1-a 또는 us-east1-b 영역에 있는 노드 중에서 선택하도록 지시합니다.</block>
  <block id="c93345596f9f82deea04d17ef8c6ca89" category="paragraph">다음 출력을 참조하십시오.</block>
  <block id="476950aea923438779c9544953093cb9" category="paragraph">기존 백엔드는 'tridentctl backend update'를 사용하여 'upportedTopologies' 목록을 포함하도록 업데이트할 수 있습니다. 이는 이미 프로비저닝된 체적에 영향을 주지 않으며 후속 PVC에만 사용됩니다.</block>
  <block id="ded10f93b9e4453980b7009035c63418" category="inline-link">컨테이너에 대한 리소스를 관리합니다</block>
  <block id="47ea3356a13b3f6644e6c05450e9d5e1" category="list-text"><block ref="47ea3356a13b3f6644e6c05450e9d5e1" category="inline-link-rx"></block></block>
  <block id="6370f866cf64618c026027da41bd248e" category="inline-link">노드 선택기</block>
  <block id="2a4ad9fc807789134426a1b2babc5733" category="list-text"><block ref="2a4ad9fc807789134426a1b2babc5733" category="inline-link-rx"></block></block>
  <block id="873bf2b9b61a741ce5b7326a3a053489" category="inline-link">친화성 및 반친화성</block>
  <block id="ec5df0a2adb621359563958138462e34" category="list-text"><block ref="ec5df0a2adb621359563958138462e34" category="inline-link-rx"></block></block>
  <block id="e1e08e40036f927a0e660c22aa837f88" category="inline-link">오염과 내약입니다</block>
  <block id="66b1e0aa9cd6e46c0b85fdf56a15154a" category="list-text"><block ref="66b1e0aa9cd6e46c0b85fdf56a15154a" category="inline-link-rx"></block></block>
  <block id="0cc7642bbaf969ea355ea12764841c91" category="summary">Astra Trident 설치를 통해 ONTAP NAS 드라이버를 생성하고 사용하는 방법에 대해 알아보십시오. 이 섹션에서는 백엔드 구성 예제 및 백엔드를 StorageClasses에 매핑하는 방법에 대한 세부 정보를 제공합니다.</block>
  <block id="19ce3b2e7823907e5153f00fe04f64f7" category="doc">구성 옵션 및 예</block>
  <block id="a85f55a18073767a4945eac810e72cb2" category="cell">"ONTAP-NAS", "ONTAP-NAS-이코노미", "ONTAP-NAS-Flexgroup", "ONTAP-SAN", "ONTAP-SAN-이코노미"</block>
  <block id="237d7a1666794b0937adde704bb4795c" category="cell">드라이버 이름 + “_” + dataLIF</block>
  <block id="07c54fe26be1e43601e99cd9d4fbe262" category="cell">마나멘타LIF</block>
  <block id="c560b8d02093547d93a87c72d8b16eaf" category="cell">“10.0.0.1”, “[2001:1234:ABCD::fee]”</block>
  <block id="bd81db53971fda3e688447b28c747d1a" category="cell">다타LIF</block>
  <block id="a0f3a965c12688befda99da850903dcb" category="cell">자동 내보내기 정책</block>
  <block id="b4ad0dff08149092bc3e4b16572af575" category="cell">자동 내보내기</block>
  <block id="e537a193eb90bd46a645ce750bb5f3fc" category="cell">["0.0.0.0/0", "::/0"]"</block>
  <block id="eea443d4fcc24d4cd2cab08c2a6c062f" category="cell">'라벨'</block>
  <block id="b5cbbe3dadaab4a036fdb38af67ee936" category="cell">볼륨에 적용할 임의의 JSON 형식 레이블 세트입니다</block>
  <block id="1d76382e861d2df96647216b26d38948" category="cell">“”</block>
  <block id="cbdaf784161be9806a24fe78a8046c01" category="cell">'고객증명서'</block>
  <block id="a84cbedc106b973917ae925d04533f97" category="cell">Base64 - 클라이언트 인증서의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="8545e54eea74cf2579fbe1cb56b11862" category="cell">'clientPrivateKey'입니다</block>
  <block id="4a54228eb2be79492f8f76bb814ddf63" category="cell">Base64 - 클라이언트 개인 키의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="b071cd8105f8f59b777098388b7a3322" category="cell">신탁인증서다</block>
  <block id="ffe4ce29fe1a6176d496c40332e9cb98" category="cell">Base64 - 신뢰할 수 있는 CA 인증서의 인코딩된 값입니다. 선택 사항. 인증서 기반 인증에 사용됩니다</block>
  <block id="6d77646a2fd9ab65f8e3344d7dce661a" category="cell">'사용자 이름'</block>
  <block id="83425e975af1b2d60355aa4162300198" category="cell">클러스터/SVM에 연결할 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다</block>
  <block id="6aa91a7fbb8c9edcf4aa5f9411aec19c" category="cell">"암호"</block>
  <block id="63d06d6cc41e485615f99a3aad0002b3" category="cell">클러스터/SVM에 연결하는 암호 자격 증명 기반 인증에 사용됩니다</block>
  <block id="afc423de2be5ca5ab3a6ae9548bbfcf3" category="cell">'VM'입니다</block>
  <block id="972abf48cbbadbcd573754140d35e19a" category="cell">사용할 스토리지 가상 머신입니다</block>
  <block id="ef65dd3301d78701f7cfcf8a01834f2f" category="cell">SVM 'managementLIF'가 지정된 경우에 파생됩니다</block>
  <block id="3b890f58db76bb3003ada171cd18c4db" category="cell">“인명이름”입니다</block>
  <block id="1c59f4b76e4f9bf529f88205cd0a8ac6" category="cell">“삼중 - &lt;backend-UUID&gt;”</block>
  <block id="c08068da3c5d19547544c4bd424a6b76" category="cell">'토르agePrefix'</block>
  <block id="e3f688f3aa653574b3253640aa98f47c" category="cell">SVM에서 새 볼륨을 프로비저닝할 때 사용되는 접두사 설정한 후에는 업데이트할 수 없습니다</block>
  <block id="a996d2f8e072c583d6cc26aa1e4aba87" category="cell">"삼중류"</block>
  <block id="12d2394af47293b12d6b5f411f99a6d1" category="cell">제한선태사용법</block>
  <block id="7962423206a6704e20fa94085d19b517" category="cell">“”(기본적으로 적용되지 않음)</block>
  <block id="9d96dfa28e7454a1119de523123a1e05" category="cell">“”(기본적으로 적용되지 않음)</block>
  <block id="c9a303edbc714d051896c3a678e59a8a" category="cell">'오만유연한'</block>
  <block id="79892588cbecd0b88729ea1a55b2a3a4" category="cell">FlexVol당 최대 LUN 수는 범위[50, 200]에 있어야 합니다.</block>
  <block id="2d782f413944b272c911c548418a18a3" category="cell">“100”</block>
  <block id="ae0784115c8f815d4a2ca170c59f3c99" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: {“api”:false, “method”:true}</block>
  <block id="07f6b23cad3d6da54012935ff972affe" category="cell">"케트리스퍼플랙스볼륨"</block>
  <block id="a13306f726fdf72d2d992a7ebdc63b1b" category="cell">FlexVol당 최대 qtree, 범위 [50, 300]에 있어야 함</block>
  <block id="28326357ec2f8c06e01271c4ee2201f1" category="cell">“200”</block>
  <block id="f703d18584e163e18762e4dc13ad96a0" category="cell">'useREST'</block>
  <block id="88dce60232453383ab0d1c3c59cc931d" category="admonition">문제 해결 및 자세한 로그 덤프가 필요한 경우가 아니면 debugTraceFlags를 사용하지 마십시오.</block>
  <block id="193a49bcfb561fea878daa5efe72cad9" category="section-title">볼륨 프로비저닝을 위한 백엔드 구성 옵션</block>
  <block id="a0ee23c5b4cbd6a28a4143933891f927" category="cell">'팩시배부</block>
  <block id="26161d08a960162cd8633d0e23058aed" category="cell">LUN에 대한 공간 할당</block>
  <block id="3be488c6a2bc52ceb7e8685ca24927d7" category="cell">"참"</block>
  <block id="a6bddf19eed00dbe2199864dee8454ce" category="cell">'예비공간'</block>
  <block id="3bce5b103341500856287f5347e19f28" category="cell">공간 예약 모드, "없음"(씬) 또는 "볼륨"(일반)</block>
  <block id="e84c56670c389b09fcad5da7309a165b" category="cell">"없음"</block>
  <block id="0ec3875cf79264e4689a646be2f704b6" category="cell">냅샷정책</block>
  <block id="77f69e470b8766d2dc5df4b7f469ed72" category="cell">사용할 스냅샷 정책입니다</block>
  <block id="84d2c2c768bd1900489bad5fb46b4aac" category="cell">"qosPolicy"</block>
  <block id="54b94bba5d336f4e3d5fd7e88544fad1" category="cell">생성된 볼륨에 할당할 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다</block>
  <block id="952e3a12d35e717bf86a6000b0c08976" category="cell">적응성 QosPolicy</block>
  <block id="11f9fcd55c1d81cf352f86fe4cdfd444" category="cell">스냅샷 "0"에 예약된 볼륨의 백분율</block>
  <block id="af6626456fa359992271ea88de34094f" category="cell">"스냅샷 정책"이 "없음"이면 "없음"</block>
  <block id="4be01095ce6e500084fc427e5dec61ac" category="cell">'plitOnClone'을 선택합니다</block>
  <block id="6f5c0c94b1a17baffd2c33facaa10db6" category="cell">생성 시 상위 클론에서 클론을 분할합니다</block>
  <block id="19b4c847405d74614976bd1228f59c9f" category="cell">"거짓"</block>
  <block id="b091cbafedf94db98f17823d044434bd" category="cell">암호화</block>
  <block id="a463baaf6666da7178b6fc6a3c8a3fee" category="cell">'생태성 스타일'을 참조하십시오</block>
  <block id="41da49bdd3fd88b2ddc6be7d6df1b335" category="cell">새로운 볼륨에 대한 보안 스타일</block>
  <block id="31aa018945eb62580d68d360cba8ba54" category="cell">'계층화 정책'</block>
  <block id="592a5879ac095ef6ca504cc43a9d7939" category="cell">"없음"을 사용하는 계층화 정책</block>
  <block id="ee6508d5290be6edafccc6e0f471f120" category="cell">ONTAP 9.5 이전 SVM-DR 구성의 경우 "스냅샷 전용</block>
  <block id="c005e78d4bd808038335c32dd84cf7da" category="cell">unixPermissions</block>
  <block id="3e9a232d025270ed6767c385b8291871" category="cell">모드를 선택합니다</block>
  <block id="2907de5eba980e910513008165ea2c2b" category="cell">'.snapshot' 디렉토리의 가시성을 제어합니다</block>
  <block id="647ce4e5394e2e595e46b4fc50a628e9" category="cell">내보내기 정책</block>
  <block id="c1a0e97f953c948568aed6c134fc9711" category="cell">사용할 엑스포트 정책</block>
  <block id="6522432847a0e6902318a976e5533f62" category="cell">“기본값”</block>
  <block id="99c2306b30b8939278f0f817230f3573" category="admonition">Astra Trident와 함께 QoS 정책 그룹을 사용하려면 ONTAP 9.8 이상이 필요합니다. 비공유 QoS 정책 그룹을 사용하고 정책 그룹이 각 구성요소별로 적용되었는지 확인하는 것이 좋습니다. 공유 QoS 정책 그룹은 모든 워크로드의 총 처리량에 대해 상한을 적용합니다.</block>
  <block id="05c4365fe7e90a545f8b24060094a36a" category="paragraph">다음은 기본값이 정의된 예입니다.</block>
  <block id="06602e99c8d46d601029e6dd0b37e3f8" category="paragraph">ONTAP-NAS와 ONTAP-NAS-Flexgroups의 경우, Astra Trident는 이제 새로운 계산을 통해 스냅샷 예비 공간 비율 및 PVC로 FlexVol의 크기를 올바르게 조정했습니다. 사용자가 PVC를 요청하면 Astra Trident는 새 계산을 사용하여 더 많은 공간을 가진 원본 FlexVol를 생성합니다. 이 계산을 통해 사용자는 PVC에서 요청한 쓰기 가능 공간을 확보할 수 있으며 요청된 공간보다 적은 공간을 확보할 수 있습니다. v21.07 이전에는 사용자가 스냅샷 보존 공간을 50%로 하여 PVC(예: 5GiB)를 요청할 때 쓰기 가능한 공간은 2.5GiB에 불과합니다. 이는 사용자가 요청한 전체 볼륨과 스냅샷 보존 비율이 다르기 때문입니다. Trident 21.07을 사용하면 쓰기 가능한 공간이 요청되고 Astra Trident는 '스냅샷 보존' 번호를 전체 볼륨의 백분율로 정의합니다. 이는 ONTAP-NAS-이코노미(ONTAP-NAS-이코노미)에는 적용되지 않습니다. 이 작동 방식을 보려면 다음 예를 참조하십시오.</block>
  <block id="86ec808b80973d24eadfc617926f534e" category="paragraph">계산은 다음과 같습니다.</block>
  <block id="28ad7be76b350116bde3ae04e5f94a60" category="paragraph">snapshotReserve = 50%, PVC request = 5GiB의 경우, 총 볼륨 크기는 2/.5 = 10GiB이고 사용 가능한 크기는 5GiB입니다. 이는 사용자가 PVC 요청에서 요청한 것입니다. 'volume show' 명령은 다음 예와 유사한 결과를 표시합니다.</block>
  <block id="2f1534ee8d0c6ec998511ed37cfe0da9" category="image-alt">에는 volume show 명령의 출력이 나와 있습니다.</block>
  <block id="daabb7db82ac9f3f074671a1185c462e" category="paragraph">이전 설치에서 기존 백엔드는 Astra Trident를 업그레이드할 때 위에서 설명한 대로 볼륨을 프로비저닝합니다. 업그레이드하기 전에 생성한 볼륨의 경우 변경 사항을 관찰하기 위해 볼륨의 크기를 조정해야 합니다. 예를 들어, '스냅샷 보존 = 50'의 2GiB PVC는 쓰기 가능한 공간 1GiB를 제공하는 볼륨을 낳았습니다. 예를 들어, 볼륨을 3GiB로 조정하면 애플리케이션에 6GiB 볼륨의 쓰기 가능 공간이 3GiB로 표시됩니다.</block>
  <block id="2aae2b6accd04335b3eeceb2193b34d6" category="section-title">최소 구성의 예</block>
  <block id="bca36ce39f61ce2d375cbdb66eab5162" category="paragraph">다음 예에서는 대부분의 매개 변수를 기본값으로 두는 기본 구성을 보여 줍니다. 이는 백엔드를 정의하는 가장 쉬운 방법입니다.</block>
  <block id="f35c0fe4b6581c16866c964cef229bfa" category="admonition">Trident가 있는 NetApp ONTAP에서 Amazon FSx를 사용하는 경우 IP 주소 대신 LIF에 대한 DNS 이름을 지정하는 것이 좋습니다.</block>
  <block id="78e5b29e139db71ceb7ca6bc99b5e228" category="paragraph">이는 최소 백엔드 구성의 예입니다. clientCertificate, clientPrivateKey, trustedCACertificate(신뢰할 수 있는 CA를 사용하는 경우 선택 사항)가 backend.json에 채워지고 클라이언트 인증서, 개인 키, 트러스트된 CA 인증서의 base64로 인코딩된 값을 각각 가져갑니다.</block>
  <block id="6a24af0a579ec0e851db9d35e047d58e" category="paragraph">이 예에서는 일부 스토리지 풀이 자체 'spaceReserve', 'spaceAllocation' 및 'encryption' 값을 설정하고 일부 풀은 위에 설정된 기본값을 덮어씁니다.</block>
  <block id="f00b69018be0961b32ee24ec54fb56d1" category="section-title">백엔드를 StorageClasses에 매핑합니다</block>
  <block id="87dc0337d3ded2211d9b01c32e22d90d" category="doc">백엔드 구성</block>
  <block id="2acbb5dd492d792d00383b0c76ade4ad" category="list-text"><block ref="2acbb5dd492d792d00383b0c76ade4ad" category="inline-link-macro-rx"></block></block>
  <block id="252e63ff646a0204671ca04a26b88e06" category="inline-link-macro">Google Cloud Platform 백엔드에 Cloud Volumes Service를 구성합니다</block>
  <block id="c00b6e370d4496e06d2135275a992af5" category="list-text"><block ref="c00b6e370d4496e06d2135275a992af5" category="inline-link-macro-rx"></block></block>
  <block id="f2733a323df72dea4b230205225bdc13" category="inline-link-macro">NetApp HCI 또는 SolidFire 백엔드를 구성합니다</block>
  <block id="b1064b6f7a5906eac23601dc24ba95a8" category="list-text"><block ref="b1064b6f7a5906eac23601dc24ba95a8" category="inline-link-macro-rx"></block></block>
  <block id="337de5d45c69b1e4dcf87a8e7ec9ff76" category="inline-link-macro">NetApp ONTAP용 Amazon FSx와 함께 Astra Trident를 사용하십시오</block>
  <block id="d7f015aa2f1d488e17e175dac6de3149" category="list-text"><block ref="d7f015aa2f1d488e17e175dac6de3149" category="inline-link-macro-rx"></block></block>
  <block id="24ca391029d6df294c5d5b8f1fe5b4eb" category="summary">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="6f95a39ae3c518928ed5e4681a0fd49b" category="doc">ONTAP NAS 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="ff342df7522d6b527768cc6bfe5f9fae" category="summary">Astra Trident를 사용하면 Kubernetes 사용자가 볼륨을 생성한 후 확장할 수 있습니다. iSCSI 및 NFS 볼륨을 확장하는 데 필요한 구성에 대한 정보를 찾습니다.</block>
  <block id="15d79b565b148caa23e6f2b53813413d" category="section-title">iSCSI 볼륨을 확장합니다</block>
  <block id="0b981ab19df55a28a02578aa5f326db8" category="paragraph">CSI 프로비저닝을 사용하여 iSCSI PV(Persistent Volume)를 확장할 수 있습니다.</block>
  <block id="f8f338469c62eb8604f5304af08466ba" category="admonition">iSCSI 볼륨 확장은 ONTAP-SAN, ONTAP-SAN-이코노미, Solidfire-SAN 드라이버로 지원되며 Kubernetes 1.16 이상이 필요합니다.</block>
  <block id="13311fb741bdb3b9d877937311a2d64d" category="paragraph">iSCSI PV를 확장하면 다음 단계가 포함됩니다.</block>
  <block id="5141e3596f63bc5db3fd9ee32b736127" category="list-text">StorageClass 정의를 편집하여 allowVolumeExpansion 필드를 true로 설정합니다.</block>
  <block id="9e7362e47322994c4d272d377e83f31b" category="list-text">PVC 정의 편집 및 'pec.resources.requests.storage'를 업데이트하여 원래 크기보다 큰 새로 원하는 크기를 반영한다.</block>
  <block id="0860a1b7122f04033fb722b29d878468" category="list-text">크기를 조절하려면 PV를 포드에 부착해야 합니다. iSCSI PV의 크기를 조정할 때 두 가지 시나리오가 있습니다.</block>
  <block id="7ac758b4597806f6880d9618fa093e52" category="list-text">PV가 포드에 연결된 경우 Astra Trident는 스토리지 백엔드의 볼륨을 확장하고 디바이스를 다시 검사하며 파일 시스템의 크기를 조정합니다.</block>
  <block id="7efffb2478ff651b7e45343b4e9f6fa8" category="list-text">연결되지 않은 PV의 크기를 조정하려고 하면 Astra Trident가 스토리지 백엔드의 볼륨을 확장합니다. PVC가 POD에 바인딩되면 Trident가 디바이스를 다시 검사해 파일 시스템의 크기를 조정합니다. 그런 다음 확장 작업이 성공적으로 완료된 후 Kubernetes에서 PVC 크기를 업데이트합니다.</block>
  <block id="ec3e34c26eaf059dc3ac58d8efc9fa37" category="paragraph">아래 예에서는 iSCSI PVS의 확장 작동 방식을 보여 줍니다.</block>
  <block id="fe9ee1935ea7894fe4fd2f600993cd7d" category="section-title">1단계: 볼륨 확장을 지원하도록 StorageClass를 구성합니다</block>
  <block id="c83b8171dcc233263cf7eeaef8da6a4d" category="paragraph">이미 존재하는 StorageClass의 경우 allowVolumeExpansion 매개변수를 포함하도록 편집합니다.</block>
  <block id="59973fd7be015512b53fe121a13d5580" category="section-title">2단계: 생성한 StorageClass를 사용하여 PVC를 생성합니다</block>
  <block id="8592e7b08d26d1aa2ef3c44409c736fa" category="paragraph">Astra Trident가 PV(Persistent Volume)를 생성하여 이 PVC(Persistent Volume Claim)와 연결합니다.</block>
  <block id="8dacc1d7fdb5bfd3f8a4daedf3ccdd88" category="section-title">3단계: PVC를 부착하는 POD를 정의합니다</block>
  <block id="85f5dec267aa48cff82ccaf993019e6d" category="paragraph">이 예제에서는 'AN-PVC'를 사용하는 POD가 생성됩니다.</block>
  <block id="ebae1958b6002fb43077a474d845284c" category="section-title">4단계: PV를 확장합니다</block>
  <block id="63188b171689bcd93b1ca818b3a2ab9c" category="paragraph">1Gi 에서 2Gi 로 생성된 PV 의 크기를 조정하려면 PVC 정의를 편집하여 'pec.resources.requests.storage'를 2Gi 로 업데이트합니다.</block>
  <block id="eabf614ed44fe1c3e78cb2300949eb63" category="section-title">5단계: 확장 확인</block>
  <block id="28abbd693f528f04d0ff068b3013fcd6" category="paragraph">PVC, PV, Astra Trident 볼륨의 크기를 확인하여 확장이 제대로 작동하는지 확인할 수 있습니다.</block>
  <block id="75b8249751a8ea5869a0b5a8e465efc1" category="section-title">NFS 볼륨을 확장합니다</block>
  <block id="578f10bb7cad2abad1cbbcb9a9a732f9" category="paragraph">NFS PV의 크기를 조정하려면 먼저 관리자가 "allowVolumeExpansion" 필드를 "true"로 설정하여 볼륨 확장을 허용하도록 스토리지 클래스를 구성해야 합니다.</block>
  <block id="27b4a9ed8609e35526601aa8d8be1ab9" category="paragraph">이 옵션 없이 스토리지 클래스를 이미 생성한 경우 'kubeck edit storageclass'를 사용하여 기존 스토리지 클래스를 편집하여 볼륨을 확장할 수 있습니다.</block>
  <block id="784f78e647973a0dcfa11b7a028c7eae" category="paragraph">Astra Trident는 이 PVC에 대해 20MiB NFS PV를 생성해야 합니다.</block>
  <block id="3b16cea25bd4a9aaf5a9c3dcc13ea7eb" category="section-title">3단계: PV를 확장합니다</block>
  <block id="e5c2c0bfcfbe01e6174199aaff9616a5" category="paragraph">새로 만든 20MiB PV의 크기를 1GiB로 조정하려면 PVC를 편집하여 pec.resources.requests.storage를 1GB로 설정합니다.</block>
  <block id="4a59ce1bc63fd7e6333968fb4bbd9d45" category="section-title">4단계: 확장을 확인합니다</block>
  <block id="c70f05fed7c73e0be4a0b24c8532a87c" category="paragraph">PVC, PV, Astra Trident 볼륨의 크기를 확인하여 크기가 올바르게 작동하는지 확인할 수 있습니다.</block>
  <block id="18320b2a705a7bed37a6bc0af4aee093" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다</block>
  <block id="e59001176f4360988f5d774a8405b4b9" category="cell">엑포트정책</block>
  <block id="8b7b728c6a1e7accd6148646ba730e77" category="summary">Astra Trident에서 백엔드를 관리하는 다양한 방법에 대해 알아보십시오.</block>
  <block id="4342473e01edd2e1440b8b76076f4c9e" category="doc">백엔드 관리 옵션 간 이동</block>
  <block id="207aacc2f1990ce861bf20cfcd0ca067" category="paragraph">Astra Trident에서 백엔드를 관리하는 다양한 방법에 대해 알아보십시오. 트리젠백엔드구성이 도입됨에 따라 관리자는 이제 두 가지 방법으로 백엔드를 관리할 수 있게 되었습니다. 이 질문은 다음과 같습니다.</block>
  <block id="a7b407f571446f9f4a30f63e8160784a" category="list-text">tridentctl을 사용하여 만든 백엔드는 트리엔백엔드구성을 사용하여 관리할 수 있습니까?</block>
  <block id="3e1fc11d05c13404995af2b9fda64675" category="list-text">트리덴ctl을 사용하여 트리엔디Config를 사용하여 만든 백엔드를 관리할 수 있습니까?</block>
  <block id="d6da18e16f248df47ee8e5139ef0156a" category="paragraph">이 섹션에서는 'Tridentctl' 객체를 만들어 Kubernetes 인터페이스를 통해 직접 생성된 백엔드를 관리하는 데 필요한 단계에 대해 설명합니다.</block>
  <block id="bee2ae6068ad50344ddb325737434004" category="paragraph">이 내용은 다음 시나리오에 적용됩니다.</block>
  <block id="e9c4de6d076377511c2b6a8463898ef2" category="list-text">tridentctl로 만든 트리젠백엔드구성이 없는 기존 백엔드입니다.</block>
  <block id="8eed1f3ae09f008e2dbfb4280a0c137c" category="list-text">tridentctl로 만든 새 백엔드와 다른 트리젠BackendConfig 개체가 있습니다.</block>
  <block id="0507a4f0ac746171a414097e7f033dca" category="paragraph">두 시나리오 모두 Astra Trident가 볼륨을 예약하고 운영하면서 백엔드가 계속 존재할 것입니다. 관리자는 다음 두 가지 옵션 중 하나를 선택할 수 있습니다.</block>
  <block id="95328f21e7a6deb7bb94acb3866753a6" category="list-text">tridentctl을 사용하여 만든 백엔드를 관리하려면 계속 사용합니다.</block>
  <block id="82c1dd66573aab904c86b63e2d5486ad" category="list-text">tridentctl을 사용하여 만든 백엔드를 새 트리젠BackendConfig 개체에 바인딩합니다. 이를 통해 뒷골은 트리덴틀이 아니라 쿠벤틀로 관리된다는 뜻이다.</block>
  <block id="d12d5022b29f44c340ee55411970fe10" category="paragraph">kubbeck을 사용하여 기존 백엔드를 관리하려면 기존 백엔드에 바인딩되는 '트리젠백엔드구성'을 생성해야 합니다. 작동 방식에 대한 개요는 다음과 같습니다.</block>
  <block id="0637b40285532fa1b6c6a4548e63d2f4" category="list-text">Kubernetes 암호를 생성하십시오. 비밀에는 Astra Trident가 스토리지 클러스터/서비스와 통신하는 데 필요한 자격 증명이 포함되어 있습니다.</block>
  <block id="b863de09ccfaf2861ead350dd78a9933" category="list-text">'트리멘백엔드구성' 객체를 만듭니다. 스토리지 클러스터/서비스에 대한 자세한 내용과 이전 단계에서 생성한 암호를 참조하십시오. 동일한 구성 매개 변수(예: 'pec.backendName', 'pec.storagePrefix', 'pec.storageDriverName' 등)를 지정할 때는 주의해야 합니다. '현재 백엔드 이름'을 설정해야 합니다.</block>
  <block id="44411eb1f3a70196b442f0ed4bb62820" category="section-title">단계 0: 백엔드를 식별합니다</block>
  <block id="c400920d4e58cf882999474fbdf967d3" category="paragraph">기존 백엔드에 바인딩하는 '트리젠백엔드구성'을 생성하려면 백엔드의 구성을 확보해야 합니다. 이 예에서는 다음과 같은 JSON 정의를 사용하여 백엔드를 생성했다고 가정합니다.</block>
  <block id="2181a22b3daf7866094f9f0d79da87d0" category="paragraph">이 예에 표시된 것처럼 백엔드에 대한 자격 증명이 포함된 암호를 생성합니다.</block>
  <block id="276e25c1cf06c603ba2d133ae2e39dde" category="paragraph">다음 단계는 기존 ONTAP-NAS-백엔드에 자동으로 바인딩되는 '트리젠백엔드구성' CR을 생성하는 것입니다(예:). 다음 요구 사항이 충족되는지 확인합니다.</block>
  <block id="0cbfd18f16db9afdef577eeddd6a8bee" category="list-text">같은 백엔드 이름은 'sepec.backendName'에 정의되어 있습니다.</block>
  <block id="f261e4f2fe82344f35f04f9b3813e425" category="list-text">구성 매개 변수는 원래 백엔드와 동일합니다.</block>
  <block id="8f50f98a5b56105263e2f7ab18dc0686" category="list-text">자격 증명은 일반 텍스트가 아닌 Kubernetes Secret을 통해 제공됩니다.</block>
  <block id="05c8cd2e49ae2ecaee101c9bc5619d49" category="paragraph">이 경우 트리젠백엔드구성은 다음과 같습니다.</block>
  <block id="63d6f3ce15066b6232a788bb692bf721" category="paragraph">트리젠백엔드구성이 만들어지면 그 단계는 반드시 '바운드'되어야 한다. 또한 기존 백엔드의 백엔드 이름과 UUID도 동일하게 반영되어야 합니다.</block>
  <block id="d1a75f7c76623350486029378ab164c3" category="paragraph">이제 백엔드는 'tbc-ONTAP-nas-backend' 트리펜엔드구성 객체를 사용하여 완벽하게 관리됩니다.</block>
  <block id="fcea92f3e948217919ca8b4051c2c61e" category="paragraph">트리덴ctl은 트리엔백구성(TrientBackendConfig)을 사용하여 만든 백엔드를 나열하는 데 사용할 수 있습니다. 또한 관리자는 트리텐틀Config를 삭제하고 pec.deletionPolicy` 가 "Stain"으로 설정되어 있는지 확인하여 tridentctl을 통해 이러한 백엔드를 완벽하게 관리할 수도 있습니다.</block>
  <block id="ab0c73d8e0377b2df5b783d3a76f2249" category="paragraph">예를 들어, 다음 백엔드가 ``트리엔백구성”을 사용하여 생성되었다고 가정해 보겠습니다.</block>
  <block id="9874d325a018b14fb52adf25f612579e" category="paragraph">출력으로부터 '(트리젠백엔드구성) '이(가) 성공적으로 생성되었으며 백엔드에 바인딩되어 있습니다 [백엔드의 UUID 확인].</block>
  <block id="ea64db0654e81907c68ffc52d023c3c7" category="paragraph">정책이라는 가치를 한번 살펴보자. 이를 보철로 설정해야 합니다. 이렇게 하면 ' TrientBackendConfig ' CR을 삭제할 때 백엔드 정의가 계속 존재하고 'tridentctl'을 사용하여 관리할 수 있습니다.</block>
  <block id="1ad97e0f65ef91102831baaa31630c76" category="admonition">'정책'이 '유지'로 설정되어 있지 않으면 다음 단계로 진행하지 마십시오.</block>
  <block id="8313f77478cb0df464604ae4435acce2" category="paragraph">마지막 단계는 트리엔디Config CR을 삭제하는 것이다. '정책'이 '유지'로 설정되어 있는지 확인한 후 삭제를 계속 수행할 수 있습니다.</block>
  <block id="c1493b6d6e05639a816e5772bbb491af" category="paragraph">트리젠벤트Config 객체를 삭제하면 Astra Trident는 백엔드 자체를 삭제하지 않고 간단히 해당 객체를 제거합니다.</block>
  <block id="99c7791f20f0d41bd8f14c11e666a405" category="summary">NetApp ONTAP용 Amazon FSx와 Astra Trident를 사용하면 Amazon Elastic Kubernetes Service(EKS)에서 실행되는 Kubernetes 클러스터에서 ONTAP가 지원하는 블록 및 파일 영구 볼륨을 프로비저닝할 수 있습니다.</block>
  <block id="7eb620c879218a348ba0e9afaedf6b01" category="paragraph">파일 시스템은 Amazon FSx의 주요 리소스이며, 이는 사내 ONTAP 클러스터와 유사합니다. 각 SVM 내에서 파일 시스템에 파일과 폴더를 저장하는 데이터 컨테이너인 하나 이상의 볼륨을 생성할 수 있습니다. NetApp ONTAP용 Amazon FSx를 사용하면 클라우드에서 Data ONTAP가 관리형 파일 시스템으로 제공됩니다. 새로운 파일 시스템 유형을 * NetApp ONTAP * 라고 합니다.</block>
  <block id="ff27e75635c1ff1e88fbc656b16e56ce" category="section-title">Astra Trident에 대해 자세히 알아보십시오</block>
  <block id="483a5da192f46e3cfe8391d3ef234fc4" category="inline-link-macro">FAQ 를 참조하십시오</block>
  <block id="486632f7d2196e772b742db4a4a0ad7c" category="inline-link-macro">Astra Trident 구축</block>
  <block id="55449fd175613962d882ab450cfc5f3c" category="inline-link">FabricPool</block>
  <block id="d07e2d99267e4fc3c508f6701be977b4" category="paragraph">NetApp ONTAP용 Amazon FSx에서 사용됩니다<block ref="d1584952da6bdedb0a24d5dbd43ce0bf" category="inline-link-rx"></block> 스토리지 계층을 관리합니다. 이 기능을 사용하면 데이터의 액세스 빈도 여부에 따라 데이터를 계층에 저장할 수 있습니다.</block>
  <block id="8e64a609e66214066595e6300aaab281" category="section-title">드라이버</block>
  <block id="79a4618bb191cb293c330f8189531a13" category="list-text">'ONTAP-SAN': 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨용 자체 Amazon FSx 내에 있는 LUN입니다.</block>
  <block id="b8f98ceeb9b158e8af3527fce91e9e57" category="list-text">'ONTAP-SAN-이코노미': 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨에 대해 Amazon FSx당 구성 가능한 LUN 수를 가진 LUN입니다.</block>
  <block id="a5bc2c9e7628ac6c73838f9fea0e6ed6" category="list-text">ONTAP-NAS: 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨용 전체 Amazon FSx입니다.</block>
  <block id="94a834f420b7c21f3a1053e6dc705a31" category="list-text">'ONTAP-NAS-E경제적인': 각 PV 프로비저닝은 qtree이며, NetApp ONTAP 볼륨에 대해 Amazon FSx당 qtree를 구성할 수 있습니다.</block>
  <block id="e42b07a9f050ef51ea1211004a50f223" category="list-text">'ONTAP-NAS-flexgroup': 프로비저닝되는 각 PV는 NetApp ONTAP FlexGroup 볼륨에 대한 전체 Amazon FSx입니다.</block>
  <block id="ed2536bee60113131cf25b2de3ec8734" category="list-text">인증서 기반: Astra Trident는 SVM에 설치된 인증서를 사용하여 FSx 파일 시스템의 SVM과 통신합니다.</block>
  <block id="80d13d3dbe137e8fb646193f275eceeb" category="list-text">kubbtl이 설치된 기존 Amazon EKS 클러스터 또는 자체 관리 Kubernetes 클러스터</block>
  <block id="52d48fdd62aa109d7f163f0ef8a31b83" category="list-text">클러스터의 작업자 노드에서 연결할 수 있는 NetApp ONTAP 파일 시스템용 기존 Amazon FSx 및 SVM(스토리지 가상 시스템)입니다.</block>
  <block id="fe914214000491758957f04647f8da36" category="inline-link">Amazon Machine Images(아마존 머신 이미지)</block>
  <block id="3e25473814d436a2ebac91120e147b0b" category="admonition">파일 시스템에 연결할 수 있는 모든 위치에서 SSH를 사용하여 파일 시스템(예: 인증서 설치)에 로그인할 수 있습니다. 파일 시스템 생성 시 구성한 fsxadmin 사용자, AWS FSX 기술파일 시스템"의 관리 DNS 이름을 사용합니다.</block>
  <block id="860958fe641e0edbd80fe522c36d0560" category="list-text">아래 예에 표시된 대로 인증서와 관리 LIF의 DNS 이름을 사용하여 백엔드 파일을 생성합니다.</block>
  <block id="1584837635038d443115ce4eeb3b33e4" category="paragraph">백엔드 만들기에 대한 자세한 내용은 다음 링크를 참조하십시오.</block>
  <block id="31e8c05beab321d1465fc4c3f77e991a" category="inline-link-macro">ONTAP SAN 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="d11f02b39cdb338286053b2f1315c6b4" category="inline-link-macro">스토리지 클래스, 볼륨 프로비저닝 및 POD에 볼륨 마운트</block>
  <block id="cc788b7e72b2a734dd0985bd1e0e9fe3" category="inline-link">NetApp ONTAP용 Amazon FSx 문서</block>
  <block id="fd570b75466e2daca21a032e6fd5981c" category="list-text"><block ref="fd570b75466e2daca21a032e6fd5981c" category="inline-link-rx"></block></block>
  <block id="0ef79cb4bb284d3ca9c3e95489919301" category="inline-link">NetApp ONTAP용 Amazon FSx 블로그 게시물</block>
  <block id="3b94214fe5975bca8da92b72f8926be2" category="list-text"><block ref="3b94214fe5975bca8da92b72f8926be2" category="inline-link-rx"></block></block>
  <block id="5f3124ab7224f89a36fbb64fd2ebda15" category="summary">Astra Trident 설치를 통해 ONTAP SAN 드라이버를 생성하고 사용하는 방법에 대해 알아보십시오. 이 섹션에서는 백엔드 구성 예제 및 백엔드를 StorageClasses에 매핑하는 방법에 대한 세부 정보를 제공합니다.</block>
  <block id="ab4ce1634362493e6de248d103136787" category="cell">'useCHAP'입니다</block>
  <block id="7c6b65d42434282f1555f13b40e9fd25" category="cell">챕터시크릿</block>
  <block id="c8a7a6136447a56280ecf99e3ed87d65" category="cell">CHAP 이니시에이터 암호입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="948938ec6491061ccf17c7ae8eafbd26" category="cell">챕터타겟이니터시크릿</block>
  <block id="48db71efc42dda989b98744160575f4f" category="cell">CHAP 타겟 이니시에이터 암호입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="28687fafefb2992ff7856dcfd2c29e1f" category="cell">'chapUsername'입니다</block>
  <block id="e3f84c141fd3f4682dfb31e0d71c7f5f" category="cell">인바운드 사용자 이름입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="62fbbf4cfd0cc0a82f953199d14a61e3" category="cell">'chapTargetUsername'입니다</block>
  <block id="a379a576b788ab047d5e6405ff4f3511" category="cell">대상 사용자 이름입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="73e65f4bf1c67cf81e3531ab80adee7e" category="paragraph">두 경우 모두 볼륨 첨부 파일에 계속 액세스할 수 있습니다. 향후 볼륨 첨부 파일은 업데이트된 igroup을 사용합니다. 이 업데이트는 백엔드에 있는 볼륨에 대한 액세스를 방해하지 않습니다.</block>
  <block id="036c0eabd455d8a92d350429f2f5747e" category="cell">생성된 볼륨에 할당할 적응형 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다</block>
  <block id="fab51d2bc90465982b0994bc86e69db9" category="admonition">'ONTAP-SAN' 드라이버를 사용하여 생성된 모든 볼륨의 경우, Astra Trident가 FlexVol에 10%의 용량을 추가하여 LUN 메타데이터를 수용합니다. LUN은 사용자가 PVC에서 요청하는 정확한 크기로 프로비저닝됩니다. Astra Trident가 FlexVol에 10%를 더합니다(ONTAP에서 사용 가능한 크기로 표시). 이제 사용자가 요청한 가용 용량을 얻을 수 있습니다. 또한 이 변경으로 인해 사용 가능한 공간이 완전히 활용되지 않는 한 LUN이 읽기 전용이 되는 것을 방지할 수 있습니다. ONTAP-SAN-경제에는 적용되지 않습니다.</block>
  <block id="824d88f50ab9e39778b0ef5bc2516b2f" category="paragraph">'스냅샷 보존'을 정의하는 백엔드의 경우 Astra Trident는 다음과 같이 볼륨의 크기를 계산합니다.</block>
  <block id="4e762198289d9294de9c1cbb3f0b26b6" category="paragraph">1.1은 LUN 메타데이터를 수용하도록 FlexVol에 추가된 10%의 Astra Trident입니다. 나프산예비공간 = 5%, PVC 요청 = 5GiB의 경우 총 용적 크기는 5.79GiB이고 사용 가능한 크기는 5.5GiB입니다. 'volume show' 명령은 다음 예와 유사한 결과를 표시합니다.</block>
  <block id="e6e049b4753c744e95db32b0eeed8d5c" category="paragraph">현재 기존 볼륨에 대해 새 계산을 사용하는 유일한 방법은 크기 조정입니다.</block>
  <block id="19fd94d2657fdd90c44f1fcd72890482" category="admonition">Astra Trident가 있는 NetApp ONTAP에서 Amazon FSx를 사용하는 경우 IP 주소 대신 LIF에 대한 DNS 이름을 지정하는 것이 좋습니다.</block>
  <block id="b0a5c44c844418c2a5474a0d4c19182c" category="paragraph">이는 최소 백엔드 구성의 예입니다. 이 기본 구성은 useCHAP가 true로 설정된 ONTAP-SAN 백엔드를 생성합니다.</block>
  <block id="22aec9ab9f9270747cb10c5bd593c1ab" category="paragraph">다음은 iSCSI의 예로, ONTAP-SAN-이코노미 드라이버를 들 수 있습니다.</block>
  <block id="c109878131f34375d85b7eff9721dcde" category="summary">Astra Trident 설치와 함께 Element 백엔드를 생성하고 사용하는 방법에 대해 알아보십시오.</block>
  <block id="d1d184cecc23825cff20fabf3cdfb862" category="list-text">Element 소프트웨어를 실행하는 지원되는 스토리지 시스템</block>
  <block id="4055116469942da7f6ed83abcf57d0a4" category="list-text">볼륨을 관리할 수 있는 NetApp HCI/SolidFire 클러스터 관리자 또는 테넌트 사용자에 대한 자격 증명</block>
  <block id="d5fa5f22855b065d96647dfb0c06d685" category="inline-link-macro">작업자 노드 준비 정보</block>
  <block id="c443982ebc2d61b1fdf8348209939f8b" category="paragraph">'솔드파이어-SAN' 스토리지 드라이버는 파일 및 블록의 볼륨 모드를 모두 지원합니다. 파일 시스템 볼륨 코드의 경우 Astra Trident가 볼륨을 생성하고 파일 시스템을 생성합니다. 파일 시스템 유형은 StorageClass에 의해 지정됩니다.</block>
  <block id="02017e70674a0c740b2b95fbb0cc2aa1" category="paragraph">파일 시스템이 없습니다. 원시 블록 장치.</block>
  <block id="e1f3ce04f7f587f86c154146eace2807" category="admonition">Astra Trident는 향상된 CSI Provisioner로 작동할 때 CHAP를 사용합니다. CHAP(CSI의 기본값)를 사용하는 경우 추가 준비가 필요하지 않습니다. 비 CSI Trident와 CHAP를 사용하려면 명시적으로 UseCHAP 옵션을 설정하는 것이 좋습니다. 그렇지 않으면 를 참조하십시오 <block ref="195a24f2e3cd9264b9f38d5f581c56cd" category="inline-link-macro-rx"></block>.</block>
  <block id="156ef6dbbdc5c1984194012f4d3505a5" category="admonition">볼륨 액세스 그룹은 Astra Trident의 기존 비 CSI 프레임워크에서만 지원됩니다. CSI 모드에서 작동하도록 구성된 경우 Astra Trident는 CHAP를 사용합니다.</block>
  <block id="03362d64938adda17736eff8a3b091cc" category="paragraph">AccessGroups나 UseCHAP가 설정되지 않은 경우 다음 규칙 중 하나가 적용됩니다.</block>
  <block id="44b5e5595eea45ebf8e49f88409afdaa" category="list-text">기본 '트리덴트' 액세스 그룹이 감지되면 액세스 그룹이 사용됩니다.</block>
  <block id="f3bf91f3dbbbaec039ad830cc87a1013" category="list-text">액세스 그룹이 감지되지 않고 Kubernetes 버전이 1.7 이상인 경우 CHAP가 사용됩니다.</block>
  <block id="2353a0a3a06283f07550efc7bad8a90e" category="cell">항상 "solidfire-san"</block>
  <block id="f4210b28f3cf7c1f7e6e328bb42c6060" category="cell">“SolidFire_” + 스토리지(iSCSI) IP 주소입니다</block>
  <block id="06981b2729b4b522b21d903c7738a2ca" category="cell">끝점</block>
  <block id="955f5caa2495689258902533d1a6cd44" category="cell">'VIP'</block>
  <block id="b07ca7de83de58a699966c9bc9003020" category="cell">스토리지(iSCSI) IP 주소 및 포트</block>
  <block id="749df53d02481e75dd919dddf42fbbef" category="cell">볼륨에 적용할 임의의 JSON 형식 레이블 세트입니다.</block>
  <block id="4e25fe4a614b527d9b3d89ee6abe5d35" category="cell">테난트이름</block>
  <block id="251f1fc42c38ca55f30e5e9d11dac168" category="cell">사용할 테넌트 이름(찾을 수 없는 경우 생성됨)</block>
  <block id="f016e2c01f2bafa45e6b537d49f0f9da" category="cell">이니토IFace</block>
  <block id="4381b3c378885de93e2166f240096338" category="cell">iSCSI 트래픽을 특정 호스트 인터페이스로 제한합니다</block>
  <block id="5ff567e0863a47346f44f87ed793f508" category="cell">'UseCHAP'입니다</block>
  <block id="d390e6782f0a0af41ea0397e46b5368e" category="cell">CHAP를 사용하여 iSCSI를 인증합니다</block>
  <block id="32738663b16444872e4e5721c7c37660" category="cell">"액세스 그룹"</block>
  <block id="c4ca01925aae0c37398f0b30a4ce1273" category="cell">사용할 액세스 그룹 ID 목록입니다</block>
  <block id="e64099a24f6ef8bbbdb23c2a803cd065" category="cell">"트리덴트"라는 액세스 그룹의 ID를 찾습니다.</block>
  <block id="26194deaf50c44db6eb5983237bdaf25" category="cell">'유형'</block>
  <block id="ee1aea1de97320ad8e98436f68b01b4a" category="cell">QoS 사양</block>
  <block id="3185240fb49cba19667fbdf639f3271e" category="paragraph">이 예에서는 CHAP 인증을 사용하는 백엔드 파일을 보여 주고 특정 QoS 보장을 포함하는 세 가지 볼륨 유형을 모델링합니다. 그런 다음 "IOPS" 스토리지 클래스 매개 변수를 사용하여 각 스토리지 클래스를 사용할 스토리지 클래스를 정의할 가능성이 높습니다.</block>
  <block id="4d0d37d727675761e4c0e324eb57ca2f" category="list-text"><block ref="4d0d37d727675761e4c0e324eb57ca2f" category="inline-link-macro-rx"></block></block>
  <block id="8682abd0ce083533bad141869c96ab2a" category="summary">Astra Trident는 볼륨을 관리하는 몇 가지 기능을 제공합니다. Astra Trident가 볼륨에 제공하는 기능에 대해 알아보십시오.</block>
  <block id="b42cbc6e68075c106b9faa27e4931091" category="doc">볼륨 작업을 수행합니다</block>
  <block id="eb487790322c4b8e9b4953d60be1acee" category="paragraph">볼륨 관리를 위한 Astra Trident의 기능에 대해 알아보십시오.</block>
  <block id="9e325272e7aed7c7bd6c28ff6fa4a90f" category="list-text"><block ref="9e325272e7aed7c7bd6c28ff6fa4a90f" category="inline-link-macro-rx"></block></block>
  <block id="c499fa59a1c9a0f6da195782a581f2e3" category="list-text"><block ref="c499fa59a1c9a0f6da195782a581f2e3" category="inline-link-macro-rx"></block></block>
  <block id="56661e701892ff873e44b62ffeec85e5" category="list-text"><block ref="56661e701892ff873e44b62ffeec85e5" category="inline-link-macro-rx"></block></block>
  <block id="c0417f5bbd54c5dc1c3704d6b566fcf3" category="list-text"><block ref="c0417f5bbd54c5dc1c3704d6b566fcf3" category="inline-link-macro-rx"></block></block>
  <block id="0f5dc79c8003190ab8f758b1748ba0d8" category="summary">NetApp은 제품과 서비스를 지속적으로 개선 및 개선하고 있습니다. 다음은 최신 버전의 Astra Trident에 포함된 최신 기능, 개선 사항 및 버그 수정 사항입니다.</block>
  <block id="5dd03e8d039863e563e049be198c3fd3" category="doc">릴리즈 노트</block>
  <block id="2e6ce374ac42de81aea6a3d682b92e33" category="paragraph">릴리즈 노트 최신 버전의 Astra Trident에 새로운 기능, 개선 사항 및 버그 수정 사항에 대한 정보를 제공합니다.</block>
  <block id="e4c4d344a524d21b898e4d04b6539aa7" category="admonition">설치 프로그램 zip 파일에 제공되는 Linux용 tridentctl 바이너리는 테스트되고 지원되는 버전입니다. zip 파일의 '/Extras' 부분에 제공된 'macos' 바이너리는 테스트되거나 지원되지 않습니다.</block>
  <block id="41cf959adc98386b54829d71a6ed5d37" category="section-title">수정</block>
  <block id="a6e7aa999ba654c6844672ae59f5137a" category="list-text">XFS 볼륨의 클론을 소스 볼륨과 동일한 노드에 마운트할 수 없는 문제(GitHub 문제 514)가 해결되었습니다.</block>
  <block id="4a921ae3eb8c2695dabd4044ff81141a" category="list-text">Astra Trident에서 종료 시 심각한 오류를 기록한 문제 해결(GitHub 문제 597)</block>
  <block id="852acc81ea6fa7363b73c5313002de83" category="list-text">Kubernetes 관련 수정 사항:</block>
  <block id="f94cc5159119c43751041256941deb2c" category="list-text">ONTAP-NAS와 ONTAP-NAS-Flexgroup 드라이버(GitHub 645호)를 사용하여 스냅샷을 생성할 때 볼륨의 사용된 공간을 최소 restoreSize로 반환합니다.</block>
  <block id="742ce2e3c9c8496323bd1176af2838a4" category="list-text">볼륨 크기 조정(GitHub 문제 560) 후 "파일 시스템 확장 실패" 오류가 기록된 문제 해결</block>
  <block id="9a445ecbad9af70a94bd7558ba95e059" category="list-text">포드가 종단 상태로 고착되는 문제 해결(GitHub 문제 572)</block>
  <block id="4f81c320a621b8c9d81c7334f2cffc71" category="list-text">ONTAP-SAN-E경제적인 FlexVol에 스냅샷 LUN이 포함될 수 있는 사례 해결(GitHub 문제 533)</block>
  <block id="169c3be63dd22b315ed7884e246338de" category="list-text">다른 이미지의 사용자 지정 YAML 설치 프로그램 문제 해결(GitHub 문제 613)</block>
  <block id="1077a1a91a96498c2f56bc630e632eee" category="list-text">스냅샷 크기 계산 수정(GitHub 문제 611)</block>
  <block id="fe705e5b02638736087c9fd97b2c4952" category="list-text">모든 Astra Trident 설치 관리자가 일반 Kubernetes를 OpenShift로 식별할 수 있는 문제 해결(GitHub 문제 639)</block>
  <block id="27b76ffa775f907a1fd51f21a669551b" category="list-text">Kubernetes API 서버에 연결할 수 없는 경우 조정을 중지하도록 Trident 연산자를 수정했습니다(GitHub 문제 599).</block>
  <block id="c1748037d10cffabb8e95e4ccf77c613" category="section-title">향상된 기능</block>
  <block id="1f9e922b6eff6cb06fca1ed9137eed38" category="list-text">GCP-CVS 성능 볼륨에 대한 "unixPermissions" 옵션에 대한 지원이 추가되었습니다.</block>
  <block id="294b850a76a040c20913e76c2fe6589a" category="list-text">600GiB~1TiB 범위의 GCP에서 확장성 최적화 CVS 볼륨 지원 추가</block>
  <block id="0333eb54465646b87754facff75fdb5f" category="list-text">Kubernetes 관련 개선사항:</block>
  <block id="c32aa411caa1ffd0e30a271f5be834d9" category="list-text">Kubernetes 1.22에 대한 지원이 추가되었습니다.</block>
  <block id="fa1fd8841173fa7ccde5059fb7c2f903" category="list-text">Trident 운영자 및 제어 차트를 Kubernetes 1.22(GitHub 문제 628)와 함께 사용할 수 있도록 했습니다.</block>
  <block id="dbaa551f190105e514f7816811f4b397" category="list-text">tridentctl 이미지 명령어(GitHub 문제 570)에 운용자 이미지 추가</block>
  <block id="be575f1ff204f2800114965a5c0d8575" category="section-title">실험적인 개선</block>
  <block id="29ddf941d9825cc9283521ee90468595" category="list-text">'ONTAP-SAN' 드라이버에 볼륨 복제 지원이 추가되었습니다.</block>
  <block id="e2f2b85987da5e2397c1e342a6fd9e28" category="list-text">ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-NAS-이코노미 드라이버에 대한 * 기술 미리보기 * REST 지원이 추가되었습니다.</block>
  <block id="95dc0391ce7b396d7dd5622284e8fc3e" category="section-title">알려진 문제</block>
  <block id="64a8f71bee95a6635e88bce00f1a2d3c" category="paragraph">알려진 문제점은 제품을 성공적으로 사용하지 못하게 만들 수 있는 문제를 식별합니다.</block>
  <block id="572b1d7e33a1c667884a1ffdff7a2d25" category="list-text">Astra Trident는 이제 StorageClass에 지정된 fsType 이 없는 볼륨에 대해 빈 fsType("fsType=""")을 적용합니다. Kubernetes 1.17 이상으로 작업할 때 Trident는 NFS 볼륨에 대한 빈 "fsType"을 제공할 수 있도록 지원합니다. iSCSI 볼륨의 경우 보안 컨텍스트를 사용하여 fsGroup을 적용할 때 StorageClass에 fsType을 설정해야 합니다.</block>
  <block id="91186d69835ccf9911e356f74938c539" category="list-text">여러 Astra Trident 인스턴스에서 백엔드를 사용할 경우 각 백엔드 구성 파일의 ONTAP 백엔드에 대해 서로 다른 'toragePrefix' 값을 사용하거나 SolidFire 백엔드에 다른 'TenantName'을 사용해야 합니다. Astra Trident는 Astra Trident의 다른 인스턴스가 생성한 볼륨을 감지할 수 없습니다. Astra Trident가 볼륨 생성을 idemptent 작업으로 처리하므로 ONTAP 또는 SolidFire 백엔드에서 기존 볼륨을 생성하려고 하면 성공합니다. 'toragePrefix' 또는 'TenantName'이 서로 다를 경우 같은 백엔드에서 생성된 볼륨의 이름 충돌이 있을 수 있습니다.</block>
  <block id="9bf4c601179068ff3574d2cf87536564" category="list-text">Astra Trident('tridentctl' 또는 Trident Operator 사용)를 설치하고 tridentctl을 사용하여 Astra Trident를 관리하는 경우 'KUBEBEECONFIG' 환경 변수를 설정해야 합니다. 이는 Kubernetes 클러스터가 트리덴트틀과 연동되어야 한다는 것을 나타내기 위해 필요합니다. 여러 Kubernetes 환경에서 작업할 경우 'KUBECONFIG' 파일을 정확하게 소싱해야 합니다.</block>
  <block id="6d791d3b45515fd8619e489b938f39e8" category="inline-link">마운트 옵션</block>
  <block id="a5c785ee36f0f2d14349653f744c8e3b" category="list-text">iSCSI PVS에 대해 온라인 공간 재확보를 수행하려면 작업자 노드의 기본 OS에 볼륨에 마운트 옵션을 전달해야 할 수 있습니다. 이는 디카드(disscard)가 필요한 RHEL/RedHat CoreOS 인스턴스에 적용됩니다<block ref="2ee633fb26bfccf07d490458d29f92a2" category="inline-link-rx"></block>에 mountmounted 폐기 옵션이 포함되어 있는지 확인합니다<block ref="b44436f062a8f5a535d8cafcffeb70b2" category="inline-link-rx"></block> 온라인 블록 삭제를 지원합니다.</block>
  <block id="c2ebda3702872aaa7ad44122f2343d7e" category="list-text">Kubernetes 클러스터당 Astra Trident 인스턴스가 두 개 이상 있는 경우, Astra Trident가 다른 인스턴스와 통신할 수 없고 자신이 생성한 다른 볼륨을 검색할 수 없기 때문에 클러스터 내에서 둘 이상의 인스턴스가 실행될 경우 예기치 않거나 잘못된 동작이 발생합니다. Kubernetes 클러스터당 하나의 Astra Trident 인스턴스만 있어야 합니다.</block>
  <block id="294f8c33b7ccdbcbf422998b64c9c931" category="list-text">Astra Trident가 오프라인인 상태에서 Astra Trident 기반의 'torageClass' 객체를 Kubernetes에서 삭제하면, Astra Trident는 온라인 상태가 되었을 때 데이터베이스에서 해당 스토리지 클래스를 제거하지 않습니다. tridentctl이나 REST API를 사용하여 이러한 스토리지 클래스를 삭제해야 합니다.</block>
  <block id="ddab3f1d971a7608afb4c30c688a32ac" category="list-text">사용자가 해당 PVC를 삭제하기 전에 Astra Trident가 프로비저닝한 PV를 삭제하는 경우 Astra Trident는 백업 볼륨을 자동으로 삭제하지 않습니다. 'tridentctl' 또는 REST API를 통해 볼륨을 제거해야 합니다.</block>
  <block id="0821431aba133adbfa7fa0ca1781eedd" category="list-text">FlexGroup은 애그리게이트 세트가 각 프로비저닝 요청에서 고유하지 않으면 한 번에 둘 이상의 ONTAP를 동시에 프로비저닝할 수 없습니다.</block>
  <block id="38699c45ccc629a8b46bd780d7aef2f6" category="list-text">IPv6를 통해 Astra Trident를 사용할 때는 대괄호 안의 백엔드 정의에 "managementLIF"와 "dataLIF"를 지정해야 합니다. 예: ``FD20:8b1e:b258:2000:f816:3eff:feec:0]'.</block>
  <block id="e9a7080bd6d1b50ff15cef6f14fa1d64" category="inline-link">Astra Trident GitHub를 참조하십시오</block>
  <block id="b94e036fb032554ca486dd8fc2e3fafe" category="list-text"><block ref="b94e036fb032554ca486dd8fc2e3fafe" category="inline-link-rx"></block></block>
  <block id="3334dfda9735f9b3ed55a34ef316b599" category="inline-link">Astra Trident 블로그</block>
  <block id="d090b5d97388b77aa02e5d1203c037a0" category="list-text"><block ref="d090b5d97388b77aa02e5d1203c037a0" category="inline-link-rx"></block></block>
  <block id="7d4fab76513c90b603a722620cde60fe" category="doc">명령줄 옵션</block>
  <block id="8db7df66ab1d7ab5f1dc947acdb5fae4" category="section-title">로깅</block>
  <block id="7e2a14542a2613424ad88206fd2dd9aa" category="list-text">'-debug': 디버깅 출력을 활성화합니다.</block>
  <block id="55e727716c7f623987be58e50732c01e" category="list-text">'-LogLevel &lt;level&gt;': 로깅 수준(debug, info, warn, error, fatal)을 설정한다. 기본적으로 info(정보) 가 사용됩니다.</block>
  <block id="30136395f01879792198317c11831ea4" category="section-title">쿠버네티스</block>
  <block id="5700f5ae190580b01f6ed6c031668336" category="list-text">'-k8s_pod': 이 옵션 또는 '-k8s_api_server'를 사용하여 Kubernetes를 지원합니다. 이 설정을 사용하면 Trident에서 포함된 POD의 Kubernetes 서비스 계정 자격 증명을 사용하여 API 서버에 연락합니다. Trident가 서비스 계정이 활성화된 Kubernetes 클러스터에서 POD로 실행되는 경우에만 작동합니다.</block>
  <block id="24095e7ef85031e99914e2c5298a7ded" category="list-text">"-k8s_api_server &lt;insecure-address:insecure-port&gt;": Kubernetes 지원을 활성화하려면 이 옵션 또는 "-k8s_pod"를 사용하십시오. Trident가 지정된 경우 제공된 비보안 주소 및 포트를 사용하여 Kubernetes API 서버에 연결합니다. 따라서 Trident를 POD 외부에 배포할 수 있지만 API 서버에 대한 비보안 연결만 지원합니다. 안전하게 연결하려면 '-k8s_POD' 옵션을 사용하여 포드에 Trident를 배포합니다.</block>
  <block id="9d77217a2dfe50f2575ced46f5e661d8" category="list-text">"-k8s_config_path &lt;file&gt;": 필수. KubeConfig 파일에 대한 경로를 지정해야 합니다.</block>
  <block id="c5fd214cdd0d2b3b4272e73b022ba5c2" category="section-title">Docker 를 참조하십시오</block>
  <block id="1e071a3d810132af1c9f8f6a03ca5609" category="list-text">'-volume_driver&lt;name&gt;': Docker 플러그인을 등록할 때 사용되는 드라이버 이름입니다. 기본값은 'NetApp'입니다.</block>
  <block id="dfbbfd6bbf6bc798d1cbe8895d1cff22" category="list-text">'-driver_port&lt;port-number&gt;': UNIX 도메인 소켓이 아닌 이 포트에서 수신 대기하십시오.</block>
  <block id="3874d7b8c9196001f8bfe4c49f43b323" category="list-text">'-config &lt;file&gt;': 필수. 백엔드 구성 파일에 대한 이 경로를 지정해야 합니다.</block>
  <block id="50780f47f6839d47d60bc4555ee00c3f" category="section-title">휴식</block>
  <block id="bfffd3cb0560af555e57dd6bad52a9be" category="list-text">"-address &lt;ip-or-host&gt;": Trident의 REST 서버가 수신할 주소를 지정합니다. 기본값은 localhost입니다. localhost에서 듣거나 Kubernetes Pod에서 실행 중인 경우, REST 인터페이스는 Pod 외부에서 직접 액세스할 수 없습니다. POD IP 주소를 통해 REST 인터페이스에 액세스할 수 있도록 하려면 "-address""를 사용합니다.</block>
  <block id="433f174b6e54b889696b2efd4ef40dc6" category="admonition">Trident REST 인터페이스는 127.0.0.1(IPv4의 경우) 또는 [::1](IPv6의 경우)에서만 수신 및 서비스하도록 구성할 수 있습니다.</block>
  <block id="049ad2e7bef322af60013bbdd35ebbe7" category="list-text">'-port&lt;port-number&gt;': Trident의 REST 서버가 수신할 포트를 지정합니다. 기본값은 8000입니다.</block>
  <block id="188cb756fe8659cb2caf27ca6d1446b4" category="list-text">REST는 REST 인터페이스를 활성화한다. 기본값은 true 입니다.</block>
  <block id="8447c4879970f03c99a2bec36a05c141" category="summary">Astra Trident의 REST API와 상호 작용하려는 경우 REST 엔드포인트를 직접 사용할 수 있습니다.</block>
  <block id="a0ebcf8495639418ba9d4b85dbb67b8b" category="doc">Astra Trident REST API</block>
  <block id="319c1a7b5479ffa2a028b658ad5b7033" category="inline-link-macro">tridentctl 명령 및 옵션</block>
  <block id="8b3c7aa88e751573c842f17535525f19" category="paragraph">API는 다음과 같이 작동합니다.</block>
  <block id="2fab7aa97b6a2cfae6563e72aac5161e" category="list-text">'&lt;triment-address&gt;/triment/v1/&lt;object-type&gt;': 해당 형식의 모든 개체를 나열합니다.</block>
  <block id="c34156b367bae1b376f09b89d3be7992" category="list-text">'&lt;trident-address&gt;/trident/v1/&lt;object-type&gt;/&lt;object-name&gt;': 명명된 개체의 세부 정보를 가져옵니다.</block>
  <block id="6692e2cd6834e6b9b2151799cac2a9f8" category="paragraph">'&lt;triment-address&gt;/triment/v1/&lt;object-type&gt;': 지정된 형식의 개체를 만듭니다.</block>
  <block id="3d2bacacf0178e742d5abb2abc32d431" category="list-text">생성할 개체의 JSON 구성이 필요합니다. 각 개체 유형의 사양은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="5b2f45c3d098b61927afda859c9144f8" category="list-text">개체가 이미 있는 경우 동작이 달라집니다. backends는 기존 개체를 업데이트하지만 다른 모든 개체 형식은 작업에 실패합니다.</block>
  <block id="ecfc51243c8c28fc234ff87f1f9ddb88" category="paragraph">삭제 &lt;triment-address&gt;/triment/v1/&lt;object-type&gt;/&lt;object-name&gt;': 명명된 리소스를 삭제합니다.</block>
  <block id="80e4e3d3203325fb6aeb139614fd09f3" category="admonition">백엔드 또는 스토리지 클래스와 연결된 볼륨은 계속 존재하므로 별도로 삭제해야 합니다. 자세한 내용은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="ce94b1f7df7a6a05a559b66f96eff1cc" category="paragraph">이러한 API의 호출 방법에 대한 예제를 보려면 debug("-d") 플래그를 전달하십시오. 자세한 내용은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="04333ff788951193122a833ecd614950" category="summary">Kubernetes 및 Trident, Trident 및 스토리지와 Kubernetes 및 스토리지 간의 관계를 결정하는 몇 가지 리소스 개체가 있습니다. 이러한 오브젝트 중 일부는 Kubernetes를 통해 관리되며 나머지는 Trident를 통해 관리됩니다.</block>
  <block id="da1e63dd673a1932cebb48b6a81bbbb1" category="doc">Kubernetes 및 Trident 오브젝트</block>
  <block id="d107eefb0ce66911b186b03b9e9c337e" category="paragraph">REST API를 사용하여 리소스 객체를 읽고 쓰면서 Kubernetes 및 Trident와 상호 작용할 수 있습니다. Kubernetes 및 Trident, Trident 및 스토리지와 Kubernetes 및 스토리지 간의 관계를 결정하는 몇 가지 리소스 개체가 있습니다. 이러한 오브젝트 중 일부는 Kubernetes를 통해 관리되며 나머지는 Trident를 통해 관리됩니다.</block>
  <block id="62499e0de79c4d07c7915a36f9faa0d8" category="section-title">개체가 서로 어떻게 상호 작용합니까?</block>
  <block id="b9ea565816618011ca591fc191fe5e63" category="paragraph">오브젝트, 목표 및 상호 작용 방식을 이해하는 가장 쉬운 방법은 Kubernetes 사용자의 스토리지에 대한 단일 요청을 따르는 것입니다.</block>
  <block id="ec7d6500a82a56ee8f5fff02eafa7af7" category="list-text">사용자가 이전에 관리자가 구성한 Kubernetes의 torageClass에서 특정 크기의 새 PersistentVolume을 요청하는 PersistentVolumeClaim을 만듭니다.</block>
  <block id="6b25cc026b6f29464d3fce0f6ec67805" category="list-text">Kubernetes의 torageClass는 Trident를 프로비저닝자로 식별하고 Trident에 요청된 클래스에 대한 볼륨 프로비저닝 방법을 알려주는 매개 변수를 포함합니다.</block>
  <block id="5b078d6b19593ee6c55f428e2c85faa7" category="list-text">Trident는 클래스에 대한 볼륨을 프로비저닝하는 데 사용할 수 있는 일치하는 'backends'와 'toragePools'를 식별하는 이름과 동일한 이름의 자체 'torageClass'를 찾습니다.</block>
  <block id="ff099186f912c7abb21bcf68690c98d7" category="list-text">Trident는 일치하는 백엔드에 스토리지를 프로비저닝하고 Kubernetes의 "PersistentVolume"과 "PersistentVolume"과 실제 스토리지 간의 관계를 유지하는 Trident의 볼륨을 찾고, 마운트하고, 처리하는 방법을 Kubernetes의 "PersistentVolume"과 두 개의 객체를 만듭니다.</block>
  <block id="6d2ae40bc02e88464563ae42ae22d54c" category="list-text">Kubernetes는 PersistentVolumeClaim을 새로운 PersistentVolume에 바인딩합니다. PersistentVolumeClaim이 실행되는 모든 호스트에서 PersistentVolume이 마운트되는 "PersistentVolumeClaim"이 포함된 POD</block>
  <block id="490c1b0e3a604c81abb3db1b778ec07b" category="list-text">사용자가 Trident를 가리키는 VolumeSnapshotClass를 사용하여 기존 PVC의 VolumeSnapshot을 생성합니다.</block>
  <block id="9f4e11d34d158ebd365226367c8b15d9" category="list-text">Trident는 PVC와 연결된 볼륨을 식별하고 백엔드에 볼륨의 스냅샷을 생성합니다. 또한 스냅샷을 식별하는 방법을 Kubernetes에 지시하는 'VolumeSnapshotContent'도 생성합니다.</block>
  <block id="c6a606bdd6882cd42de13f2ba3614285" category="list-text">사용자는 'VolumeSnapshot'을 소스로 사용하여 'PersistentVolumeClaim'을 생성할 수 있습니다.</block>
  <block id="8ecb92f33c033b00fcf3c18e59c4b177" category="list-text">Trident는 필요한 스냅샷을 식별하고 "PersistentVolume"과 "Volume"을 생성하는 것과 동일한 단계를 수행합니다.</block>
  <block id="428895404a5e57e01a138a5df672d0fc" category="inline-link">영구 볼륨</block>
  <block id="173423532ed9a565a05f32db2c8f8172" category="admonition">Kubernetes 객체에 대한 자세한 내용은 를 읽는 것이 좋습니다<block ref="92dc8ed82beb7484ab6097a3e91b0deb" category="inline-link-rx"></block> 섹션을 참조하십시오.</block>
  <block id="794a32773794ee6c545794c065d1a88b" category="paragraph">Kubernetes "PersistentVolumeClaim" 개체는 Kubernetes 클러스터 사용자가 만든 스토리지 요청입니다.</block>
  <block id="43cf8e1465c61efc8b1b9bf71aa9931c" category="paragraph">Trident는 표준 사양 외에도 사용자가 백엔드 구성에서 설정한 기본값을 무효화하려는 경우 다음 볼륨별 주석을 지정할 수 있도록 합니다.</block>
  <block id="55f6611cb342565cf0f5002400f53a95" category="cell">주석</block>
  <block id="1527fede1d561a899313c8cb3eb1e7bf" category="cell">볼륨 옵션</block>
  <block id="db8a0bbeae97b94338c1b7a61e2a1ec3" category="cell">지원되는 드라이버</block>
  <block id="f3780100617165ed98557e3a6d2be72d" category="cell">trident.netapp.io/fileSystem</block>
  <block id="44d4d4eb1f08d8eb29766160086f61dd" category="cell">파일 시스템</block>
  <block id="979f70bf9da982ee97ac075df4f048c3" category="cell">trident.netapp.io/cloneFromPVC</block>
  <block id="b4ead50a5ca4f307f7d61da7763ad204" category="cell">CloneSourceVolume</block>
  <block id="46ec89aa5290ead7b514dd5182caa0a7" category="cell">trident.netapp.io/splitOnClone</block>
  <block id="58c1c86186ef8de4f6e12d8f3aed8b64" category="cell">SplitOnClone 을 참조하십시오</block>
  <block id="80f05e749a4f524e8c8a05fa19d5df0e" category="cell">ONTAP-NAS, ONTAP-SAN</block>
  <block id="d6f010e4b4bf9748dcaa34feb70188ce" category="cell">trident.netapp.io/protocol</block>
  <block id="81788ba0d7d02d81c063dbca621ba11b" category="cell">프로토콜</block>
  <block id="100b8cad7cf2a56f6df78f171f97a1ec" category="cell">모두</block>
  <block id="e9898504ff0569325d48acaee7e9ced9" category="cell">trident.netapp.io/exportPolicy</block>
  <block id="61396290e72fa7d707996351c8815bd6" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup</block>
  <block id="2902d12b1fe6d9ef5bd1a3474f2356e9" category="cell">trident.netapp.io/snapshotPolicy</block>
  <block id="0a236e7685e50a59df980d0a30929d6c" category="cell">스냅샷 정책</block>
  <block id="7f3bf2672240703dc69740ce11443cf2" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN</block>
  <block id="6224177007fc13e9e0d3789985ed165a" category="cell">trident.netapp.io/snapshotReserve</block>
  <block id="bb0d75280f9b683f2f1f0767fd0aff9b" category="cell">snapshotReserve</block>
  <block id="1cb43054bed661d8c8457ddbb43e1b1b" category="cell">trident.netapp.io/snapshotDirectory</block>
  <block id="1ae33c448502ac3d326593aee304c21f" category="cell">스냅샷 디렉토리</block>
  <block id="ec1739ebad429a70f25efc292c347f8e" category="cell">trident.netapp.io/unixPermissions</block>
  <block id="69d900d222446aab8591b45a7363c9e7" category="cell">trident.netapp.io/blockSize</block>
  <block id="480d1b61a0432d1319f7504a3d7318dd" category="cell">블록 크기</block>
  <block id="c0d2a793e71b152662b3e8cd2da00620" category="cell">solidfire-SAN</block>
  <block id="fc5f8320f80474f09bdd1e3c3849123e" category="paragraph">생성된 PV에 'Delete' Reclaim 정책이 있는 경우, Trident는 PV가 해제될 때(즉, 사용자가 PVC를 삭제할 때) PV와 보조 볼륨을 모두 삭제합니다. 삭제 작업이 실패할 경우 Trident는 PV를 해당 상태로 표시하고 성공할 때까지 또는 PV를 수동으로 삭제할 때까지 주기적으로 작업을 다시 시도합니다. PV에서 '+Retain+' 정책을 사용할 경우 Trident는 이를 무시하고 관리자가 Kubernetes 및 백엔드에서 이를 정리하여 제거하기 전에 볼륨을 백업 또는 검사할 수 있다고 가정합니다. PV를 삭제해도 Trident에서 백업 볼륨을 삭제하지 않습니다. REST API('tridentctl')를 사용하여 제거해야 합니다.</block>
  <block id="5dad99bb31feaed11fecbe29cf682e51" category="paragraph">Trident는 CSI 사양을 사용하여 볼륨 스냅샷 생성을 지원합니다. 볼륨 스냅샷을 생성하고 이를 데이터 소스로 사용하여 기존 PVC를 복제할 수 있습니다. 이렇게 하면 PVS의 시점 복제본을 스냅샷 형태로 Kubernetes에 표시할 수 있습니다. 그런 다음 스냅샷을 사용하여 새 PVS를 생성할 수 있습니다. 이 기능이 어떻게 동작하는지 알아보려면 "+주문형 볼륨 스냅샷+"를 살펴보십시오.</block>
  <block id="2553df6c9f03b727070656d38019ad3e" category="paragraph">또한 Trident는 클론 생성을 위한 "cloneFromPVC" 및 "plitOnClone" 주석을 제공합니다. 이러한 주석을 사용하여 Kubernetes 1.13 이하 버전에서 CSI 구현을 사용하지 않고 PVC를 복제하거나 Kubernetes 릴리스가 베타 볼륨 스냅샷(Kubernetes 1.16 이하)을 지원하지 않을 경우 사용할 수 있습니다. Trident 19.10은 PVC를 통한 클론 생성을 위한 CSI 워크플로우를 지원합니다.</block>
  <block id="91adc865e5be78d779fd6aa38481ca58" category="admonition">CSI Trident와 기존 비 CSI 프런트엔드 및 CLoneFromPVC와 'PlitOnClone' 주석을 사용할 수 있습니다.</block>
  <block id="96e0288ecc3c91f97de46420e70a4f8f" category="paragraph">예를 들어 이미 mysql이라는 PVC가 있는 사용자는 trident.netapp.io/cloneFromPVC: mysql 같은 주석을 사용해 mysqlclone이라는 새로운 PVC를 만들 수 있습니다. 이 주석을 설정하면 Trident가 볼륨을 처음부터 프로비저닝하는 대신 MySQL PVC에 해당하는 볼륨을 클론합니다.</block>
  <block id="ff0fa770e22db25a156c5e2d7f017283" category="paragraph">다음 사항을 고려하십시오.</block>
  <block id="5faae6e509c8aecf9f8815a4ceef02b3" category="list-text">유휴 볼륨의 클론을 생성하는 것이 좋습니다.</block>
  <block id="f89d76e06e88814705882a1faad838fb" category="list-text">PVC와 그 클론은 동일한 Kubernetes 네임스페이스에서 동일한 스토리지 클래스를 가져야 합니다.</block>
  <block id="f769a6b54b1d1476b6628ebd1c4b98c4" category="list-text">ONTAP-NAS와 ONTAP-SAN 드라이버를 함께 사용하면 trident.netapp.io/splitOnClone` 과 함께 PVC 주석 trident.netapp.io/cloneFromPVC` 을 설정하는 것이 바람직할 수 있습니다. Trident는 trident.netapp.io/splitOnClone` 를 true로 설정하면 상위 볼륨에서 복제된 볼륨을 분할하여 복제된 볼륨의 수명 주기를 부모 볼륨에서 완전히 분리하여 스토리지 효율성을 잃게 됩니다. trident.netapp.io/splitOnClone` 를 설정하지 않거나 "false"로 설정하지 않으면 상위 볼륨과 클론 볼륨 간의 종속성을 생성하여 클론이 먼저 삭제되지 않으면 상위 볼륨을 삭제할 수 없게 되어 백엔드에서 공간 소비가 줄어듭니다. 클론을 분할하는 것이 올바른 시나리오는 빈 데이터베이스 볼륨을 복제하여 볼륨과 해당 클론이 크게 달라질 것으로 예상되며 ONTAP에서 제공하는 스토리지 효율성의 이점을 얻지 못하는 경우입니다.</block>
  <block id="83a9930ebb180c904bf2e71e27928287" category="paragraph">'ample-input' 디렉토리에는 Trident와 함께 사용할 PVC 정의의 예가 포함되어 있습니다. Trident 볼륨과 관련된 매개 변수 및 설정에 대한 자세한 설명은 Trident Volume 개체를 참조하십시오.</block>
  <block id="6cb5412cc2fe8210c4d14d6d6b08ab79" category="paragraph">Kubernetes "PersistentVolume" 개체는 Kubernetes 클러스터에서 사용할 수 있는 스토리지 부분을 나타냅니다. 사용 포드와 독립적인 라이프 사이클이 있습니다.</block>
  <block id="292289b7334983e53d9fb9bd00d30820" category="admonition">Trident는 "PersistentVolume" 개체를 만들고 프로비저닝하는 볼륨을 기준으로 Kubernetes 클러스터에 자동으로 등록합니다. 스스로 관리할 수 없습니다.</block>
  <block id="443f09ca4d0d1cc13b5baa064b90c0b7" category="paragraph">Trident 기반의 'torageClass'를 참조하는 PVC를 생성하면 Trident는 해당 스토리지 클래스를 사용하여 새 볼륨을 프로비저닝하고 해당 볼륨에 대한 새 PV를 등록합니다. 프로비저닝 볼륨과 해당 PV를 구성할 때 Trident는 다음 규칙을 따릅니다.</block>
  <block id="b27c91fe87605abbb0d5240430518a1c" category="list-text">Trident는 Kubernetes의 PV 이름과 스토리지 프로비저닝에 사용되는 내부 이름을 생성합니다. 두 경우 모두 이름은 해당 범위에서 고유합니다.</block>
  <block id="9c2f88a5c4297bd88ead0cd6314fe886" category="list-text">볼륨의 크기는 플랫폼에 따라 가장 가까운 할당 가능한 수량으로 반올림될 수 있지만 PVC에서 요청된 크기와 최대한 가깝게 일치합니다.</block>
  <block id="0d35625a483152791f4e2d0b751a09cc" category="paragraph">Kubernetes의 torageClass 객체는 속성 세트를 사용하여 스토리지를 프로비저닝하기 위해 PersistentVolumeClaims의 이름으로 지정됩니다. 스토리지 클래스 자체는 사용할 구축 소유자를 식별하고 프로비저닝이 이해할 수 있는 조건으로 해당 자산 세트를 정의합니다.</block>
  <block id="f7738d717849274e5992d460fd2c0a75" category="paragraph">관리자가 만들고 관리해야 하는 두 가지 기본 개체 중 하나입니다. 다른 하나는 Trident 백엔드 객체입니다.</block>
  <block id="e51377a773f4713e536b061eaa2d4b04" category="paragraph">Trident를 사용하는 Kubernetes의 torageClass 개체는 다음과 같습니다.</block>
  <block id="39edc8618b50008d4cb2050414d6921f" category="paragraph">이러한 매개 변수는 Trident에만 해당되며 Trident에 클래스에 볼륨을 프로비저닝하는 방법을 알려줍니다.</block>
  <block id="b16da8ed7f6c8cce3011dc2b6c7bd1a4" category="paragraph">스토리지 클래스 매개 변수는 다음과 같습니다.</block>
  <block id="f2bbdf9f72c085adc4d0404e370f0f4c" category="cell">속성</block>
  <block id="b651efdb98a5d6bd2b3935d0c3f4a5e2" category="cell">필수 요소입니다</block>
  <block id="736b91750e516139acc13c5eb6564f92" category="cell">속성</block>
  <block id="59a1e7292a0114529fb1b3401b37bc28" category="cell">[string] 문자열을 매핑합니다</block>
  <block id="7fa3b767c460b54a2be4d49030b349c7" category="cell">아니요</block>
  <block id="1b40216e6fe613bd013bf8710182e650" category="cell">아래의 특성 섹션을 참조하십시오</block>
  <block id="c614017642b6cfd9e6a25c7df122d917" category="cell">스토리지 풀</block>
  <block id="b8f32852327d2ffce86ae3ead4fdfb52" category="cell">Map [string] StringList 입니다</block>
  <block id="bdd0ddb870ed9de6f6e7d3a75200e9f7" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="145d1b89a9f9ed8bdc16d1f7a814cace" category="cell">추가 StoragePools</block>
  <block id="6907a73ad9068ddf5f99d022102220bb" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="7df974d787ead594df017a11672f2f0e" category="cell">excludeStoragePools를 참조하십시오</block>
  <block id="99ba77776c83983f5ecbd2b51f2b43ef" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="f74d4b2b456fb453c0980710290f66eb" category="paragraph">스토리지 속성 및 가능한 값은 스토리지 풀 선택 특성 및 Kubernetes 속성으로 분류할 수 있습니다.</block>
  <block id="2fdf10f3f64b631cd3a137740de02f8b" category="section-title">스토리지 풀 선택 특성입니다</block>
  <block id="1f5912cd581dba393d5eecc43059adf4" category="paragraph">이러한 매개 변수는 지정된 유형의 볼륨을 프로비저닝하는 데 사용해야 하는 Trident 관리 스토리지 풀을 결정합니다.</block>
  <block id="c82a6100dace2b41087ba6cf99a5976a" category="cell">값</block>
  <block id="6bb24468956384c482a8b5a901fb6383" category="cell">제공합니다</block>
  <block id="15c2d85f1fae22a3c3a0594510a1f611" category="cell">요청하십시오</block>
  <block id="7aa57840938d59b415c1e10dcd1f7173" category="cell">에 의해 지원됩니다</block>
  <block id="0e72be2e13bf8a2ff8078d3435e5aa7c" category="cell">미디어 ^1^</block>
  <block id="b45cffe084dd3d20d928bee85e7b0f21" category="cell">문자열</block>
  <block id="9ccd7f94313a98beb95801927907a0ab" category="cell">HDD, 하이브리드, SSD</block>
  <block id="9bf3032f6854fb376cd8e3e92e11b077" category="cell">풀에는 이 유형의 미디어가 포함되어 있으며, 하이브리드는 둘 모두를 의미합니다</block>
  <block id="5c79c761bae4c27e96c04e54d1da1e91" category="cell">지정된 미디어 유형입니다</block>
  <block id="c9cb5e737e2746339fd0b462332c8740" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, solidfire-SAN</block>
  <block id="b713baf75bcf13859037b5274d27d4b8" category="cell">프로비저닝 유형</block>
  <block id="6026fbd9abd05590949de220154e3262" category="cell">얇고 두껍습니다</block>
  <block id="3064025fe3541bec9942e14fcaedfab7" category="cell">풀은 이 프로비저닝 방법을 지원합니다</block>
  <block id="cf65591e3da90317fc132ea7464105d8" category="cell">프로비저닝 방법이 지정되었습니다</block>
  <block id="55b56fb238360663afa6230ad82e74a0" category="cell">백엔드 유형</block>
  <block id="0e1201d4d96df2d9d03c9c66b90874a1" category="cell">풀이 이 백엔드 유형에 속합니다</block>
  <block id="c4efe19137f43450149d48fddbab6c28" category="cell">백엔드가 지정되었습니다</block>
  <block id="a04622349b3ede0d4176ca2c2e161763" category="cell">모든 드라이버</block>
  <block id="695633290d050f31cec0c9d4bd4a57fe" category="cell">스냅샷 수</block>
  <block id="c506ff134babdd6e68ab3e6350e95305" category="cell">불입니다</block>
  <block id="ac1ffb15effdc77a86029972670d022f" category="cell">참, 거짓</block>
  <block id="4ac43bef181074fbd4a1f3620b46f77f" category="cell">풀은 스냅샷이 있는 볼륨을 지원합니다</block>
  <block id="13410bff9f7871113a6af273e2a1b97f" category="cell">스냅샷이 활성화된 볼륨</block>
  <block id="bc3832c405ec6cb9c831849328240f3b" category="cell">복제</block>
  <block id="609d32aa243917905f282544b543752a" category="cell">풀은 볼륨 클론을 지원합니다</block>
  <block id="bcb81802de31cf9c717de3c1d6c2f610" category="cell">클론이 활성화된 볼륨</block>
  <block id="5bdf74912a51c34815f11e9a3d20b609" category="cell">암호화</block>
  <block id="5f2f2cc138a8bc7067c7f61ab4db0f4d" category="cell">풀은 암호화된 볼륨을 지원합니다</block>
  <block id="0bda31a93b84fd2b45a90df39c4c8049" category="cell">암호화가 활성화된 볼륨입니다</block>
  <block id="dcc09b4a72e31323b652676ce4677771" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroups, ONTAP-SAN</block>
  <block id="79073619fba8242703524f16870ff858" category="cell">IOPS</block>
  <block id="fa7153f7ed1cb6c0fcf2ffb2fac21748" category="cell">내부</block>
  <block id="86e5d65893929e5d38b4bdcb9fb48ecd" category="cell">양의 정수입니다</block>
  <block id="bf57d1db8292b2855fa998a86562cfa7" category="cell">풀은 이 범위에서 IOPS를 보장할 수 있습니다</block>
  <block id="342a7ce5bb7debc6ba84dc2a3bced587" category="cell">볼륨은 이러한 IOPS를 보장합니다</block>
  <block id="895f3d78c77292d9761bdabdc3cf0c99" category="paragraph">^1^: ONTAP Select 시스템에서 지원되지 않습니다</block>
  <block id="5b3c68bde0b3658758a8ebf47ec6abf1" category="paragraph">대부분의 경우 요청된 값이 프로비저닝에 직접적인 영향을 미치며, 예를 들어 일반 프로비저닝을 요청하면 볼륨이 걸쭉하게 프로비저닝됩니다. 하지만 Element 스토리지 풀은 제공된 IOPS 최소 및 최대값을 사용하여 요청된 값이 아닌 QoS 값을 설정합니다. 이 경우 요청된 값은 스토리지 풀을 선택하는 데만 사용됩니다.</block>
  <block id="311fa7e17587a62a6fdcb110253feed7" category="paragraph">이상적으로는 '속성'을 단독으로 사용하여 특정 클래스의 요구 사항을 충족하는 데 필요한 스토리지의 품질을 모델링할 수 있습니다. Trident는 사용자가 지정한 '속성'의 _ALL_과 일치하는 스토리지 풀을 자동으로 검색하여 선택합니다.</block>
  <block id="d0c865b74e0c4b4b387506e9e95d22b2" category="paragraph">클래스에 맞는 풀을 자동으로 선택하기 위해 속성(attributes)을 사용할 수 없는 경우, 'toragePools' 및 'additionalStoragePools' 매개 변수를 사용하여 풀을 더 세분화하거나 특정 풀 세트를 선택할 수도 있습니다.</block>
  <block id="06a87a25fa98442cf561762851213f7e" category="paragraph">'toragePools' 매개 변수를 사용하면 지정된 'attributes'와 일치하는 풀 세트를 추가로 제한할 수 있습니다. 즉, Trident는 프로비저닝에서 'attributes'와 'toragePools' 매개 변수로 식별되는 풀의 교집합을 사용합니다. 매개 변수만 사용하거나 둘 다 함께 사용할 수 있습니다.</block>
  <block id="0c66a737e57eb6ac0885d2ba6d87cc12" category="paragraph">"additionalStoragePools" 매개 변수를 사용하면 "attributes" 및 "toragePools" 매개 변수로 선택한 풀에 관계없이 Trident에서 프로비저닝에 사용하는 풀 집합을 확장할 수 있습니다.</block>
  <block id="2ed95c63c6e58641d710e098e7e23154" category="paragraph">'excludeStoragePools' 매개 변수를 사용하여 Trident에서 프로비저닝을 위해 사용하는 풀 집합을 필터링할 수 있습니다. 이 매개 변수를 사용하면 일치하는 풀이 모두 제거됩니다.</block>
  <block id="9f8bfd75f7eb5b95503bb0abedf83b40" category="paragraph">'toragePools' 및 'additionalStoragePools' 매개 변수에서 각 항목은 '&lt;backend&gt;:&lt;storagePoolList&gt;' 형식을 사용합니다. 여기서 '&lt;storagePoolList&gt;'는 지정된 백엔드에 대한 쉼표로 구분된 스토리지 풀 목록입니다. 예를 들어, additionalStoragePools 값은 ontapnas_192.168.1.100:aggr1,aggr2;solidfire_192.168.1.101:bronze처럼 보일 수 있습니다. 이러한 목록에는 백엔드 및 목록 값 모두에 대한 regex 값이 적용됩니다. tridentctl 백엔드 가져오기 를 사용하여 백엔드와 해당 풀의 목록을 가져올 수 있습니다.</block>
  <block id="c087dddd46fcf0fbbf390abeff2216c3" category="section-title">Kubernetes 특성</block>
  <block id="d05956159ee82aafaaacfe08d33d3be6" category="paragraph">이러한 특성은 동적 프로비저닝 중 Trident가 스토리지 풀/백엔드를 선택하는 데 아무런 영향을 주지 않습니다. 대신 이러한 특성은 Kubernetes 영구 볼륨에서 지원하는 매개 변수만 제공합니다. 작업자 노드는 파일 시스템 생성 작업을 담당하며 xfsprogs와 같은 파일 시스템 유틸리티가 필요할 수 있습니다.</block>
  <block id="0e6ac0d7fca9c59e6545312a071555b6" category="cell">관련 드라이버</block>
  <block id="ae6b2a160dd2fafdee385c348edee0c1" category="cell">Kubernetes 버전</block>
  <block id="7cfbb6f07899c8071ff38e69dca190e2" category="cell">fsType입니다</block>
  <block id="64b6d80cc167d5c657b60054dbe396ee" category="cell">ext4, ext3, xfs 등</block>
  <block id="7928a56d4874d982a06a59e3f30f6935" category="cell">블록 볼륨의 파일 시스템 유형입니다</block>
  <block id="b1c94ca2fbc3e78fc30069c8d0f01680" category="cell">모두</block>
  <block id="2435c5eb0d842c13f635d4b1d6667a52" category="paragraph">Trident 설치 프로그램 번들에는 'Sample-input/storage-class- *.YAML'의 Trident와 함께 사용할 수 있는 여러 가지 스토리지 클래스 정의가 포함되어 있습니다. Kubernetes 스토리지 클래스를 삭제하면 해당 Trident 스토리지 클래지도 삭제됩니다.</block>
  <block id="65d18b5db5d5f35e4ddc5c696687d1bd" category="paragraph">쿠버네티스 VolumeSnapshotClass 객체는 'torageClaes'와 유사합니다. 이 기능을 사용하면 여러 스토리지 클래스를 정의할 수 있으며, 스냅샷을 필요한 스냅샷 클래스와 연결하기 위해 볼륨 스냅숏에서 참조할 수 있습니다. 각 볼륨 스냅샷은 단일 볼륨 스냅샷 클래스와 연결됩니다.</block>
  <block id="031e09713b698739db52cb150ef97605" category="paragraph">스냅샷을 생성하려면 관리자가 VolumeSnapshotClass를 정의해야 합니다. 볼륨 스냅샷 클래스는 다음과 같은 정의로 생성됩니다.</block>
  <block id="879cd061c6bf448cd6fc39dd56947611" category="paragraph">driver는 CSI-snapclass 클래스의 볼륨 스냅샷을 요청하는 Kubernetes를 Trident에서 처리하도록 지정합니다. "eletionPolicy"는 스냅샷을 삭제할 때 수행할 작업을 지정합니다. "eletionPolicy"를 "Delete"로 설정하면 스냅샷이 삭제될 때 스토리지 클러스터의 기본 스냅샷과 볼륨 스냅샷 객체가 제거됩니다. 또는 '유지'로 설정하면 VolumeSnapshotContent와 물리적 스냅샷이 보존됩니다.</block>
  <block id="7ba558df52a052235cf288011e5d667c" category="paragraph">Kubernetes 'VolumeSnapshot' 개체는 볼륨의 스냅샷을 생성하는 요청입니다. PVC는 사용자가 볼륨에 대해 요청하는 것처럼 볼륨 스냅샷은 사용자가 기존 PVC의 스냅샷을 생성하도록 요청하는 것입니다.</block>
  <block id="f67af493d1fd83b472d5f27307b2f3d9" category="paragraph">볼륨 스냅샷 요청이 들어오면 Trident는 백엔드의 볼륨에 대한 스냅샷 생성을 자동으로 관리하고 고유한 'VolumeSnapshotContent' 객체를 생성하여 스냅샷을 표시합니다. 기존 PVC에서 스냅샷을 생성하고 새 PVC를 생성할 때 스냅샷을 DataSource로 사용할 수 있습니다.</block>
  <block id="53847015682974d066a919b1b45a44a5" category="admonition">VolumeSnapshot의 생수는 소스 PVC와는 독립적입니다. 소스 PVC가 삭제된 후에도 스냅샷이 지속됩니다. 연관된 스냅샷이 있는 PVC를 삭제할 때 Trident는 이 PVC에 대한 백업 볼륨을 * Deleting * 상태로 표시하지만 완전히 제거하지는 않습니다. 연결된 모든 스냅샷이 삭제되면 볼륨이 제거됩니다.</block>
  <block id="e562bdcf97dce6973a736651f45eb054" category="paragraph">Kubernetes의 'VolumeSnapshotContent' 객체는 이미 프로비저닝된 볼륨에서 생성된 스냅샷을 나타냅니다. 이 스냅샷은 "PersistentVolume"과 유사하며 스토리지 클러스터에서 프로비저닝된 스냅샷을 나타냅니다. 스냅샷이 생성될 때 PersistentVolumeClaim 및 PersistentVolume 개체와 마찬가지로 VolumeSnapshotContent 개체는 스냅샷 생성을 요청한 VolumeSnapshot 객체에 대한 일대일 매핑을 유지합니다.</block>
  <block id="ca8035550d447392debfcaeb62855bd3" category="admonition">Trident는 'VolumeSnapshotContent' 객체를 생성한 후 프로비저닝하는 볼륨을 기준으로 Kubernetes 클러스터에 자동으로 등록합니다. 스스로 관리할 수 없습니다.</block>
  <block id="af741aec1c66e51c00d35a38f92471de" category="paragraph">VolumeSnapshotContent 객체에는 스냅샷 스냅샷(스냅샷 핸들 등)을 고유하게 식별하는 세부 정보가 포함되어 있습니다. 이 나프산Handle은 PV의 이름과 VolumeSnapshotContent 객체의 이름을 조합한 독특한 것이다.</block>
  <block id="b22c73e808eef321ee9941ec2e58b64f" category="paragraph">스냅샷 요청이 들어오면 Trident가 백엔드에 스냅샷을 생성합니다. 스냅샷이 생성된 후 Trident는 'VolumeSnapshotContent' 객체를 구성하여 해당 스냅샷을 Kubernetes API에 노출합니다.</block>
  <block id="7c43d52062b795d2d8e7f33b9dbbf671" category="paragraph">Kubernetes 사용자 지정 리소스는 관리자가 정의하며 비슷한 객체를 그룹화하는 데 사용되는 Kubernetes API의 엔드포인트입니다. Kubernetes에서는 오브젝트 컬렉션을 저장하기 위한 사용자 지정 리소스의 생성을 지원합니다. kubeck Get CRD를 실행하여 이러한 리소스 정의를 얻을 수 있습니다.</block>
  <block id="09d4c17e4e0e002375326eee41d0f77f" category="paragraph">사용자 정의 리소스 정의(CRD) 및 관련 오브젝트 메타데이터는 Kubernetes에서 메타데이터 저장소에 저장됩니다. 따라서 Trident를 위한 별도의 저장소가 필요하지 않습니다.</block>
  <block id="798d49964270b9d2f638171af7258d00" category="paragraph">19.07 릴리스부터 Trident는 다양한 "CustomResourceDefinition" 개체를 사용하여 Trident 백 엔드, Trident 스토리지 클래스 및 Trident 볼륨과 같은 Trident 개체의 ID를 보존합니다. 이러한 오브젝트는 Trident에서 관리합니다. 또한 CSI 볼륨 스냅샷 프레임워크는 볼륨 스냅샷을 정의하는 데 필요한 일부 CRD를 소개합니다.</block>
  <block id="9f59afd5e4687b9960361128f049dae4" category="paragraph">CRD는 Kubernetes를 구성하는 것입니다. 위에 정의된 리소스의 객체는 Trident에 의해 생성됩니다. 간단히 예로, 'tridentctl'을 사용하여 백엔드를 생성할 때 해당하는 'tridentbackends' CRD 객체는 Kubernetes에서 사용할 수 있도록 생성됩니다.</block>
  <block id="7cdfd680fe492e028cde251c38475469" category="paragraph">다음은 Trident의 CRD에 대해 고려해야 할 몇 가지 사항입니다.</block>
  <block id="adecfe476427253e9c680a7c5150a9cc" category="list-text">Trident가 설치되면 일련의 CRD가 생성되어 다른 리소스 유형과 마찬가지로 사용할 수 있습니다.</block>
  <block id="b54c0b51e5e24cea2035a3e3624c5719" category="list-text">Trident의 이전 버전('etcd'를 사용하여 상태를 유지 관리)에서 업그레이드할 경우 Trident 설치 프로그램이 'etcd' 키 값 데이터 저장소에서 데이터를 마이그레이션하고 해당 CRD 개체를 만듭니다.</block>
  <block id="c4b35352cbf7a52a9444a610687067f8" category="inline-link-macro">Trident를 제거합니다</block>
  <block id="193c267230acf55be171a6a179560847" category="paragraph">Trident는 Kubernetes의 torageClass 오브젝트에 대해 공급자 필드에 csi.trident.netapp.io`/`netapp.io/trident` 를 지정하는 일치하는 스토리지 클래스를 만듭니다. 스토리지 클래스 이름은 이 이름이 나타내는 Kubernetes의 torageClass 개체와 일치합니다.</block>
  <block id="64cf33bfeab6c6bd8aa626b86fda9cbd" category="admonition">Kubernetes를 사용하면 Trident를 프로비저닝한 Kubernetes의 torageClass가 등록되면 이러한 객체가 자동으로 생성됩니다.</block>
  <block id="51fa0a833f47d8f00ee2677c6fa7b075" category="paragraph">스토리지 클래스는 볼륨에 대한 일련의 요구 사항으로 구성됩니다. Trident는 이러한 요구 사항을 각 스토리지 풀에 있는 속성과 일치시킵니다. 일치하는 경우 해당 스토리지 풀이 해당 스토리지 클래스를 사용하여 볼륨을 프로비저닝할 수 있는 유효한 타겟입니다.</block>
  <block id="04d84bba5a5e103ae9c192c03a7ad2f3" category="paragraph">REST API를 사용하여 스토리지 클래스를 직접 정의하는 스토리지 클래스 구성을 생성할 수 있습니다. 그러나 Kubernetes 구축의 경우 새로운 Kubernetes의 torageClass 오브젝트를 등록할 때 이러한 객체가 생성되기를 기대합니다.</block>
  <block id="21283df20640a21f468122a427ef1bfc" category="section-title">Trident 백엔드 객체</block>
  <block id="3c244b984a2188556c1115a5a27dbe1b" category="paragraph">백엔드는 Trident가 볼륨을 프로비저닝하는 스토리지 공급자를 나타냅니다. 단일 Trident 인스턴스가 원하는 수의 백엔드를 관리할 수 있습니다.</block>
  <block id="d71c5fad4769c19422c07158e24510ba" category="admonition">이것은 직접 만들고 관리하는 두 가지 개체 유형 중 하나입니다. 다른 하나는 Kubernetes의 torageClass 오브젝트입니다.</block>
  <block id="54fd1dc39c3eecd913b4c9140522996c" category="paragraph">스토리지 풀은 각 백엔드에서 용량 할당에 사용할 수 있는 고유한 위치를 나타냅니다. ONTAP의 경우 SVM에 있는 애그리게이트와 대응합니다. NetApp HCI/SolidFire의 경우 관리자 지정 QoS 밴드에 해당합니다. Cloud Volumes Service의 경우 클라우드 공급자 지역에 해당합니다. 각 스토리지 풀에는 고유한 스토리지 특성 세트가 있으며, 이 특성 집합은 성능 특성과 데이터 보호 특성을 정의합니다.</block>
  <block id="4ab1440e71a70a97c4966bcc0095f02b" category="paragraph">다른 오브젝트와 달리 스토리지 풀 후보 는 항상 자동으로 검색되고 관리됩니다.</block>
  <block id="894765102686902c6acc3024e5bdb9bd" category="paragraph">볼륨은 NFS 공유 및 iSCSI LUN과 같은 백엔드 엔드포인트로 구성된 기본 프로비저닝 단위입니다. Kubernetes에서는 이러한 항목이 "PersistentVolumes"에 직접 해당합니다. 볼륨을 생성할 때 볼륨의 용량을 할당할 수 있는 위치와 크기를 결정하는 스토리지 클래스가 있는지 확인합니다.</block>
  <block id="2e53db54827c8c05b7bfe9cb31f299d9" category="admonition">Kubernetes에서 이러한 오브젝트는 자동으로 관리됩니다. 프로비저닝 Trident를 보려면 해당 Trident를 확인하십시오.</block>
  <block id="22fcc98910d0241e9835f502b7cb2398" category="admonition">연결된 스냅샷이 있는 PV를 삭제하면 해당 Trident 볼륨이 * Deleting * 상태로 업데이트됩니다. Trident 볼륨을 삭제하려면 볼륨의 스냅샷을 제거해야 합니다.</block>
  <block id="05353bc86910df31b2da9c8d3d26aad1" category="paragraph">볼륨 구성은 프로비저닝된 볼륨에 있어야 하는 속성을 정의합니다.</block>
  <block id="2af72f100c356273d46284f6fd1dfc08" category="cell">버전</block>
  <block id="ce9af1e3f0493eb7d5ffdf584ed763ba" category="cell">Trident API 버전("1")</block>
  <block id="b068931cc450442b63f5b3d276ea4297" category="cell">이름</block>
  <block id="a6105c0a611b41b08f1209506350279e" category="cell">예</block>
  <block id="017dbd2b0a2195c3e8052cdff67bad39" category="cell">생성할 볼륨의 이름입니다</block>
  <block id="78ec9b60245b46a4f05158076962ace9" category="cell">storageClass 를 선택합니다</block>
  <block id="fa00f346deccdbebef2b3cc0702d41de" category="cell">볼륨을 프로비저닝할 때 사용할 스토리지 클래스입니다</block>
  <block id="f7bd60b75b29d79b660a2859395c1a24" category="cell">크기</block>
  <block id="264c52ca068dfed30f5826bb054839f4" category="cell">용량 할당할 볼륨의 크기(바이트)입니다</block>
  <block id="4f18882934f0472b4bfa32928bf92f14" category="cell">사용할 프로토콜 유형;"파일" 또는 "블록"</block>
  <block id="252c6d364cc1a0437939a4f01b0717ae" category="cell">내부 이름</block>
  <block id="2857a43e58983276d059c0e6e2fcb0e9" category="cell">스토리지 시스템에 있는 객체의 이름으로, Trident에서 생성</block>
  <block id="e94d46d7c89bcb7e6ac2e2df4d21bafb" category="cell">ONTAP(NAS, SAN): 상위 클론에서 클론을 분할합니다</block>
  <block id="819549a86d14e849e1d0042c9156d781" category="cell">ONTAP - *: 사용할 스냅샷 정책</block>
  <block id="e38882545bfedafc7e8ec5973b2e6dd8" category="cell">ONTAP - *: 스냅숏용으로 예약된 볼륨의 비율입니다</block>
  <block id="fc86db1233bfa77d5143dcaae9842cb1" category="cell">ONTAP-NAS *: 사용할 엑스포트 정책</block>
  <block id="48e1d8180a61943f438c259b2b6715f8" category="cell">ONTAP-NAS *: 스냅샷 디렉토리가 표시되는지 여부를 나타냅니다</block>
  <block id="3f7c94eec4bbf43962e1667f5a334469" category="cell">ONTAP-NAS *: 초기 UNIX 권한</block>
  <block id="4b2d5d83aef608a3fb59ec6eda8bea26" category="cell">SolidFire - *: 블록/섹터 크기</block>
  <block id="62fe71ae4f6a04a6937feb48ba5dc4f4" category="cell">파일 시스템 유형입니다</block>
  <block id="49539689cebb34166a417b3b666818e5" category="paragraph">볼륨 구성을 사용하여 REST API를 사용하여 볼륨을 직접 프로비저닝할 수 있지만 Kubernetes 배포에서는 대부분의 사용자가 표준 Kubernetes "PersistentVolumeClaim" 방법을 사용할 것으로 예상됩니다. Trident는 프로비저닝 프로세스의 일부로 이 볼륨 개체를 자동으로 만듭니다.</block>
  <block id="a1b3787bbd275b7ed5812d022dd36932" category="paragraph">스냅샷은 볼륨의 시점 복제본으로, 새 볼륨을 용량 할당하거나 복구 상태를 복구하는 데 사용할 수 있습니다. Kubernetes에서는 이러한 객체가 'VolumeSnapshotContent' 객체와 직접 일치합니다. 각 스냅샷은 스냅샷에 대한 데이터의 소스인 볼륨에 연결됩니다.</block>
  <block id="cdf5c8d3dd31e49b82a5b3e2c4a65280" category="paragraph">각 '스냅샷' 개체에는 아래 나열된 속성이 포함됩니다.</block>
  <block id="27118326006d3829667a400ad23d5d98" category="cell">문자열</block>
  <block id="de73fbae2864dd61c921cf0648a9717a" category="cell">Trident 스냅샷 개체의 이름입니다</block>
  <block id="8e744456fb3d02d69442038d3e771460" category="cell">스토리지 시스템의 Trident 스냅샷 개체의 이름입니다</block>
  <block id="617a43eb0446f84414df73cce2997fa1" category="cell">볼륨 이름</block>
  <block id="b58c8ff1e837af6dafa971bf3d320646" category="cell">스냅샷이 생성된 영구 볼륨의 이름입니다</block>
  <block id="2c2aed4b417a0f9c189d7ad6414ae28c" category="cell">볼륨 국제 이름</block>
  <block id="db1a117103c348ebaec41f9e249554c3" category="cell">스토리지 시스템에서 연결된 Trident 볼륨 개체의 이름입니다</block>
  <block id="73f3d5934fdd36989f24cbae94ab423b" category="paragraph">Kubernetes 'VolumeSnapshot' 객체 요청이 생성되면 Trident는 백업 스토리지 시스템에 스냅샷 객체를 생성하여 작동합니다. 이 스냅샷 개체의 인터날Name은 볼륨 스냅샷 개체의 UID(예: 스냅샷-e8d8a0ca-9826-11e9-9807-525400f3f660)와 접두사 스냅샷-UID를 결합하여 생성됩니다. 볼륨 이름 과 볼륨 InternalName 은 백업 볼륨의 세부 정보를 가져오는 방식으로 채워집니다.</block>
  <block id="e977c869b42c54e3c7d8fb9c071aab2b" category="summary">Astra Trident가 통신하는 포트에 대해 자세히 알아보십시오.</block>
  <block id="b229055f6bd047c28dfc84c9bee4c252" category="doc">Astra Trident 포트</block>
  <block id="219abf04d1bb79760c15ca6966b68fb3" category="paragraph">Astra Trident는 다음 포트를 통해 통신합니다.</block>
  <block id="60aaf44d4b562252c04db7f98497e9aa" category="cell">포트</block>
  <block id="261addf78c7b2c961032b3dd08ba0b1f" category="cell">목적</block>
  <block id="7e6b20d014d1c659e4eaf20dc2dcd7eb" category="cell">8443</block>
  <block id="69bbf3571db03f0487c04a8254d15c75" category="cell">백채널 HTTPS</block>
  <block id="bc3c4a6331a8a9950945a1aa8c95ab8a" category="cell">8001입니다</block>
  <block id="e5a4c481cc6f5935efb2c9d381f2e342" category="cell">Prometheus 메트릭 엔드포인트</block>
  <block id="67ff32d40fb51f1a2fd2c4f1b1019785" category="cell">8000</block>
  <block id="10f5b805a46ea829cc3b9d8560a224ae" category="cell">Trident REST 서버</block>
  <block id="35cf0f704286108deb76366a16415140" category="cell">17546</block>
  <block id="fb1396f82d0096741ea1b06f8cee2340" category="cell">Trident 디포드에 사용되는 활성/준비 프로브 포트</block>
  <block id="afe272beb780ad53d441c342bf1c8c77" category="summary">Trident에 대한 간단한 액세스를 제공하는 명령줄 유틸리티인 tridentctl 에 대해 자세히 알아보십시오.</block>
  <block id="4e49f66de2e2dc43c25555fe50639334" category="paragraph">를 클릭합니다<block ref="5a856e83aada9750fe5389f8da94335b" category="inline-link-rx"></block> Astra Trident에 대한 간단한 액세스를 제공하는 명령줄 유틸리티인 tridentctl이 포함되어 있습니다. 충분한 권한을 가진 Kubernetes 사용자는 이를 사용하여 Astra Trident를 설치할 뿐 아니라 직접 상호 작용하여 Astra Trident Pod가 포함된 네임스페이스를 관리할 수 있습니다.</block>
  <block id="8ca34267f11cb69ea424bc0320f0e295" category="paragraph">사용법은 tridentctl - -help를 실행한다.</block>
  <block id="2dd878ee55d738aa02e6b0b162d45708" category="paragraph">사용 가능한 명령:</block>
  <block id="4386bd8da14af923cbb7ac011ffc048e" category="list-text">'create': Astra Trident에 리소스를 추가합니다.</block>
  <block id="f40f9a4cf242d0355aaf8d9e06617436" category="list-text">삭제: Astra Trident에서 하나 이상의 리소스를 제거합니다.</block>
  <block id="94b75e236d78fe800d1d32acc3882789" category="list-text">'Get': Astra Trident에서 하나 이상의 리소스를 받아보세요.</block>
  <block id="bc9ef80dceea04796c6218fe96e05b30" category="list-text">도움말 : 명령에 대한 도움말입니다.</block>
  <block id="f5421bf790b945f508fa1b9f223318e5" category="list-text">"이미지": Astra Trident가 필요로 하는 컨테이너 이미지 테이블을 인쇄합니다.</block>
  <block id="40e65170f778aaa7f4ab7f645b3bb3df" category="list-text">가져오기: 기존 자원을 Astra Trident로 가져옵니다.</block>
  <block id="a824e587817131e2052a450803b2d97c" category="list-text">설치: Astra Trident 설치</block>
  <block id="c90c365a06ede3139cad79d4e55673ee" category="list-text">로그: 아스트라 트리덴트(Astra Trident)의 로그를 인쇄합니다.</block>
  <block id="e5c5ad2be68f58e910aa42a9fcc98141" category="list-text">'종료': Astra Trident에서 리소스를 보냅니다.</block>
  <block id="3166458a066b2d14394e408f1f8fed84" category="list-text">"설치 제거": Astra Trident를 제거합니다.</block>
  <block id="8c8fcf9d4df8bd54d26dc748cc4bac55" category="list-text">업데이트: Astra Trident에서 자원을 수정합니다.</block>
  <block id="042aeda3cc45bf1f53a0e74660dbd924" category="list-text">업그레이드: Astra Trident에서 리소스를 업그레이드합니다.</block>
  <block id="d014c15bf0496b645d02caf1704932f7" category="list-text">'러션': 아스트라 트리덴트(Astra Trident)의 버전을 인쇄해 보세요.</block>
  <block id="1c90ba5cf3791b6148c7887a696911ec" category="paragraph">플래그:</block>
  <block id="568cd496b6bde641a886745edfa59ae7" category="list-text">''-d,--debug': 출력 디버그</block>
  <block id="fe27ec35afa597521f9616f18c32e556" category="list-text">''-h,- 도움말: tridentctl 도움말.</block>
  <block id="874377d6c0baee9e8e842c8abf13d28c" category="list-text">''-n,-namespace string': Astra Trident 배포의 네임스페이스.</block>
  <block id="463b413ea9e7764a789f3e987cb06fc8" category="list-text">''-o, - 출력 문자열: 출력 형식. json|YAML|name|wide|ps(기본값) 중 하나.</block>
  <block id="85c5338e138fc6d122a579f7a07040bf" category="list-text">``s’, -- 서버 문자열: Astra Trident REST 인터페이스의 주소/포트.</block>
  <block id="b8d486e9285b25b72d6efad05e41de4d" category="paragraph">'create' 명령을 실행하여 Astra Trident에 리소스를 추가할 수 있습니다.</block>
  <block id="6d5c7e6905e460d1fba1f2dd1c0d2a8a" category="paragraph">사용 가능한 옵션: "backend": Astra Trident에 백엔드를 추가합니다.</block>
  <block id="0d847e459450017616b8ab50b372ad2e" category="paragraph">"Delete" 명령을 실행하여 Astra Trident에서 하나 이상의 리소스를 제거할 수 있습니다.</block>
  <block id="16713f316b7cce82385c040efc32ac83" category="paragraph">사용 가능한 옵션:</block>
  <block id="417f8bf14ed5852917d189612c7d163c" category="list-text">백엔드: Astra Trident에서 하나 이상의 스토리지 백엔드를 삭제합니다.</block>
  <block id="4896fd245b78ab9b7d044375c1fce85e" category="list-text">'스냅샷': Astra Trident에서 하나 이상의 볼륨 스냅샷을 삭제합니다.</block>
  <block id="cef6b6bb7932e7450e35eafc3d986f18" category="list-text">'스토라게': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스토리지 클래스를 삭제합니다.</block>
  <block id="14eeaf8d1da512153855b759185ee129" category="list-text">'볼륨': Astra Trident에서 하나 이상의 스토리지 볼륨을 삭제합니다.</block>
  <block id="c7a7a677647f05a4032891d4aef5bed5" category="paragraph">"get" 명령을 실행하여 Astra Trident에서 하나 이상의 리소스를 가져올 수 있습니다.</block>
  <block id="2dd609bd837a41363817262fd314b0be" category="list-text">"백엔드": Astra Trident에서 하나 이상의 스토리지 백엔드를 가져옵니다.</block>
  <block id="ad4ba4a1b0612fa67f4386330ac00e9d" category="list-text">스냅샷: 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스냅샷을 얻을 수 있습니다.</block>
  <block id="5385ccfb9fd8a07e53dc1a6ac58a101d" category="list-text">'스라거글라스': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스토리지 클래스를 받으세요.</block>
  <block id="060da5b15e6fb7129c04e18b3d96c702" category="list-text">'볼륨': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 볼륨을 가져옵니다.</block>
  <block id="16ca0a361439e1f936eaa5c919443b10" category="paragraph">"images" 플래그를 실행하여 Astra Trident에 필요한 컨테이너 이미지 테이블을 인쇄할 수 있습니다.</block>
  <block id="1008ac4609cab9210ae758ff8fee8127" category="paragraph">플래그: * ``h, - 도움말’: 이미지 도움말. * ``v, - -k8s-version string': Kubernetes 클러스터의 의미 있는 버전</block>
  <block id="df5ec83145dcd824f8daf85d89e5dd8a" category="paragraph">'볼륨 가져오기' 명령을 실행하여 기존 볼륨을 Astra Trident로 가져올 수 있습니다.</block>
  <block id="ccf1bb29ef5562c033962d35014005e9" category="paragraph">별칭: 볼륨, v</block>
  <block id="48c7ae9a5466415a6b9666ad86746640" category="list-text">''-f, --파일 이름 문자열': YAML 또는 JSON PVC 파일 경로.</block>
  <block id="1bb2af29a08ab6ea9414a8656234b8c6" category="list-text">''-h, - 도움말: 볼륨 도움말.</block>
  <block id="0ad393d5c23749c23f3855220b55375a" category="list-text">'--관리 안 함: PV/PVC만 생성 볼륨 라이프사이클 관리를 가정하지 마십시오.</block>
  <block id="42ddf993417d9568ca6a057fe55f9c63" category="paragraph">설치 플래그를 실행하여 Astra Trident를 설치할 수 있습니다.</block>
  <block id="d14ef114d140fec912921e8447a4dd25" category="list-text">"--autosupport-image string": AutoSupport Telemetry의 컨테이너 이미지(기본값: "NetApp/트리덴트 자동 지원: 20.07.0")</block>
  <block id="fbd7cc4267716ab9206612c6dcaa206e" category="list-text">`--autosupport-proxy string': AutoSupport 텔레메트리 전송을 위한 프록시의 주소/포트입니다.</block>
  <block id="8bb3d6751910d39b8c964e90434b79db" category="list-text">"--CSI": CSI Trident 설치(Kubernetes 1.13의 경우에만 재정의, 기능 게이트 필요)</block>
  <block id="778cbd0cbbd73953bc965ad29269803c" category="list-text">''--enable-node-prep': 노드에 필요한 패키지 설치 시도</block>
  <block id="23945a1dd08f0fb29fc1b73a02a2f48d" category="list-text">''--generate-custom-YAML': 아무것도 설치하지 않고 YAML 파일을 생성합니다.</block>
  <block id="351ac43ddb05bc31fb7aa4d76c9098ed" category="list-text">''-h, - 도움말: 설치 도움말.</block>
  <block id="1968a7e86875b6b6ca9d5222172f8d16" category="list-text">`--http-request-timeout': Trident 컨트롤러의 REST API에 대한 HTTP 요청 시간 초과를 재정의합니다(기본값 1m30s).</block>
  <block id="3b825e283b9b4452c1ef223373ad950d" category="list-text">''--image-registry string': 내부 이미지 레지스트리의 주소/포트입니다.</block>
  <block id="ba7224837b2ded4b5b295c1012fcc2c0" category="list-text">''--k8s-timeout duration': 모든 Kubernetes 운영(기본값 3m0s)의 시간 초과.</block>
  <block id="6018142252ad7b87dc139b3235ff4fd3" category="list-text">''--kubelet-dir string': kubelet의 내부 상태(기본값 "/var/lib/kubelet")의 호스트 위치입니다.</block>
  <block id="e36f8ff54239eb329caf981624e29cb9" category="list-text">''--log-format string': Astra Trident 로깅 형식(text, json)(기본 "text").</block>
  <block id="75f452bd493d8727bcf31563cc9106b4" category="list-text">`--pv string ': Astra Trident가 사용한 레거시 PV의 이름이며, 이 이름이 존재하지 않는지 확인합니다(기본 "삼중류").</block>
  <block id="ba2a8d0773dc83972c406043a789e4dd" category="list-text">''--PVC string': Astra Trident에서 사용하는 기존 PVC의 이름인 경우 이 항목이 존재하지 않는지 확인합니다(기본 "삼중류").</block>
  <block id="6c99958eae5167b3baa561e4f7ee33f1" category="list-text">``침묵 AutoSupport’’는 AutoSupport 번들을 NetApp에 자동으로 보내지 않습니다(기본값: TRUE).</block>
  <block id="77c96d54825d934e8abaadbc0049935d" category="list-text">'--silent': 설치 중 대부분의 출력을 비활성화합니다.</block>
  <block id="daeedc3203fdc6c1fb8dfe70e2381ed3" category="list-text">'--trident-image string': 설치할 Astra Trident 이미지.</block>
  <block id="9a7a8500c6fa970d6879b522c3e33437" category="list-text">''--use-custom-YAML': 설정 디렉토리에 존재하는 기존 YAML 파일을 사용합니다.</block>
  <block id="bbf23448d408765a1240d287ed41ceff" category="list-text">''--use-ipv6: Astra Trident의 통신에는 IPv6를 사용합니다.</block>
  <block id="501416d02a886c81e8849b2f400e28a3" category="paragraph">"logs" 플래그를 실행하여 Astra Trident의 로그를 인쇄할 수 있습니다.</block>
  <block id="be8607b2dc354b7010b1464ac140fc1b" category="list-text">``A, - 아카이브' : 달리 명시하지 않는 한 모든 로그를 포함하는 지원 아카이브를 만듭니다.</block>
  <block id="d8d07479f4d5c7f0ef2b0f51407f070c" category="list-text">''-h, - 도움말: 로그 도움말.</block>
  <block id="f925a9593a051a85d10acec74988d84f" category="list-text">''-l,-log string': Astra Trident log를 표시합니다. 트리덴트|auto|트리덴트-operator|all 중 하나(기본 "자동").</block>
  <block id="d8a224d86fa21c6c564987d0848bf681" category="list-text">''--node string: 노드 POD 로그를 수집할 Kubernetes 노드 이름입니다.</block>
  <block id="a335d03b82ae4916c848dd419432f477" category="list-text">''-p, -- previous': 이전 컨테이너 인스턴스에 대한 로그가 있으면 가져옵니다.</block>
  <block id="d7d7c214e32f71943c71783fa9d5fb55" category="list-text">'--사이드카': 사이드카 컨테이너의 통나무를 가져오십시오.</block>
  <block id="3121026e841bd19d147c54ac43e423c0" category="paragraph">'send' 명령을 실행하여 Astra Trident에서 리소스를 보낼 수 있습니다.</block>
  <block id="9ce1e94be8ccb1612967a7e2cbe69a6f" category="paragraph">사용 가능한 옵션: 'AutoSupport': AutoSupport 아카이브를 NetApp에 보냅니다.</block>
  <block id="e980a564a92aa568234d9757a591756b" category="paragraph">"uninstall" 플래그를 실행하여 Astra Trident를 제거할 수 있습니다.</block>
  <block id="328865de703bbe034177e6eb51dc3d28" category="paragraph">'update' 명령어를 실행하여 Astra Trident에서 자원을 수정할 수 있다.</block>
  <block id="8680f448b33371bcb4778563a93f4702" category="paragraph">사용 가능한 옵션: "backend": Astra Trident에서 백엔드를 업데이트합니다.</block>
  <block id="87911de7a0bc3ff821f75ab303a0edc0" category="paragraph">"업그레이드" 명령을 실행하여 Astra Trident에서 리소스를 업그레이드할 수 있습니다.</block>
  <block id="70cc5172db10ac60dd0b32e57285e85c" category="paragraph">사용 가능한 옵션: 볼륨: NFS/iSCSI에서 CSI로 하나 이상의 영구 볼륨을 업그레이드합니다.</block>
  <block id="9867997bba4e250bad7411d19fce3905" category="paragraph">'tridentctl' 및 실행 중인 Trident 서비스의 버전을 인쇄하려면 'rsion' 플래그를 실행할 수 있습니다.</block>
  <block id="800f73959f4b721c78f4651c6b4b2052" category="paragraph">플래그: * `--client': 클라이언트 버전만 해당(서버 필요 없음). '-h, - 도움말': 버전 도움말.</block>
  <block id="a1582c89f8e85f372306a05848eafb68" category="summary">NetApp 스토리지 제품 포트폴리오는 Kubernetes 클러스터의 다양한 측면과 통합되어 고급 데이터 관리 기능을 제공하며, Kubernetes 구축의 기능, 기능, 성능 및 가용성을 향상합니다.</block>
  <block id="9944b094c4079f770fabc4ae629feb0f" category="doc">Kubernetes와 통합된 NetApp 제품</block>
  <block id="3cce5f3eaf76e098ba8e28f7bbba3f92" category="section-title">아스트라</block>
  <block id="293b14f82e58fc3efc27bf18185a38c8" category="paragraph"><block ref="35a6b548833df39b8bbc748563b1938b" category="inline-link-rx"></block> 퍼블릭 클라우드와 온프레미스 모두에서 Kubernetes에서 실행되는 데이터 리치 컨테이너 워크로드를 손쉽게 관리, 보호 및 이동할 수 있습니다. Astra는 퍼블릭 클라우드 및 온프레미스에 있는 NetApp의 검증되고 광범위한 스토리지 포트폴리오의 Trident를 사용하여 영구 컨테이너 스토리지를 프로비저닝하고 제공합니다. 또한, 스냅샷, 백업 및 복원, 활동 로그, 데이터 보호, 재해/데이터 복구, 데이터 감사, Kubernetes 워크로드의 마이그레이션 사용 사례를 위한 액티브 클론 복제와 같은 풍부한 고급 애플리케이션 인식 데이터 관리 기능을 제공합니다.</block>
  <block id="51fd2fc669e51c6870f1148623240f69" category="paragraph">ONTAP는 모든 애플리케이션에 고급 데이터 관리 기능을 제공하는 NetApp의 다중 프로토콜 통합 스토리지 운영 체제입니다. ONTAP 시스템은 All-Flash, 하이브리드 또는 All-HDD 구성을 제공하며 엔지니어링 하드웨어(FAS 및 AFF), 화이트박스(ONTAP Select), 클라우드 전용(Cloud Volumes ONTAP) 등 다양한 구축 모델을 제공합니다.</block>
  <block id="cbb7697b4f6f189240d043ff70ca133c" category="admonition">Trident는 위에 언급된 모든 ONTAP 배포 모델을 지원합니다.</block>
  <block id="5c04ffbd0c110bf7b37d6b95eb756b75" category="paragraph"><block ref="700b45b9fca207b66f675c8d5dfb073b" category="inline-link-rx"></block> 는 클라우드에서 ONTAP 데이터 관리 소프트웨어를 실행하는 소프트웨어 전용 스토리지 어플라이언스입니다. Cloud Volumes ONTAP를 운영 워크로드, 재해 복구, DevOps, 파일 공유 및 데이터베이스 관리에 사용할 수 있습니다. 스토리지 효율성, 고가용성, 데이터 복제, 데이터 계층화, 애플리케이션 정합성을 보장함으로써 엔터프라이즈 스토리지를 클라우드로 확장합니다.</block>
  <block id="04452ff4732608f62e53d20e4b8f4c92" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block> 은 완벽하게 관리되는 AWS 서비스로, 고객이 NetApp의 ONTAP 스토리지 운영 체제에서 제공하는 파일 시스템을 시작하고 실행할 수 있도록 지원합니다. ONTAP용 FSX를 사용하면 고객이 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에 AWS에 데이터를 저장할 때 간편성, 민첩성, 보안, 확장성을 활용할 수 있습니다. ONTAP용 FSX는 ONTAP의 다양한 파일 시스템 기능과 관리 API를 지원합니다.</block>
  <block id="27bb76bfb1e4f9966c31f5042348cd1e" category="section-title">Element 소프트웨어</block>
  <block id="231afe47f3f37d3808096b36c28b4ded" category="inline-link">요소</block>
  <block id="1fdf61a8f946268990d8e15dd9069a6d" category="paragraph"><block ref="eca39b018af81e7b5c8e71b5b4aa3790" category="inline-link-rx"></block> 스토리지 관리자가 성능을 보장하고 단순화된 스토리지 설치 공간을 활용하여 워크로드를 통합할 수 있도록 지원합니다. Element는 스토리지 관리의 모든 측면을 자동화하는 API와 결합되어 스토리지 관리자가 더 적은 노력으로 더 많은 작업을 수행할 수 있게 합니다.</block>
  <block id="08edd2123939d5309dced149763a50ee" category="section-title">NetApp HCI</block>
  <block id="25f221cc63a7e1fa55b05c29420a72a2" category="paragraph"><block ref="2841e7defe3939e68d83d007d1ad666b" category="inline-link-rx"></block> 일상적인 작업을 자동화하고 인프라 관리자가 보다 중요한 기능에 집중할 수 있도록 하여 데이터 센터의 관리 및 확장을 단순화합니다.</block>
  <block id="be17f8b9c728a6cb61cad5a2609b3888" category="paragraph">NetApp HCI는 Trident에서 완전히 지원합니다. Trident는 컨테이너화된 애플리케이션에 대한 스토리지 장치를 기본 NetApp HCI 스토리지 플랫폼에 직접 프로비저닝 및 관리할 수 있습니다.</block>
  <block id="29e7ab00082418141d470583a19c28d3" category="paragraph"><block ref="2384314bcd106c8062815b2ed789c4ad" category="inline-link-rx"></block> NetApp에서 제공하는 엔터프라이즈급 Azure 파일 공유 서비스입니다. Azure에서 기본적으로 가장 까다로운 파일 기반 워크로드를 실행하고 NetApp에서 기대하는 성능 및 강력한 데이터 관리를 제공할 수 있습니다.</block>
  <block id="a3b5183ae6f5c3f1d6644448f795b5cb" category="inline-link">Google Cloud용 NetApp Cloud Volumes Service</block>
  <block id="a1515efe69d0ac9d979af2bdfc068934" category="paragraph"><block ref="68704f3321dd8ca7029c03c29da7736a" category="inline-link-rx"></block> 는 NFS 및 SMB를 통해 NAS 볼륨을 All-Flash 성능으로 제공하는 클라우드 네이티브 파일 서비스입니다. 이 서비스를 사용하면 기존 애플리케이션을 포함한 모든 워크로드를 GCP 클라우드에서 실행할 수 있습니다. GCE(Google Compute Engine) 인스턴스에 대한 일관된 고성능, 즉각적인 복제, 데이터 보호 및 보안 액세스를 제공하는 완전 관리형 서비스를 제공합니다.</block>
  <block id="5ee08ab883e000ce6b739dbb0b6ff376" category="summary">Kubernetes 시스템 일부에 대해 자세히 알아보십시오.</block>
  <block id="607ae6360b32f1bd6e559e915d414fab" category="doc">Kubernetes 개념</block>
  <block id="d60f0fff1c23a02458849862f593357e" category="inline-link">Kubernetes 시스템</block>
  <block id="a7018a5fd7b610274c7786aa5402e64d" category="paragraph">의 각 부분에 대해 자세히 알아보십시오<block ref="f01a74527fa0343e793eb393c9d4809a" category="inline-link-rx"></block>.</block>
  <block id="fc96768681dcf6770119445ffe2537cd" category="summary">볼륨을 생성하려면 필요한 경우 지정된 Astra Trident 드라이버 이름과 함께 표준 docker 볼륨 명령을 사용합니다.</block>
  <block id="feabbbf9b5afb31194daf0d8e3ff75dc" category="doc">볼륨 작업</block>
  <block id="00e5ed77f92b42f144be7dfb7106bf10" category="paragraph">필요한 경우 지정된 Astra Trident 드라이버 이름을 사용하여 표준 docker 볼륨 명령을 사용하여 볼륨을 쉽게 생성, 클론 생성 및 제거할 수 있습니다.</block>
  <block id="dc88dce8ec264777b2f90ec0af744f43" category="section-title">볼륨을 생성합니다</block>
  <block id="a32b09b1335e0afbb640a9412690680d" category="list-text">기본 이름을 사용하여 드라이버로 볼륨을 생성합니다.</block>
  <block id="8b5708fe1297b9ca8b3be5b99bf29407" category="list-text">특정 Astra Trident 인스턴스를 사용하여 볼륨 생성:</block>
  <block id="93da65a9fd0004d9477aeac024e08e15" category="inline-link-macro">옵션</block>
  <block id="593e5c95e1adc19e8d81719c16b57bc1" category="admonition">지정하지 않은 경우 <block ref="3a0a40f90bfa29e0eb23418c553e5ef5" category="inline-link-macro-rx"></block>, 드라이버 기본값이 사용됩니다.</block>
  <block id="1e1e2461d5dfd51f1ebd0eadcba142f4" category="list-text">기본 볼륨 크기를 재정의합니다. 다음 예를 참조하여 드라이버로 20GiB 볼륨을 생성합니다.</block>
  <block id="5149eec9d959a54cf392efaa710541d1" category="admonition">볼륨 크기는 옵션 단위(예: 10G, 20GB, 3TiB)가 포함된 정수 값이 포함된 문자열로 표시됩니다. 단위를 지정하지 않으면 기본값은 G입니다 크기 단위는 2(B, KiB, MiB, GiB, TiB) 또는 10(B, KB, MB, GB, TB)의 거듭제곱으로 표현될 수 있습니다. 단축 단위는 2의 거듭제곱을 사용합니다(G=GiB, T=TiB,…).</block>
  <block id="9bc129eac7adf7ea5d8ed1c021fab2dc" category="section-title">볼륨을 제거합니다</block>
  <block id="281a0f40363a276c6ec125244c784112" category="list-text">다른 Docker 볼륨과 마찬가지로 볼륨을 제거합니다.</block>
  <block id="7959e3701f7a7fba7713c7530d496324" category="admonition">'솔드파이어-SAN' 드라이버를 사용할 때 위의 예에서는 볼륨을 삭제하고 삭제합니다.</block>
  <block id="5a1345d94751fc14bedf8f6f5e77a0ff" category="paragraph">Docker를 위한 Astra Trident를 업그레이드하려면 다음 단계를 수행하십시오.</block>
  <block id="d50044469c0bf9ab38eff9cf7243fb25" category="section-title">볼륨의 클론을 생성합니다</block>
  <block id="9374b766b9dd78063440afd69afabf38" category="list-text">볼륨을 검사하여 스냅샷을 열거합니다.</block>
  <block id="2747096689037792fa87de7a0e8440e2" category="list-text">기존 볼륨에서 새 볼륨을 생성합니다. 이렇게 하면 새 스냅샷이 생성됩니다.</block>
  <block id="31d9b5ed201aa44dbeae6d17d38c0c6f" category="list-text">볼륨의 기존 스냅샷에서 새 볼륨을 생성합니다. 새 스냅샷은 생성하지 않습니다.</block>
  <block id="516b30a46da41c6969cb7249d6567905" category="section-title">외부에서 생성된 볼륨에 액세스합니다</block>
  <block id="d8c20bb137be94fec8295c3fc5175b54" category="paragraph">Trident*만 * 을 사용하여 컨테이너별로 외부에서 생성된 블록 장치(또는 해당 클론)에 액세스할 수 있습니다. * 파티션이 없고 파일 시스템이 Astra Trident에서 지원하는 경우(예: "ext4"-formatted"/dev/sdc1"은 Astra Trident를 통해 액세스할 수 없습니다.</block>
  <block id="c2bccf4258de19dd1e03e25f66d80f98" category="summary">Docker와 함께 Astra Trident를 사용할 때 알려진 문제에 대한 정보를 확인하십시오.</block>
  <block id="3a3b7ac2e39541ea05707ccd6eb054d4" category="doc">알려진 문제 및 제한 사항</block>
  <block id="ba6bb78ba304725781af9e773f1957e2" category="paragraph">Docker에서 Astra Trident를 사용할 때 알려진 문제 및 제한 사항에 대한 정보를 확인하십시오.</block>
  <block id="8bb35988eac5a841d2af092365f1aa42" category="section-title">이전 버전에서 Trident Docker 볼륨 플러그인을 20.10 이상으로 업그레이드하면 해당 파일 또는 디렉터리 오류가 없는 업그레이드 오류가 발생합니다.</block>
  <block id="7aebfa1e2291377e040de92d7f7f335f" category="list-title">해결 방법</block>
  <block id="f49f11bc5398ac13e500d16eac424e77" category="list-text">플러그인을 비활성화합니다.</block>
  <block id="cc3dae6dd6670606c41c62b10273605e" category="list-text">플러그인을 제거합니다.</block>
  <block id="6010901b5c4bb6ad671e6f07fcc038d8" category="list-text">추가 'config' 매개 변수를 제공하여 플러그인을 다시 설치합니다.</block>
  <block id="e527ab8c1c51767e38a3603d51d2d6e5" category="section-title">볼륨 이름은 최소 2자 이상이어야 합니다.</block>
  <block id="45c9df594d13c8a5e5472503d5f14b01" category="inline-link">버그 25773을 참조하십시오</block>
  <block id="c167efd138e06a8ee59885983c5ddf69" category="admonition">이는 Docker 클라이언트의 제한 사항입니다. 클라이언트는 단일 문자 이름을 Windows 경로로 해석합니다.<block ref="f082f49b923960d888c1d98a1e9f4fcb" category="inline-link-rx"></block>.</block>
  <block id="3c4f022a33d4aace82350c9966fa238b" category="section-title">Docker Swarm에는 Astra Trident가 모든 스토리지 및 드라이버 조합에서 이를 지원하지 않는 특정 동작이 있습니다.</block>
  <block id="a7c3ff464b1ef4364de4df03d66bee5e" category="list-text">현재 Docker Swarm은 볼륨 ID 대신 볼륨 이름을 고유한 볼륨 식별자로 사용합니다.</block>
  <block id="61ab6f5cff8de89cba95d9e3bbc4ff71" category="list-text">볼륨 요청은 Swarm 클러스터의 각 노드로 동시에 전송됩니다.</block>
  <block id="521e51548c3f7c96e72d432edf4af42d" category="list-text">볼륨 플러그인(Astra Trident 포함)은 Swarm 클러스터의 각 노드에서 독립적으로 실행해야 합니다. ONTAP의 작동 방식과 'ONTAP-NAS' 및 'ONTAP-SAN' 드라이버의 작동 방식 때문에 이러한 제한 내에서 작동할 수 있는 유일한 드라이버가 됩니다.</block>
  <block id="69418caf7b92279073f695612c68de99" category="paragraph">나머지 드라이버에는 명확한 "승자" 없이 단일 요청에 대해 대량의 볼륨을 생성할 수 있는 경합 상태와 같은 문제가 있습니다. 예를 들어, Element에는 볼륨의 이름이 같지만 ID가 다를 수 있는 기능이 있습니다.</block>
  <block id="48cbf13b390ff021b130d5f372147af5" category="paragraph">NetApp은 Docker 팀에 피드백을 제공했지만, 향후 소구에 대한 표시는 제공하지 않습니다.</block>
  <block id="29cff148f43bc689eb14447b333f6f83" category="section-title">FlexGroup를 프로비저닝하고 있는 경우, 두 번째 FlexGroup에 프로비저닝되는 FlexGroup와 공통되는 하나 이상의 애그리게이트가 있는 경우 ONTAP는 두 번째 FlexGroup를 프로비저닝하지 않습니다.</block>
  <block id="0e9e734e557a02db30a20e5ac259cfb9" category="summary">각 스토리지 드라이버에는 다양한 옵션이 있으며, 볼륨 생성 시 이를 지정하여 결과를 사용자 지정할 수 있습니다. 구성된 스토리지 시스템에 적용되는 옵션은 아래를 참조하십시오.</block>
  <block id="11e1b165c1d718d825f4bb9aaf0b884e" category="doc">드라이버별 볼륨 옵션</block>
  <block id="bca0712c590c8d3c228bf1044aed730b" category="paragraph">볼륨 생성 작업 중에 이러한 옵션을 사용하는 것은 간단합니다. CLI 동작 중에 '-o' 연산자를 사용하여 옵션과 값을 제공한다. 이러한 값은 JSON 구성 파일의 모든 등가 값을 재정의합니다.</block>
  <block id="6021d91bdededf94b8ae37c30e820118" category="section-title">ONTAP 볼륨 옵션</block>
  <block id="16dc9caa069072a49db7ea7c81a7cf66" category="paragraph">NFS 및 iSCSI에 대한 볼륨 생성 옵션은 다음과 같습니다.</block>
  <block id="054b4f3ea543c990f6b125f41af6ebf7" category="cell">옵션을 선택합니다</block>
  <block id="d3a07c97b6050b305c7dda0aea1657be" category="paragraph">볼륨의 크기는 기본적으로 1GiB로 설정됩니다.</block>
  <block id="69e8c7b4f73d39cea9948875813f7ddd" category="paragraph">볼륨을 씬 또는 일반 프로비저닝합니다. 기본값은 Thin 입니다. 유효한 값은 '없음'(씬 프로비저닝) 및 '볼륨'(일반 프로비저닝)입니다.</block>
  <block id="91853d7e2338a1395280185fc93d4650" category="paragraph">그러면 스냅샷 정책이 원하는 값으로 설정됩니다. 기본값은 '없음'입니다. 즉, 볼륨에 대해 스냅샷이 자동으로 생성되지 않습니다. 스토리지 관리자가 수정하지 않는 한, "default"라는 정책이 모든 ONTAP 시스템에 존재하며, 이 정책은 6시간, 2일, 2주 스냅샷을 생성하고 유지합니다. 스냅숏에 보존되어 있는 데이터는 볼륨의 모든 디렉터리에서 '.snapshot' 디렉토리를 찾아 복구할 수 있습니다.</block>
  <block id="b8a0fde33bd7662b7b9cb4158f04ef52" category="paragraph">이렇게 하면 스냅숏 예비 공간이 원하는 비율로 설정됩니다. 기본값은 값이 없습니다. 즉, snapshotPolicy를 선택한 경우 ONTAP가 snapshotReserve(일반적으로 5%)를 선택하거나 snapshotPolicy가 none인 경우 0%를 선택합니다. 모든 ONTAP 백엔드에 대한 구성 파일에서 기본 snapshotReserve 값을 설정할 수 있으며 ONTAP-NAS-이코노미 를 제외한 모든 ONTAP 백엔드에 대한 볼륨 생성 옵션으로 사용할 수 있습니다.</block>
  <block id="0625856b9dc58db03a6e2c49b1f029e3" category="paragraph">볼륨을 클론 생성할 때 ONTAP가 상위 클론에서 즉시 클론을 분할합니다. 기본값은 false 입니다. 볼륨을 클론 복제하는 사용 사례에는 스토리지 효율성을 높일 기회가 없을 것 같기 때문에 생성 즉시 클론을 상위 볼륨에서 분리하는 것이 가장 좋습니다. 예를 들어 빈 데이터베이스를 복제하면 많은 시간을 절약할 수 있지만 스토리지 절감 효과는 거의 없으므로 즉시 클론을 분리하는 것이 좋습니다.</block>
  <block id="cdaf246fba737b75127faa65456baa30" category="paragraph">볼륨에 사용할 계층화 정책을 설정합니다. 비활성(콜드) 상태일 때 데이터를 클라우드 계층으로 이동할지 결정합니다.</block>
  <block id="1c46d85ab16f6b373409ad15260b1b0a" category="paragraph">다음 추가 옵션은 NFS * 에만 적용됩니다 *.</block>
  <block id="b145a4acc7a577d843f538580013776b" category="paragraph">볼륨 자체에 대한 권한 집합을 제어합니다. 기본적으로 사용 권한은 '---rwxr-XR-x' 또는 숫자 표기 0755로 설정되며 root는 소유자가 됩니다. 텍스트 또는 숫자 형식이 작동합니다.</block>
  <block id="76a4004d727b54162f2e0542094a89a3" category="paragraph">이것을 "참"으로 설정하면 볼륨에 액세스하는 클라이언트에 '.snapshot' 디렉토리가 표시됩니다. 기본값은 false로, 이는 '.snapshot' 디렉토리의 가시성이 기본적으로 해제되어 있음을 의미합니다. 공식 MySQL 이미지 등 일부 이미지는 '.snapshot' 디렉토리가 표시될 때 예상대로 작동하지 않습니다.</block>
  <block id="700d608597316c75fc869190f51cff49" category="paragraph">볼륨에 사용할 엑스포트 정책을 설정합니다. 기본값은 '기본값'입니다.</block>
  <block id="6b068a846d408b1d9ccd2c7220326b9d" category="paragraph">볼륨에 액세스하는 데 사용할 보안 스타일을 설정합니다. 기본값은 UNIX입니다. 유효한 값은 UNIX와 Mixed입니다.</block>
  <block id="842aac52866a44b40a5733ce352cf6df" category="paragraph">다음 추가 옵션은 iSCSI * 에만 적용됩니다 *.</block>
  <block id="3184b1a9846944fabb00496c4b6b613a" category="cell">파일 시스템 유형</block>
  <block id="56efcdcb9168adcb146b4d86bf55e99d" category="cell">iSCSI 볼륨을 포맷하는 데 사용되는 파일 시스템을 설정합니다. 기본값은 ext4 입니다. 유효한 값은 ext3, ext4, xfs입니다.</block>
  <block id="79686ba706c992e7385f0c5b28be8294" category="cell">이를 "false"로 설정하면 LUN의 공간 할당 기능이 해제됩니다. 기본값은 "true"입니다. 즉, 볼륨에 공간이 부족하고 볼륨의 LUN에서 쓰기를 허용할 수 없을 때 ONTAP에서 호스트에 알립니다. 또한 이 옵션을 사용하면 호스트가 데이터를 삭제할 때 ONTAP에서 자동으로 공간을 재확보할 수 있습니다.</block>
  <block id="ff7c0fcd6a31e735a61c001f75426961" category="section-title">예</block>
  <block id="9e6d454a094b92b0132e48d2369debf5" category="paragraph">아래 예를 참조하십시오.</block>
  <block id="be1e1c94a5fc3bb66c2ae9425eeefbdb" category="list-text">10GiB 볼륨 생성:</block>
  <block id="a6490f19f59ecd8e4ed8634990ea366c" category="list-text">스냅샷을 사용하여 100GiB 볼륨 생성:</block>
  <block id="297d0d2fcc555e5037c8d251daf5a620" category="list-text">setuid 비트가 설정된 볼륨을 생성합니다.</block>
  <block id="6e31a0481f4f7e423abcde0bf31025c8" category="paragraph">최소 볼륨 크기는 20MiB입니다.</block>
  <block id="a65684b0a191599ad968126dd65f2e9d" category="paragraph">스냅숏 예비 공간이 지정되지 않고 스냅샷 정책이 "없음"인 경우 Trident는 0%의 스냅숏 예비 공간을 사용합니다.</block>
  <block id="8c05fd71822bf85c290cef86db959f68" category="list-text">스냅숏 정책이 없고 스냅숏 예비 공간이 없는 볼륨을 생성합니다.</block>
  <block id="d15d662af6e4417b0b7c134a84ed577c" category="list-text">스냅샷 정책이 없는 볼륨 및 10%의 사용자 지정 스냅숏 예비 공간을 생성합니다.</block>
  <block id="52a56a468f11c3298931c8e32c938e15" category="list-text">스냅샷 정책 및 10%의 사용자 지정 스냅숏 예비 공간이 있는 볼륨을 생성합니다.</block>
  <block id="0a77fdb1c16069c98ebe6510137af9d2" category="list-text">스냅샷 정책을 사용하여 볼륨을 생성하고 ONTAP의 기본 스냅샷 예약 공간(일반적으로 5%)을 적용합니다.</block>
  <block id="f6f813eaaff2b296a27b6bf051485d2b" category="section-title">Element 소프트웨어 볼륨 옵션</block>
  <block id="a514753df071ac540af065b659d1c65c" category="paragraph">Element 소프트웨어 옵션은 볼륨과 연관된 서비스 품질(QoS) 정책의 크기 및 크기를 표시합니다. 볼륨을 생성할 때 해당 볼륨과 연관된 QoS 정책은 '-o type=service_level' 명명법을 사용하여 지정합니다.</block>
  <block id="f201e088f13d93e3d12b3c0ef78dece3" category="paragraph">Element 드라이버로 QoS 서비스 수준을 정의하는 첫 번째 단계는 하나 이상의 유형을 생성하고 구성 파일의 이름과 연결된 최소, 최대 및 버스트 IOPS를 지정하는 것입니다.</block>
  <block id="5cb7e4a4b6a51af0b5b09cb230b83422" category="paragraph">기타 Element 소프트웨어 볼륨 생성 옵션에는 다음이 포함됩니다.</block>
  <block id="8730c4572b866ffc01a4aefebc896555" category="paragraph">볼륨 크기, 기본값 1GiB 또는 구성 항목... "기본값":{"크기":"5G"}.</block>
  <block id="d52146098b8ecd83b888289a86e26d19" category="cell">블록사이즈</block>
  <block id="348ef18ccca06aa29547bd9ad87beebe" category="paragraph">512 또는 4096 중 하나를 사용합니다. 기본값은 512 또는 구성 항목 DefaultBlockSize 입니다.</block>
  <block id="1daf1c12549d6d3ae75c4d8d5f59d532" category="paragraph">QoS 정의가 포함된 다음 샘플 구성 파일을 참조하십시오.</block>
  <block id="7afe0c73e341cee7c90b4d4dda4600d9" category="paragraph">위 구성에서는 Bronze, Silver, Gold의 세 가지 정책 정의가 있습니다. 이러한 이름은 임의로 지정됩니다.</block>
  <block id="cb5b68dacb07bd02a5152bf4ad1de8c6" category="list-text">10GiB 골드 볼륨 생성:</block>
  <block id="89014c611c13195dc852587ef9d2bb16" category="list-text">100GiB Bronze 볼륨 생성:</block>
  <block id="23c9c608b55b9071002aeddfd6c5563c" category="summary">Astra Trident를 구축하기 전에 호스트에 필수 프로토콜 사전 요구 사항을 설치하고 구성해야 합니다.</block>
  <block id="782bd8949cb40c80fd3f3126eccab35a" category="doc">배포를 위한 사전 요구 사항</block>
  <block id="b4851e92b19af0c5c82447fc0937709d" category="inline-link-macro">요구 사항</block>
  <block id="d46ecc35447a8c17ef014ff6daf07bba" category="inline-link">설치 또는 업데이트합니다</block>
  <block id="1035fa0ac2c3ed19f6ba56cafe7e121f" category="list-text">지원되는 버전의 Docker가 설치되어 있는지 확인합니다. Docker 버전이 오래되었으면<block ref="0b011811ae105895ca4da9769d7e6f99" category="inline-link-rx"></block>.</block>
  <block id="7760c52227ccba10f5bc395571ca7a60" category="list-text">프로토콜 사전 요구 사항이 호스트에 설치 및 구성되어 있는지 확인합니다.</block>
  <block id="d2eb05d1990246a079aeb2f56e3a4237" category="paragraph">Astra Trident의 여러 인스턴스를 동일한 호스트에서 동시에 실행할 수 있습니다. 이를 통해 여러 스토리지 시스템 및 스토리지 유형에 동시에 연결할 수 있으며, Docker 볼륨에 사용되는 스토리지를 사용자 지정할 수 있습니다.</block>
  <block id="89bcbd8e4ba49b7310e9fa748e878c4b" category="inline-link-macro">배포를 위한 사전 요구 사항</block>
  <block id="88f0ab229fa9d759d74fcf6ab7cc17b1" category="section-title">Docker 관리형 플러그인 방법(버전 1.13/17.03 이상)</block>
  <block id="135b308ed83c53f1516b7c754566d1c4" category="admonition-title">시작하기 전에</block>
  <block id="070ecb002d71e4e7618a4b46a5ba690f" category="admonition">기존 데몬 방법으로 Astra Trident pRE Docker 1.13/17.03을 사용한 경우, 관리 플러그인 방법을 사용하기 전에 Astra Trident 프로세스를 중지하고 Docker 데몬을 다시 시작해야 합니다.</block>
  <block id="7bf1ee8f4e093050c1cdf1842931af7d" category="list-text">실행 중인 모든 인스턴스 중지:</block>
  <block id="47b9ec5c8c4439980c63f4188bad5324" category="list-text">Docker를 다시 시작합니다.</block>
  <block id="5311ac4d72d5c91dcaa39b896d3b8027" category="list-text">Docker Engine 17.03(새로운 1.13) 이상이 설치되어 있는지 확인합니다.</block>
  <block id="07d6db5e99a0aa19fe76f15efed30ecf" category="inline-link">설치를 설치하거나 업데이트합니다</block>
  <block id="2c3bc9d0632e0cccc05fdd3c42467df9" category="paragraph">버전이 최신 버전이 아니면<block ref="ddebe10ca17c0276898872fa2632e8fb" category="inline-link-rx"></block>.</block>
  <block id="48afbcf494fc19ee409f5aff48ae32c3" category="list-text">구성 파일을 생성하고 다음과 같이 옵션을 지정합니다.</block>
  <block id="9314e9bcd24c80b255fc3e9e697a2ada" category="list-text">config 기본 파일 이름은 config.json 이지만 원하는 이름은 파일 이름으로 config 옵션을 지정하여 사용할 수 있습니다. 구성 파일은 호스트 시스템의 '/etc/netapdvp' 디렉토리에 있어야 합니다.</block>
  <block id="8798dc2a3b5e61873054923c9f170ac7" category="list-text">로그 수준: 로깅 수준(debug, info, warn, error, fatal)을 지정합니다. 기본값은 '정보'입니다.</block>
  <block id="45ed67026a1141006588fcc698646141" category="list-text">debug: 디버그 로깅을 사용할 수 있는지 여부를 지정합니다. 기본값은 false 입니다. TRUE인 경우 로그 수준을 재정의합니다.</block>
  <block id="3bed6f89999b483af7f55024d9e7c02a" category="list-text">구성 파일의 위치를 생성합니다.</block>
  <block id="28156615c51d4bad2ee47d0a9f43f404" category="list-text">구성 파일을 생성합니다.</block>
  <block id="a4574d19d34a14aa0accde782f35318b" category="list-text">Astra Trident를 사용하여 구성된 시스템의 스토리지를 소모합니다.</block>
  <block id="a9c521f25a3bacb94ad1dd4705b3585f" category="list-text">"firstVolume"이라는 이름의 볼륨을 생성합니다.</block>
  <block id="4fbca4f67cbe96bc7d7a16691d2912c2" category="list-text">컨테이너가 시작될 때 기본 볼륨을 생성합니다.</block>
  <block id="b8e88709dbc4f2f80a96f53f83862704" category="list-text">"firstVolume" 볼륨을 제거합니다.</block>
  <block id="0e68ac1d84bfedf203365a9fb37db9ed" category="section-title">기존 방법(버전 1.12 이하)</block>
  <block id="2c1107bda4c1ae7904ab1835c35973b7" category="list-text">Docker 버전 1.10 이상이 설치되어 있는지 확인합니다.</block>
  <block id="b6fdfa2eab3e357687eba5ddec2bea0c" category="paragraph">버전이 최신 버전이 아니면 설치를 업데이트하십시오.</block>
  <block id="45c61654258cfd16ceec15df7df02138" category="inline-link">배포 지침을 따릅니다</block>
  <block id="07dff22faeb910f375341cfcbd4899fd" category="paragraph">또는,<block ref="9ce989a7f7f995616a47f5dd291ed229" category="inline-link-rx"></block>.</block>
  <block id="588d2fe1c60271cde75dbeba32e0b25b" category="list-text">시스템에 NFS 및/또는 iSCSI가 구성되어 있는지 확인합니다.</block>
  <block id="03fe5b0d58270efa87041677cac72ad7" category="list-text">NetApp Docker Volume Plugin 설치 및 구성:</block>
  <block id="f45f5a64dae951d3e37c9bd382201b06" category="list-text">응용 프로그램 다운로드 및 압축 풀기:</block>
  <block id="b255d9e06a4ca8e9f5bc31c9198426ad" category="list-text">용지함 경로의 위치로 이동:</block>
  <block id="ca8a5486f4257b2aef35a8e769fc51d9" category="list-text">바이너리를 배치하고 구성 파일을 생성한 후 원하는 구성 파일을 사용하여 Trident 데몬을 시작합니다.</block>
  <block id="d3fa61f14ead6cf1cf1d584cf0b6c4e1" category="admonition">지정하지 않는 한 볼륨 드라이버의 기본 이름은 "NetApp"입니다.</block>
  <block id="9ad37c975c341297c49c69353516a727" category="paragraph">데몬이 시작된 후에는 Docker CLI 인터페이스를 사용하여 볼륨을 생성하고 관리할 수 있습니다</block>
  <block id="e3dec3f86b9a3b1be209ab63855ce432" category="list-text">볼륨 생성:</block>
  <block id="5ff2e3e853922fdb84ef21b85ffdac2e" category="list-text">컨테이너를 시작할 때 Docker 볼륨 프로비저닝:</block>
  <block id="8f6a91f5f21d0478e3fd89095fc28ab9" category="list-text">Docker 볼륨 제거:</block>
  <block id="e63e2a2b9c9184e703ff8d93bb92508b" category="section-title">시스템 시작 시 Astra Trident를 시작합니다</block>
  <block id="5b51496da86e5a2073e0c618390c3d2a" category="list-text">파일을 올바른 위치에 복사합니다.</block>
  <block id="44103de0a164f687d305ad91e919d8ee" category="paragraph">실행 중인 인스턴스가 두 개 이상인 경우 단위 파일에 고유한 이름을 사용해야 합니다.</block>
  <block id="3223aadc84a3ccb4a3473ba01c895184" category="list-text">파일을 편집하고 설명(행 2)을 드라이버 이름과 구성 파일 경로(줄 9)에 맞게 변경하여 환경을 반영합니다.</block>
  <block id="1edae3931401a32d7dd7dd6e0a2ad563" category="list-text">IT 부서에서 변경 사항을 수집하도록 시스템 다시 로드:</block>
  <block id="db38a93e27eba57d507611d002ad612f" category="list-text">서비스를 활성화합니다.</block>
  <block id="c7e0a4deeebe264aa7d5f7f3ca3ef77f" category="paragraph">이 이름은 '/usr/lib/systemd/system' 디렉토리에 있는 파일의 이름에 따라 달라집니다.</block>
  <block id="baa04490a79e9e8de7fa4cd44e2c6fbb" category="list-text">서비스를 시작합니다.</block>
  <block id="93c7574cf83c1f01b04891cf2d826cea" category="list-text">상태를 봅니다.</block>
  <block id="f4f15418284ae7a01b27fccc1af0463a" category="admonition">단위 파일을 수정할 때마다 'stemctl daemon -reload' 명령을 실행하여 변경 사항을 확인합니다.</block>
  <block id="27dce2b92c5c5b89e353888e6cb24dea" category="summary">사용 중인 볼륨에 영향을 주지 않고 Docker용 Astra Trident를 안전하게 업그레이드할 수 있습니다. 업그레이드 프로세스 중에는 플러그인에서 지시하는 docker volume 명령이 성공하지 못하는 짧은 기간이 있으며 플러그인이 다시 실행될 때까지 응용 프로그램에서 볼륨을 마운트할 수 없습니다. 대부분의 경우 몇 초 이내에 완료됩니다.</block>
  <block id="0350c5473efd300324aaaadeecc676d2" category="doc">Astra Trident를 업그레이드하거나 제거합니다</block>
  <block id="f683581d3e75f05f9d9215f9b4696cef" category="section-title">업그레이드</block>
  <block id="ed279061e829314cb0dc7a1708ca5e5b" category="list-text">기존 볼륨 나열:</block>
  <block id="7c256ad076320e18e087b238e9063f3f" category="list-text">플러그인 비활성화:</block>
  <block id="f4ea3e4191f5bda0b91e08059bf9842a" category="list-text">플러그인 업그레이드:</block>
  <block id="b2449107a206e37587b47513f76a7b27" category="admonition">Astra Trident의 18.01 릴리스는 nDVP를 대체합니다. 'NetApp/ndvp-plugin' 이미지에서 'NetApp/트리덴트 - 플러그인' 이미지로 직접 업그레이드해야 합니다.</block>
  <block id="824ba648551a27da6c43705bcd663830" category="list-text">플러그인 활성화:</block>
  <block id="e4c48899ce42f4eb019f54a1a8e66560" category="list-text">플러그인이 활성화되어 있는지 확인합니다.</block>
  <block id="c4d884c606b57bb6cb43864e3499d5a2" category="list-text">볼륨이 표시되는지 확인합니다.</block>
  <block id="103e515a078c6f2419abc4c84554d67c" category="admonition">Astra Trident(20.10 이전)의 이전 버전에서 Astra Trident 20.10 이상으로 업그레이드하는 경우 오류가 발생할 수 있습니다. 자세한 내용은 을 참조하십시오 <block ref="6d21ff1c2708107ac3f4ed1a6e27b449" category="inline-link-macro-rx"></block>. 오류가 발생하면 먼저 플러그인을 비활성화하고 플러그인을 제거한 다음 추가 구성 매개 변수 "docker plugin install NetApp/trident-plugin:20.10 -- alias NetApp --grant-all-permissions config=config.json"을 전달하여 필요한 Astra Trident 버전을 설치해야 합니다</block>
  <block id="a27dfe771799a09fd55fea73286eb6ab" category="section-title">설치 제거</block>
  <block id="7578be09dc225364649898a30619a336" category="paragraph">Docker용 Astra Trident를 제거하려면 다음 단계를 수행하십시오.</block>
  <block id="867d93c3d1de0e8e75fa408cfadcbba5" category="list-text">플러그인이 생성한 모든 볼륨을 제거합니다.</block>
  <block id="4a28a108f39c07ac09218644ca6e9bb0" category="list-text">플러그인 제거:</block>
  <block id="4cfa22b281cbd36e1a275d61ec23a9b4" category="summary">문제 해결에 도움이 되는 로그를 수집할 수 있습니다. 로그를 수집하는 방법은 Docker 플러그인을 실행하는 방법에 따라 다릅니다.</block>
  <block id="fe1786b49549e8e06a89b9c57d7fc514" category="doc">로그를 수집합니다</block>
  <block id="83f4d02d2dd31f09291e098bf4ae502b" category="list-text">권장 관리 플러그인 방법(예: docker plugin 명령 사용)을 사용하여 Astra Trident를 실행 중인 경우 다음과 같이 봅니다.</block>
  <block id="17c40798131b12188d43b1a90dabfc69" category="paragraph">표준 로깅 수준에서는 대부분의 문제를 진단할 수 있어야 합니다. 충분하지 않은 경우 디버그 로깅을 활성화할 수 있습니다.</block>
  <block id="c28722abec5c1daefa02916119bbff91" category="list-text">디버그 로깅을 사용하려면 디버그 로깅을 사용하도록 설정한 플러그인을 설치합니다.</block>
  <block id="b142025dd533fb27bf7df1a93c55e311" category="paragraph">또는 플러그인이 이미 설치된 경우 디버그 로깅을 활성화합니다.</block>
  <block id="98e6888e14bd8bcd734870a8331ca6ea" category="list-text">호스트에서 바이너리 자체를 실행하는 경우 호스트의 '/var/log/netapp dvp' 디렉토리에서 로그를 사용할 수 있습니다. 디버그 로깅을 사용하려면 플러그인을 실행할 때 '-debug'를 지정합니다.</block>
  <block id="2aa0797ce5da04d1c6f027c9b3276483" category="section-title">일반적인 문제 해결 팁</block>
  <block id="94d799ff06bdb0aedb7b64151dac73d7" category="list-text">새 사용자가 실행하는 가장 일반적인 문제는 플러그 인을 초기화할 수 없도록 잘못 구성된 것입니다. 이 경우 플러그인을 설치하거나 활성화하려고 할 때 다음과 같은 메시지가 표시될 수 있습니다.</block>
  <block id="fe6b4529e706ebc0f7e3668d3230d029" category="paragraph">"데몬으로부터 오류 응답: UNIX/run/docker/plugins/&lt;id&gt;/NetApp.sock:connect:해당 파일 또는 디렉토리 없음</block>
  <block id="3d924bd43304301ed127cbbd303a4fa6" category="paragraph">즉, 플러그인을 시작하지 못했습니다. 다행히 플러그인은 사용자가 겪을 수 있는 대부분의 문제를 진단하는 데 도움이 되는 포괄적인 로깅 기능을 갖추고 있습니다.</block>
  <block id="79c820c2d64495c47651e58e73f97294" category="list-text">PV를 컨테이너에 마운트하는 데 문제가 있는 경우 rpcbind가 설치되어 실행되고 있는지 확인합니다. 호스트 OS에 필요한 패키지 관리자를 사용하고 rpcbind가 실행 중인지 확인합니다. 'stemctl status rpcbind' 또는 이와 동등한 기능을 실행하여 rpcbind 서비스의 상태를 확인할 수 있습니다.</block>
  <block id="2358ca3eef46b0e25466e80dbea7ea4b" category="summary">Astra Trident 구성에 사용할 수 있는 구성 옵션을 확인하십시오.</block>
  <block id="34e1f7eb303c0a150cd440611b3b5e24" category="doc">스토리지 구성 옵션</block>
  <block id="51f834b47bcd78a0f4f40fd8ca40446f" category="section-title">글로벌 구성 옵션</block>
  <block id="b22d82aea9557ba6aa7b915d40309d9b" category="paragraph">이러한 구성 옵션은 사용 중인 스토리지 플랫폼에 관계없이 모든 Astra Trident 구성에 적용됩니다.</block>
  <block id="63b276a6c28274ed5e553d4ce3fe7eb1" category="paragraph">구성 파일 버전 번호입니다</block>
  <block id="c4ca4238a0b923820dcc509a6f75849b" category="paragraph">1</block>
  <block id="ac5eb8fcbd1ed9c85a98d91e10e26a38" category="paragraph">스토리지 드라이버 이름입니다</block>
  <block id="3f2b20ce3aa5e39b0dbfe20326747a7b" category="paragraph">볼륨 이름에 대한 선택적 접두사입니다. 기본값: “netapdvp_”.</block>
  <block id="46fa46eed970046d03e2dedc95cdc83b" category="paragraph">스테이징 _</block>
  <block id="fcf783284187f1e80e772eacd9266ee1" category="paragraph">볼륨 크기에 대한 선택적 제한. 기본값: ""(강제 적용 안 됨)</block>
  <block id="75da9d6de91e782eca4fa00341367135" category="paragraph">10G</block>
  <block id="3eed2a7dac1f2329f3a9574a68e5e1c4" category="admonition">요소 백엔드에 'toragePrefix'(기본값 포함)를 사용하지 마십시오. 기본적으로 '졸idfire-san' 드라이버는 이 설정을 무시하고 접두어를 사용하지 않습니다. Docker 볼륨 매핑에 특정 tenantID를 사용하거나 이름 문지가 사용된 경우 Docker의 Docker 버전, 드라이버 정보 및 원시 이름으로 채워진 특성 데이터를 사용하는 것이 좋습니다.</block>
  <block id="0863f9e97e159e3ea1ce46bdb49b1254" category="paragraph">생성하는 모든 볼륨에서 기본 옵션을 지정하지 않아도 됩니다. '크기' 옵션은 모든 컨트롤러 유형에 사용할 수 있습니다. 기본 볼륨 크기를 설정하는 방법은 ONTAP 구성 섹션을 참조하십시오.</block>
  <block id="41ad23e0468b5a035cae097ac8b28bb9" category="paragraph">새 볼륨의 선택적 기본 크기입니다. 기본값: “1G”</block>
  <block id="08aa1584c9a5791fb64b0f7f1453f9eb" category="paragraph">10G</block>
  <block id="0353522b39b87d54d40d3f09ec668851" category="section-title">ONTAP 구성</block>
  <block id="cd536bce1bed61366e8d17a85fe6678a" category="paragraph">위의 글로벌 구성 값 외에도 ONTAP를 사용할 경우 다음과 같은 최상위 옵션을 사용할 수 있습니다.</block>
  <block id="464779f3491153dd1e79ddbd8a81e3f0" category="paragraph">ONTAP 관리 LIF의 IP 주소입니다. FQDN(정규화된 도메인 이름)을 지정할 수 있습니다.</block>
  <block id="190dafab69706a67221c1226360de7dc" category="paragraph">10.0.0.1</block>
  <block id="98a2cd7efa1ba950d42e42af495c4248" category="paragraph">10.0.0.2</block>
  <block id="11053eb2b6ac6e8802c67c054cf55ad9" category="paragraph">사용할 스토리지 가상 머신(관리 LIF가 클러스터 LIF인 경우 필요)</block>
  <block id="b26399fddd6473c150b4e7528fb04fdc" category="paragraph">SVM_NFS 를 클릭합니다</block>
  <block id="723a179bbb9fc3c4f12cf296a8841b27" category="paragraph">스토리지 디바이스에 접속할 사용자 이름입니다</block>
  <block id="6173aa5206484b5224450952747c7148" category="paragraph">vsadmin을 선택합니다</block>
  <block id="8cf10281cf3b9290d5988c57a7d19693" category="paragraph">스토리지 디바이스에 연결하는 암호입니다</block>
  <block id="5ebe2294ecd0e0f08eab7690d2a6ee69" category="paragraph">비밀</block>
  <block id="7e6d207f2b120c6cc9caa98510aa51c6" category="cell">골재</block>
  <block id="ac53191a99c328660eafa4696375dbfb" category="paragraph">프로비저닝을 위한 애그리게이트(선택 사항, SVM에 셋팅해야 하는 경우) ONTAP-NAS-Flexgroup 드라이버의 경우 이 옵션이 무시됩니다. SVM에 할당된 모든 애그리게이트는 FlexGroup 볼륨을 프로비저닝하는 데 사용됩니다.</block>
  <block id="70d2c7701d2837552c0a38c02a326592" category="paragraph">aggr1</block>
  <block id="925060a0c0a15f99ef1bee43f1660ea4" category="paragraph">선택 사항으로, 사용량이 이 백분율보다 높을 경우 용량 할당에 실패합니다</block>
  <block id="f819de81247be4a5428dc0e169de28b8" category="paragraph">75%</block>
  <block id="876885770cf58d20ef5672cc5594e85d" category="inline-link">NFS 호스트 구성 정보는 여기 를 참조하십시오</block>
  <block id="0a19ca3d1db7e5bc24b58f73b91c3f49" category="paragraph">NFS 마운트 옵션을 세밀하게 제어합니다. 기본값은 "-o nfsvers=3"입니다. * ONTAP-NAS 및 ONTAP-NAS-이코노미 드라이버에만 사용 가능 *.<block ref="71f7a3f48cfd3876cffba401813b7db0" category="inline-link-rx"></block>.</block>
  <block id="301c869c551e12d862ab0291837102a0" category="paragraph">o nfsvers = 4</block>
  <block id="00d72747af4eb1f0bab120935efe88fe" category="paragraph">플러그인에서 사용되는 igroup. 기본값은 “netapdvp”입니다. * ONTAP-SAN driver * 에서만 사용 가능.</block>
  <block id="79e762988462f6f8da9becfbfd789755" category="paragraph">myigroup</block>
  <block id="5c5adadf8175fd69d4af9bfdb608c42c" category="paragraph">최대 요청 가능 볼륨 크기 및 qtree 상위 볼륨 크기. * 이 옵션은 'ONTAP-NAS-이코노미' 드라이버의 경우 FlexVol의 크기를 추가로 제한합니다 *.</block>
  <block id="f07e606cfe25ac6fb07d9c4af941d9a2" category="paragraph">300g</block>
  <block id="981ba910eb0ffc42f42059de056624b4" category="paragraph">FlexVol당 최대 qtree는 범위 [50, 300]에 있어야 하며 기본값은 200입니다. * 'ONTAP-NAS-이코노미' 드라이버의 경우 이 옵션을 사용하여 FlexVol*당 최대 qtree 수를 사용자 지정할 수 있습니다.</block>
  <block id="94f6d7e04a4d452035300f18b984988c" category="paragraph">300</block>
  <block id="3890063556e337d458019437f027030b" category="paragraph">생성하는 모든 볼륨에 기본 옵션을 지정하지 않아도 됩니다.</block>
  <block id="887ba6a0090fff5ace8889efb3b766af" category="paragraph">공간 예약 모드, "없음"(씬 프로비저닝) 또는 "볼륨"(일반)</block>
  <block id="334c4a4c42fdb79d7ebc3e73b517e6f8" category="paragraph">없음</block>
  <block id="b614ecafc9c9bbcd0206b519e5481f8d" category="paragraph">사용할 스냅샷 정책, 기본값은 "없음"입니다.</block>
  <block id="e35ead0e9e7038a6c58695bfa4741686" category="paragraph">Snapshot reserve percentage, 기본값은 ""이며 ONTAP의 기본값을 사용합니다</block>
  <block id="d3d9446802a44259755d38e6d163e820" category="paragraph">10</block>
  <block id="eb28cb6308c229ba4561cf02d78b9a07" category="paragraph">생성 시 복제본을 상위 복제본에서 분할합니다. 기본값은 "false"입니다.</block>
  <block id="b326b5062b2f0e69046810717534cb09" category="paragraph">참</block>
  <block id="a3b703e23c8d0caf2b2fb4f46057013b" category="paragraph">프로비저닝된 NFS 볼륨에 대한 NAS 옵션, 기본값: “777”</block>
  <block id="f1c1592588411002af340cbaedd6fc33" category="paragraph">777</block>
  <block id="525eba0ced0a1c122a9112c4d10fbdc2" category="paragraph">".snapshot" 디렉토리에 액세스하기 위한 NAS 옵션은 기본적으로 "false"로 설정됩니다.</block>
  <block id="b60dd25e9d373b87424c30a74da2703f" category="paragraph">사용할 NFS 엑스포트 정책의 NAS 옵션, 기본값: "기본값"</block>
  <block id="c21f969b5f03d33d43e04f8f136e7682" category="paragraph">기본값</block>
  <block id="79c6531f572824f3178c8b1fb0f35d26" category="paragraph">파일 시스템 유형을 선택하는 SAN 옵션, 기본값은 "ext4"로 설정됩니다.</block>
  <block id="310201b6353c5f38bc039e0e51b079d3" category="paragraph">XFS</block>
  <block id="3cec6d01b4f10a61939982ecfb47fc7f" category="paragraph">사용할 계층화 정책, 기본값은 "없음", ONTAP 9.5 이전 SVM-DR 구성의 경우 "스냅샷 전용"입니다</block>
  <block id="90adf331b7868c7af46ad6e035e93844" category="section-title">축척 옵션</block>
  <block id="493a6606c4789fad3c7317b99cb563d0" category="paragraph">ONTAP-NAS와 ONTAP-SAN 드라이버는 각 Docker 볼륨에 대해 ONTAP FlexVol를 생성합니다. ONTAP는 최대 12,000개의 FlexVol 클러스터를 사용하여 클러스터 노드당 최대 1,000개의 FlexVol을 지원합니다. Docker 볼륨 요구 사항이 이러한 제한 범위 내에 있을 경우 Docker 볼륨 세부 스냅샷 및 클론 복제와 같은 FlexVol에서 제공되는 추가 기능 때문에 'ONTAP-NAS' 드라이버가 선호되는 NAS 솔루션입니다.</block>
  <block id="b8f30e4086b754ccaf7bd5d01d8df137" category="paragraph">FlexVol에 허용 가능한 것보다 더 많은 Docker 볼륨이 필요한 경우 ONTAP-NAS-이코노미 또는 ONTAP-SAN-이코노미 드라이버를 선택합니다.</block>
  <block id="50710f3a4715e3f874848944b6b54e28" category="paragraph">'ONTAP-NAS-이코노미' 드라이버는 자동으로 관리되는 FlexVol 풀 내에 ONTAP qtree로 Docker 볼륨을 생성합니다. qtree는 일부 기능을 희생하여 클러스터 노드당 최대 100,000 및 클러스터당 2,400,000까지 훨씬 더 뛰어난 확장을 제공합니다. 'ONTAP-NAS-G경제적인' 드라이버는 Docker 볼륨의 세분화된 스냅샷 또는 클론 복제를 지원하지 않습니다.</block>
  <block id="0c8b91c6c2ba9c892f3eea2cd9c86cd1" category="admonition">Swarm은 여러 노드에서 볼륨 생성을 조율하지 않으므로 현재 Docker Swarm에서 ONTAP-NAS-이코노미 드라이버가 지원되지 않습니다.</block>
  <block id="5849dbe631db5b1e1b365f9f2f84ff60" category="paragraph">ONTAP-SAN-이코노미 드라이버는 자동으로 관리되는 FlexVol의 공유 풀 내에 Docker 볼륨을 ONTAP LUN으로 생성합니다. 이렇게 하면 각 FlexVol가 하나의 LUN에만 제한되지 않으며 SAN 워크로드에 더 나은 확장성을 제공합니다. 스토리지 시스템에 따라 ONTAP는 클러스터당 최대 16384개의 LUN을 지원합니다. 볼륨이 그 아래에 LUN이 있으므로 이 드라이버는 Docker 볼륨 세부 스냅샷 및 클론 복제를 지원합니다.</block>
  <block id="65e92c8f7fa9750b795cc1046328cf06" category="paragraph">수십 억 개의 파일로 구성된 페타바이트 용량으로 확장할 수 있는 단일 볼륨의 병렬 처리를 늘리려면 ONTAP-NAS-Flexgroup 드라이버를 선택하십시오. FlexGroups의 이상적인 사용 사례로는 AI/ML/DL, 빅데이터 및 분석, 소프트웨어 빌드, 스트리밍, 파일 저장소 등이 있습니다. Trident는 FlexGroup 볼륨을 프로비저닝할 때 SVM에 할당된 모든 애그리게이트를 사용합니다. Trident의 FlexGroup 지원에도 다음과 같은 고려 사항이 있습니다.</block>
  <block id="9d83b6d2e2b099e63bf8e2fc8c870893" category="list-text">ONTAP 버전 9.2 이상이 필요합니다.</block>
  <block id="e7c74973b26ad51b9db42a9c347a8cd4" category="list-text">이번 작부터 FlexGroups는 NFS v3만 지원합니다.</block>
  <block id="02a100b04add3b90fddef64499e825a2" category="list-text">SVM에 대해 64비트 NFSv3 식별자를 사용하는 것이 좋습니다.</block>
  <block id="496f8625569b787269edab0f3de973da" category="list-text">최소 권장 FlexGroup 크기는 100GB입니다.</block>
  <block id="db78b2a7acf43fa03cd95fb3a77c82f9" category="list-text">FlexGroup 볼륨에 대해서는 클론 생성이 지원되지 않습니다.</block>
  <block id="f5ac1e3c252855373c7f660dbd89699d" category="inline-link">NetApp FlexGroup 볼륨 모범 사례 및 구현 가이드 를 참조하십시오</block>
  <block id="df1a7e79743809601db1d20d6a33ae52" category="paragraph">FlexGroups에 적합한 FlexGroups 및 워크로드에 대한 자세한 내용은 를 참조하십시오<block ref="b8a99695d7979127a1cab07b42e22743" category="inline-link-rx"></block>.</block>
  <block id="b30b6b60171d85877ea91897bdd6faed" category="paragraph">같은 환경에서 고급 기능과 대규모 확장을 위해 ONTAP-NAS를 사용하는 Docker Volume Plugin과 ONTAP-NAS-E경제적인 인스턴스를 여러 개 실행할 수 있습니다.</block>
  <block id="0c0f6724044ed44fb85d2ce3193cb7c3" category="section-title">ONTAP 구성 파일의 예</block>
  <block id="9420b5e8ed08a163eeafb1d5026f74be" category="paragraph">* 'ONTAP-NAS' 드라이버용 NFS 예 *</block>
  <block id="c26e7b2e60e156979940cd72ed83d0b9" category="paragraph">* 'ONTAP-NAS-Flexgroup' 드라이버의 NFS 예 *</block>
  <block id="3a57e82fd5f9855754a03019c433aff7" category="paragraph">* 'ONTAP-NAS-이코노미' 드라이버용 NFS 예 *</block>
  <block id="2bfad97b56e71c619e45f6d4c2e4c2e2" category="paragraph">* 'ONTAP-SAN' 드라이버용 iSCSI 예 *</block>
  <block id="98f803effb81ad687bcd941b70439aaa" category="paragraph">* 'ONTAP-SAN-이코노미' 드라이버용 NFS 예시 *</block>
  <block id="ffe54c343031d16e77db73e2d950e277" category="section-title">Element 소프트웨어 구성</block>
  <block id="3afcd136a7bffa20fc39ba6581412cd2" category="paragraph">Element 소프트웨어(NetApp HCI/SolidFire)를 사용하는 경우 글로벌 구성 값 외에도 이러한 옵션을 사용할 수 있습니다.</block>
  <block id="c61f15977fe4efa0866eea87fb740cda" category="paragraph">iSCSI IP 주소 및 포트</block>
  <block id="6a6b63874c664c103982f6d422c6384e" category="paragraph">10.0.0.7:3260</block>
  <block id="72deb2676231ab8e068ef60dd89edd4c" category="paragraph">사용할 SolidFireF 테넌트(찾을 수 없는 경우 생성됨)</block>
  <block id="5eda5112bf8affeb1d2cd8eea6302076" category="paragraph">“Docker”</block>
  <block id="d2672389886b173aef703433f7e4b89b" category="paragraph">iSCSI 트래픽을 기본 인터페이스가 아닌 인터페이스로 제한할 때 인터페이스를 지정합니다</block>
  <block id="5935dcd024929bc7086bb230802bf576" category="paragraph">아래 예를 참조하십시오</block>
  <block id="5e9bf55f849ccc5a31a50d1fa784d28c" category="cell">레가시NamePrefix</block>
  <block id="db7adc3775b0b56c59ce4263fbd79fbf" category="paragraph">업그레이드된 Trident 설치의 접두사 1.3.2 이전 버전의 Trident를 사용하고 기존 볼륨을 업그레이드하는 경우 이 값을 설정하여 볼륨 이름 방법을 통해 매핑된 이전 볼륨에 액세스해야 합니다.</block>
  <block id="8d3aa50a0f9c3c059677927a3fbbfcda" category="paragraph">“netapdvp-”</block>
  <block id="36f9c7b615268efec7f4c56c387a55bb" category="paragraph">졸idfire-san 드라이버는 Docker Swarm을 지원하지 않습니다.</block>
  <block id="1059bb8540c48e6b455e802384bad65d" category="section-title">Element 소프트웨어 구성 파일의 예</block>
  <block id="1a269fb3ec0496720ca75e984d8de40e" category="cell">hostProjectNumber입니다</block>
  <block id="1631dca111b8c1a922c7f29d48eb7121" category="cell">네트워크</block>
  <block id="c412f3b9b270250331aa1ef4102ef8c1" category="summary">여러 스토리지 구성을 동시에 사용할 수 있도록 하려는 경우 Astra Trident의 여러 인스턴스가 필요합니다. 여러 인스턴스의 핵심은 컨테이너형 플러그인에서 -alias 옵션을 사용하거나 호스트에서 Trident를 인스턴스화할 때 -volume-driver 옵션을 사용하여 다른 이름을 지정하는 것입니다.</block>
  <block id="4f07a71d2e33da91dec1396b7a204a40" category="doc">여러 Astra Trident 인스턴스를 관리합니다</block>
  <block id="8f327f2ceda84404290184a7454160ed" category="paragraph">여러 스토리지 구성을 동시에 사용할 수 있도록 하려는 경우 Trident의 여러 인스턴스가 필요합니다. 여러 인스턴스의 핵심은 컨테이너형 플러그인과 함께 '- alias' 옵션을 사용하거나 호스트에서 Trident를 인스턴스화할 때 '- volume-driver' 옵션을 사용하여 다른 이름을 지정하는 것입니다.</block>
  <block id="52ef1c6ffefaba3249f208369424635d" category="section-title">Docker 관리 플러그인 단계(버전 1.13/17.03 이상)</block>
  <block id="547c4a5f7c863aad85f5265c03ed72ea" category="list-text">별칭 및 구성 파일을 지정하는 첫 번째 인스턴스를 시작합니다.</block>
  <block id="991ac134f22efa2bb955362d95827ae5" category="list-text">다른 별칭과 구성 파일을 지정하여 두 번째 인스턴스를 시작합니다.</block>
  <block id="aa0dc0ac69e69c434317798e1aa9842b" category="list-text">별칭을 드라이버 이름으로 지정하는 볼륨을 생성합니다.</block>
  <block id="5ae25a45ab76de161f87fc41a84f746d" category="paragraph">예를 들어 금괴 볼륨의 경우:</block>
  <block id="6dab7c53f6e3de2eae52e928dfe5b861" category="paragraph">예를 들어, 은 볼륨의 경우:</block>
  <block id="67754cb209925946943e297b3a8be344" category="section-title">기존(버전 1.12 이하) 단계</block>
  <block id="cbd128765e82966ed5e454a99b22e688" category="list-text">사용자 지정 드라이버 ID를 사용하여 NFS 구성으로 플러그인을 시작합니다.</block>
  <block id="51c923daa4caf6aea6d24201b73871b6" category="list-text">사용자 지정 드라이버 ID를 사용하여 iSCSI 구성으로 플러그인을 시작합니다.</block>
  <block id="dd72ade865d731ba8f6a6fc4c8ccd86f" category="list-text">각 드라이버 인스턴스에 Docker 볼륨 프로비저닝:</block>
  <block id="8e2044cc9d4e8f515ad4809a68d75465" category="paragraph">예를 들어, NFS의 경우:</block>
  <block id="d39eb6e4299503c5d451d19b9645be42" category="paragraph">예를 들어 iSCSI의 경우:</block>
  <block id="b928e0aee19c1e2cc91c85e8a0856936" category="summary">Astra Trident를 설치 및 사용하는 동안 발생할 수 있는 문제를 해결하려면 여기에 제공된 포인터를 사용하십시오.</block>
  <block id="231cf4c70d866b616c21baddaeed0696" category="doc">문제 해결</block>
  <block id="8ef0ab9bbedaa7608c9abed7c7213218" category="admonition">Astra Trident에 대한 도움을 받으려면 'tridentctl logs-a-n tri덴트'를 사용하여 지원 번들을 생성한 후 'NetApp Support&lt;Getting Help&gt;'로 보내십시오.</block>
  <block id="40e41fb2db11266b8f751c0d5c67cba0" category="inline-link">NetApp Knowledgebase(로그인 필요)</block>
  <block id="01005ecf4349194d1ec13d0ba516c9e5" category="admonition">문제 해결 문서의 전체 목록을 보려면 을 참조하십시오<block ref="57f5c759ada931c6a2051314ca6ee99e" category="inline-link-rx"></block>. Astra와 관련된 문제 해결에 대한 정보도 찾을 수 있습니다<block ref="695f48b1d8b7348c0e2828947d24161e" category="inline-link-rx"></block>.</block>
  <block id="163fb9eb00818e2c7109900db1a3cc82" category="section-title">일반 문제 해결</block>
  <block id="f504c27d1ad305a988958b64f34468cb" category="list-text">Trident 포드가 제대로 표시되지 않으면(예: 두 개 미만의 준비된 컨테이너로 'ContainerCreating' 단계에 Trident 포드가 들러붙은 경우) kubeck-n trident t덴트 설명 배포 트리덴트를 실행하고 'kebctl-n trident tor stand' kudl-********** 를 실행합니다 이 밖에도 많은 정보를 얻을 수 있습니다. 쿠벨렛 로그(예: 저널링ctl-xeu kubelet)를 얻는 것도 도움이 될 수 있습니다.</block>
  <block id="05d68d1b7214c73141ed12aaed0c2ab5" category="list-text">Trident 로그에 충분한 정보가 없으면 설치 옵션에 따라 설치 매개 변수에 '-d' 플래그를 전달하여 Trident에 대한 디버그 모드를 활성화할 수 있습니다.</block>
  <block id="bc6de9cad530a57dba08ff711f4a6b5f" category="paragraph">그런 다음 디버그가 "./tridentctl logs -n triment"를 사용하여 설정되었는지 확인하고 로그에서 level=debug msg를 검색합니다.</block>
  <block id="8e95ae46f32b05cf983c93e608530e36" category="list-text">운영자와 함께 설치됩니다</block>
  <block id="6a304a6cf7cd8c90bac892ab0fb9c134" category="paragraph">Astra Trident 20.07 및 20.10의 경우 Torc 대신 tprov를 사용합니다.</block>
  <block id="79b91d0489c081de6794796638793787" category="list-text">헬름과 함께 설치</block>
  <block id="d356d628089d439d75e3f85564372658" category="list-text">tridentctl과 함께 설치됩니다</block>
  <block id="87248f7afe198418bdbedd919695631e" category="list-text">또한 백엔드 정의에 debugTraceFlags를 포함하여 각 백엔드에 대한 디버그 로그를 얻을 수 있습니다. 예를 들어, debugTraceFlags:{"API":true, "method":true,}"를 포함하여 Trident 로그에 API 호출 및 메서드 트래버스된 메서드를 가져옵니다. 기존 백엔드는 tridentctl 백엔드 업데이트로 debugTraceFlags를 구성할 수 있습니다.</block>
  <block id="6cc37a0664d7f97f87d34eadef23dbad" category="list-text">RedHat CoreOS를 사용할 때는 작업자 노드에서 iscsid가 활성화되어 있고 기본적으로 시작되는지 확인합니다. 이 작업은 OpenShift MachineConfigs를 사용하거나 점화 템플릿을 수정하여 수행할 수 있습니다.</block>
  <block id="4582245538a41243a95713a7d0c21b64" category="list-text">에서 Trident를 사용할 때 일반적으로 발생할 수 있는 문제입니다<block ref="4568986ef6397d7c901269fc0e190ede" category="inline-link-rx"></block> 테넌트 및 클라이언트 암호가 권한이 부족한 앱 등록에서 나오는 경우 입니다. Trident 요구사항의 전체 목록은 를 참조하십시오 <block ref="c09112d17e34405b7a5c3d246f91583f" category="inline-link-macro-rx"></block> 구성.</block>
  <block id="7f0ecdfa510b31b01d331c2760643b83" category="list-text">PV를 컨테이너에 마운트하는 데 문제가 있는 경우 rpcbind가 설치되어 실행되고 있는지 확인합니다. 호스트 OS에 필요한 패키지 관리자를 사용하고 rpcbind가 실행 중인지 확인합니다. 'stemctl status rpcbind' 또는 이와 동등한 기능을 실행하여 rpcbind 서비스의 상태를 확인할 수 있습니다.</block>
  <block id="78aeadc89feb4cf244398a7d35a0d656" category="list-text">Trident 백엔드가 이전에 작업을 수행했음에도 불구하고 "실패" 상태에 있다고 보고할 경우 백엔드와 연결된 SVM/관리 자격 증명을 변경하면 원인일 수 있습니다. 'tridentctl update backend'를 사용하여 백엔드 정보를 업데이트하거나 Trident POD를 바운딩하면 이 문제가 해결됩니다.</block>
  <block id="dd5955dd3991dcacca2b395215df8ecd" category="list-text">베타 볼륨 스냅샷을 사용하도록 Kubernetes 클러스터 및/또는 Trident를 업그레이드할 경우 기존의 모든 알파 스냅샷 CRS가 완전히 제거되었는지 확인합니다. 그런 다음 "tridentctl oblividate alpha-snapshot-crd" 명령을 사용하여 알파 스냅샷 CRD를 삭제할 수 있습니다. 을 참조하십시오<block ref="f3109660248c628e79ddf256944df58b" category="inline-link-rx"></block> 알파 스냅샷 마이그레이션 단계를 이해합니다.</block>
  <block id="b851cfc28cd6e5cb9aaf87bdb59a68aa" category="list-text">Docker를 컨테이너 런타임으로 사용하여 Trident를 설치할 때 권한 문제가 발생하면 '--in cluster=false' 플래그를 사용하여 Trident를 설치해 보십시오. 설치자 포드는 사용하지 않고 설치자 이용으로 인한 권한 문제를 피한다.</block>
  <block id="6f7d49547ff47cfaf1fd93d134b603be" category="list-text">실패한 실행 후 정리 작업을 위해 'uninstall parameter &lt;uninstall Trident&gt;'를 사용합니다. 기본적으로 이 스크립트는 Trident에서 만든 CRD를 제거하지 않으므로 실행 중인 구축에서도 안전하게 제거한 후 다시 설치할 수 있습니다.</block>
  <block id="f1112223b41fddc71fd6a626582dfb78" category="inline-link">Trident 버전</block>
  <block id="7dc9f8824c461c84d9bb1563a0615526" category="list-text">Trident를 완전히 제거하려면 'tridentctl oblividate CRD' 명령을 실행합니다. 그러면 모든 CRD 객체가 제거되고 CRD의 정의가 해제됩니다. Trident는 이미 프로비저닝한 PVS를 더 이상 관리하지 않습니다.</block>
  <block id="e7fc3eac0c0cea530e0f52e3ddf37079" category="admonition">이 후 Trident를 처음부터 다시 구성해야 합니다.</block>
  <block id="51748ba3d16ecfd8c45c7ebf2043b738" category="list-text">설치가 성공적으로 완료된 후 PVC가 보류 단계에 고착되면 kubeck tl t설명해 PVC를 실행하면 Trident가 이 PVC에 대한 PV를 프로비저닝하지 못한 이유에 대한 추가 정보가 제공됩니다.</block>
  <block id="a900bd1dbd5690f78a30ca74d138d0b7" category="section-title">연산자를 사용하여 실패한 Trident 배포 문제 해결</block>
  <block id="0e89989064bf4afdc37fd5a7be4f607d" category="paragraph">연산자를 사용하여 Trident를 배포하는 경우 트리펜터터의 상태가 Installing에서 Installed로 변경됩니다. 'Failed(실패)' 상태를 확인하고 운용자가 자체적으로 복구할 수 없는 경우 다음 명령어를 실행해 운용자의 로그를 확인해야 한다.</block>
  <block id="df9771dbb13da45493e576499910c0b4" category="paragraph">삼원 운영자 컨테이너의 로그를 뒤로하면 문제가 있는 위치를 가리킬 수 있습니다. 예를 들어, 이러한 문제 중 하나는 Airgapped 환경의 업스트림 등록부에서 필요한 컨테이너 이미지를 가져올 수 없는 것일 수 있습니다.</block>
  <block id="0fd4c6187c561958bc76052df7774593" category="paragraph">Trident의 설치가 실패한 이유를 이해하려면 '트리엔트오케스트레이터' 상태를 살펴보아야 합니다.</block>
  <block id="1e054f4c292a5388d6318461fe73d749" category="paragraph">이 오류는 Trident를 설치하는 데 사용된 '트리엔오케스트레이터'가 이미 있음을 나타냅니다. 각 Kubernetes 클러스터에는 Trident의 인스턴스가 하나만 있을 수 있으므로 운영자는 언제든지 생성할 수 있는 활성 'Trident Orchestrator'가 하나만 존재하도록 합니다.</block>
  <block id="568fcf9beb0dbd37c57dff251a3164ed" category="paragraph">또한 Trident Pod의 상태를 관찰하면 무언가 잘못되었음을 나타내는 경우가 많습니다.</block>
  <block id="f89c17ddb9f8bdaf5c95a466d5f6a500" category="paragraph">하나 이상의 컨테이너 이미지를 가져오지 않았기 때문에 포드를 완전히 초기화할 수 없다는 것을 분명히 알 수 있습니다.</block>
  <block id="d57d1a6de03b2ddf3ee54f680152e2b6" category="paragraph">이 문제를 해결하려면 트리엔오케스트레이터 CR을 편집해야 합니다. 또는 '트리엔오케스트레이터'를 삭제하고 수정되고 정확한 정의를 가진 새 정의를 만들 수 있습니다.</block>
  <block id="021e9ae5361eb14975bf9a30f99770f5" category="paragraph">무엇이 잘못되었는지 알 수 있도록 디버그 모드를 켜고 무엇이 문제인지 이해하는 데 도움이 되는 ''-d' 인수를 사용하여 설치 프로그램을 다시 실행할 수 있습니다.</block>
  <block id="01539f4f1fd20792cbbae6bb0506cc20" category="paragraph">이 문제를 해결한 후 다음과 같이 설치를 정리한 다음 'tridentctl install' 명령을 다시 실행할 수 있습니다.</block>
  <block id="d327e8f24b63b83e091dccdc48dd7b1b" category="sidebar">Astra Trident 문서</block>
  <block id="7d0ee6fed10d3d4e5c9ee496729ab519" category="sidebar">릴리스 정보</block>
  <block id="93168a8084b3e838d2932c4734bd234e" category="sidebar">이전 버전</block>
  <block id="1fe917b01f9a3f87fa2d7d3b7643fac1" category="sidebar">FAQ 를 참조하십시오</block>
  <block id="312b0dc38b01ff32c1b2f5f81ee1ab2d" category="sidebar">Trident 연산자를 사용하여 배포합니다</block>
  <block id="6a693eb5cd23e4e5743663c7edc37aed" category="sidebar">Docker를 위한 Astra Trident 구축</block>
  <block id="386307d41b3f4169a1e6e046a727cdd2" category="sidebar">Trident 연산자를 사용하여 업그레이드합니다</block>
  <block id="eb1f347fa6176ae2c9175df3bc414954" category="sidebar">Astra Trident를 사용해 보십시오</block>
  <block id="81a123ccab93cd947289b672b0e50348" category="sidebar">데모 자습서</block>
  <block id="28348a71bed382b86fa6de4d3a307715" category="sidebar">Astra Trident 비디오</block>
  <block id="813011e2103649bb71f124adedcc10ea" category="sidebar">블로그 커뮤니티</block>
  <block id="6394eceb2639574114b02e6e817eb19a" category="sidebar">Astra 블로그</block>
  <block id="874d8a5301794a9ca2aba132ac2460f3" category="sidebar">쿠버네티스 허브</block>
  <block id="d59c00abbeaf33a9a094b3a69c563405" category="sidebar">NetApp.IO를 참조하십시오</block>
  <block id="0460583622f03a52d7693094d6fa2452" category="sidebar">개념</block>
  <block id="c949166d6970748c0094c800daa3324a" category="sidebar">Astra Trident 관리</block>
  <block id="a20f982d79c3dd66d244ffe0f7d940ee" category="sidebar">모범 사례 및 권장사항</block>
  <block id="c91cf7abea9584bc1edbc8ff4948ada0" category="sidebar">Astra Trident 통합</block>
  <block id="58eaebf972358f1cf03d386a4ade1a0f" category="sidebar">다음 단계</block>
  <block id="63d5049791d9d79d86e9a108b0a999ca" category="sidebar">참조하십시오</block>
  <block id="324fb1352ffffb105d10013810c42896" category="sidebar">Kubernetes 및 Astra Trident 오브젝트</block>
  <block id="f14894e4c400a400c02367258a93029a" category="sidebar">Docker를 위한 Astra Trident</block>
  <block id="e08bfc79c5202517b3814efd6e82fb2c" category="sidebar">Trident 업그레이드 또는 제거</block>
  <block id="cf282b9c05ab0f84b1690e644cd3f68e" category="list-text">ONTAP-NAS-Flexgroup 드라이버의 경우 각 PV(Persistent Volume)가 FlexGroup에 매핑됩니다. 따라서 볼륨 스냅샷이 NetApp FlexGroup 스냅샷으로 생성됩니다. NetApp의 스냅샷 기술은 경쟁 스냅샷 기술보다 뛰어난 안정성, 확장성, 복구 가능성 및 성능을 제공합니다. 이러한 스냅샷 복사본은 생성하는 데 필요한 시간과 스토리지 공간 모두에서 매우 효율적입니다.</block>
  <block id="b89df534de66f446ec6482f9d7898bb2" category="cell">'controllerPluginNodeSelector'</block>
  <block id="8d414af35aeb82413205fa45551a5545" category="cell">기본값 없음, 선택 사항</block>
  <block id="df1f367efe879ec0030f43610e29c5af" category="cell">'컨트롤러 PluginTolerations'</block>
  <block id="47a441037628a3c0f0edb0daccb33f99" category="cell">노드플러거노드 선택기</block>
  <block id="f297db5a937924105908a365d9d4c4ff" category="cell">노드 PluginTolerations</block>
  <block id="4352a1b4e004cf57ac04661a18de43aa" category="inline-link-macro">노드에 Pod 할당</block>
  <block id="b3b67fd79d24b4873c8164c750c21798" category="admonition">포드 매개 변수 포맷에 대한 자세한 내용은 을 참조하십시오 <block ref="7b3a69fdac08c769183925679da4c365" category="inline-link-macro-rx"></block>.</block>
  <block id="d6601a8eb863a49ea065281f70a5956b" category="summary">Astra Trident는 NetApp이 Astra 제품군의 일부로 유지 관리하는 완전히 지원되는 오픈 소스 프로젝트입니다. 컨테이너 스토리지 인터페이스(CSI)와 같은 업계 표준 인터페이스를 사용하여 컨테이너화된 애플리케이션의 지속성 요구를 충족하도록 설계되었습니다.</block>
  <block id="bb453665f57f6823950856f7a9bad0c3" category="inline-link-macro">Astra 제품군</block>
  <block id="9f469e7cb13566d8a664e8ab4d46f9e1" category="paragraph">Astra Trident는 NetApp이 의 일부로 유지 관리하는 완전히 지원되는 오픈 소스 프로젝트입니다 <block ref="a1650a2308dbba03b9ca704756a5a37d" category="inline-link-macro-rx"></block>. 컨테이너 스토리지 인터페이스(CSI)와 같은 업계 표준 인터페이스를 사용하여 컨테이너화된 애플리케이션의 지속성 요구를 충족하도록 설계되었습니다.</block>
  <block id="165fe4b78b5877cf8db8ac6361e5c85a" category="paragraph">Astra 페이지에서 무료 평가판을 신청하실 수 있습니다.</block>
  <block id="d13de4a83d7b44c2e65495def8ef1c7b" category="section-title">를 참조하십시오</block>
  <block id="fa80e31eb77798b8dd995ddd9553be6e" category="inline-link">NetApp Astra 제품군</block>
  <block id="ed394f5572d8e7df474126557b3288f8" category="list-text"><block ref="ed394f5572d8e7df474126557b3288f8" category="inline-link-rx"></block></block>
  <block id="ef22ff17624b3faeed227ce5c717eb5f" category="inline-link">Astra Control Service 문서</block>
  <block id="0ae0ea6967e9321db008cee4ad5f290c" category="list-text"><block ref="0ae0ea6967e9321db008cee4ad5f290c" category="inline-link-rx"></block></block>
  <block id="3a4b2c66d4bdac6ce0e3340c71a39eda" category="inline-link">Astra Control Center 문서</block>
  <block id="ea643bf7aaf130341a17f697a7009368" category="list-text"><block ref="ea643bf7aaf130341a17f697a7009368" category="inline-link-rx"></block></block>
  <block id="9d6ffa6ef31bd0b92876314219f18ef5" category="inline-link">Astra API 설명서</block>
  <block id="9c2cf0e947812ecb3fc0bfccaa8b3c61" category="list-text"><block ref="9c2cf0e947812ecb3fc0bfccaa8b3c61" category="inline-link-rx"></block></block>
  <block id="a93e9e44b7a375a4236260f5ff2b251e" category="inline-link">Astra Trident 21.07</block>
  <block id="3830d427e146a8a64454dc373d9b1502" category="list-text"><block ref="3830d427e146a8a64454dc373d9b1502" category="inline-link-rx"></block></block>
  <block id="af7c8216a3289efe1a298a19c00b8b8c" category="section-title">호스트 운영 체제를 테스트했습니다</block>
  <block id="57b3e1695eb7d16642702fbce3837b86" category="paragraph">기본적으로 Astra Trident는 컨테이너에서 실행되므로 모든 Linux 작업자에서 실행됩니다. 그러나 이러한 작업자들은 표준 NFS 클라이언트 또는 iSCSI 이니시에이터를 사용하여 Astra Trident가 제공하는 볼륨을 사용 중인 백엔드에 따라 마운트할 수 있어야 합니다.</block>
  <block id="681d715b456f6d29a501b8f132e941a1" category="cell">v1.22.0</block>
  <block id="c0227cef6f07a8cd2ac72f2945b031aa" category="section-title">오픈 소스</block>
  <block id="0172b29a9f5d94dc62ee592a98183f3b" category="paragraph">각 릴리스의 공지 파일에서 Astra Trident용 NetApp 소프트웨어에 사용된 타사 저작권 및 라이센스를 검토할 수 있습니다<block ref="4a3c8c5a408c6db1c44c04391a8a0a2f" category="inline-link-rx"></block>.</block>
  <block id="29db8b676d0a02f8179869506102c8ce" category="doc">ONTAP 또는 Cloud Volumes ONTAP SAN 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="133184f8c608809bdc057abf1397d10d" category="paragraph">ONTAP 및 Cloud Volumes ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="75419edaab27be09afdb3415e83d93f6" category="paragraph">'SUDO mpathconf - -enable - -with_multipathd y - -find_multiprohs n'</block>
  <block id="60c268e00db3206011b54b01705d7211" category="admonition">etc/multipath.conf에 debrofs 아래에 find_multiprohs no가 포함되어 있는지 확인합니다.</block>
  <block id="b85c80e2af7e3d7dd06b874ed048d430" category="paragraph">'sudo tee /etc/multipath.conf&lt;-'EOF' 기본값 {user_friendly_names yes find_multipath no} EOF sudo systemctl enable--now multipath-tools.service sudo service multipath-tools restart'입니다</block>
  <block id="a3610578ce54198653d7e0b2cc53c05d" category="inline-link-macro">ONTAP 또는 Cloud Volumes ONTAP NAS 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="f4f833852bac4217eff92d53c1bd24dc" category="list-text"><block ref="f4f833852bac4217eff92d53c1bd24dc" category="inline-link-macro-rx"></block></block>
  <block id="df7d9b009cdb0a2623872cb3f905e161" category="list-text"><block ref="df7d9b009cdb0a2623872cb3f905e161" category="inline-link-macro-rx"></block></block>
  <block id="4d80e2460d711b841338dfbeea2ca8c1" category="paragraph">ONTAP 및 Cloud Volumes ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="9d4568c009d203ab10e33ea9953a0264" category="cell">""</block>
  <block id="7072ec708b0ea7e3243747d8b79c0d20" category="admonition">이전 Trident 릴리스에서 업그레이드하고 Azure NetApp Files를 사용하는 경우 이제 ''location'' config 매개 변수는 필수 싱글톤 필드입니다.</block>
  <block id="b956e1f58f802db57dd9f871ac59ed6c" category="paragraph">중복된 리소스 이름을 허용하고 작업을 단일 위치로 제한하도록 ANF 드라이버를 수정했습니다.</block>
  <block id="851679bec9b3e6c8e6284128fb750b1e" category="list-text">Kubernetes의 향상된 기능:</block>
  <block id="2767b461b2b49786f390c9e0509d2d12" category="list-text">Kubernetes 1.23 지원 추가.</block>
  <block id="7f10502f6f15537f180f07f0c89d2642" category="inline-link-macro">GitHub 문제 #651</block>
  <block id="2ff7a365e7c341f8f381cd7c2a4e15f6" category="list-text">Trident Operator 또는 Hrom을 통해 설치된 Trident Pod에 대한 예약 옵션을 추가합니다. (<block ref="15fbe6dcd60762941b28bc5990803bde" category="inline-link-macro-rx"></block>)</block>
  <block id="90fdd892e78b26eb18a250c9c1bc19ff" category="inline-link-macro">GitHub 문제 #633</block>
  <block id="3ff8e54aa1f3735deb64771c4c65c420" category="list-text">GCP 드라이버에서 지역 간 볼륨을 허용합니다. (<block ref="efd445659801b6abfdba2997e23e5f4f" category="inline-link-macro-rx"></block>)</block>
  <block id="fef8c75d6cd00955b0f1c84d40af01aa" category="inline-link-macro">GitHub 문제 #666</block>
  <block id="9f81aabbbba9f61bfecaf1340c407ed1" category="list-text">ANF 볼륨에 'unixPermissions' 옵션에 대한 지원이 추가되었습니다. (<block ref="b2ee1a79cce917ad1d60b3bec442914a" category="inline-link-macro-rx"></block>)</block>
  <block id="a4233200da50a08b295311036bb03ac1" category="section-title">사용 중단</block>
  <block id="de6284c149d2e011da3909f1ef2af627" category="paragraph">Trident REST 인터페이스는 127.0.0.1 또는 [::1] 주소에서만 수신 및 제공할 수 있습니다</block>
  <block id="cdb544a92bee555749f43046d53ef34e" category="admonition">v21.10.0 릴리즈에는 노드를 제거한 다음 Kubernetes 클러스터에 다시 추가할 때 Trident 컨트롤러를 CrashLoopBackOff 상태로 전환할 수 있는 문제가 있습니다. 이 문제는 v21.10.1(GitHub 문제 669)에서 해결되었습니다.</block>
  <block id="cd1bf2431d703fd3c62a278b9c812d56" category="list-text">GCP CVS 백엔드에서 볼륨을 가져올 때 잠재적인 경쟁 조건이 수정되어 가져오지 못했습니다.</block>
  <block id="8e1e1dad95de3dc781f25f58483acdf3" category="list-text">노드를 제거할 때 Trident 컨트롤러를 CrashLoopBackOff 상태로 전환할 수 있는 문제를 해결한 다음 Kubernetes 클러스터(GitHub 문제 669)에 다시 추가되었습니다.</block>
  <block id="d7c32cb5ff2be4aaff3a8eaea9d18e0d" category="list-text">SVM 이름이 지정되지 않은 경우 SVM이 더 이상 검색되지 않는 문제 해결(GitHub 문제 612)</block>
  <block id="a55b7ee69c26277a1088efc103e15297" category="paragraph">사용 가능한 명령 및 전역 옵션은 다음과 같습니다.</block>
  <block id="94912f7fb206038e8527957b44dfbf25" category="paragraph">그러면 모든 Trident 포드가 다시 시작됩니다. 이 작업은 몇 초 정도 걸릴 수 있습니다. 'kubeck get pod-n trident'의 출력에서 '나이' 열을 관찰하여 이를 확인할 수 있습니다.</block>
  <block id="597a56086e1f9d7ca5e8f55c40a0153a" category="list-text">OpenShift Container Platform에서 지원하는 RedHat CoreOS(RHCOS) 버전</block>
  <block id="73e93ad328287e5ce4c06228cfdba2bf" category="cell">v1.23.0</block>
  <block id="08ee53e1d5cefb7967a295e98036598e" category="cell">스냅샷 디렉터리의 표시 여부를 제어합니다</block>
  <block id="016a4b469916e37291cfe2f7fab49aaf" category="cell">[재치 단체</block>
  <block id="66d09fbe1165f3d10b368cbe0cc029f4" category="cell">검색된 자원을 필터링하기 위한 자원 그룹 목록입니다</block>
  <block id="36cbcb8a57112362b05d06b9fe037a6e" category="cell">"[]"(필터 없음)</block>
  <block id="d4b4343f054233d7d339bb1501425fd4" category="cell">'netap계정'</block>
  <block id="61476ef20a8015760b9cb3c1bd0ea435" category="cell">검색된 리소스를 필터링하기 위한 NetApp 계정의 목록입니다</block>
  <block id="722c7b4409fa4d1fe6aaa2902ae66473" category="cell">용량풀</block>
  <block id="225abbb59bc0bbaa2a5852ada333b31b" category="cell">검색된 리소스를 필터링하기 위한 용량 풀 목록입니다</block>
  <block id="f2a5b99a63a463017b3e5f5848444d9a" category="cell">"[]"(필터 없음, 임의)</block>
  <block id="91b3c29beb3641dce2fcf3d2382fac4f" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: "\{"api":false, "method":true, "discovery":true}". 문제 해결 중이 아니며 자세한 로그 덤프가 필요한 경우가 아니면 이 방법을 사용하지 마십시오.</block>
  <block id="520d0db389f362bf79ef56ca0af3dcab" category="cell">형식</block>
  <block id="dde92bca1b59f0db813ef42a2688752e" category="cell">리소스 그룹</block>
  <block id="671e72ca3ef632233f4c27dfef1ec109" category="cell">리소스 그룹&gt;</block>
  <block id="ac252743de820aac9183d9f76d4bed67" category="cell">NetApp 계정</block>
  <block id="2bf2783c6d0d867a9fe629138b38bd84" category="cell">리소스 그룹&gt;/&lt;NetApp 계정&gt;</block>
  <block id="9eea1c08013c37f1499f428378764a08" category="cell">용량 풀</block>
  <block id="01c656d6b97f45a90022ee307283ae01" category="cell">리소스 그룹&gt;/&lt;NetApp 계정&gt;/&lt;용량 풀&gt;</block>
  <block id="bf76cafc47141522dca89c4d6e25b822" category="cell">가상 네트워크</block>
  <block id="8c9309282517a29ad09b10443d825c7c" category="cell">리소스 그룹&gt;/&lt;가상 네트워크&gt;</block>
  <block id="9770c6469e9d27585d6c0c389ede7bc3" category="cell">서브넷</block>
  <block id="7addf9faaab78a084548d05b695cd2e2" category="cell">리소스 그룹&gt;/&lt;가상 네트워크&gt;/&lt;서브넷&gt;</block>
  <block id="976a6dc52dbcabb541efa0a91e922604" category="cell">""(미리보기 기능, 가입 시 화이트리스트 필요)</block>
  <block id="a78703e6fcb2511d5a565496df5b2082" category="section-title">예 2: 용량 풀 필터를 사용하는 특정 서비스 수준 구성</block>
  <block id="cce172403b73af5c2a4e93081affcc7f" category="inline-link">Astra Trident 21.10</block>
  <block id="606b9e83fb467a43b3065d4fd5037094" category="list-text"><block ref="606b9e83fb467a43b3065d4fd5037094" category="inline-link-rx"></block></block>
  <block id="ee50d481128d1543f9945b4a4f3fbe9d" category="paragraph">공기 박형 설치의 경우 다음 목록은 Astra Trident를 설치하는 데 필요한 컨테이너 이미지의 참조입니다. tridentctl images 명령을 사용하여 필요한 컨테이너 영상의 목록을 확인합니다.</block>
  <block id="ec3f9af8f611100a0182ffb9ab2e5ef8" category="paragraph">ONTAP 내에서 Trident 드라이버가 사용할 수 있는 보다 제한적인 역할을 만들 수 있지만 권장하지 않습니다. Trident의 대부분의 새로운 릴리즈에서는 추가 API를 호출하므로 업그레이드가 어렵고 오류가 발생하기 쉽습니다.</block>
  <block id="ee50ce7340da5b018abe62c8e613cae0" category="summary">Astra Trident는 Trident Orchestrator를 위한 여러 명령줄 옵션을 공개하고 특정 포트를 통해 통신합니다.</block>
  <block id="94efe0c9471991c69d2a3b0970a56744" category="paragraph">Astra Trident는 Trident Orchestrator를 위한 여러 명령줄 옵션을 제공합니다. 이러한 옵션을 사용하여 배포를 수정할 수 있습니다.</block>
  <block id="6add71a247c8f4513060920be14857bc" category="cell">allowVolumeExpansion</block>
  <block id="84e2c64f38f78ba3ea5c905ab5a2da27" category="cell">부울</block>
  <block id="675e3f37a9adfd7ab6433906c490fa06" category="cell">PVC 크기 증가에 대한 지원을 활성화 또는 비활성화합니다</block>
  <block id="c791531450eeeb073b30215d9c306a00" category="cell">1.11+</block>
  <block id="086b513e7d83c4cf32a8bd3550679276" category="cell">볼륨BindingMode 를 선택합니다</block>
  <block id="fd656a4f359aa12808a6d0ceb5792342" category="cell">Immediate, WaitForFirstConsumer입니다</block>
  <block id="5e7777e1f9cfa3a93159ee44cf3f1f5a" category="cell">볼륨 바인딩 및 동적 프로비저닝이 수행될 시기를 선택합니다</block>
  <block id="8264769021597389583b0a7d1fa7e076" category="inline-link-macro">Kubernetes: Pod 또는 컨테이너의 보안 컨텍스트를 구성합니다</block>
  <block id="dca8809f382a96564d64ae1525b39048" category="list-text">'fsType' 매개 변수는 SAN LUN에 대해 원하는 파일 시스템 유형을 제어하는 데 사용됩니다. 또한 Kubernetes는 스토리지 클래스에 'fsType'이 있음을 사용하여 파일 시스템이 있음을 나타냅니다. fsType이 설정된 경우에만 POD의 fsGroup 보안 컨텍스트를 사용하여 볼륨 소유권을 제어할 수 있습니다. 을 참조하십시오 <block ref="7940a62969e5aeae7f6e32b04e7a11e3" category="inline-link-macro-rx"></block> 'fsGroup' 컨텍스트를 사용하여 볼륨 소유권을 설정하는 방법에 대한 개요를 제공합니다. Kubernetes는 다음과 같은 경우에만 'fsGroup' 값을 적용합니다.</block>
  <block id="6dd29ca7439e52dcf2fbc569066b3d67" category="list-text">스토리지 클래스에 fsType이 설정되어 있습니다.</block>
  <block id="45d2174daba36b76955e69d2eddf26ca" category="list-text">PVC 액세스 모드는 RWO입니다.</block>
  <block id="ba5b62efad4f90a8f4bb806cba4a3ea4" category="paragraph">NFS 스토리지 드라이버의 경우 파일 시스템이 NFS 내보내기의 일부로 이미 존재합니다. fsGroup을 사용하려면 스토리지 클래스가 여전히 fsType을 지정해야 합니다. NFS 또는 null이 아닌 값으로 설정할 수 있습니다.</block>
  <block id="368b120a3b5f53a49dc3ab96ec9b8dbd" category="paragraph">NetApp은 제품과 서비스를 지속적으로 개선 및 개선하고 있습니다. Astra Trident의 최신 기능 몇 가지를 소개합니다. 이전 릴리스는 를 참조하십시오<block ref="25da125dffad1d6323c21354bccf0203" category="inline-link-rx"></block>.</block>
  <block id="a98b2ebbcbb381d3abc81e2ecfb2054c" category="inline-link-macro">GitHub 문제 #691</block>
  <block id="61465c1d4383dd4afdf168925e15e767" category="list-text">삭제된 노드에서 볼륨 게시를 취소하는 문제 해결 (<block ref="5fee6ab43e8008edba54375694a29266" category="inline-link-macro-rx"></block>)</block>
  <block id="e50f1057ba4b67b255c98fa09c5ba6f8" category="list-text">ONTAP API 응답에서 공간 집계에 대한 nil 필드에 액세스할 때 패닉이 수정되었습니다.</block>
  <block id="3c72f47eeb46270dd13a77b32ec10dd3" category="list-text">* Kubernetes: * 대규모 클러스터의 노드 등록 백오프 재시도 시간을 늘립니다.</block>
  <block id="0ef48234390855900384d0bc8a0a8a24" category="list-text">동일한 이름의 여러 리소스가 Azure-NetApp-files 드라이버를 혼동할 수 있는 문제 해결</block>
  <block id="7eaa7391130c13b3bf9a7e4ae755d908" category="list-text">ONTAP SAN IPv6 데이터 LIF는 이제 대괄호와 함께 지정된 경우 작동합니다.</block>
  <block id="404cef2e43cb97ccef52692419ad6f6b" category="inline-link-macro">GitHub 문제 #489</block>
  <block id="7213ed07f5b718aa66cfac350f023a77" category="list-text">이미 가져온 볼륨을 가져오려고 하면 PVC가 보류 상태로 남겨둔 EOF가 반환되는 문제가 해결되었습니다. (<block ref="b9a2290d6389b9a605883cda4e717749" category="inline-link-macro-rx"></block>)</block>
  <block id="c28d8c94f865f3ef7e4b01a157510ef6" category="list-text">SolidFire 볼륨에 32개 이상의 스냅샷을 생성할 때 Astra Trident 성능이 느려지는 문제를 해결했습니다.</block>
  <block id="d0aaca968285d0d47ea0c5a0f7b9bab5" category="list-text">SHA-1을 SSL 인증서 생성에서 SHA-256으로 교체했습니다.</block>
  <block id="92e6030d252cfd43e0567e282a0d2c9b" category="paragraph">Astra Trident는 을 사용하여 Kubernetes 클러스터에 있는 노드를 선택적으로 생성하여 연결할 수 있습니다<block ref="80b9a4f4a1bc9851317207ee3477041a" category="inline-link-rx"></block>. CSI 토폴로지 기능을 사용하면 지역 및 가용성 영역에 따라 볼륨에 대한 액세스가 노드의 하위 집합으로 제한될 수 있습니다. 오늘날의 클라우드 공급자는 Kubernetes 관리자가 영역 기반의 노드를 생성할 수 있습니다. 노드는 지역 내 또는 여러 지역의 여러 가용성 영역에 위치할 수 있습니다. Astra Trident는 다중 영역 아키텍처에서 워크로드용 볼륨 프로비저닝을 지원하기 위해 CSI 토폴로지를 사용합니다.</block>
  <block id="d293f031e5664526b25f3a65012401b7" category="cell">'IPv6'</block>
  <block id="997cff957213b9212a22d7cac2b4275d" category="list-text">생성된 인증서를 사용하여 인증을 테스트합니다. ONTAP 관리 LIF&gt; 및 &lt;SVM 이름&gt;을 관리 LIF IP 및 SVM 이름으로 바꿉니다. LIF의 서비스 정책이 'default-data-management'로 설정되어 있는지 확인해야 합니다.</block>
  <block id="1e6c7220f5d4eb181d67b4d5043336f5" category="paragraph">NetApp ONTAP용 Amazon FSx와 Astra Trident를 사용하면 Amazon EKS(Elastic Kubernetes Service)에서 실행되는 Kubernetes 클러스터가 ONTAP에서 지원하는 블록 및 파일 영구 볼륨을 프로비저닝할 수 있습니다.</block>
  <block id="10b862795141355be1c179a2f878f507" category="list-text">** Quick create**를 사용하여 ONTAP 파일 시스템용 FSx를 생성하지 마십시오. 빠른 생성 워크플로에서는 자동 백업을 사용할 수 있으며 수신 거부 옵션은 제공하지 않습니다.</block>
  <block id="a10ab8f133704d9a58a1dff179ad7f7d" category="list-text">** 표준 생성** 을 사용하는 경우 자동 백업을 비활성화합니다. 자동 백업을 비활성화하면 Trident는 추가적인 수동 개입 없이 볼륨을 성공적으로 삭제할 수 있습니다.</block>
  <block id="4ef50c481a6113a6276514f572c414d2" category="inline-image-macro">자동 백업을 사용하지 않도록 설정하는 AWS 콘솔 스크린샷</block>
  <block id="cce5aa9218d4019d57adcf814d7189c1" category="paragraph"><block ref="cce5aa9218d4019d57adcf814d7189c1" category="inline-image-macro-rx" type="image"></block></block>
  <block id="45b09f7cb3dcbe0274eef2b3fce46bea" category="paragraph">예, Astra Trident는 오프라인으로 설치할 수 있습니다. 을 참조하십시오 <block ref="4a2b27d6d4bc3dd7ae85bfd131d50753" category="inline-link-macro-rx"></block>.</block>
  <block id="6efc6545e459b8bb96815706b41a84cd" category="paragraph">Trident 설치 프로그램은 Kubernetes 클러스터의 PersistentVolume, PersistentVolumeClaim, StorageClass 및 Secret 리소스에 대한 특정 액세스 권한을 가진 Kubernetes ClusterRole을 생성합니다. 을 참조하십시오 <block ref="7a68296d6f600eac17d317743bea0050" category="inline-link-macro-rx"></block>.</block>
  <block id="0f43ba8a9cfc14b033c2c652f53bfcb9" category="paragraph">필요한 경우 설치에 Astra Trident가 사용하는 정확한 매니페스트 파일을 로컬에서 생성하고 수정할 수 있습니다. 을 참조하십시오 <block ref="7a68296d6f600eac17d317743bea0050" category="inline-link-macro-rx"></block>.</block>
  <block id="72fec731c958562fd09df08eef5fbb89" category="paragraph">다운그레이드를 원할 경우 다양한 요소를 평가해야 합니다. 을 참조하십시오 <block ref="ea621a0de3f004c488ea799d0fd7e41d" category="inline-link-macro-rx"></block>.</block>
  <block id="da4ba399089f873246a85825f8a3e1c3" category="list-text">이 작업이 완료되면 원하는 버전의 Trident 바이너리(이 예: 20.07)를 얻고 이를 사용하여 Astra Trident를 설치합니다. 에 대한 사용자 지정 YAML을 생성할 수 있습니다 <block ref="a251ebefafa5a5d36d857b7034f07489" category="inline-link-macro-rx"></block> 필요한 경우</block>
  <block id="e9c44bbfd795a5d63d74c6a77afee70d" category="paragraph">법적 고지 사항은 저작권 선언, 상표, 특허 등에 대한 액세스를 제공합니다.</block>
  <block id="6016a2b341113bf496b719905398ecd2" category="section-title">저작권</block>
  <block id="09e95b77ffe81fe465a83ba99efad5c8" category="paragraph"><block ref="09e95b77ffe81fe465a83ba99efad5c8" category="inline-link-rx"></block></block>
  <block id="126a02652da6de02962cf1b654fd6376" category="section-title">상표</block>
  <block id="c4ce4761e466527d26b3e3d5ed1006fd" category="paragraph">NetApp, NetApp 로고, NetApp 상표 페이지에 나열된 마크는 NetApp Inc.의 상표입니다. 기타 회사 및 제품 이름은 해당 소유자의 상표일 수 있습니다.</block>
  <block id="7aa531e9acfe2b98e34d2c92fe9846ff" category="paragraph"><block ref="7aa531e9acfe2b98e34d2c92fe9846ff" category="inline-link-rx"></block></block>
  <block id="be89498d2f8a22ce47c02ba9795fe2af" category="section-title">특허</block>
  <block id="d0b19d36be2c5f16e9aef46c8a452d3d" category="paragraph">NetApp 소유 특허 목록은 다음 사이트에서 확인할 수 있습니다.</block>
  <block id="d7f1fbcf9ce4e42f705add574d262b2c" category="paragraph"><block ref="d7f1fbcf9ce4e42f705add574d262b2c" category="inline-link-rx"></block></block>
  <block id="56c34c6410dd45c5cec44149ad0ce037" category="section-title">개인 정보 보호 정책</block>
  <block id="fc248f74f5e36542f7f5627b8610e9a3" category="paragraph"><block ref="fc248f74f5e36542f7f5627b8610e9a3" category="inline-link-rx"></block></block>
  <block id="056b6e39cb1ae24d946674f95697989a" category="paragraph">운영자를 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다.</block>
  <block id="25c11af81bf0b01ce7b0f24ddc9f7136" category="section-title">기타 알려진 구성 옵션</block>
  <block id="ffedfe711d36cdc8c41927063ae77027" category="paragraph">VMware Tanzu 포트폴리오 제품에 Astra Trident를 설치할 경우:</block>
  <block id="8ded34c5caad3971bb6d0a2b202d7b32" category="list-text">클러스터는 권한이 있는 워크로드를 지원해야 합니다.</block>
  <block id="dbe38f4f0d856b41827e6e4531720a5e" category="list-text">kubelet-dir 플래그는 kubelet 디렉토리의 위치로 설정해야 합니다. 기본적으로 이 값은 '/var/vcap/data/kubelet'입니다.</block>
  <block id="4dc3529fbf05312075f0aa52f9c0908e" category="paragraph">Trident 연산자, Hrom 및 tridentctl 배포에서는 -kubelet -dir 을 사용하여 kubelet 위치를 지정하는 작업이 알려져 있습니다.</block>
  <block id="8fad5c21cf613e120f249eadc62cda2f" category="paragraph">Astra Trident는 GKE(Google Kubernetes Engine), EKS(Amazon Elastic Kubernetes Service), AKS(Azure Kubernetes Service), Rancher, VMware Tanzu Portfolio를 비롯한 기타 완전 관리형 및 자체 관리 Kubernetes 오퍼링과도 작동합니다.</block>
  <block id="82720d84ad009f069fd0b2cfaf6c3dac" category="summary">Docker를 위한 Astra Trident는 NetApp의 스토리지 플랫폼을 위한 Docker 에코시스템과 직접 통합됩니다. 또한 향후 추가 플랫폼을 추가할 수 있도록 스토리지 플랫폼에서 Docker 호스트에 이르는 스토리지 리소스의 프로비저닝 및 관리를 지원합니다.</block>
  <block id="6798a0701cedf1202e1d70210a3a9a83" category="paragraph">ONTAP-NAS, ONTAP-SAN, 졸idfire-SAN, GCP-CVS 스토리지 드라이버를 사용할 때 Astra Trident는 볼륨을 복제할 수 있습니다. ONTAP-NAS-Flexgroup 또는 ONTAP-NAS-이코노미 드라이버를 사용할 때는 복제가 지원되지 않습니다. 기존 볼륨에서 새 볼륨을 생성하면 새 스냅샷이 생성됩니다.</block>
  <block id="a264f15eaddf1d50155847119366be6b" category="list-text">ONTAP-NAS, ONTAP-SAN, GCP-CV, Azure-NetApp-파일 드라이버의 경우 각 PV(영구 볼륨)가 FlexVol에 매핑됩니다. 따라서 볼륨 스냅샷이 NetApp 스냅샷으로 생성됩니다. NetApp의 스냅샷 기술은 경쟁 스냅샷 기술보다 뛰어난 안정성, 확장성, 복구 가능성 및 성능을 제공합니다. 이러한 스냅샷 복사본은 생성하는 데 필요한 시간과 스토리지 공간 모두에서 매우 효율적입니다.</block>
  <block id="2c7e2299fa3c14b5e6f60015eb016a87" category="admonition">GCP에서 NetApp Cloud Volumes Service가 지원하는 볼륨을 가져오려면 해당 이름 대신 볼륨 경로를 기준으로 볼륨을 식별합니다.</block>
  <block id="37202a3ee6673127b64f84af27fdf523" category="paragraph">adroit-jolly-swift 볼륨 경로를 사용하여 백엔드에서 gcpcvs_YEppr이라는 GCP-CV 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="ec2577b4770848fd294d6ca069c34a43" category="paragraph">Astra Trident는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, GCP-CV, Azure-NetApp-files 백엔드에 프로비저닝된 NFS PVS의 볼륨 확장을 지원합니다.</block>
  <block id="986d46700a93c1b67573285912b2a857" category="paragraph">Cloud Volumes ONTAP은 NAS 및 SAN 프로토콜(NFS, SMB/CIFS 및 iSCSI)을 지원하는 파일 공유 및 블록 레벨 스토리지 등 다양한 활용 사례에 맞게 엔터프라이즈급 스토리지 기능과 함께 데이터 제어를 제공합니다. Cloud Volume ONTAP와 호환되는 드라이버는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-SAN, ONTAP-SAN 경제입니다. Cloud Volume ONTAP for Azure, Cloud Volume ONTAP for GCP에 적용할 수 있습니다.</block>
  <block id="62e0abd2d56d565a2b31e85b446fa800" category="paragraph">볼륨 가져오기를 사용하면 기존 스토리지 볼륨을 Kubernetes 환경으로 가져올 수 있습니다. 이는 현재 ONTAP-NAS, ONTAP-NAS-Flexgroup, 졸idfire-SAN, Azure-NetApp-files, GCP-cvs 드라이버의 지원을 받고 있습니다. 이 기능은 기존 애플리케이션을 Kubernetes로 포팅하거나 재해 복구 시나리오에서 유용합니다.</block>
  <block id="555c97661fe540a8eabda5c4680e2f81" category="paragraph">'Azure-NetApp-files' 또는 'GCP-CV' 드라이버를 사용하는 경우 'tridentctl import volume &lt;backend-name&gt;&lt;volume path&gt; -f/path/PVC.YAML' 명령을 사용하여 Astra Trident에서 관리할 Kubernetes로 볼륨을 가져옵니다. 이렇게 하면 고유한 볼륨 참조가 보장됩니다.</block>
  <block id="cca7544fa2044ea81b43c1e0896bf58e" category="cell">ONTAP-NAS, ONTAP-SAN, solidfire-SAN, Azure-NetApp-파일, GCP-CV, ONTAP-SAN - 경제성</block>
  <block id="870594bba77423ccae9ad70861e02951" category="cell">ONTAP-NAS, ONTAP-NAS-flexgroup, ONTAP-SAN, GCP-CV</block>
  <block id="33dece0bdda0f88a645c739f3714c038" category="cell">ONTAP-NAS, ONTAP-SAN, solidfire-SAN, GCP-CV</block>
  <block id="2e647c10640a301eccdc45d7ad72507d" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN-이코노미, solidfire-SAN, GCP-CV, Azure-NetApp-파일</block>
  <block id="051fb2c3f62667c87a197ae412a4dbeb" category="cell">ONTAP(NAS, SAN) 및 SolidFire - *: 복제할 볼륨의 이름입니다</block>
  <block id="c12963ed77d398c8f97e09be58a20fed" category="paragraph">Trident는 볼륨을 생성할 때 'internalName'을 생성합니다. 이 단계는 두 단계로 구성됩니다. 먼저, 저장소 접두사(기본 "트리덴트" 또는 백엔드 구성의 접두사)를 볼륨 이름에 추가하여 "&lt;prefix&gt;-&lt;volume-name&gt;" 형식의 이름을 만듭니다. 그런 다음 백엔드에서 허용되지 않는 문자를 대체하여 이름을 삭제하는 작업을 진행합니다. ONTAP 백엔드의 경우 하이픈을 밑줄로 바꿉니다. 따라서 내부 이름은 "&lt;prefix&gt;_&lt;volume-name&gt;"이 됩니다. 요소 백엔드의 경우 밑줄을 하이픈으로 바꿉니다.</block>
  <block id="ba600e29b197aa569df1df520cc4e4c9" category="paragraph">예, Astra Trident는 Azure의 Azure NetApp Files 서비스와 GCP의 Cloud Volumes Service를 지원합니다.</block>
  <block id="804a6c22698fe4782c44f1e8d446964e" category="paragraph">현재 ONTAP-NAS, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN-이코노미, 졸idfire-SAN의 온디맨드 스냅샷 지원을 이용할 수 있습니다. GCP-CV와 Azure-NetApp-files 백엔드 드라이버.</block>
  <block id="4af8991c21dff2f779496b8350d1124b" category="inline-link">Astra Trident 22.01</block>
  <block id="7669b0b69333e81c7c208aea3d1a3c6f" category="list-text"><block ref="7669b0b69333e81c7c208aea3d1a3c6f" category="inline-link-rx"></block></block>
  <block id="682c6ce09c9faae3a3e22c55c8db592e" category="list-text">ANF 드라이버가 여러 내보내기 규칙을 사용하여 볼륨을 클론하지 못한 문제 해결</block>
  <block id="723b30bcece2d0d47914a6eaf0c550cc" category="list-text">이제 Trident는 보안 엔드포인트의 응답에 HSTS 헤더를 추가합니다.</block>
  <block id="621b9733ee07089711b96dd6b0b7861a" category="list-text">이제 Trident는 Azure NetApp Files UNIX 사용 권한 기능을 자동으로 활성화하려고 시도합니다.</block>
  <block id="3f39a3207529d5f8129199a33e60ef87" category="section-title">제거</block>
  <block id="3d0d8392962843a02a6fa979f76b5a91" category="paragraph">E-Series 드라이버(20.07 이후 비활성화됨)가 제거되었습니다.</block>
  <block id="72387bfdb0acfd8a27877f000a3abeac" category="section-title">22.01.1의 변경 사항</block>
  <block id="135c438d01a49275c458e22005e39c6e" category="section-title">22.01.0의 변경 사항</block>
  <block id="58a2e8c17107cc1ca9cb1317cd0c1ee9" category="section-title">21.10.1 변경</block>
  <block id="43e92857220d1a7ea1da88250ea5e2e3" category="section-title">21.10.0 변경</block>
  <block id="9c87569b835a8f66b7490390d350d9a4" category="paragraph">Kubernetes 배포 시 스냅샷 컨트롤러와 CRD가 포함되지 않은 경우 다음과 같이 배포할 수 있습니다.</block>
  <block id="469f7ca16938508b5dcb777767828b70" category="list-text">볼륨 스냅샷 CRD를 생성합니다.</block>
  <block id="65b146df7d5c27b212f54a7c9980960b" category="list-text">원하는 네임스페이스에 스냅샷 컨트롤러를 생성합니다. 아래 YAML 매니페스트를 편집하여 네임스페이스를 수정하십시오.</block>
  <block id="086e6c16e3fe8e13c336612ef636aa02" category="sidebar">아스트라 트리덴트</block>
  <block id="5a333b18a215ecfd4457ba0e1732654b" category="section-title">Trident가 로드 공유 미러가 구성된 SVM에서 볼륨을 프로비저닝할 수 있습니까?</block>
  <block id="0e7629426b9d7596800cd5d72f558a7f" category="paragraph">NFS를 통해 데이터를 제공하는 SVM의 루트 볼륨에 로드 공유 미러를 생성할 수 있습니다. ONTAP는 Trident에서 생성한 볼륨의 로드 공유 미러를 자동으로 업데이트합니다. 이로 인해 볼륨 마운팅이 지연될 수 있습니다. Trident를 사용하여 여러 볼륨을 생성할 경우 볼륨 프로비저닝은 ONTAP에서 로드 공유 미러 업데이트에 따라 달라집니다.</block>
  <block id="d5d195efeafde24a6a22effd3dd39339" category="list-text">자격 증명 기반: 파일 시스템에 대해 'fsxadmin' 사용자를 사용하거나 SVM용으로 구성된 'vsadmin' 사용자를 사용할 수 있습니다.</block>
  <block id="0b4a92a731cb582bd951a7aa481f0602" category="list-text">Anthos On-Premise(VMware) 및 Anthos의 Bare Metal 1.9, 1.10, 1.11</block>
  <block id="7d3f46589c43a64fd040e4f0e0691a86" category="inline-link-macro">Helm 차트</block>
  <block id="c9ffe59301b588bbc33bb004cfd312ee" category="section-title">Trident 연산자를 구축하고 Hrom을 사용하여 Astra Trident를 설치합니다</block>
  <block id="1ea1b160621872df5909653ebde1bf7f" category="paragraph">자격 증명 기반 방법과 인증서 기반 방법 간에 이동하기 위해 기존 백엔드를 업데이트할 수 있습니다. 그러나 한 번에 하나의 인증 방법만 지원됩니다. 다른 인증 방법으로 전환하려면 백엔드 구성에서 기존 방법을 제거해야 합니다.</block>
  <block id="7335992f174c029a990442aca68aacbd" category="admonition">자격 증명과 인증서 * 를 모두 제공하려고 하면 구성 파일에 둘 이상의 인증 방법이 제공된다는 오류가 발생하여 백엔드 생성이 실패합니다.</block>
  <block id="d1914bc190cdc3bc9eee6db0c81021bc" category="section-title">노드 서비스 검색</block>
  <block id="2b6ab5193160f5eaca51526b15f27e3a" category="admonition">노드 서비스 검색은 검색된 서비스를 식별하지만 서비스가 올바르게 구성된다고 보장하지 않습니다. 반대로 검색된 서비스가 없으면 볼륨 마운트가 실패한다고 보장할 수 없습니다.</block>
  <block id="66896c99fb06e0b6c86498b249f8217a" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다.</block>
  <block id="412427d9207c4cc4b01539aff3c50e7c" category="cell">'네트워크 기능'</block>
  <block id="6dc4cb19f2792a3eadfa64d4b4b6d177" category="paragraph">모든 Kubernetes 작업자 노드에 적절한 NFS 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="f1f954e59a21e3ffe189e77dd2ee9f86" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="6adbf3424e5de1b4e2baad3b4d632c4a" category="paragraph">다른 인증 방법을 사용하거나 자격 증명을 회전하도록 기존 백엔드를 업데이트할 수 있습니다. 이렇게 하면 사용자 이름/암호를 사용하는 백엔드를 인증서를 사용하도록 업데이트할 수 있고 인증서를 사용하는 백엔드는 사용자 이름/암호 기반으로 업데이트할 수 있습니다. 이렇게 하려면 기존 인증 방법을 제거하고 새 인증 방법을 추가해야 합니다. 그런 다음 필요한 매개 변수가 포함된 업데이트된 backend.json 파일을 사용하여 'tridentctl backend update'를 실행합니다.</block>
  <block id="da5e3ce6518bd669264e1e0768c2d9f1" category="paragraph">모든 Kubernetes 작업자 노드에는 적절한 iSCSI 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="f1f954e59a21e3ffe189e77dd2ee9f86" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="4169ad079be240db45893881a795d255" category="paragraph">에서 문제를 만듭니다<block ref="e71a8230f1c77ee7d957187295b859e4" category="inline-link-rx"></block> 제목에 * RFE * 를 기재하고 문제에 대한 설명을 기재하십시오.</block>
  <block id="a7cfd917113a9ee9c1e789887d1d809f" category="inline-link-macro">불화 채널</block>
  <block id="c0ecc0f40acc112b78de6c3fd3c29e83" category="paragraph">질문, 문제 또는 요청이 있을 경우 Astra를 통해 문의해 주십시오 <block ref="6130664377fa14615bb1abd5257e9714" category="inline-link-macro-rx"></block> 또는 GitHub 를 선택합니다.</block>
  <block id="880cacf6429ab3c253b14beac8b73951" category="summary">Kubernetes Pod 보안 표준(PSS) 및 Pod 보안 정책(PSP)에서 사용 권한 수준을 정의하고 Pod의 동작을 제한합니다. OpenShift Security Context Constraints(SCC)도 OpenShift Kubernetes Engine에 특정한 POD 제한을 정의합니다. 이러한 사용자 지정을 제공하기 위해 Astra Trident는 설치 중에 특정 권한을 활성화합니다.</block>
  <block id="bc3c69459955aa51e6720ee4098db2c2" category="doc">POD 보안 표준(PSS) 및 보안 컨텍스트 제약(SCC)</block>
  <block id="9d482ecca4ba8a41fd8e1180c97a4b97" category="paragraph">Kubernetes Pod 보안 표준(PSS) 및 Pod 보안 정책(PSP)에서 사용 권한 수준을 정의하고 Pod의 동작을 제한합니다. OpenShift Security Context Constraints(SCC)도 OpenShift Kubernetes Engine에 특정한 POD 제한을 정의합니다. 이러한 사용자 지정을 제공하기 위해 Astra Trident는 설치 중에 특정 권한을 활성화합니다. 다음 섹션에서는 Astra Trident에서 설정한 사용 권한에 대해 자세히 설명합니다.</block>
  <block id="80af9ab2cf8f28973d329b09a2aa3bf3" category="inline-link-macro">Kubernetes: 보안</block>
  <block id="181049d711e79ba087e97d579f11e3f7" category="admonition">PSS는 Pod 보안 정책(PSP)을 대체합니다. PSP는 Kubernetes v1.21에서 사용되지 않으며 v1.25에서 제거됩니다. 자세한 내용은 을 참조하십시오 <block ref="18a97095ea40d42decd22f31a2040afe" category="inline-link-macro-rx"></block>.</block>
  <block id="92699490afddc06ebad285ff002fc80d" category="section-title">필요한 Kubernetes 보안 컨텍스트 및 관련 필드</block>
  <block id="ed5dea09095f671b801bee34ea28a319" category="cell">권한</block>
  <block id="b315e1c68490baab38c1a28e00fe0f5a" category="cell">특별 권한</block>
  <block id="62868c5d24fd89e2fd8046454e18b6c4" category="inline-link-macro">Kubernetes: 마운트 전파</block>
  <block id="a2d97da130dea6b381b1e770af5d9c74" category="cell">CSI를 사용하려면 마운트 지점이 양방향이어야 합니다. 즉, Trident 노드 포드가 권한이 있는 컨테이너를 실행해야 합니다. 자세한 내용은 을 참조하십시오 <block ref="36e6e997c8e1e33355ee35fb5cf65f2b" category="inline-link-macro-rx"></block>.</block>
  <block id="92a5c8ffa6bee2a9377f18499950da23" category="cell">호스트 네트워킹</block>
  <block id="154cdce0e5451a5578085caa8a7e7a3e" category="cell">iSCSI 데몬에 필요합니다. iscsiadm은 iSCSI 마운트를 관리하고 호스트 네트워킹을 사용하여 iSCSI 데몬과 통신합니다.</block>
  <block id="2ff982b19c53a275ae05f015dafe166d" category="cell">호스트 IPC</block>
  <block id="eac6730a7bdbb0156f167d1a073b4a7c" category="cell">NFS는 IPC(프로세스 간 통신)를 사용하여 NFSD와 통신합니다.</block>
  <block id="b25a60a6190808e0d6e849ca6325b91c" category="cell">호스트 PID</block>
  <block id="50a75b984e49b81a5c2b366ffe8cfba2" category="cell">NFS에 대해 RPC-statd를 시작해야 합니다. Astra Trident는 호스트 프로세스를 쿼리하여 NFS 볼륨을 마운트하기 전에 "RPC-statd"가 실행되고 있는지 확인합니다.</block>
  <block id="82ec2cd6fda87713f588da75c3b1d0ed" category="cell">제공합니다</block>
  <block id="4aeb7a1484240b8d479aee0a012de3a4" category="cell">'SYS_ADMIN' 기능은 권한 있는 컨테이너의 기본 기능의 일부로 제공됩니다. 예를 들어, Docker는 권한이 있는 컨테이너인 'CapPrm:0000003fffffffffff''CapEff:0000003fffffffffff'에 대해 이러한 기능을 설정합니다</block>
  <block id="b2dbe899d8bf9b4c25f337efe8b1ce7c" category="cell">Seccomp</block>
  <block id="bc13155252332e44b7dd850ea5842641" category="cell">Seccomp 프로필은 권한 있는 컨테이너에서 항상 "제한 없음"이므로 Astra Trident에서 활성화할 수 없습니다.</block>
  <block id="1a3d8802d280d4ec910f54042cd62998" category="cell">SELinux</block>
  <block id="86b4800be380b1baaeaeead5f71076db" category="cell">OpenShift에서는 특권 컨테이너가 'spc_t'(슈퍼 프리빌리지 컨테이너) 도메인에서 실행되고 권한 없는 컨테이너는 container_t 도메인에서 실행됩니다. 컨테이너에서는 컨테이너 SELinux가 설치된 상태로 모든 컨테이너가 'PC_t' 도메인에서 실행되어 SELinux를 효과적으로 비활성화합니다. 따라서 Astra Trident는 컨테이너에 'eLinuxOptions'를 추가하지 않습니다.</block>
  <block id="52a8b954485e8bf8ebe32865d17563a6" category="cell">DAC</block>
  <block id="6ddc0f1aebd745677bb51e725f080883" category="cell">권한이 있는 컨테이너는 루트로 실행되어야 합니다. 권한이 없는 컨테이너는 root로 실행되어 CSI에 필요한 UNIX 소켓에 액세스합니다.</block>
  <block id="479f0a2e760ff0014bb53fcbe4b5dfbf" category="section-title">POD 보안 표준(PSS)</block>
  <block id="b021df6aac4654c454f46c77646e745f" category="cell">라벨</block>
  <block id="ede4d9142f78c8313ce1ea912023214a" category="cell">pod-security.Kubernetes.io/force 포드-security.Kubernetes.io/force-version을 적용합니다</block>
  <block id="0ccd226f7ad098ef19857dcf15eed611" category="cell">Trident 컨트롤러와 노드를 설치 네임스페이스에 받아들일 수 있습니다. 네임스페이스 레이블을 변경하지 마십시오.</block>
  <block id="0634b3cd8d233df0b38fe73154f03a86" category="cell">최근 실시한 PSS의 최신 버전이나 PSS의 최고 버전 &gt;</block>
  <block id="830d087702172a8173337c2f014f24b3" category="admonition">네임스페이스 레이블을 변경하면 포드가 예약되지 않고 "오류 생성:..." 또는 "경고: 트리덴트 - CSI -..."가 발생할 수 있습니다. 이 경우 특권 네임스페이스 레이블이 변경되었는지 확인합니다. 있는 경우 Trident를 다시 설치합니다.</block>
  <block id="a2e4b41e2525b6345ec43bbfe91c66fb" category="section-title">PSP(POD 보안 정책)</block>
  <block id="6f16a5f8ff5d75ab84c018adacdfcbb7" category="cell">필드에 입력합니다</block>
  <block id="0c3c80a8b192c50af55549addaec04e9" category="cell">'allowPrivilegeegeEscalation'</block>
  <block id="13d1281eff2b6a57e6fe877e0379a8f0" category="cell">권한 있는 컨테이너는 권한 에스컬레이션을 허용해야 합니다.</block>
  <block id="22cfef4d87bd251ba39dd92d08a6b0bb" category="cell">"참"입니다</block>
  <block id="f3acfbe4d2b93ab163024b31a31b1a6e" category="cell">'allowedCSIDrivers'입니다</block>
  <block id="e4938c724a08c7ba91677f8cb5e069f0" category="cell">Trident는 인라인 CSI 임시 볼륨을 사용하지 않습니다.</block>
  <block id="ce2c8aed9c2fa0cfbed56cbda4d8bf07" category="cell">비어 있습니다</block>
  <block id="2eb7a988516ab2e49fd1dd1d0f505ba4" category="cell">'allowedCapabilities'</block>
  <block id="7f18f0f8e3ec21ef031ae007e78292f1" category="cell">권한이 없는 Trident 컨테이너는 기본 세트보다 더 많은 기능을 필요로 하지 않으며 권한이 있는 컨테이너에 모든 가능한 기능이 부여됩니다.</block>
  <block id="577f713a1a3fd5fe6851754c1e780b62" category="cell">'allowedFlexVolumes'</block>
  <block id="5a40ff04e0748fc5c56343bfccb1bf43" category="inline-link-macro">FlexVolume 드라이버</block>
  <block id="117394bda9c12e1ab1e0ddefda7340f6" category="cell">Trident는 을 사용하지 않습니다 <block ref="5cf2fb2d9c4de828b06e030ea5b9ff75" category="inline-link-macro-rx"></block>따라서 허용된 볼륨 목록에 포함되지 않습니다.</block>
  <block id="e26fd3e84b999df4093d0b9f1cf8bbdb" category="cell">'allowedHostPaths'</block>
  <block id="87c065485525cde8c75f60bd233a546b" category="cell">Trident 노드 포드는 노드의 루트 파일 시스템을 마운트하므로 이 목록을 설정하는 데는 아무런 이점이 없습니다.</block>
  <block id="88e5e12dbdeac08e751e562ed902d6af" category="cell">'allowedProcMountTypes'</block>
  <block id="b989e7796e7fe01d9a48795f499ee3e8" category="cell">Trident는 'ProcMountTypes'를 사용하지 않습니다.</block>
  <block id="6784c364453355e4499a625166f9d76e" category="cell">Trident는 안전하지 않은 '스컬'을 필요로 하지 않습니다.</block>
  <block id="43dbe35647dc1ec91f9ab70bb9c67eb7" category="cell">"기본 추가 기능"을 참조하십시오</block>
  <block id="21b6f9c280cf0efb8619e386208ee181" category="cell">권한이 있는 컨테이너에 기능을 추가할 필요가 없습니다.</block>
  <block id="782434a33bb3747f8aa86293dc2ae86c" category="cell">월권 AllowPrivilegeEscalation</block>
  <block id="4e1db4d4f52542bf76625bb1724050ca" category="cell">권한 에스컬레이션을 허용하는 작업은 각 Trident 포드에서 처리됩니다.</block>
  <block id="249091efa412cf5e332461c484b979d0" category="cell">거짓입니다</block>
  <block id="7b18008579516cbef313996f0c7a3f5e" category="cell">'바이디니데시스틀스'</block>
  <block id="1507e7ba036aa98fd30589e618a7a4eb" category="cell">'스매스들'은 허용되지 않습니다.</block>
  <block id="042337cb48219589a279b3bf0ba9107a" category="cell">'fsGroup'입니다</block>
  <block id="07556f620d0b827238e3ef0142c49b78" category="cell">Trident 컨테이너가 루트로 실행됩니다.</block>
  <block id="ac0f2e366ea63da20af91efebbac6563" category="cell">러아사니</block>
  <block id="0041ceee5434032966a8b03eae8738ac" category="cell">호스티IPC</block>
  <block id="41c30833eb5d5997e9b7a31ee0c66616" category="cell">NFS 볼륨을 마운트하려면 호스트 IPC가 nfsd와 통신해야 합니다</block>
  <block id="9bffb5bb38918d1a1d3ae47e97dfc0c4" category="cell">호스트 네트워크</block>
  <block id="42a138ad382896646a09fac2eb0167c6" category="cell">iscsiadm을 사용하려면 호스트 네트워크가 iSCSI 데몬과 통신해야 합니다.</block>
  <block id="13135fc0519a6dd0521fa0c0e2445184" category="cell">'hostPID'</block>
  <block id="608c4a2fdcf8e14356058df9005ae8ad" category="cell">노드에서 RPC-statd가 실행되고 있는지 확인하려면 호스트 PID가 필요합니다.</block>
  <block id="7d820b24ee2bfd41495fba608bfe1fb0" category="cell">호스트 포트</block>
  <block id="7afcaaf2763ecc0e6dee9f0b63026a58" category="cell">Trident는 호스트 포트를 사용하지 않습니다.</block>
  <block id="cb8c6f5ff29df99724d3704d1af54bbd" category="cell">특권</block>
  <block id="aadb34687d099e9a40c9ad3bbaca9b52" category="cell">Trident 노드 포드는 볼륨을 마운트하려면 권한이 있는 컨테이너를 실행해야 합니다.</block>
  <block id="cd8e4b4bb856b53433b1d0369136d7c3" category="cell">"RootFilesystem"을 선택합니다</block>
  <block id="7621dbe4e923ccb1331f44e5fc326954" category="cell">Trident 노드 포드는 노드 파일 시스템에 써야 합니다.</block>
  <block id="7214fd778499c002452dfa1de7a63694" category="cell">레퀴레드드롭카포비스</block>
  <block id="0a687403dd751d7bcf9d36eb39b73187" category="cell">Trident 노드 포드는 권한이 있는 컨테이너를 실행하고 기능을 삭제할 수 없습니다.</block>
  <block id="56d058c51fcd79545706c62569ba5a19" category="cell">"없음"</block>
  <block id="e0cfa7f1a22bfc61e3c23d9b472cb229" category="cell">루아그룹</block>
  <block id="72a9e1b9b252e5cf0980f359420147d4" category="cell">'runAsUser'입니다</block>
  <block id="0be043db3067cfba9e355c71f0d47963" category="cell">루아안니</block>
  <block id="2b13c797fbca116e0445fe9ed04aa753" category="cell">'런타임 클래스'</block>
  <block id="90eaf8074aef1d40fdd4ebb096ba3445" category="cell">트라이던트(Trident)는 RuntimeClasses를 사용하지 않습니다.</block>
  <block id="af697e6f277a737b01025e1b3ac8fd44" category="cell">'e linux'</block>
  <block id="b2fe00f20eadde0a1ed6fcbd7f899a41" category="cell">Trident는 현재 컨테이너 실행 시간과 Kubernetes 배포판이 SELinux를 처리하는 방식에 차이가 있으므로 'eLinuxOptions'를 설정하지 않습니다.</block>
  <block id="07b8b968ede124e1134951b502139223" category="cell">업플레탈그룹</block>
  <block id="707325d27093188691659cc218115f02" category="cell">'볼륨'</block>
  <block id="fd284b15eb12231bdce65744e6704677" category="cell">Trident Pod에는 이러한 볼륨 플러그인이 필요합니다.</block>
  <block id="c28fb07c7c2463112f74e84cdea6df77" category="cell">대스트패스, 투상도, 최고가</block>
  <block id="12ed56c889a6b18b5fce1be5bd30b1c8" category="section-title">SCC(Security Context Constraints)</block>
  <block id="3ad6cb6100190c8f81e99fd52debf7ef" category="cell">라벨</block>
  <block id="244a3eb95cc1438e96d275b17eaa5bca" category="cell">'allowHostDirVolumePlugin'을 선택합니다</block>
  <block id="bdf1cf802b14a9ec8b930e1603663b2a" category="cell">Trident 노드 포드는 노드의 루트 파일 시스템을 마운트합니다.</block>
  <block id="bb46f3196a53f2e3664f53addee28df1" category="cell">'allowHostIPC'입니다</block>
  <block id="040a3e4977d39efd21138ca276545e91" category="cell">NFS 볼륨을 마운트하려면 호스트 IPC가 nfsd와 통신해야 합니다.</block>
  <block id="75a4305006cbe99edf6e6ec43424a3f9" category="cell">'allowHostNetwork'입니다</block>
  <block id="3dc9b606cf3a7a8fc44c8489687131d1" category="cell">'allowHostPID'</block>
  <block id="31773567f0268170ecfa4c74f91c5b74" category="cell">'allowHostPorts'입니다</block>
  <block id="606a5f1c705c363af0a1f97e60feaddc" category="cell">'allowPrivilegedContainer'</block>
  <block id="2cc90cbcd409b90ed2d4270b587b4611" category="cell">'allowedUnsafeSysctls'</block>
  <block id="5be47a456f397efee757d8dd4e0c8726" category="cell">그룹</block>
  <block id="c2ca437ef2abb914a8fc2ebb1b926ef6" category="cell">이 SCC는 Trident에만 해당되며 사용자에게 바인딩됩니다.</block>
  <block id="fae56626a2743154c04411ee3d701833" category="cell">새리눅스컨텍스트</block>
  <block id="5987c8a1437c5254a436c29c94220b55" category="cell">'eccompProfiles</block>
  <block id="2c8f9f1b9abdfa728b8f5d50686e4da0" category="cell">특권 컨테이너는 항상 "비제한" 상태로 실행됩니다.</block>
  <block id="f94a437fb7858e092079378f93ef2c71" category="cell">'사용자'</block>
  <block id="402b7d2d5aea5e79576f9a964df89a32" category="cell">이 SCC를 Trident 네임스페이스의 Trident 사용자에게 바인딩하기 위해 하나의 항목이 제공됩니다.</block>
  <block id="274b68192b056e268f128ff63bfcd4a4" category="cell">해당 없음</block>
  <block id="50af2a553c2117ddd78da33865c6e35b" category="cell">hostPath, downwardAPI, 투영, emptyDir</block>
  <block id="b8f52a0e5f45341fb88241356af7f0c7" category="list-text">을 참조하십시오 <block ref="7c28a1514d14039d3824999236c4890d" category="inline-link-macro-rx"></block> 볼륨 확장에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="d63b67088a9f91802e555f6613dfc7e2" category="list-text">tridentctl uninstall 명령을 사용하여 Trident를 제거할 때 Trident Pod는 삭제되지만 생성된 CRD는 정리되지 않습니다. 을 참조하십시오 <block ref="3e5b286354565ddfee44ed92d763b424" category="inline-link-macro-rx"></block> Trident를 완전히 제거하고 처음부터 다시 구성할 수 있는 방법을 이해합니다.</block>
  <block id="6386b0f17b85463db72887bca8ae2bb7" category="inline-link-macro">백엔드 구성 중</block>
  <block id="4ec9b12b750288e91222e3a7e15db932" category="paragraph">이러한 개체를 구성하는 방법에 대한 자세한 내용은 을 참조하십시오 <block ref="2e76dfee6bc1b5ee4173b3c5bbcd99e5" category="inline-link-macro-rx"></block>.</block>
  <block id="1733f6bf382fd79ef07194c1f01825fa" category="paragraph">Trident에서 Deamonset을 사용하면 Kubernetes에서 가장 높은 우선 순위 클래스인 '시스템 노드 크리티컬' 우선 순위 클래스를 사용하여 Astra Trident가 정상 노드 종료 중에 볼륨을 식별 및 정리하고, Trident에서 POD를 통해 리소스 압력이 높은 클러스터에서 낮은 우선 순위로 워크로드를 사전 예방할 수 있습니다.</block>
  <block id="bc1252710ec794375d6c59f55eea9823" category="paragraph">이를 위해 Astra Trident는 'ResourceQuota' 객체를 사용하여 Trident의 "system-node-critical" 우선 순위 클래스가 충족되도록 합니다. Astra Trident는 배포 및 디멘트되기 전에 'ResourceQuota' 객체를 찾고 발견되지 않으면 적용합니다.</block>
  <block id="253c5669d0ddb02485528df359bfb37d" category="paragraph">기본 리소스 할당량 및 우선순위 클래스에 대한 더 많은 제어가 필요한 경우 'CUSTOM.YAML'을 생성하거나 제어 차트를 사용하여 'ResourceQuota' 객체를 구성할 수 있습니다.</block>
  <block id="b6ba871f235b09a3d76844b7b5901586" category="paragraph">다음은 Trident 데모의 우선 순위를 지정하는 'ResourceQuota' 개체의 예입니다.</block>
  <block id="4f4b1cca8d1c78f8ba309694d46d80f2" category="inline-link-macro">Kubernetes: 리소스 할당량</block>
  <block id="8893dca3c9374b0380c7018fc6f23846" category="paragraph">리소스 할당량에 대한 자세한 내용은 을 참조하십시오 <block ref="1fb556021be57083646a3e3c0079c64c" category="inline-link-macro-rx"></block>.</block>
  <block id="222924a66611c61f2a2192a2bab92ecf" category="inline-link-macro">제거 중</block>
  <block id="dbcf7f603282c175a634104f7dbd55f2" category="paragraph">드문 경우지만 ResourceQuota 객체를 만든 후 설치가 실패하는 경우 먼저 시도해 보십시오 <block ref="3bd802fb95da78515b3c3d98916ee73c" category="inline-link-macro-rx"></block> 그런 다음 다시 설치합니다.</block>
  <block id="c4af59b1638f70f51816423f72df4dba" category="paragraph">이 기능이 작동하지 않으면 수동으로 ResourceQuota 객체를 제거합니다.</block>
  <block id="ba991f2f6d0f733e9b8a2136cedc99b2" category="paragraph">사용자 고유의 리소스 할당을 제어하려면 다음 명령을 사용하여 Astra Trident의 ResourceQuota 객체를 제거할 수 있습니다.</block>
  <block id="c217b0ac2dd5504f79ba78b220a9c358" category="summary">NetApp은 다양한 방법으로 Trident를 지원합니다. 불협화채널 등 광범위한 자아 지원 옵션이 연중 무휴로 제공됩니다.</block>
  <block id="1b3d6decfa71cc52ecc9b041f40a02e5" category="paragraph">또한 Astra의 컨테이너 사용자(Astra Trident 개발자 포함)로 구성된 활발한 공용 커뮤니티가 있습니다 <block ref="6130664377fa14615bb1abd5257e9714" category="inline-link-macro-rx"></block>. 프로젝트에 대한 일반적인 질문을 하고 비슷한 생각을 가진 동료와 관련 주제를 논의할 수 있는 좋은 장소입니다.</block>
  <block id="9337cac2cd1105449cd4e78ff2a353a4" category="cell">"k8s.gcr.io/sig-storage(k8s 1.19 이상) 또는 quay.io/k8scsi"</block>
  <block id="702fa57eedc6ee8490a7294016f8b14f" category="list-text">트리덴트의 지략적인 요아ML</block>
  <block id="6b51834314ece904405eb0ce1a6e6bd8" category="list-text">NetApp HCI/Element 소프트웨어 11 이상</block>
  <block id="468bc1e7f7712a8dc9b91d063523cdff" category="cell">v1.24.0</block>
  <block id="05759468b045fc55d22e8e6881dca01f" category="paragraph">** Kubernetes**</block>
  <block id="a885c202ff7951e3ed11491edbe869b2" category="inline-link-macro">GitHub 문제 #700</block>
  <block id="b649490c5687c23484f5e4043e17b9c5" category="list-text">Hrom 또는 Trident 연산자를 사용하여 Trident를 구성할 때 노드 선택기에 대한 부울 및 숫자 값을 처리하는 문제가 해결되었습니다. (<block ref="4be853b49b0a07556a73959d38037d90" category="inline-link-macro-rx"></block>)</block>
  <block id="0ae28ee1c5edfd4bee3e296a8261ed8b" category="inline-link-macro">GitHub 문제 #736</block>
  <block id="69ce5488c3078e15fc6e51116d1d17ba" category="list-text">CHAP가 아닌 경로에서 발생하는 오류를 처리하는 문제를 수정함으로써 kubelet이 실패한 경우 다시 시도합니다. <block ref="a21b5d75e3a2341288a5ed769d7d4ca2" category="inline-link-macro-rx"></block>)</block>
  <block id="701ba87ab75dde70f4604769defc7d00" category="list-text">k8s.gcr.io에서 registry.k8s.io로 CSI 이미지의 기본 레지스트리로 전환합니다</block>
  <block id="95b61962ec35cc252a4791e4101c5aaa" category="list-text">ONTAP-SAN 볼륨은 이제 노드별 igroup을 사용하며 해당 노드에 능동적으로 게시되는 LUN만 igroup에 매핑하여 보안 상태를 향상합니다. Trident가 활성 워크로드에 영향을 주지 않고 안전하게 수행할 수 있다고 판단하면 기존 볼륨이 새로운 igroup 체계로 자동으로 전환됩니다.</block>
  <block id="90e3cd7cff1c9f6f4b8d2a509b127d44" category="list-text">Trident 설치에 리소스 할당량을 포함함으로써 PriorityClass 소비가 기본적으로 제한될 때 Trident DemonSet이 예약되도록 합니다.</block>
  <block id="838a6d7e89b7c366cfc25d3b2115b901" category="inline-link-macro">GitHub 문제 #717</block>
  <block id="83a65beedcdd811d7b3b4fe9d2c4614f" category="list-text">ANF 드라이버에 네트워크 기능에 대한 지원이 추가되었습니다. (<block ref="e0e89f8bd936a5eb3adce74cac88eab0" category="inline-link-macro-rx"></block>)</block>
  <block id="cab6f6f91105d87aa3f65650df43c553" category="inline-link-macro">GitHub 문제 #228</block>
  <block id="00ea108f36897d9ed3523b970b09e6ea" category="list-text">ONTAP 드라이버에 기술 미리 보기 자동 MetroCluster 전환 감지 기능이 추가되었습니다. (<block ref="0c9c84232975bfb33d3481050e5ef924" category="inline-link-macro-rx"></block>)</block>
  <block id="0b4fe975279063a2d1790cd061a8b8d1" category="list-text">** Kubernetes:** 최소 지원 Kubernetes를 1.19로 업데이트했습니다.</block>
  <block id="108e9d089b04380952a04c1021cdad80" category="list-text">백엔드 구성은 더 이상 단일 구성에서 여러 인증 유형을 사용할 수 없습니다.</block>
  <block id="de278730ee66ed696db3f71d20aa30a5" category="list-text">AWS CVS 드라이버(22.04 이후 더 이상 사용되지 않음)가 제거되었습니다.</block>
  <block id="16cbbf51150ac75556b3850ff4a5a013" category="list-text">노드 포드에 불필요한 SYS_ADMIN 기능이 제거되었습니다.</block>
  <block id="9f0be62f4bbebd42af8782e0151af649" category="list-text">노드 준비 작업을 간단한 호스트 정보로 줄이고 활성 서비스 검색을 통해 작업 노드에서 NFS/iSCSI 서비스를 사용할 수 있다는 최선의 확인 작업을 수행할 수 있습니다.</block>
  <block id="5b6cf869265c13af8566f192b4ab3d2a" category="section-title">문서화</block>
  <block id="d3889fc650fa47326b5f1d0c56f50970" category="inline-link-macro">POD 보안 표준</block>
  <block id="4e8effbd512bb14dbe10454c0f045ff2" category="paragraph">새로운 소식 <block ref="305368b4f0d008a807e095ab9da58448" category="inline-link-macro-rx"></block> (PSS) 섹션에 설치 시 Astra Trident에서 활성화한 상세 권한이 추가되었습니다.</block>
  <block id="278dc4a29aa2b881b9dc4b45a82929c5" category="section-title">22.04의 변경</block>
  <block id="cb60f101c87f3def78d0fef168389244" category="inline-link-macro">GitHub 문제 #681</block>
  <block id="2901fba3b85d37ea6000d90e72366ba6" category="list-text">iSCSI 이니시에이터 이름의 구문 분석 기능이 향상되었습니다. (<block ref="3947f141b94c1867221790f45a6ee173" category="inline-link-macro-rx"></block>)</block>
  <block id="8804e61e26be921d78a1632ad8607a4c" category="inline-link-macro">GitHub 문제 #598</block>
  <block id="d0aad022e470a22fe71fa5616ce002f8" category="list-text">CSI 스토리지 클래스 매개 변수가 허용되지 않는 문제를 해결했습니다. (<block ref="032ea6b8f2fceffcd025bdcae99652ae" category="inline-link-macro-rx"></block>)</block>
  <block id="34fb36c5e51f4530848bc5114cf29aa7" category="inline-link-macro">GitHub 문제 #671</block>
  <block id="951995417edc5c2968955384b925b27e" category="list-text">Trident CRD에서 중복 키 선언을 수정했습니다. (<block ref="6e73ffca3c5d1dc68cd639612845812c" category="inline-link-macro-rx"></block>)</block>
  <block id="55cd7443e4a1278a57f612df28b8eee3" category="inline-link-macro">GitHub 문제 #629</block>
  <block id="ec74c645b7b5f9d3051f68de156927d9" category="list-text">부정확한 CSI 스냅샷 로그를 수정했습니다. (<block ref="9b20149e8d36c115b9349e728abebd54" category="inline-link-macro-rx"></block>))</block>
  <block id="28341d7630f486a1b72b5b97d39ce589" category="list-text">삭제된 노드에서 볼륨 게시를 취소하는 문제 해결 (<block ref="439c8b5253b3b0fa8d2ddb79f44cd784" category="inline-link-macro-rx"></block>)</block>
  <block id="fbb82269f3871bc5751dda6ade9cd9ea" category="inline-link-macro">GitHub 문제 #656</block>
  <block id="e02171b3da303c0d6b9bd3102650bb07" category="list-text">블록 디바이스에서 파일 시스템 불일치를 처리하는 기능이 추가되었습니다. (<block ref="b6c419ed0f79d6957e3796ca0e0742cb" category="inline-link-macro-rx"></block>)</block>
  <block id="1bae87f1c9d9a094dce218672331de02" category="inline-link-macro">GitHub 문제 #715</block>
  <block id="4aeb6a7748e689a0ce92c16344bb6285" category="list-text">설치 중 'imageRegistry' 플래그를 설정할 때 자동 지원 이미지를 가져오는 문제가 해결되었습니다. (<block ref="5f789d3f3d58c42cfbeb0b6394bac993" category="inline-link-macro-rx"></block>)</block>
  <block id="70703300e76c51632e4ea22ce53c74af" category="inline-link-macro">GitHub 문제 #698</block>
  <block id="99df1eeec5b67fac5a47fb610c720712" category="list-text">이제 Trident의 보안 끝점에 대한 인바운드 연결에는 TLS 1.3 이상이 필요합니다. (<block ref="5ab4d3faf45db0d93ac1a5f7438f1c62" category="inline-link-macro-rx"></block>)</block>
  <block id="3786cba0bc294f586b13783c69b08371" category="inline-link-macro">GitHub 문제 #694</block>
  <block id="c0f60be70f5b8a5bc6c7c8071f4481fb" category="list-text">* Kubernetes *: Trident가 이제 시스템 노드 크리티컬 우선 순위 클래스에서 실행됩니다. (<block ref="b04869f92878b510e393bc41361c825d" category="inline-link-macro-rx"></block>)</block>
  <block id="8f5cc6430613f1c12f36965050bb7197" category="sidebar">불화</block>
  <block id="094a6e8342b02106129112ad2ff3d374" category="list-text">Mirantis Kubernetes 엔진 3.5</block>
  <block id="c53358822905bb04d312060d1cb568af" category="inline-link">Astra Trident 22.04</block>
  <block id="fdd380631ba8063e7b8f842282a01e40" category="list-text"><block ref="fdd380631ba8063e7b8f842282a01e40" category="inline-link-rx"></block></block>
  <block id="ccb5eb98656346cbfa0b207e7d363bef" category="inline-link-macro">배포 방법</block>
  <block id="e2bcf5dc117f31569d413bd9b7698bf2" category="list-text">중 하나를 사용하여 Astra Trident를 배포합니다 <block ref="71cad0f2a077aa26894105299bf47b53" category="inline-link-macro-rx"></block>.</block>
  <block id="26798b67dd2e5b4c8d4f03c4c16170c7" category="list-text"><block ref="26798b67dd2e5b4c8d4f03c4c16170c7" category="inline-link-macro-rx"></block></block>
  <block id="85d7b73826973ab07bfe78af69bd85f4" category="list-text"><block ref="85d7b73826973ab07bfe78af69bd85f4" category="inline-link-macro-rx"></block></block>
  <block id="a1142049a82a11e90102d655bb7e234d" category="inline-link-macro">GitHub의 _Assets_섹션</block>
  <block id="756909f99bc1a720d318a5f5b94eb094" category="section-title">문제 해결을 위해 로그를 수집합니다</block>
  <block id="3d945423f8e9496c429a5d8c65b4604f" category="paragraph">우분투</block>
  <block id="134bf17c90c90b5aeed99dde262bf14d" category="admonition">Trident에 대한 네임스페이스를 이미 만든 경우에는 '--create-namespace' 매개 변수가 추가 네임스페이스를 만들지 않습니다.</block>
  <block id="76ab201466ec43d71ec9051f8a556457" category="paragraph">SAN 스토리지 드라이버를 사용하는 ONTAP 백엔드의 경우 Astra Trident는 양방향 CHAP를 설정하고 "tridentctl"을 통해 CHAP 사용자 이름과 암호를 관리할 수 있습니다. 을 참조하십시오 <block ref="2e905590b15db776a189c7b5f90d9174" category="inline-link-macro-rx"></block> Astra Trident가 ONTAP 백엔드에서 CHAP를 구성하는 방법을 이해합니다.</block>
  <block id="ea4a2eeab32b5cd82414bd4a2fc3e8e6" category="section-title">Astra Trident가 NVE 및 NAE와 연동되는 방식</block>
  <block id="c638f77e97a62d0d11f775816222d62a" category="inline-link-macro">NetApp 볼륨 암호화 구성 개요</block>
  <block id="b65b10bf779c45e4940c255ecf83bdc3" category="paragraph">NetApp ONTAP는 유휴 데이터 암호화를 제공하여 디스크를 도난, 반환 또는 용도 변경할 때 중요한 데이터를 보호합니다. 자세한 내용은 을 참조하십시오 <block ref="e0b51490e5d435c82abc702d0a4ca15c" category="inline-link-macro-rx"></block>.</block>
  <block id="2f96099170687a6fc94d47d5c9e1db78" category="list-text">백엔드에서 NAE가 활성화된 경우 Astra Trident에 프로비저닝된 모든 볼륨은 NAE가 활성화됩니다.</block>
  <block id="f2e4034ee02b84093370b28f55809870" category="list-text">NAE가 백엔드에서 활성화되지 않은 경우, 백엔드 구성에서 NVE 암호화 플래그를 'false'로 설정하지 않으면 Astra Trident에 프로비저닝된 모든 볼륨은 NVE를 사용할 수 있습니다.</block>
  <block id="82d9a35a126449139766a969834999ca" category="paragraph">NAE 지원 백엔드의 Astra Trident에 생성된 볼륨은 NVE 또는 NAE 암호화여야 합니다.</block>
  <block id="1bb1c0791a9e9cff8de216ed44b1de31" category="list-text">Trident 백엔드 구성에서 NVE 암호화 플래그를 'true'로 설정하여 NAE 암호화를 재정의하고 볼륨별로 특정 암호화 키를 사용할 수 있습니다.</block>
  <block id="c376f853ae2704beeb8bbb6836ada303" category="list-text">NAE 지원 백엔드에서 NVE 암호화 플래그를 'false'로 설정하면 NAE 지원 볼륨이 생성됩니다. NVE 암호화 플래그를 'false'로 설정하여 NAE 암호화를 비활성화할 수 없습니다.</block>
  <block id="5991606c4d185f50bd7f678053004989" category="list-text">NVE 암호화 플래그를 'true'로 명시적으로 설정하여 Astra Trident에서 NVE 볼륨을 수동으로 생성할 수 있습니다.</block>
  <block id="b6c7fef7b7bcf035a4f4ad02ff8808c2" category="paragraph">백엔드 구성 옵션에 대한 자세한 내용은 다음을 참조하십시오.</block>
  <block id="06c4db929b729ddf158ceb5cc15b122b" category="inline-link-macro">ONTAP SAN 구성 옵션</block>
  <block id="6d9333eebb991611d29a4f8b7cc21fec" category="cell">새 볼륨에 NVE(NetApp Volume Encryption)를 사용하도록 설정하고 기본값은 'false'입니다. 이 옵션을 사용하려면 NVE 라이센스가 클러스터에서 활성화되어 있어야 합니다. 백엔드에서 NAE가 활성화된 경우 Astra Trident에 프로비저닝된 모든 볼륨은 NAE가 활성화됩니다. 자세한 내용은 다음을 참조하십시오. <block ref="00deada136b55f176f599153703cf50d" category="inline-link-macro-rx"></block>.</block>
  <block id="911675212835161abe9bce3f33c70af0" category="paragraph">새 볼륨에 NVE(NetApp Volume Encryption)를 사용하도록 설정하고 기본값은 'false'입니다. 이 옵션을 사용하려면 NVE 라이센스가 클러스터에서 활성화되어 있어야 합니다.</block>
  <block id="1811ba2842625864e8f6233e19051566" category="paragraph">백엔드에서 NAE가 활성화된 경우 Astra Trident에 프로비저닝된 모든 볼륨은 NAE가 활성화됩니다.</block>
  <block id="cd6eb5bfdf9299ea3a76e2eb822c8293" category="paragraph">자세한 내용은 다음을 참조하십시오. <block ref="00deada136b55f176f599153703cf50d" category="inline-link-macro-rx"></block>.</block>
  <block id="2bc97a247278d92f5552529c55ab7f0d" category="paragraph">새 볼륨에 NVE(NetApp Volume Encryption)를 지원하며 기본값은 'false'입니다. 이 옵션을 사용하려면 NVE 라이센스가 클러스터에서 활성화되어 있어야 합니다.</block>
  <block id="17d79009c5c2bb6bd570bb6f87552a2d" category="paragraph">Astra Trident는 NFS 및 iSCSI PVS 크기를 조정할 수 있도록 지원합니다. 따라서 사용자는 Kubernetes 계층을 통해 직접 볼륨의 크기를 조정할 수 있습니다. ONTAP, SolidFire/NetApp HCI 및 Cloud Volumes Service 백엔드를 포함한 모든 주요 NetApp 스토리지 플랫폼에서 볼륨 확장이 가능합니다. 나중에 확장을 허용하려면 볼륨과 연관된 StorageClass에서 allowVolumeExpansion을 true로 설정합니다. 영구 볼륨의 크기를 조정해야 할 때마다 영구 볼륨 클레임의 'pec.resources.requests.storage' 주석을 필요한 볼륨 크기로 편집합니다. Trident는 스토리지 클러스터의 볼륨 크기를 자동으로 조정합니다.</block>
  <block id="ee3d8ea22d8bf88f2f7fcd6d6dbf26d2" category="paragraph">메트릭 서비스는 관리자에게 OpenShift 클러스터의 상태, 리소스 활용도 및 가용성에 대한 중요한 정보를 제공합니다. 또한 POD 자동 확장 기능도 필요하며, 많은 조직에서 비용 청구 및/또는 애플리케이션 표시를 위해 메트릭 서비스의 데이터를 사용합니다.</block>
  <block id="5e5cb863d5fe17c205c3d2201a1a2235" category="paragraph">Astra Trident는 Kubernetes 클러스터에 Pod로 구축하고 Kubernetes 워크로드에 동적 스토리지 오케스트레이션 서비스를 제공합니다. 컨테이너화된 애플리케이션을 통해 ONTAP(AFF/FAS/Select/Cloud/Amazon FSx for NetApp ONTAP), Element 소프트웨어(NetApp HCI/SolidFire), Azure NetApp Files 서비스 및 Google Cloud의 Cloud Volumes Service를 비롯한 NetApp의 광범위한 포트폴리오에서 영구 스토리지를 빠르고 쉽게 사용할 수 있습니다.</block>
  <block id="f21f22dde0e0692333a7a28cce456b08" category="sidebar">모든 Astra 문서</block>
  <block id="06d5b814514e67e2a36b491b2493aed1" category="paragraph">여기에 나열된 권장 사항을 사용하여 Astra Trident 설치가 안전한지 확인합니다.</block>
  <block id="252ee40ccbd23adc008945e85af83513" category="section-title">NVE와 NAE가 포함된 Astra Trident를 사용하십시오</block>
  <block id="676ad90ce2543d29917d8a5a6fc02e01" category="inline-link-macro">ONTAP NAS 구성 옵션</block>
  <block id="a44b6b00e5eebd7494e1fd00658685e2" category="inline-link-macro">NIST</block>
  <block id="83188252104d97bbc732f23aa3b26ae2" category="inline-link-macro">Gitlab: cryptsetup</block>
  <block id="15671c66e35f11a8d4024ff7ca5e7fb6" category="list-text">성능상의 이유로 작업자 노드는 AES-NI(Advanced Encryption Standard New Instructions)를 지원하는 것이 좋습니다. AES-NI 지원을 확인하려면 다음 명령을 실행합니다.</block>
  <block id="0520b57116af979714f913239aa512a5" category="inline-link-macro">인텔: AES-NI(Advanced Encryption Standard Instructions)</block>
  <block id="64e4c9865ee7451edfc34d72da12ee7d" category="paragraph">아무 것도 반환되지 않으면 프로세서는 AES-NI를 지원하지 않습니다. AES-NI에 대한 자세한 내용은 다음 웹 사이트를 참조하십시오. <block ref="e77f47a78a9c4677daf14d5366b503b4" category="inline-link-macro-rx"></block>.</block>
  <block id="227eef96675ec0e7595951c060437608" category="list-text">사용<block ref="bed471c4a88e25ac9a7e4a7b980700a8" prefix=" " category="inline-code"></block> LUKS 암호화를 사용하여 스토리지 풀을 정의합니다. 예를 들면 다음과 같습니다.</block>
  <block id="e646e16bee8b32e6ea29e30d01970a6c" category="section-title">제한 사항</block>
  <block id="21d437ff7c8ceb5481603b5d2c05442a" category="inline-link">Astra Trident 22.07</block>
  <block id="8a7908446b584a99ce1055c602a9c74e" category="list-text"><block ref="8a7908446b584a99ce1055c602a9c74e" category="inline-link-rx"></block></block>
  <block id="027daea9679099cb5b0c6ddd862f1afc" category="paragraph">* Astra Trident 22.10으로 업그레이드하기 전에 다음 중요 정보를 읽어야 합니다. *</block>
  <block id="83261c9e7e65d5ffc2d188c07767e5f6" category="admonition-title">strong&gt;Astra Trident 22.10에 대한 중요 정보&lt;/strong&gt;</block>
  <block id="c5d2d3c8dfa65a831c35d09ac4683434" category="list-text">이제 Trident에서 Kubernetes 1.25가 지원됩니다. Kubernetes 1.25로 업그레이드하기 전에 Astra Trident를 22.10으로 업그레이드해야 합니다.</block>
  <block id="27418d8553177383cd6e1bb0e1ce4a57" category="list-text">Astra Trident는 이제 SAN 환경에서 다중 경로 구성을 사용하도록 엄격히 적용되며 권장값은 입니다<block ref="db729c5c8df447087e5a84b961df14f6" prefix=" " category="inline-code"></block> 다중 경로 .conf 파일</block>
  <block id="7b9eed191ce5e7cc8c8d1cb8cfe2d8c8" category="paragraph">비 경로 다중화 구성 또는 의 사용<block ref="a3a1d5b95e345a3db24a5a30e349f699" prefix=" " category="inline-code"></block> 또는<block ref="e82e6d155396541f07f7347c984444ea" prefix=" " category="inline-code"></block> multipath.conf 파일의 값으로 인해 마운트 오류가 발생합니다. Trident에서 의 사용을 권장했습니다<block ref="db729c5c8df447087e5a84b961df14f6" prefix=" " category="inline-code"></block> 21.07 릴리스 이후.</block>
  <block id="84ec6afbbe3e33afb3eba2b0375718b1" category="inline-link-macro">문제 #759</block>
  <block id="e07bc583b0f70b05fdbb1008303e8f85" category="list-text">을 사용하여 생성된 ONTAP 백엔드에 대한 특정 문제를 해결했습니다<block ref="d3ed68f7315b7e72b8d886b2278fcac3" prefix=" " category="inline-code"></block> 22.07.0 업그레이드 중 온라인 상태로 전환되지 않는 필드(<block ref="294e408500bc8358b70c680986c23bdb" category="inline-link-macro-rx"></block>)를 클릭합니다.</block>
  <block id="958424a347179b6856de7610a2b99b8d" category="inline-link-macro">문제 #548</block>
  <block id="9663034bca37c0603d813726d885503d" category="inline-link-macro">문제 # 760</block>
  <block id="26d08c0516dec92a4420f06d4da4fcf1" category="list-text">Docker**:** 일부 환경에서 Docker 볼륨 플러그인을 시작하지 못하는 문제 해결(<block ref="78b7b57a86c570439562f2c638103de5" category="inline-link-macro-rx"></block> 및 <block ref="968dd574470c019c42c32878b5799fe9" category="inline-link-macro-rx"></block>)를 클릭합니다.</block>
  <block id="120b67b07f827aba020a1e3932877333" category="list-text">보고 노드에 속하는 데이터 LIF의 일부만 게시되도록 ONTAP SAN 백엔드에 특정한 SLM 문제를 수정했습니다.</block>
  <block id="8f9d66f5cbbd4fc027dbd00d46032c8e" category="list-text">볼륨을 연결할 때 iSCSI LUN에 대한 불필요한 검사가 발생하는 성능 문제를 해결했습니다.</block>
  <block id="4a9eb9834d90361e1b70e6ac3c8b9a5c" category="list-text">Astra Trident iSCSI 워크플로우 내에서 세분화된 재시도 횟수를 제거하여 빠르게 실패하고 외부 재시도 간격을 줄일 수 있습니다.</block>
  <block id="08e9e62a917aaf944b6ff85929a9f1dd" category="list-text">해당 다중 경로 장치가 이미 플러시되었을 때 iSCSI 장치를 플러싱할 때 오류가 반환되는 문제를 해결했습니다.</block>
  <block id="bc5611c731b034c5f323419d0258aa44" category="list-text">쿠버네티스:</block>
  <block id="98f7f8fbd26f9272ad6a29f2fb6c930b" category="list-text">Trident Deployment 및 DemonSet에 대해 별도의 ServiceAccount, ClusterRole 및 ClusterRoleBinding을 추가하여 이후의 사용 권한 개선을 허용합니다.</block>
  <block id="609df46dff884c3eec4386eb8db4e358" category="inline-link-macro">네임스페이스 간 볼륨 공유</block>
  <block id="09065204259df86d4fe38c35ea23f5af" category="list-text">모든 Trident<block ref="aa44e980d222d5134b5e0d8a062e1543" prefix=" " category="inline-code"></block> 이제 스토리지 드라이버가 ONTAP REST API에서 작동합니다.</block>
  <block id="8485ea08789af7b6b7b44e024b526f9b" category="list-text">새로운 운영자 YAML 추가 <block ref="5a02ebff4889c2de0379a0fb10bed282" prefix="(" category="inline-code"></block>)를 사용하지 않을 경우<block ref="316707d12484dd3afede08839dee49bc" prefix=" " category="inline-code"></block> Kubernetes 1.25를 지원합니다.</block>
  <block id="26e871bef43095263845143b043aee4f" category="inline-link-macro">LUKS 암호화 볼륨 지원</block>
  <block id="30b044636a9c63ab4b202192eec30c1c" category="list-text">Windows Server 2019 노드에 대한 지원이 추가되었습니다.</block>
  <block id="38b9dc57f44121e6d970b34eede9ad0d" category="inline-link-macro">Windows 노드에서 SMB 볼륨 지원</block>
  <block id="af8a9d07c7391207db96957ab59cb459" category="list-text">** Kubernetes:** 최소 지원 Kubernetes를 1.20으로 업데이트했습니다.</block>
  <block id="d667cfc8e8d6ec0c2352fe97b0f09e40" category="list-text">ADS(Astra Data Store) 드라이버를 제거했습니다.</block>
  <block id="9b363ea2db99fe0dc5e9b43f47a37f20" category="list-text">에 대한 지원이 제거되었습니다<block ref="a6105c0a611b41b08f1209506350279e" prefix=" " category="inline-code"></block> 및<block ref="8c319f28d81d1527a9428e9a5c2195f5" prefix=" " category="inline-code"></block> 에 대한 옵션<block ref="19b30dc119e514235b739e076be9b3cc" prefix=" " category="inline-code"></block> iSCSI에 대한 작업자 노드 경로 다중화를 구성하는 경우</block>
  <block id="1407cfeeb5e3916e1435ddea0f1c0a28" category="section-title">22.07 변경</block>
  <block id="6f4b2a393838b7a42ebca342bdba2246" category="cell">v1.25.0</block>
  <block id="071d9becf308917b53d70c09e7da51b6" category="list-text">지원되는 NetApp 스토리지 시스템에 대한 액세스</block>
  <block id="19eb712f406fc64109f96d9cf4055cb9" category="list-text">모든 Kubernetes 작업자 노드에서 볼륨을 마운트할 수 있습니다.</block>
  <block id="5f35b91e200cda68bf700d65b89c2c73" category="list-text">가 설치된 Linux 호스트<block ref="0f12ee5c9f1dd90158580f1c292b0d37" prefix=" " category="inline-code"></block> (또는<block ref="fb024832e51eb5f6da9113a745f1eb59" prefix=" " category="inline-code"></block>, OpenShift를 사용하는 경우) 사용하려는 Kubernetes 클러스터를 관리하도록 설치 및 구성한 것입니다.</block>
  <block id="c1c8ac442a800bb41f1cc1dc1350132e" category="admonition">Astra Trident를 Windows 노드에서 실행하도록 설정하려면 을 추가합니다<block ref="636d7cccc33f77beafb20be9cf83cd53" prefix=" " category="inline-code"></block> 설치 명령에 플래그 지정:<block ref="a240440622dae805c5d62a3c17f5f51e" prefix=" " category="inline-code"></block>.</block>
  <block id="50f33d14f129e4548c1c270fd6725a78" category="section-title">구성 옵션</block>
  <block id="05f901da7fdacb9ca59e3d7e2d40f98d" category="cell"><block ref="0f4137ed1502b5045d6083aa258b5c42" prefix="" category="inline-code"></block></block>
  <block id="fbbd7b4b14060c4fdb02f92c4c08e702" category="cell">를 로 설정합니다<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block> Windows 작업자 노드에 설치할 수 있습니다.</block>
  <block id="a3ff66cf5848a34d56915c8e879a5d52" category="section-title">샘플 구성</block>
  <block id="a6ba054ae6c021e3bc8a173393842c3d" category="paragraph">정의할 때 위에서 언급한 속성을 사용할 수 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 를 눌러 설치를 사용자 정의합니다.</block>
  <block id="3dabf672facbe8c5e2eeff030c2b8520" category="example-title">예 1: 기본 사용자 정의 구성</block>
  <block id="d21e69ca251cfbb211d0ee66fd06d5b3" category="paragraph">다음은 기본 사용자 지정 구성의 예입니다.</block>
  <block id="8438aa96607926cc56a36b843e04244f" category="example-title">예 2: 노드 선택기를 사용하여 배포</block>
  <block id="fd2915a467b0d801691fa5242e597f02" category="paragraph">이 예제에서는 노드 선택기를 사용하여 Trident를 배포하는 방법을 보여 줍니다.</block>
  <block id="aa5b232f08f4f3a911b242c500c5c9a1" category="example-title">예 3: Windows 작업자 노드에 배포</block>
  <block id="74b19e3113c78692266e87afce12f681" category="paragraph">이 예제에서는 Windows 작업자 노드에 대한 배포를 보여 줍니다.</block>
  <block id="8720cc63ac2a7bd9564830d7e775715e" category="paragraph"><block ref="210ab9e731c9c36c2c38db15c28a8d1c" prefix="" category="inline-code"></block> 플래그: *<block ref="490aa9b616d8535386ddf1c7037f79a0" prefix=" " category="inline-code"></block>: 볼륨에 대한 도움말입니다. *<block ref="e3bbbed29599d3e6e29ae22829ad7f13" prefix=" " category="inline-code"></block>: 하위 원본 볼륨으로 쿼리를 제한합니다. *<block ref="aed2a4a749284f757648f1057abf44cd" prefix=" " category="inline-code"></block>: 볼륨 부하로 쿼리 제한.</block>
  <block id="5f82f4ab2783617b6e62bdd43d4a4e49" category="doc">ONTAP SAN 드라이버를 사용하여 백엔드를 구성할 준비를 합니다</block>
  <block id="19eb1a22d8687def5fb4904d3402728a" category="doc">네임스페이스 전체에서 NFS 볼륨을 공유합니다</block>
  <block id="9553e9f0cb878601784cbe35c7767060" category="paragraph">Astra 트리펜볼륨 레퍼런스 CR을 사용하면 하나 이상의 Kubernetes 네임스페이스에서 ReadWriteMany(rwx) NFS 볼륨을 안전하게 공유할 수 있습니다. 이 Kubernetes 네이티브 솔루션은 다음과 같은 이점을 제공합니다.</block>
  <block id="6b456f0abe4c4d2f0beb62e5985136cf" category="list-text">보안을 보장하기 위한 다양한 수준의 액세스 제어</block>
  <block id="6e5d93bf8e8aaaa4795a50f012bc8fea" category="list-text">모든 Trident NFS 볼륨 드라이버와 호환됩니다</block>
  <block id="0ece56dd58b5aabac15e0d0a30553bc0" category="list-text">tridentctl 또는 기타 기본 Kubernetes 기능이 아닌 기능에 의존하지 않습니다</block>
  <block id="b6fcfcfd30bda2a77ebc74f23270f581" category="paragraph">이 다이어그램은 2개의 Kubernetes 네임스페이스에서 NFS 볼륨 공유를 보여 줍니다.</block>
  <block id="45208a2cac11f33c3e6af84d444ac7c5" category="image-alt">네임스페이스 간 공유의 개념적 다이어그램</block>
  <block id="06ad314b340900d226b1196e1fe289e9" category="section-title">빠른 시작</block>
  <block id="f5b36cc36c8381e7577788dd4db2019d" category="paragraph">몇 단계만으로 NFS 볼륨 공유를 설정할 수 있습니다.</block>
  <block id="88b05b42d60719619c24f6101bcd381a" category="paragraph">소스 네임스페이스 소유자는 소스 PVC의 데이터에 액세스할 수 있는 권한을 부여합니다.</block>
  <block id="7037976663710169f00563675ffd3f91" category="paragraph">클러스터 관리자는 대상 네임스페이스의 소유자에게 트리엔VolumeReference CR을 생성할 수 있는 권한을 부여합니다.</block>
  <block id="46374486db0641fa4a3fc8e9c73766ed" category="paragraph">대상 네임스페이스의 소유자는 소스 PVC를 참조하기 위해 트리엔VolumeReference CR을 생성합니다.</block>
  <block id="33fefc8d535df49d886c4bc78a08e3e5" category="paragraph">대상 네임스페이스의 소유자는 원본 PVC의 데이터 소스를 사용하기 위해 하위 PVC를 만듭니다.</block>
  <block id="7238deab481379c03df561ea7c9b0e2e" category="section-title">소스 및 대상 네임스페이스를 구성합니다</block>
  <block id="b23d212300860aa39d44f8fad02636a1" category="paragraph">보안을 보장하기 위해 네임스페이스 간 공유는 소스 네임스페이스 소유자, 클러스터 관리자 및 대상 네임스페이스 소유자의 협업 및 조치가 필요합니다. 사용자 역할은 각 단계에서 지정됩니다.</block>
  <block id="aae019fccb9b3ffee1ee77e9e5f2377a" category="list-text">* 원본 네임스페이스 소유자: * PVC를 만듭니다 <block ref="30520f4f96804df83914260b79f55962" prefix="(" category="inline-code"></block>)를 대상 네임스페이스와 공유할 수 있는 권한을 부여하는 소스 네임스페이스의 경우 <block ref="6fde1ba4470caca933058264dbfdea2e" prefix="(" category="inline-code"></block>)를 사용합니다<block ref="287f26e3328f9ac0f3f4da2cdaddd3e2" prefix=" " category="inline-code"></block> 주석.</block>
  <block id="3c2d838391ba40c10d124535dfb833e2" category="paragraph">Astra Trident가 PV 및 백엔드 NFS 스토리지 볼륨을 생성합니다.</block>
  <block id="365b452a5b5d2d01e1f193fc8bd9bf2c" category="list-text">쉼표로 구분된 목록을 사용하여 PVC를 여러 네임스페이스에 공유할 수 있습니다. 예를 들면, 다음과 같습니다.<block ref="6b31015528f67fe4ce10b7c81957f601" prefix=" " category="inline-code"></block>.</block>
  <block id="fefd0d1f7e80bb8a4657265696b66694" category="list-text">를 사용하여 모든 네임스페이스에 공유할 수 있습니다<block ref="3389dae361af79b04c9c8e7057f60cc6" prefix=" " category="inline-code"></block>. 예를 들면, 다음과 같습니다.<block ref="e06421e15aa316addc52dd6c697027b7" prefix=" " category="inline-code"></block></block>
  <block id="bac5e1b9773b73b6702dfe25c8a61a05" category="list-text">PVC를 업데이트하여 를 포함할 수 있습니다<block ref="287f26e3328f9ac0f3f4da2cdaddd3e2" prefix=" " category="inline-code"></block> 언제든지 주석을 추가할 수 있습니다.</block>
  <block id="512fce88fc641bb15b14b72474159acd" category="list-text">* 클러스터 관리자: * 대상 네임스페이스 소유자에게 대상 네임스페이스에서 트리젠VolumeReference CR을 생성할 수 있는 권한을 부여하기 위해 사용자 지정 역할을 생성하고 kubecon무화하십시오.</block>
  <block id="5f560764a361bf1159f8a6c8cbd15dad" category="list-text">* 대상 네임스페이스 소유자: * 소스 네임스페이스를 참조하는 대상 네임스페이스에서 트리젠VolumeReference CR을 만듭니다<block ref="30520f4f96804df83914260b79f55962" prefix=" " category="inline-code"></block>.</block>
  <block id="d9bb6497cda089fc4a386c685a97cffa" category="list-text">* 대상 네임스페이스 소유자: * PVC를 만듭니다 <block ref="3f6857fc20ae2372499a71869ac3fe7e" prefix="(" category="inline-code"></block>)를 대상 네임스페이스에서 사용합니다 <block ref="6fde1ba4470caca933058264dbfdea2e" prefix="(" category="inline-code"></block>)를 사용합니다<block ref="57c54cbee1c6ed3d5902aa1d8cd1e55a" prefix=" " category="inline-code"></block> 원본 PVC를 지정하는 주석.</block>
  <block id="e22f320aefbf1cdb3ccd68c26b050060" category="admonition">대상 PVC의 크기는 소스 PVC보다 작거나 같아야 합니다.</block>
  <block id="c6e8d7b047a148bcf2aeae743c286bbb" category="paragraph">Astra Trident가 을 읽습니다<block ref="57c54cbee1c6ed3d5902aa1d8cd1e55a" prefix=" " category="inline-code"></block> 대상 PVC에 주석을 추가하여 대상 PV를 원본 PV를 가리키는 자체 스토리지 리소스가 없는 하위 볼륨으로 생성하고 소스 PV 스토리지 리소스를 공유합니다. 대상 PVC와 PV가 정상으로 표시됩니다.</block>
  <block id="a5ddf1dcee266e65795efb120a45d2cb" category="section-title">공유 볼륨을 삭제합니다</block>
  <block id="2b71b549a21992aba927484a35ad72f6" category="paragraph">여러 네임스페이스에서 공유되는 볼륨을 삭제할 수 있습니다. Astra Trident는 소스 네임스페이스에서 볼륨에 대한 액세스를 제거하고 볼륨을 공유하는 다른 네임스페이스에 대한 액세스를 유지 관리합니다. 볼륨을 참조하는 모든 네임스페이스가 제거되면 Astra Trident가 볼륨을 삭제합니다.</block>
  <block id="9f2f83b0c97d84774c1d61107283bb68" category="paragraph">를 사용합니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 유틸리티, 를 실행할 수 있습니다<block ref="b5eda0a74558a342cf659187f06f746f" prefix=" " category="inline-code"></block> 하위 볼륨을 가져오는 명령입니다. 자세한 내용은 다음 링크를 참조하십시오.../triment-reference/tridentctl.html<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix="[" category="inline-code"></block> 명령 및 옵션].</block>
  <block id="b1cc54ad6906d5f41516543bae01e46f" category="list-text"><block ref="490aa9b616d8535386ddf1c7037f79a0" prefix="" category="inline-code"></block>: 볼륨에 대한 도움말입니다.</block>
  <block id="20668f390d13376c8d13ab4b20a53b5d" category="list-text"><block ref="e3bbbed29599d3e6e29ae22829ad7f13" prefix="" category="inline-code"></block>: 하위 원본 볼륨으로 쿼리를 제한합니다.</block>
  <block id="92c22bb3853554f94f513a2d2f36e8ef" category="list-text"><block ref="aed2a4a749284f757648f1057abf44cd" prefix="" category="inline-code"></block>: 볼륨 부하로 쿼리 제한.</block>
  <block id="3ad6cc2d4a6ad6fbd07574653275a161" category="list-text">Astra Trident는 대상 네임스페이스가 공유 볼륨에 쓰는 것을 막을 수 없습니다. 파일 잠금 또는 기타 프로세스를 사용하여 공유 볼륨 데이터를 덮어쓰지 않도록 해야 합니다.</block>
  <block id="3908892c437778f8b161a2ca006782cd" category="list-text">하위 볼륨에서는 스냅샷, 클론 및 미러링을 사용할 수 없습니다.</block>
  <block id="e6fe09cae66ba22c6abbd2511f660545" category="summary">ANF 백엔드를 구성하려면 먼저 다음 요구 사항을 충족해야 합니다.</block>
  <block id="aec47cf6a0cb83824b504b756eb4b71c" category="doc">Azure NetApp Files 백엔드를 구성할 준비를 합니다</block>
  <block id="fafa3c0a3cb069057415a83c6ebcceba" category="paragraph">Azure NetApp Files를 처음 사용하거나 새 위치에서 사용하는 경우 일부 초기 구성이 필요합니다.</block>
  <block id="97d64245613ba751b698ce77fd51779a" category="inline-link">Azure: Azure NetApp Files를 설정하고 NFS 볼륨을 생성합니다</block>
  <block id="2aa05cb8290726bf399391736b2c3515" category="list-text">Azure NetApp Files를 설정하고 NFS 볼륨을 생성하려면 을 참조하십시오<block ref="b6e93c3bfc36cf835c63e42e55586d97" category="inline-link-rx"></block>.</block>
  <block id="a2d5857c3b9121391e94a67cf08493ee" category="inline-link">Azure: Azure NetApp Files용 SMB 볼륨을 생성합니다</block>
  <block id="04c87c2db0b97d613ced591af56ad5bb" category="list-text">Azure NetApp Files를 구성하고 SMB 볼륨을 추가하려면 다음을 참조하십시오.<block ref="c33ad357613bf495746b18bdb4ed3ee8" category="inline-link-rx"></block>.</block>
  <block id="caa7dc98c21b44b17c214508b9b0fa3c" category="list-text"><block ref="bc54592d6183695b841c6d1880ec0bf8" prefix="" category="inline-code"></block>,<block ref="93c5bebdea9c94a0740fe6fd9bb250f0" prefix=" " category="inline-code"></block>, 및<block ref="2b53761249254ce6b502f521e5cc0683" prefix=" " category="inline-code"></block> 에서 <block ref="63405c89f422580946169fa59c41e7ae" category="inline-link-macro-rx"></block> Azure NetApp Files 서비스에 대한 충분한 권한이 있는 Azure Active Directory에서 앱 등록에서는 다음 중 하나를 사용해야 합니다.</block>
  <block id="ee495045d2c4c5131217a0248a404b4d" category="inline-link-macro">Azure에서 사전 정의</block>
  <block id="0b0da58ea52df6ff74bcbb53ae7ba931" category="list-text">소유자 또는 참가자 역할입니다 <block ref="76b3209c91e1786a477c35a6e91cf55f" category="inline-link-macro-rx"></block></block>
  <block id="2fbc632d5939633cc9c3b254d116080f" category="inline-link-macro">사용자 지정 참가자 역할</block>
  <block id="b0ee19cc46a4fb3df97c1c676c0a5d57" category="inline-link-macro">Azure 포털을 사용하여 역할을 할당합니다</block>
  <block id="993c1a80e778c965961521eeb4afd398" category="list-text">A <block ref="8ad3956583058d3582a7dd1281d1f882" category="inline-link-macro-rx"></block> 구독 레벨입니다 <block ref="e023f2926fb9af676f2809a760efeb14" prefix="(" category="inline-code"></block>) 다음 사용 권한은 Astra Trident에 필요한 권한만 가집니다. 사용자 지정 역할을 만든 후 <block ref="af58105ed429db29198b767444ed6d0d" category="inline-link-macro-rx"></block>.</block>
  <block id="daba51cb28ea016a4e85ad77defc5a2c" category="list-text">Azure를 선택합니다<block ref="d5189de027922f81005951e6efe0efd5" prefix=" " category="inline-code"></block> 하나 이상의 항목이 포함되어 있습니다 <block ref="e2df5d3690a644a8599397d798c15f56" category="inline-link-macro-rx"></block>. Trident 22.01부터<block ref="d5189de027922f81005951e6efe0efd5" prefix=" " category="inline-code"></block> 매개 변수는 백엔드 구성 파일의 최상위 수준에 있는 필수 필드입니다. 가상 풀에 지정된 위치 값은 무시됩니다.</block>
  <block id="77a4a369d552f7d3be163bda86f9113f" category="section-title">SMB 볼륨에 대한 추가 요구사항</block>
  <block id="1f43150a13f29c496f07ed4a9750b2ff" category="list-text">Linux 컨트롤러 노드 및 Windows Server 2019를 실행하는 Windows 작업자 노드가 있는 Kubernetes 클러스터 Astra Trident는 Windows 노드에서 실행되는 Pod에만 마운트된 SMB 볼륨을 지원합니다.</block>
  <block id="43950c84ce08a6b99dc3b224bc37d814" category="list-text">ANF가 Active Directory에 인증할 수 있도록 Active Directory 자격 증명이 포함된 Astra Trident 암호가 하나 이상 있어야 합니다. 암호를 생성합니다<block ref="e47a193687dde960f6b6f80d394142a3" prefix=" " category="inline-code"></block>:</block>
  <block id="7595de66780a622cdd37b4823afebc07" category="inline-link-macro">GitHub:CSI 프록시</block>
  <block id="c680a0c023a6d45186b9752a07e9938c" category="inline-link-macro">GitHub: Windows용 CSI 프록시</block>
  <block id="2d6b406e65ac91f2af09f4228e3efe4f" category="list-text">Windows 서비스로 구성된 CSI 프록시. 를 구성합니다<block ref="0f8126c17871ed45f2a848f15d96a1bb" prefix=" " category="inline-code"></block>를 참조하십시오 <block ref="3ca23c6eadaac7aa23a492aef5e5d012" category="inline-link-macro-rx"></block> 또는 <block ref="0b56a9ad79a8fef177779e7d3d856994" category="inline-link-macro-rx"></block> Windows에서 실행되는 Kubernetes 노드의 경우:</block>
  <block id="3fec7156504f6ca677ea0a137456913e" category="summary">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 Google Cloud용 Cloud Volumes Service를 구성하는 방법을 알아보십시오.</block>
  <block id="eb89f16d07a93fa10a31ec6309045fe9" category="doc">ONTAP SAN 구성 옵션 및 예</block>
  <block id="b8ae61dc50cf8e8b79e68bc4a8d36393" category="cell"><block ref="0f179ba2bc32ab5d8f60692f5b800c86" prefix="" category="inline-code"></block></block>
  <block id="a56dcba8eacdac67fb510e1434d560d8" category="inline-link-macro">LUKS(Linux Unified Key Setup) 사용</block>
  <block id="8f145066de3f0e0a9d2e9cc5bf6f09f5" category="doc">ONTAP NAS 백엔드를 구성합니다</block>
  <block id="fd05c90de484dbc1cb963df796886af4" category="doc">ONTAP NAS 드라이버를 사용하여 백엔드를 구성할 준비를 합니다</block>
  <block id="481e993a13f6d4f981acc2da60465e2a" category="summary">ANF에 대한 NFS 및 SMB 백엔드 구성 옵션에 대해 알아보고 구성 예를 검토하십시오.</block>
  <block id="17a48ec106d5505e674ccdf56fce1058" category="doc">Azure NetApp Files 백엔드 구성 옵션 및 예</block>
  <block id="4bb587d1662752a66d32e629a36d70c0" category="paragraph">Astra Trident는 백엔드 구성(서브넷, 가상 네트워크, 서비스 수준 및 위치)을 사용하여 요청된 위치에서 사용할 수 있고 요청된 서비스 수준 및 서브넷과 일치하는 용량 풀에 ANF 볼륨을 생성합니다.</block>
  <block id="5fe26149fa172056aee5f841415c55fa" category="admonition">Astra Trident는 수동 QoS 용량 풀을 지원하지 않습니다.</block>
  <block id="1a5743e0279e48054d3f9bb1ebc7e266" category="paragraph">ANF 백엔드는 이러한 구성 옵션을 제공합니다.</block>
  <block id="55eaeeb515ba1b8a42eb736b0e58f41f" category="cell">볼륨에 대한 VNET 기능 집합은 일 수 있습니다<block ref="972e73b7a882d0802a4e3a16946a2f94" prefix=" " category="inline-code"></block> 또는<block ref="eb6d8ae6f20283755b339c0dc273988b" prefix=" " category="inline-code"></block>. 일부 지역에서는 네트워크 기능을 사용할 수 없으며 구독에서 활성화해야 할 수도 있습니다. 지정 <block ref="b0fdc9c7b96e4249152c61b506703142" prefix=" " category="inline-code"></block> 이 기능을 사용하지 않으면 볼륨 프로비저닝이 실패합니다.</block>
  <block id="cc3d42de123c784e8d8e3c8404b943be" category="cell">NFS 마운트 옵션에 대한 세밀한 제어 SMB 볼륨에 대해 무시됩니다. NFS 버전 4.1을 사용하여 볼륨을 마운트하려면 을 포함합니다 <block ref="c72da907ddca73ee114d92e5e098ce0e" prefix=" " category="inline-code"></block> 쉼표로 구분된 마운트 옵션 목록에서 NFS v4.1을 선택합니다. 스토리지 클래스 정의에 설정된 마운트 옵션은 백엔드 구성에 설정된 마운트 옵션을 재정의합니다.</block>
  <block id="f0873081464f48da27a1068215270c60" category="cell"><block ref="296026821ada2ab8aebcf13547a63df5" prefix="" category="inline-code"></block></block>
  <block id="c0a4a0396978d1ad8816d2e358a2f05e" category="cell">NFS 또는 SMB 볼륨 생성을 구성합니다. 옵션은 입니다<block ref="2521ef5d58fc027d3121662b7d8f9ac2" prefix=" " category="inline-code"></block>,<block ref="79e0f325804dafbdaef73b3b17c0fd8d" prefix=" " category="inline-code"></block> 또는 null입니다. Null로 설정하면 기본적으로 NFS 볼륨이 설정됩니다.</block>
  <block id="71e598dd105d32592243532b55392c55" category="cell"><block ref="2521ef5d58fc027d3121662b7d8f9ac2" prefix="" category="inline-code"></block></block>
  <block id="8cacf42dcc11f9e7779267100d4fd305" category="inline-link-macro">Azure NetApp Files 볼륨에 대한 네트워크 기능을 구성합니다</block>
  <block id="4ace77649689419cf09eed38ddf4e74c" category="admonition">네트워크 기능에 대한 자세한 내용은 을 참조하십시오 <block ref="d4c16e3034c39d54544a2d5f2b2953d9" category="inline-link-macro-rx"></block>.</block>
  <block id="d37198994935307f0e4a95505678642e" category="section-title">필요한 권한 및 리소스</block>
  <block id="dff55a3160f253fb2aab1c949fa24db0" category="paragraph">PVC를 생성할 때 "용량 풀을 찾을 수 없음" 오류가 발생하는 경우 앱 등록에 필요한 사용 권한 및 리소스(서브넷, 가상 네트워크, 용량 풀)가 연결되지 않은 것일 수 있습니다. DEBUG가 활성화된 경우 Astra Trident는 백엔드가 생성될 때 검색된 Azure 리소스를 기록합니다. 적절한 역할이 사용되고 있는지 확인합니다.</block>
  <block id="1860dce26ad531b08f4b17950bbda6a7" category="paragraph">의 값<block ref="6a3560738716ddd805d769d4460ca7aa" prefix=" " category="inline-code"></block>,<block ref="87d26f327b9deeb6141721bda7f8ca65" prefix=" " category="inline-code"></block>,<block ref="338b00a62e6d8d3234c056bf48b711d0" prefix=" " category="inline-code"></block>,<block ref="a88edbe6cce8d8f180d87bef83408312" prefix=" " category="inline-code"></block>, 및<block ref="4f556606ab1f7cb51dd23811407facbd" prefix=" " category="inline-code"></block> 간단한 이름 또는 정규화된 이름을 사용하여 지정할 수 있습니다. 이름이 같은 여러 리소스와 이름이 일치할 수 있으므로 대부분의 경우 정규화된 이름을 사용하는 것이 좋습니다.</block>
  <block id="8771cfaef1f991e1642d0a1ece8dcfa3" category="paragraph">를 클릭합니다<block ref="6a3560738716ddd805d769d4460ca7aa" prefix=" " category="inline-code"></block>,<block ref="87d26f327b9deeb6141721bda7f8ca65" prefix=" " category="inline-code"></block>, 및<block ref="338b00a62e6d8d3234c056bf48b711d0" prefix=" " category="inline-code"></block> 값은 검색된 리소스 집합을 이 스토리지 백엔드에서 사용할 수 있는 리소스로 제한하는 필터이며, 이 둘을 조합하여 지정할 수 있습니다. 정규화된 이름은 다음 형식을 따릅니다.</block>
  <block id="be1b9ef68f31ecee991e2282c1f24f0f" category="section-title">볼륨 프로비저닝</block>
  <block id="6154de53659ccfe0ba0733effdb2da13" category="paragraph">구성 파일의 특수 섹션에서 다음 옵션을 지정하여 기본 볼륨 프로비저닝을 제어할 수 있습니다. 을 참조하십시오 <block ref="c850cc933797a5d4472ae11f15a5ef5e" category="inline-xref-macro-rx"></block> 를 참조하십시오.</block>
  <block id="ea221277b2f168f5e17d112765f4a1c0" category="cell">새 볼륨에 대한 엑스포트 규칙<block ref="c72971f17465d2a32345bc872af62a34" prefix=" " category="inline-code"></block> CIDR 표기법을 사용하여 IPv4 주소 또는 IPv4 서브넷의 조합을 쉼표로 구분해야 합니다. SMB 볼륨에 대해 무시됩니다.</block>
  <block id="21590b83460bd480131384ef53bdccc4" category="cell">새 볼륨의 UNIX 사용 권한(8진수 4자리) SMB 볼륨에 대해 무시됩니다.</block>
  <block id="10c0eb6973453da95b4ef937f19ddb6c" category="section-title">예제 설정</block>
  <block id="36867df20f9068f37b26d3120d5e7ba4" category="paragraph">이는 절대적인 최소 백엔드 구성입니다. 이 구성을 통해 Astra Trident는 구성된 위치에서 ANF에 위임된 모든 NetApp 계정, 용량 풀 및 서브넷을 검색하고 해당 풀 및 서브넷 중 하나에 무작위로 새 볼륨을 배치합니다. 왜냐하면<block ref="296026821ada2ab8aebcf13547a63df5" prefix=" " category="inline-code"></block> 생략됩니다<block ref="2521ef5d58fc027d3121662b7d8f9ac2" prefix=" " category="inline-code"></block> 기본값은 NFS 볼륨에 대해 백엔드가 프로비저닝됩니다.</block>
  <block id="9c1aa30bfee58070482e646ad5d8bb4b" category="paragraph">이 백엔드 구성은 Azure에 볼륨을 배치합니다<block ref="6356111305f5daab178fa6051b7a8ae7" prefix=" " category="inline-code"></block> 의 위치<block ref="7057376a419b3334cc7b8b7a9f064abb" prefix=" " category="inline-code"></block> 용량 풀. Astra Trident는 해당 위치의 ANF에 위임된 모든 서브넷을 자동으로 검색하여 그 중 하나에 무작위로 새 볼륨을 배치합니다.</block>
  <block id="c0b04213f295bd61098649d5dec24291" category="section-title">스토리지 클래스 정의</block>
  <block id="cad675ae3fb846705512fe460e615ac3" category="paragraph">다음 사항을 참조하십시오<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 정의는 위의 스토리지 풀을 참조합니다.</block>
  <block id="1abbfd87ab307af55b755fd27ce60191" category="paragraph">사용<block ref="4d859186a09b1da3597e5901157d9400" prefix=" " category="inline-code"></block> 각각에 대해 지정할 수 있습니다<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 볼륨을 호스팅하는 데 사용되는 가상 풀입니다. 볼륨은 선택한 풀에 정의된 측면을 갖습니다.</block>
  <block id="4b7db799aa8307d15835ff36beb1b97c" category="section-title">SMB 볼륨에 대한 정의의 예</block>
  <block id="82b60bb483328d8efe9240dc8aa4a600" category="paragraph">사용<block ref="296026821ada2ab8aebcf13547a63df5" prefix=" " category="inline-code"></block>,<block ref="e12fdd044232e643620eed06bf33c7af" prefix=" " category="inline-code"></block>, 및 <block ref="1ad68a6a046942b7c1666aed825df70a" prefix=" " category="inline-code"></block>, SMB 볼륨을 지정하고 필요한 Active Directory 자격 증명을 제공할 수 있습니다.</block>
  <block id="6de60e9a6b0ad8adcd762a8c85d540e2" category="example-title">예제 1: 기본 네임스페이스의 기본 구성</block>
  <block id="1d8d21debc328526252944d2264246ca" category="example-title">예제 2: 네임스페이스당 다른 암호 사용</block>
  <block id="06bb6ebc4dada525717294b660ba2b3b" category="example-title">예 3: 볼륨별로 다른 암호 사용</block>
  <block id="c51cc3b801a879870aea846bdde1c7a3" category="section-title">백엔드를 생성합니다</block>
  <block id="7d8058d93ec1d95c673d83bf303326ff" category="doc">ONTAP NAS 구성 옵션 및 예</block>
  <block id="618a7676e411bbfbd9dbdb2411019951" category="summary">Astra Trident의 백엔드로 Azure NetApp Files(ANF)를 구성할 수 있습니다. ANF 백엔드를 사용하여 NAS 및 SMB 볼륨을 연결할 수 있습니다.</block>
  <block id="9d556ecfb4757173c93a34a5466447d7" category="list-text"><block ref="9d556ecfb4757173c93a34a5466447d7" category="inline-link-macro-rx"></block></block>
  <block id="ea61e2c2ff507048203824add1eb7c21" category="section-title">고려 사항</block>
  <block id="8f395c84ad002394e9f070a25937dcc4" category="list-text">Azure NetApp Files 서비스는 100GB 미만의 볼륨을 지원하지 않습니다. Astra Trident는 더 작은 볼륨을 요청하는 경우 100GB 볼륨을 자동으로 생성합니다.</block>
  <block id="1cf44a6bee7fa333861e5d0042926fb5" category="list-text">Astra Trident는 Windows 노드에서 실행되는 Pod에만 마운트된 SMB 볼륨을 지원합니다.</block>
  <block id="279096894abe6299537e865410f3d494" category="list-text">Astra Trident는 Windows ARM 아키텍처를 지원하지 않습니다.</block>
  <block id="ef0f938ae67a04ac3370fe516c2a6baf" category="list-text">Kubernetes 1.25 지원 추가. Kubernetes 1.25로 업그레이드하기 전에 Astra Trident를 22.10으로 업그레이드해야 합니다.</block>
  <block id="d041a310ba7cc2599250e64801594107" category="list-text">에 대한 지원이 추가되었습니다 <block ref="ca184a2eda203b6d98158bdf24e5cf7d" category="inline-link-macro-rx"></block>.</block>
  <block id="adbfe36f6399f2846983b2901604a962" category="list-text">추가되었습니다 <block ref="40be42d37bc6014716dcd0a1d368ffb5" category="inline-link-macro-rx"></block> 를 통해<block ref="bc5779a2d33eeb1304bae57f15920cfc" prefix=" " category="inline-code"></block> 스토리지 드라이버.</block>
  <block id="f18a50f02f48551895d57b81dd288142" category="sidebar">네임스페이스 전체에서 NFS 볼륨을 공유합니다</block>
  <block id="fd1117c82327fbe8671f26e897ceb8f4" category="inline-link-macro">BlueXP를 사용하는 Astra Trident</block>
  <block id="a76a1e164520105317267dc41b95e8ce" category="paragraph">와 함께 <block ref="f8c16e8c21124ccc028d2db7fd32a98f" category="inline-link-macro-rx"></block>Astra Trident의 최신 버전으로 업그레이드하고, 스토리지 클래스를 추가 및 관리하고, 작업 환경에 연결한 다음, Cloud Backup Service를 사용하여 영구 볼륨을 백업할 수 있습니다. BlueXP는 Trident 연산자를 사용하여 수동으로 또는 Helm을 사용하여 Astra Trident 구축을 지원합니다.</block>
  <block id="6ce33e8f1e198bf1c3583bc5ef789b75" category="paragraph">백엔드 정의 파일의 암호화 매개 변수를 사용하여 Trident에서 프로비저닝한 볼륨에 대한 암호화를 설정할 수 있습니다. 자세한 내용은 다음을 참조하십시오. <block ref="3260a21902518174ce8d9bfef42be276" category="inline-link-macro-rx"></block></block>
  <block id="cae73b6a00921ef48cee176b0d4336fe" category="inline-link-macro">구성 옵션</block>
  <block id="094d2b2ef4b98bdb0943b10cc4e305f4" category="admonition">Trident 설치 매개 변수를 필요에 따라 변경해야 합니다(예: 의 값 변경)<block ref="d771848c80f96e5954a8658655cf79d7" prefix=" " category="inline-code"></block>,<block ref="7ecc687ea7566f05fd13fde7be607bfc" prefix=" " category="inline-code"></block>개인 이미지 저장소 및 제공<block ref="0d9b54b29da54379cca6b8782b9faae5" prefix=" " category="inline-code"></block>) 네임스페이스 범위 연산자를 삭제한 후 클러스터 범위 연산자를 설치하기 전에 먼저 . 업데이트할 수 있는 전체 매개 변수 목록은 을 참조하십시오 <block ref="d752d8869a42e1b0fd341b92b54677e0" category="inline-link-macro-rx"></block>.</block>
  <block id="66f2c42a4ca561f5472459301bc7d096" category="list-text">이제 ONTAP 드라이버에 대한 자동 MetroCluster 전환 감지 기능을 사용할 수 있습니다.</block>
  <block id="e87ded5ef8bc8adbc3c135528636f4f2" category="list-text"><block ref="e87ded5ef8bc8adbc3c135528636f4f2" category="inline-link-macro-rx"></block></block>
  <block id="fce586d9f649fb529d0a1846495ba259" category="list-text"><block ref="fce586d9f649fb529d0a1846495ba259" category="inline-link-macro-rx"></block></block>
  <block id="d85acedd7a50ec026ef39bce58a2c4fc" category="paragraph">NetApp 스토리지 플랫폼이 제공하는 데이터 보호 및 복구 옵션에 대해 알아보십시오. Astra Trident는 이러한 기능 중 일부를 활용할 수 있는 볼륨을 프로비저닝할 수 있습니다. 지속성 요구사항이 있는 각 애플리케이션에 대한 데이터 보호 및 복구 전략이 있어야 합니다.</block>
  <block id="ecd7650a65b79124ad23fb7eed8faa7e" category="paragraph">NetApp 포트폴리오의 각 스토리지 플랫폼은 컨테이너식으로 애플리케이션에 이점을 제공하는 고유한 기능을 제공합니다.</block>
  <block id="e6dc22cf3c59dda6e09524b2b133f336" category="section-title">플랫폼 개요</block>
  <block id="050fb8b0306d7532dbf8c15b8cba9745" category="paragraph">Trident는 ONTAP 및 요소와 함께 작동합니다. 모든 애플리케이션과 시나리오에 적합한 플랫폼이 한 개 있는 것은 아니지만, 플랫폼을 선택할 때 애플리케이션과 장치를 관리하는 팀의 요구 사항을 고려해야 합니다.</block>
  <block id="31b1d21fc5180ec9a5b3d9d7d5ce3295" category="paragraph">https://&lt;login&gt;:&lt;password&gt;@&lt;mvip&gt;/json-rpc/&lt;element-version&gt; 으로 문의하십시오</block>
  <block id="8eadd25d5b4b5d0637cc13cd7349ce5d" category="paragraph">https://admin:admin@192.168.160.3/json-rpc/8.0 으로 문의하십시오</block>
  <block id="88825f48aa3e053d7df66897e8b63e38" category="section-title">요구 사항을 확인합니다</block>
  <block id="6bee7851f8606d588c9122b234c202e3" category="list-text">배포가 모든 를 충족하는지 확인합니다 <block ref="6fc1811f5f9a8ae54793544600e2dff7" category="inline-link-macro-rx"></block>.</block>
  <block id="71503111a9a38d6809e90320e9623ce0" category="paragraph">NetApp은 사용자가 요청할 수 있는 즉시 사용 가능한 연구소 이미지를 제공합니다 <block ref="eb9c34df0ed196dd801ef85207c8bf2c" category="inline-link-macro-rx"></block>.</block>
  <block id="8e38f783b1f4f54c97bae54c0e8a176f" category="section-title">시험 구동에 대해 자세히 알아보십시오</block>
  <block id="99dc40aa93c5cb01a5d80f68e3287975" category="paragraph">테스트 드라이브는 3노드 Kubernetes 클러스터 및 Astra Trident가 설치 및 구성된 샌드박스 환경을 제공합니다. Astra Trident에 대해 알아보고 기능을 둘러보는 것도 좋습니다.</block>
  <block id="38b6e376f2701385062dee4bb00e03d2" category="summary">Astra Trident 설치 프로그램을 사용하여 배포를 사용자 지정할 수 있습니다.</block>
  <block id="0dabff490bbf6c7e308950959cc5a024" category="section-title">설치 프로그램에 대해 알아보십시오</block>
  <block id="1637137b97f70f3de86dbf02ba8c262b" category="paragraph">Astra Trident 설치 프로그램을 사용하여 특성을 사용자 지정할 수 있습니다. 예를 들어, Trident 이미지를 개인 저장소에 복사한 경우 를 사용하여 이미지 이름을 지정할 수 있습니다<block ref="00e6ff45e8bcc6b9e35e9c68d8d5135c" prefix=" " category="inline-code"></block>. Trident 이미지와 필요한 CSI 사이드카 이미지를 개인 저장소에 복사한 경우 를 사용하여 해당 저장소의 위치를 지정하는 것이 좋습니다<block ref="53b228c1c8295f49b0c35325e14fcd6a" prefix=" " category="inline-code"></block> 스위치를 누릅니다<block ref="c4c34dc2c7d5cb25c084ca11127ba1c6" prefix=" " category="inline-code"></block>.</block>
  <block id="5e3a3cabc9ba472e33de86a5a8f32dcd" category="section-title">ONTAP 스토리지 드라이버에 대해 알아보십시오</block>
  <block id="99c850b82f45e568828f2a8c5ab8f94d" category="section-title">볼륨 액세스 그룹에 대해 알아보십시오</block>
  <block id="7c14ddfe8f627e4786f4da7cd4cea9ba" category="section-title">스토리지 클래스 연결</block>
  <block id="ab4589eca69db942d79a0dbbd9ec8399" category="section-title">볼륨 생성</block>
  <block id="3b878279a04dc47d60932cb294d96259" category="section-title">개요</block>
  <block id="a6fbed601c3d014f6d8342990aeee0b5" category="section-title">볼륨 스냅샷 생성에 대해 자세히 알아보십시오</block>
  <block id="65e30750e10ee81a457f6e2a2d52b4a4" category="section-title">사용 가능한 명령 및 옵션</block>
  <block id="bd75dd911fd79061ecd2d46e65ed7f74" category="paragraph">있습니다 <block ref="8321852d17a287399cb52ef30f4b21eb" category="inline-link-macro-rx"></block> Astra Trident REST API와 상호 작용하는 가장 쉬운 방법은 REST 엔드포인트를 직접 사용하는 것입니다.</block>
  <block id="7a72a102c2990b674624e8b6ec834e4d" category="section-title">REST API 사용 시기</block>
  <block id="d08436e363d4793fd6a0de3022ebfd63" category="paragraph">REST API는 Kubernetes가 아닌 구축 환경에서 Astra Trident를 독립 실행형 바이너리로 사용하는 고급 설치에 유용합니다.</block>
  <block id="14dc7970933630896b0232f2a8b52039" category="paragraph">더 나은 보안을 위해 Astra Trident를 사용해 보십시오<block ref="aba3d4b49c454e1974970e7b5514b001" prefix=" " category="inline-code"></block> 는 POD 내에서 실행할 때 기본적으로 localhost로 제한됩니다. 이 동작을 변경하려면 Astra Trident를 설정해야 합니다<block ref="38df54fe961fa2bf2a7f82a5854fabad" prefix=" " category="inline-code"></block> 인수가 해당 POD 구성의 인수입니다.</block>
  <block id="eee97547fb40d9c4df018377ac6478bb" category="section-title">REST API 사용</block>
  <block id="ee656aff7dc78e280efdea39a682afbb" category="section-title">업그레이드 전 고려 사항</block>
  <block id="c88fd7d0135b7fc6ed1fdefdef8d4914" category="list-text">볼륨 스냅샷의 베타 릴리스에는 수정된 CRD 세트와 스냅샷 컨트롤러가 도입되며, 이 두 가지 모두 Astra Trident를 설치하기 전에 설정해야 합니다.<block ref="e4a27565231679ceaa893efb487dac52" category="inline-link-rx"></block> 알파 볼륨 스냅샷을 베타 형식으로 마이그레이션하는 단계에 대해 설명합니다.</block>
  <block id="4e9ac50b8f51023570ef0b0a0a827912" category="inline-link-macro">지원되는 Kubernetes 버전</block>
  <block id="26dbe1fe275b741e7240a373222d3480" category="paragraph">CRD를 사용하는 Astra Trident 릴리즈로 이전할 때는 다운그레이드를 고려해야 합니다. Astra Trident는 CRD를 사용하여 상태를 유지하기 때문에 생성된 모든 스토리지 요소(백엔드, 스토리지 클래스, PV 및 볼륨 스냅샷)는 에 기록된 데이터 대신 CRD 객체를 연결합니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block> PV(이전 설치 버전의 Astra Trident에서 사용). 새로 생성된 PVS, 백엔드 및 스토리지 클래스는 모두 CRD 객체로 유지됩니다.</block>
  <block id="06b33bc9cc124539c964174ecd43eb43" category="paragraph">CRD를 사용하여 실행되는 Astra Trident 버전에 대해서만 다운그레이드를 시도하십시오(19.07 이상). 그러면 다운그레이드가 발생한 후 현재 Astra Trident 릴리스에 대해 수행된 작업이 표시됩니다.</block>
  <block id="c27e444dab3a08bf8ec59794897c1a27" category="inline-link-macro">지원되는 Kubernetes 버전</block>
  <block id="279d526c0cf636b7292c2cfddc1d9957" category="list-text">를 실행하는 Kubernetes 클러스터 <block ref="54886eff1282d00a4f74bc7c51429511" category="inline-link-macro-rx"></block></block>
  <block id="482d7c15b1a7200b3981ee1f99a86fef" category="list-text"><block ref="482d7c15b1a7200b3981ee1f99a86fef" category="inline-link-macro-rx"></block></block>
  <block id="756efcb3a97cdd37e8b34de3913c3d8f" category="paragraph">를 참조하십시오 <block ref="18d5551396fb2ce2e009cfdb709e4875" category="inline-link-macro-rx"></block>. 필수 구성 요소가 충족되었는지 확인한 후 Astra Trident를 배포할 준비가 되었습니다.</block>
  <block id="0d41f8565b8b74a59fc029ccf2becd83" category="list-text">관리 플러그인 시스템을 사용하여 Astra Trident를 시작합니다. 대치<block ref="3d689bd3819ead35ed794427bd12f459" prefix=" " category="inline-code"></block> 사용 중인 플러그인 버전(xxx.xx.x)을 사용합니다.</block>
  <block id="4f0e7dc30ffb3e25e75331c9afb2243a" category="cell">볼륨 모드</block>
  <block id="28c142639a9bbdd526b8eb986c13907d" category="paragraph">파일 시스템이 없습니다. 원시 블록 디바이스입니다</block>
  <block id="0453a3e06be842b09a9479fe06f0dd13" category="paragraph">파일 시스템 볼륨 모드에서는 rwx를 사용할 수 없습니다.</block>
  <block id="04de2f1b0cab8344abeded774f82f9d5" category="admonition">ONTAP 백엔드는 보안 역할(사용자 이름/암호)에 대한 로그인 자격 증명을 사용하거나 ONTAP 클러스터에 설치된 개인 키와 인증서를 사용하여 인증할 수 있습니다. 기존 백엔드를 업데이트하여 를 사용하여 한 인증 모드에서 다른 인증 모드로 이동할 수 있습니다<block ref="defd1e55f93269ac9278afc086951ba8" prefix=" " category="inline-code"></block>.</block>
  <block id="964ea71824e902693c3ef56b57cf78be" category="summary">Astra Trident를 사용하면 기본 네임스페이스에서 볼륨을 생성하고 하나 이상의 보조 네임스페이스에서 공유할 수 있습니다.</block>
  <block id="98f770b0af18ca763421bac22b4b6805" category="section-title">피처</block>
  <block id="8ff961668c6784e84b25c265cbb629d7" category="paragraph">네임스페이스 간 볼륨 액세스에 대한 자세한 내용은 다음을 참조하십시오.</block>
  <block id="f1cfea5f1444de607dfa549b3aa57010" category="inline-link-macro">네임스페이스 간 볼륨 공유: 네임스페이스 간 볼륨 액세스를 위해 hello를 사용합니다</block>
  <block id="2780f690b7670efc296ac19ef3029d0c" category="list-text">를 방문하십시오 <block ref="b0d29f1b2abb2cc552e4cc47177582ef" category="inline-link-macro-rx"></block>.</block>
  <block id="96e1384807331548bf745acde0fe1b73" category="inline-link-macro">NetAppTV를 참조하십시오</block>
  <block id="414883f8b6ef58c7b3b37e66fbfd482f" category="list-text">데모를 시청해보시기 바랍니다 <block ref="1945a2d4809e81668f29485f6ae1bbc8" category="inline-link-macro-rx"></block>.</block>
  <block id="387492c079b6cb13a8ba91c4a60f67b7" category="section-title">볼륨 스냅샷 컨트롤러 배포</block>
  <block id="6c5b68b88f6af6f28b3bf69ad9c17b70" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>. ** 기존 설치를 완전히 제거하지 않는 한 CRD를 삭제하지 마십시오.**</block>
  <block id="c97d8f6272d9a08ec67b35acba91f6d3" category="list-text">Trident 연산자는 사용 중인 Trident 버전에 연결된 연산자 매니페스트를 사용하여 삭제할 수 있습니다. 예를 들면, 다음과 같습니다.<block ref="e4411f2e6de8cc67724fb259f247dc3e" prefix=" " category="inline-code"></block> 위치<block ref="7d2e512472107955c1b3fb2ce2e19bc4" prefix=" " category="inline-code"></block> 은 버전 번호입니다(예<block ref="ea99d71aa7a32717f8398c406b38b062" prefix=" " category="inline-code"></block>) 및<block ref="5765a306f9d7568469e1db22a96adfd0" prefix=" " category="inline-code"></block> 번들 YAML 파일 이름입니다.</block>
  <block id="bd2cc8575fe69c7f775292759380c838" category="inline-link-macro">Bundle_PRE_1_25.YAML</block>
  <block id="5a02ebff4889c2de0379a0fb10bed282" category="inline-link-macro">Bundle_post_1_25.YAML</block>
  <block id="6f8896eb5896943e1606d92193f72fb8" category="section-title">를 사용하여 Trident 배포가 성공하지 못한 경우 문제 해결<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="d59db7846bd10b6d60d21543df9faa9e" category="paragraph-title">필요한 것</block>
  <block id="04c73907481b6acb2b019a0a76516a25" category="section-title">을 사용하여 를 제거합니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="4eb50f197bd48a10bc9ee0dab2f65bcf" category="section-title">을 사용하여 Astra Trident를 설치한 경우의 다운그레이드 프로세스<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="f9ed548281d3b3a21b1334ae3f6a1ce3" category="section-title"><block ref="8321592ce24c8a122ecf26a63cfca407" prefix="" category="inline-code"></block> 및<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block> 가져오기</block>
  <block id="fe55f3445ba74156978bcd34c5a1af5c" category="section-title"><block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix="" category="inline-code"></block> 가져오기</block>
  <block id="22a6337b056e3b93b46c9304d3248391" category="section-title"><block ref="8e2dcfd7e7e24b1ca76c1193f645902b" prefix="" category="inline-code"></block> 가져오기</block>
  <block id="9883195da65e8e652cb10271a5250822" category="section-title"><block ref="5935ea92cdd7d975b4e764b429f21c01" prefix="" category="inline-code"></block> 가져오기</block>
  <block id="809e945dc23c25ac16aba1fa16892444" category="section-title"><block ref="bc5779a2d33eeb1304bae57f15920cfc" prefix="" category="inline-code"></block> 가져오기</block>
  <block id="6c6e605e09d47da14693d106977b6eb0" category="section-title">관리<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 을 사용하여 백엔드를 만듭니다<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block></block>
  <block id="78fb4311dea625690d7fb6274025625a" category="section-title">2단계: A를 작성합니다<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block> 있습니다</block>
  <block id="d6f4b4bedc693acd49ad08c1cf0cdad5" category="section-title">3단계: 의 상태를 확인합니다<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block> 있습니다</block>
  <block id="a035fed1dd97545349b5fffbd9e3e88f" category="section-title">관리<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block> 을 사용하여 백엔드를 만듭니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="0901a332c26ed210204bad23d45c8b6d" category="section-title">1단계: 확인<block ref="98e7d6463271d7848db255ae6467817a" prefix=" " category="inline-code"></block> 가 로 설정되어 있습니다<block ref="16d79ff80feadcf2f52096f073f2b94a" prefix=" " category="inline-code"></block></block>
  <block id="2f1beb23541bc11eb53ca6b33485d4f8" category="section-title">2단계: 를 삭제합니다<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block> 있습니다</block>
  <block id="06c2cea18679d64399783748fa367bdd" category="inline-image-macro">1개</block>
  <block id="32ec9b4824220f8ae03a723da009cd54" category="paragraph-title"><block ref="58f667aaf05f87159670e12bd9bc076b" category="inline-image-macro-rx" type="image"></block> 볼륨을 공유하도록 소스 PVC를 구성합니다</block>
  <block id="aada29daee1d64ed0fe907043855cb7e" category="inline-image-macro">2개</block>
  <block id="82a9b6c32a91a1f4a714d648f5d3260f" category="paragraph-title"><block ref="54f425ce8d89f4ed6b8a546561af5d60" category="inline-image-macro-rx" type="image"></block> 대상 네임스페이스에서 CR을 만들 수 있는 권한을 부여합니다</block>
  <block id="ca8a2087e5557e317599344687a57391" category="inline-image-macro">세 가지</block>
  <block id="311a877e773f97b1e237db665a868dd9" category="paragraph-title"><block ref="05b2444faffd66d76e88602ea7dd353f" category="inline-image-macro-rx" type="image"></block> 대상 네임스페이스에서 트리젠VolumeReference 를 생성합니다</block>
  <block id="981b8fcee42e1e726a67a2b9a98ea6e9" category="inline-image-macro">네</block>
  <block id="fb16fc9d34d26a8e74ba1a7180766513" category="paragraph-title"><block ref="beadfa85a2fdca06b91edc1131c603e6" category="inline-image-macro-rx" type="image"></block> 대상 네임스페이스에서 하위 PVC를 만듭니다</block>
  <block id="fd69c5cf902969e6fb71d043085ddee6" category="paragraph-title">결과</block>
  <block id="3f8e335666124e3b7f5db07f03fef0b1" category="section-title">사용<block ref="fed7609223e8cae53e079facb24f3426" prefix=" " category="inline-code"></block> 하위 볼륨을 쿼리합니다</block>
  <block id="260817022a7340fc89eae3e7dbed8f6a" category="section-title">을 사용한 정의 예<block ref="4d859186a09b1da3597e5901157d9400" prefix=" " category="inline-code"></block> 필드에 입력합니다</block>
  <block id="72b06f7d7f6d50adf7364ca262469512" category="section-title"><block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix="" category="inline-code"></block> 인증서 기반 인증을 사용하는 드라이버</block>
  <block id="81801ea9aa153d054652d45bc18af0a7" category="section-title"><block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix="" category="inline-code"></block> 양방향 CHAP가 있는 드라이버</block>
  <block id="5d49eece8e9afa44ffdead9ff18462be" category="section-title"><block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix="" category="inline-code"></block> 드라이버</block>
  <block id="19ef07597f79648211dbed100709836b" category="section-title">포함할 백엔드를 업데이트합니다<block ref="1f2a94e142bf020b1f7c6297ec12413f" prefix=" " category="inline-code"></block></block>
  <block id="004d3e2a4856b16f30a875347fa180b1" category="paragraph-title">알아야 할 내용</block>
  <block id="891d26d5e7410db6c0a971245c6025c0" category="section-title">예 1: 에 대한 백엔드 구성<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block> 세 가지 볼륨 유형을 가진 드라이버</block>
  <block id="4a8519b09a0b2a70d40200e88ec2c5dc" category="section-title"><block ref="caafdf62a2c609bfa5316118231a1007" prefix="" category="inline-code"></block> 드라이버</block>
  <block id="454631312fab234fc91bb2f85a751fac" category="section-title"><block ref="913a4b06671d1e04e6582a85afe3abbe" prefix="" category="inline-code"></block></block>
  <block id="e892fda55ead7e15eed753e850d35f12" category="section-title">2단계: 을 작성합니다<block ref="913a4b06671d1e04e6582a85afe3abbe" prefix=" " category="inline-code"></block> 있습니다</block>
  <block id="a0d777cf1acc36406564409adef85b17" category="section-title">지원되는 버전의 은 무엇입니까<block ref="a226e9fbdfc1c8dd7e7fef4d333f86ed" prefix=" " category="inline-code"></block>?</block>
  <block id="96bcb2f9805dd9a55f15f122db8c9e7b" category="section-title">를 백업합니다<block ref="a226e9fbdfc1c8dd7e7fef4d333f86ed" prefix=" " category="inline-code"></block> 클러스터 데이터</block>
  <block id="74257eabdceb63f8522f7c68b103da3a" category="section-title">사용 안 함<block ref="d51321f13693d09d4a9cbb2758b42d12" prefix=" " category="inline-code"></block> 애플리케이션 SVM을 위해</block>
  <block id="e49cf31f5ed35f0eb694c7714e8c3234" category="section-title"><block ref="76ea0bebb3c22822b4f0dd9c9fd021c5" prefix="" category="inline-code"></block></block>
  <block id="3649b15e31d22a1e2210f014d843b9fa" category="section-title"><block ref="099af53f601532dbd31e0ea99ffdeb64" prefix="" category="inline-code"></block></block>
  <block id="a4027ed0f56ae6ac2cbb7605a519932b" category="section-title"><block ref="b5eda0a74558a342cf659187f06f746f" prefix="" category="inline-code"></block></block>
  <block id="7920cf9e1a990d156e390321c1d5efeb" category="section-title"><block ref="59b514174bffe4ae402b3d63aad79fe0" prefix="" category="inline-code"></block></block>
  <block id="df6d9d5a4c545407095ea4ca424e9457" category="section-title"><block ref="f6c534966bc7687e0c87134d025f8837" prefix="" category="inline-code"></block></block>
  <block id="cc27cfd3259c2299d8dece590d5f6985" category="section-title"><block ref="19ad89bc3e3c9d7ef68b89523eff1987" prefix="" category="inline-code"></block></block>
  <block id="2acfb4ba14a6f33d7e82e8d1dda6542f" category="section-title"><block ref="2165e4fa5bddb65a31f6a0c495c2fa37" prefix="" category="inline-code"></block></block>
  <block id="9ce837bc2492d4ed390bc5d1ea9d1437" category="section-title"><block ref="2541d938b0a58946090d7abdde0d3890" prefix="" category="inline-code"></block></block>
  <block id="30cf71e674825d319eb0406032c1a80b" category="section-title"><block ref="3ac340832f29c11538fbe2d6f75e8bcc" prefix="" category="inline-code"></block></block>
  <block id="238000b5c5df1cc446f5ba823c01807c" category="section-title"><block ref="ae26b3d8e556703291282149e3ae894f" prefix="" category="inline-code"></block></block>
  <block id="c4e2f712f33e39883cdadc27311ff798" category="section-title">쿠버네티스<block ref="2b3f8e4d49589c4452db0a07d619d824" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="40f23ed795a1a88d4da7ac2ef847ff7f" category="section-title">쿠버네티스<block ref="858e55ea2e6429120a862313c50a9f5f" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="7df5b64daec466033329296995f05735" category="section-title">쿠버네티스<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="db36743614e87531d560fe8ae0bc6c7d" category="section-title">쿠버네티스<block ref="19476662cd814e0aa085eca121de89b8" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="63f2f0978770be469911c5f1722d82ca" category="section-title">쿠버네티스<block ref="310a3378435f31620fbc3e7831ac7286" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="1ca312948dba5b1321da24bc362f4148" category="section-title">쿠버네티스<block ref="d6a1ae997b76c43d7aaf3b22e620401e" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="4171707fb2a131f0fae96196310c5e3b" category="section-title">쿠버네티스<block ref="99bc4b850e05bafd67cf5f5f49344c1e" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="a8a62fe3b16797ce253b78f83dc73a18" category="section-title">트라이던트<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="8a4410d54113ca147b35c633207444b7" category="section-title">트라이던트<block ref="5e5d444b688db40e013a7d0b8b3c0898" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="f08d82cd2f4fa097db43220a04f62434" category="section-title">트라이던트<block ref="bd7a9717d29c5ddcab1bc175eda1e298" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="9b53117639a1995b2872ed6bca3dec8e" category="section-title">트라이던트<block ref="d4e2713d1b1725a1592f9268589f990d" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="65589e383667ac98801982f7e9704f2a" category="section-title">아스트라 트리덴트<block ref="0b79951d94d2a7fc1f7ba55091959bda" prefix=" " category="inline-code"></block> 오브젝트</block>
  <block id="4f89992961c018acecad7b373dcce336" category="section-title">정리<block ref="0b79951d94d2a7fc1f7ba55091959bda" prefix=" " category="inline-code"></block> 설치에 실패한 경우</block>
  <block id="b9984d1eca39b86eb39cedf7db8f8c62" category="section-title">제거<block ref="0b79951d94d2a7fc1f7ba55091959bda" prefix=" " category="inline-code"></block></block>
  <block id="d3f7afc310875b4ea262305c6d7d6ca2" category="section-title"><block ref="7528035a93ee69cedb1dbddb2f0bfcc8" prefix="" category="inline-code"></block></block>
  <block id="1713a64319d60f7c9dce75d4e48ee14f" category="section-title"><block ref="a02439ec229d8be0e74b0c1602392310" prefix="" category="inline-code"></block></block>
  <block id="e4bcff97a02bbf2d15fc5a1c18b2b3dc" category="section-title"><block ref="32f68a60cef40faedbc6af20298c1a1e" prefix="" category="inline-code"></block></block>
  <block id="cc414e256eb2f4bb405602498ece0af6" category="section-title">CVS for GCP에 대한 Astra Trident 지원에 대해 알아보십시오</block>
  <block id="a3edb76d25dfeb8d67e4711eafd2b5ca" category="paragraph">스토리지 시스템에 사용할 백엔드 드라이버를 선택하고 구축합니다.</block>
  <block id="a57628924f909d4edd5cb81ee4f10896" category="section-title">ONTAP 백엔드 드라이버</block>
  <block id="4ea57c8a88545a4fc2039131bc6fd74d" category="paragraph">ONTAP 백엔드 드라이버는 사용된 프로토콜과 스토리지 시스템에서 볼륨을 프로비저닝하는 방법에 따라 다릅니다. 따라서 배포할 드라이버를 결정할 때는 신중하게 고려해야 합니다.</block>
  <block id="642b59503457da90c85cbb7a35e02089" category="paragraph">사용 가능한 ONTAP 백엔드 드라이버는 다음과 같습니다.</block>
  <block id="e44e590e4645ab9ef08fb84f61cede17" category="section-title">Cloud Volumes ONTAP 백엔드 드라이버</block>
  <block id="fdde450e1a16aa1461e62c6fa5ac621f" category="section-title">ONTAP 백엔드 드라이버용 Amazon FSx</block>
  <block id="d079959bb7c738f4e1704de5ff69b897" category="section-title">NetApp HCI/SolidFire 백엔드 드라이버</block>
  <block id="64648abd6d020446c9c8d556a1584d71" category="section-title">Azure NetApp Files 백엔드 드라이버</block>
  <block id="0dceb918cb4a4d7dcbe5af26d08e7657" category="section-title">특정 백엔드 활용도</block>
  <block id="ebaf90f7386ae95e7960a2fc0084116e" category="section-title">QoS 정책을 에뮬레이트합니다</block>
  <block id="125ad0610423d53866d257eb097320e4" category="section-title">특정 기능을 기반으로 백엔드를 활용합니다</block>
  <block id="b6e026d8066036cf2628237905a58384" category="section-title">다양한 서비스 수준/QoS 에뮬레이션</block>
  <block id="628fd4af2a4e2fce014efbf03b84bb71" category="section-title">특정 측면 지정</block>
  <block id="1ee74a3407fb0558688a68f8a4011d8b" category="paragraph">외부 스냅샷 컨트롤러와 사용자 정의 리소스 정의(CRD)가 있어야 합니다. Kubernetes Orchestrator의 책임입니다(예: Kubeadm, GKE, OpenShift).</block>
  <block id="4e9d71562a7ee4d135b94aa7e33203d4" category="paragraph">Kubernetes 배포 시 스냅샷 컨트롤러 및 CRD가 포함되지 않은 경우 를 참조하십시오 <block ref="66b3d1bc7c4350b2c78856aa6724afe9" category="inline-xref-macro-rx"></block>.</block>
  <block id="af79c649a1b22da7699446c292250fcc" category="admonition">GKE 환경에서 필요 시 볼륨 스냅샷을 생성할 경우 스냅샷 컨트롤러를 생성하지 마십시오. GKE는 내장된 숨겨진 스냅샷 컨트롤러를 사용합니다.</block>
  <block id="a19c6b176bcf5d5df56d61bfda053c09" category="section-title">1단계: 을 작성합니다<block ref="19476662cd814e0aa085eca121de89b8" prefix=" " category="inline-code"></block></block>
  <block id="5113d8074a0a5072af49f1e1fa6901bd" category="paragraph">이 예에서는 볼륨 스냅샷 클래스를 생성합니다.</block>
  <block id="ce43eda1a51d5de70f422e14ca195db3" category="paragraph">자세한 내용은 LINK:./trident-reference/objects.html#Kubernetes-volumesshotshotclass-objects를 참조하십시오<block ref="19476662cd814e0aa085eca121de89b8" prefix="[" category="inline-code"></block>].</block>
  <block id="a599393b295f7ad56a8c7f1d327290de" category="paragraph">이 예에서는 기존 PVC의 스냅샷을 생성합니다.</block>
  <block id="4191daf22334ac03a54cdf8adbfd6dfe" category="paragraph">이 예제에서는 이름이 인 PVC에 대해 스냅샷이 생성됩니다<block ref="30520f4f96804df83914260b79f55962" prefix=" " category="inline-code"></block> 스냅샷 이름이 로 설정되어 있습니다<block ref="2599ab7993e15386327b6345bc1cc4e1" prefix=" " category="inline-code"></block>.</block>
  <block id="b2b2f8b28370c274887f8aa2f82bb5d4" category="paragraph">다음은 스냅샷을 사용하여 PVC를 생성하는 예제입니다.</block>
  <block id="f6bd0d7447ff66cc6b859603a88fbde9" category="section-title">관련 링크</block>
  <block id="35aa4a2a819e526c2e930e487df8d423" category="list-text"><block ref="35aa4a2a819e526c2e930e487df8d423" category="inline-link-macro-rx"></block></block>
  <block id="19476662cd814e0aa085eca121de89b8" category="inline-link-macro">VolumeSnapshotClass</block>
  <block id="d63cadc96caf4b05f8fa532b08e889da" category="list-text"><block ref="d63cadc96caf4b05f8fa532b08e889da" category="inline-link-macro-rx"></block></block>
  <block id="31f8757839909e87266f2b53482c86ef" category="list-text">Windows Server 2019</block>
  <block id="3b64653c97a388d828849314b6a1b383" category="cell">풀의 레이블 값은 다음과 같아야 합니다.</block>
  <block id="6da89265a9a8b0b28eb4946bb2ec0c6d" category="cell">일치</block>
  <block id="ecf92052d55345fee4602d9eb8c22063" category="cell">일치하지 않습니다</block>
  <block id="c6c1caf73b0f83d807abe5a717014ab7" category="cell">값 집합에 있어야 합니다</block>
  <block id="8daf6b016f4033d59900c23f162c0f73" category="cell">값 집합에 있지 않습니다</block>
  <block id="c6bfba38b789fec8271d1d1496a9ee59" category="cell"><block ref="42538adbdb6240b2b083a000a615d5bd" prefix="" category="inline-code"></block></block>
  <block id="152f5dc0f7ac734f8e8ee17d4a482462" category="cell">보호</block>
  <block id="7b532e697a35209f3df3956577cc3d9c" category="cell">모든 값과 함께 존재합니다</block>
  <block id="eb0254f1d0a82e646c239d4d2e2f83ac" category="cell"><block ref="f65e5ff2a1bb1af969dccabe7dcd5cdd" prefix="" category="inline-code"></block></block>
  <block id="67a3b723b2d9024808eb2c6e686d00a0" category="cell">! 보호</block>
  <block id="1fde97909b90bb329db2062f7744bd45" category="cell">존재하지 않습니다</block>
  <block id="5eb07a7cb7d445ef6bbb17270c65cf52" category="list-text">RHCOS 버전 4.5 이상 또는 기타 RHEL 호환 Linux 배포를 사용하는 경우 를 참조하십시오<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block> 드라이버 및 Element OS 12.5 이전 버전에서는 CHAP 인증 알고리즘이 에서 MD5로 설정되어 있는지 확인합니다<block ref="104f48adc29dc1e1d7c9bbe7b5dd3f8d" prefix=" " category="inline-code"></block>. 보안 FIPS 호환 CHAP 알고리즘 SHA1, SHA-256 및 SHA3-256은 Element 12.7에서 사용할 수 있습니다.</block>
  <block id="18c20e5d2e368f36f420dd39019d460f" category="list-text">를 사용하는 경우<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block> OpenShift 4.5를 사용하는 드라이버 기본 작업자 노드가 CHAP 인증 알고리즘으로 MD5를 사용하는지 확인합니다. 보안 FIPS 호환 CHAP 알고리즘 SHA1, SHA-256 및 SHA3-256은 Element 12.7에서 사용할 수 있습니다.</block>
  <block id="5896cc977dd7b9854957e18a2a5bf072" category="cell">생성된 볼륨에 할당할 적응형 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다. ONTAP에서 지원되지 않음 - NAS - 이코노미</block>
  <block id="19ab49765cdd2c8ab592eb40eeff08cf" category="cell">ONTAP-SAN, solidfire-SAN, ONTAP-SAN - 경제성</block>
  <block id="054b5072368dea4f8748909c16c7de98" category="cell">Thick: All ONTAP; Thin: All ONTAP &amp; solidfire-SAN</block>
  <block id="dbdc06f8742b98dcacdf7fdb1af111ea" category="paragraph">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, solidfire-SAN, GCP-CV, Azure-NetApp-파일, ONTAP-SAN-이코노미</block>
  <block id="f888aa18c19e41f8c1263fa99ca8b94c" category="cell">solidfire-SAN, ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN - 경제성</block>
  <block id="a64f78ea5d42780118e8f5c7f6cfdcbb" category="list-text"><block ref="a64f78ea5d42780118e8f5c7f6cfdcbb" category="inline-link-macro-rx"></block></block>
  <block id="65a38da8aec2b99cf44dbf919fbd6991" category="list-text"><block ref="65a38da8aec2b99cf44dbf919fbd6991" category="inline-link-macro-rx"></block></block>
  <block id="05a2712653dfbf7d695c18242d9848e6" category="paragraph">RHEL 8+</block>
  <block id="bba4e1b8d8614fe9da2d67e2dcef4b52" category="paragraph"><block ref="8321592ce24c8a122ecf26a63cfca407" prefix="" category="inline-code"></block>,<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block>,<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block>,<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block>,<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block></block>
  <block id="c95cada2a569592345ebc18e5ef4c7aa" category="paragraph">프로토콜 LIF의 IP 주소입니다.</block>
  <block id="8d9cb98e50e02ba3850a7ebcaeccc076" category="paragraph">* ONTAP NAS 드라이버 *: 지정할 것을 권장합니다<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block>. 제공되지 않는 경우 Astra Trident는 SVM에서 데이터 LIF를 가져옵니다. NFS 마운트 작업에 사용할 FQDN(정규화된 도메인 이름)을 지정하면 여러 데이터 LIF에서 로드 밸런싱을 위해 라운드 로빈 DNS를 생성할 수 있습니다.</block>
  <block id="25edde63e4922bb316018c25888e64a6" category="inline-link-macro">ONTAP 선택적 LUN 맵</block>
  <block id="d26c127ab3dc860f4758d7b6a9b70413" category="paragraph">* ONTAP SAN 드라이버 *: iSCSI에 대해 지정하지 마십시오. Astra Trident가 사용합니다 <block ref="2de2f329c45219df280af5a70ed7a17c" category="inline-link-macro-rx"></block> 다중 경로 세션을 설정하는 데 필요한 iSCI LIF를 검색하려면 경고 발생 시<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> 명시적으로 정의됩니다.</block>
  <block id="0350980c728940d67af063bb5d711f0f" category="paragraph">시스템 기반 시스템용 샘플 장치 파일은 에서 찾을 수 있습니다<block ref="50a97f9b0dec64cc53ca48406c60fe4d" prefix=" " category="inline-code"></block> Git repo에 있습니다. RHEL에서 파일을 사용하려면 다음을 수행하십시오.</block>
  <block id="5a04d9954bfe73c6033b2a6a77d3bae8" category="paragraph">Astra Trident를 설치한 후 백엔드 생성, 스토리지 클래스 생성, 볼륨 프로비저닝 및 POD에 볼륨 마운팅을 진행할 수 있습니다.</block>
  <block id="2f6c694f9d016c7193ece4853c402d96" category="doc">Trident 운영자 설치를 사용자 지정합니다</block>
  <block id="79445b5dba623a55ad4d974712853c2f" category="cell"><block ref="2b8b5018006a800ae06485c3aacfa08d" prefix="" category="inline-code"></block></block>
  <block id="cbea7dc9eb2c3c926a86130b0be6368f" category="cell">Trident 운영자의 이미지 풀 정책을 설정합니다. 유효한 값은 다음과 같습니다.<block ref="68eec46437c384d8dad18d5464ebc35c" prefix=" " category="inline-code"></block> 항상 이미지를 당깁니다.<block ref="7803982c6b845094275e8e83f0fad3a6" prefix=" " category="inline-code"></block> 이미지가 아직 노드에 없는 경우에만 이미지를 가져옵니다.<block ref="6e7b34fa59e1bd229b207892956dc41c" prefix=" " category="inline-code"></block> 이미지를 당기지 않습니다.</block>
  <block id="ac7c98af4f51cc4b20acafb785a53284" category="cell"><block ref="7803982c6b845094275e8e83f0fad3a6" prefix="" category="inline-code"></block></block>
  <block id="00148cd37a97a236d1ff100ec0464493" category="summary">Trident 연산자를 구축하고 Hrom을 사용하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되어 있지 않은 설치에 적용됩니다.</block>
  <block id="2f74d18d1c9959832fc00b898fa2417e" category="doc">H제어(표준 모드)를 사용하여 Trident 연산자 배포</block>
  <block id="6852076d7b753ee3ea825ae4af1375ac" category="inline-link-macro">오프라인 배포를 위한 프로세스입니다</block>
  <block id="20815399023070f3335b67451f864388" category="paragraph">Trident 연산자를 구축하고 Hrom을 사용하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되어 있지 않은 설치에 적용됩니다. 개인 이미지 레지스트리가 있는 경우 를 사용합니다 <block ref="95202a095b590d767c9926fd1850fb68" category="inline-link-macro-rx"></block>.</block>
  <block id="9899a49139c92dc0ebfa6808b9d83291" category="section-title">Astra Trident 23.01에 대한 중요 정보입니다</block>
  <block id="d883ab5f686800bc89cab8e6bd776c10" category="paragraph">* Astra Trident * 에 대한 다음 중요 정보를 읽어야 합니다</block>
  <block id="92b6d6e1b0bf78702d88ede445c4256f" category="example-title">&lt;strong&gt; 중요 정보 Astra Trident &lt;/strong&gt;</block>
  <block id="bdae2123f4237558f3521f7e74c70955" category="list-text">이제 Trident에서 Kubernetes 1.26이 지원됩니다. Kubernetes를 업그레이드하기 전에 Trident를 업그레이드하십시오.</block>
  <block id="7416271d47db3d82227ab2164e43c75c" category="list-text">Astra Trident는 SAN 환경에서 다중 경로 구성을 엄격하게 사용하며 권장 값은 입니다<block ref="db729c5c8df447087e5a84b961df14f6" prefix=" " category="inline-code"></block> 다중 경로 .conf 파일</block>
  <block id="2f5480efe7a0a4b0cffbf110abec11c2" category="paragraph">Trident 사용 <block ref="cdacb2b0d49176a3c0d8cc9d693de833" category="inline-link-macro-rx"></block> Trident 연산자를 구축하고 Trident를 한 번에 설치할 수 있습니다.</block>
  <block id="3342f1a2f74c6062a39d3076c35c5a5b" category="inline-link-macro">설치 개요</block>
  <block id="6657de3ab3deaeef939684c50d5310e3" category="paragraph">검토 <block ref="17128a3e349370ba21c9ca13ca0bc297" category="inline-link-macro-rx"></block> 설치 사전 요구 사항을 충족하고 환경에 맞는 올바른 설치 옵션을 선택했는지 확인합니다.</block>
  <block id="8f3958d59b8da100a4663b1cace112b7" category="inline-link-macro">구축 사전 요구 사항</block>
  <block id="64d2af40480a5cebf7e64939f6253bf3" category="paragraph">또한 <block ref="c7282b7e52e27c635b613335e59bf436" category="inline-link-macro-rx"></block> 필요한 것입니다 <block ref="fc0cdbd8defe0c7175199dd05a0f8e76" category="inline-link-macro-rx"></block>.</block>
  <block id="113fbd468c6aaecfbef57e5d1e9b500d" category="list-text">Astra Trident Helm 리포지토리를 추가합니다.</block>
  <block id="d75fdc8e85ddcd7e9dc9f367168dec11" category="paragraph">을 사용할 수 있습니다<block ref="cd4140d3de30b520500459331d08d2bf" prefix=" " category="inline-code"></block> 이름, 네임스페이스, 차트, 상태, 앱 버전과 같은 설치 세부 정보를 검토하려면 수정본 번호.</block>
  <block id="4c5ab57df808d08e9978671e7e81bb2a" category="section-title">설치 중에 구성 데이터를 전달합니다</block>
  <block id="c2bae6a1b11b371647052979113c2b7c" category="cell"><block ref="2c1d18b300e96c797f390483b0c6acdb" prefix="" category="inline-code"></block> (또는<block ref="5338b151154663bac9980b0f044518f2" prefix=" " category="inline-code"></block>)</block>
  <block id="0bfab21a3b7a34a60173df3f165eda9c" category="paragraph">재정의가 있는 YAML 파일을 지정합니다. 이 옵션은 여러 번 지정할 수 있으며 가장 오른쪽 파일이 우선 적용됩니다.</block>
  <block id="ef136231fb37749162723573d36b19c9" category="cell"><block ref="8b5806248570dbb13e7d3bc5e6c0ee37" prefix="" category="inline-code"></block></block>
  <block id="7595b6387dfaf9307f563edc4d951a0d" category="paragraph">명령줄에 overrides를 지정합니다.</block>
  <block id="01e12de62fa77fda2815719aed8ff892" category="section-title">다음 단계</block>
  <block id="94498fae00c7d39d673cb4558db7bc6f" category="inline-link-macro">백엔드 및 스토리지 클래스를 생성하고, 볼륨을 프로비저닝하고, POD에 볼륨을 마운트합니다</block>
  <block id="a8726a62b6428d53252a80359035e514" category="paragraph">이제 가능합니다 <block ref="1c0bc5c2bfbcde176e7340e3acb3bb23" category="inline-link-macro-rx"></block>.</block>
  <block id="324e584edb971a95594d9f53d3cd5b56" category="summary">Trident 연산자(수동 또는 Helm 사용) 또는 를 사용하여 Astra Trident를 설치할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>. 이 항목에서는 적합한 설치 프로세스를 선택하는 데 필요한 중요한 정보를 제공합니다.</block>
  <block id="0769d1459ee3d99d6454d7f99246c894" category="doc">Astra Trident 설치에 대해 자세히 알아보십시오</block>
  <block id="32a389c0498b062693ada7b4b9ac88d7" category="paragraph">Astra Trident를 다양한 환경과 조직에 설치할 수 있도록 NetApp은 다양한 설치 옵션을 제공합니다. Trident 연산자(수동 또는 Helm 사용) 또는 를 사용하여 Astra Trident를 설치할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>. 이 항목에서는 적합한 설치 프로세스를 선택하는 데 필요한 중요한 정보를 제공합니다.</block>
  <block id="ef911ad0da9f5477ca7ec7af0ba4181a" category="paragraph">설치 경로에 관계없이 다음 항목이 있어야 합니다.</block>
  <block id="3f2851ece89063ca1615062ac2117a4e" category="list-text">지원되는 버전의 Kubernetes 및 기능 요구 사항을 실행하는 지원되는 Kubernetes 클러스터에 대한 모든 권한이 활성화됩니다. 를 검토합니다 <block ref="3675fd04b78685cacd6e23511ab11d10" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="f6f19569d16b2b36f137e3df3e315626" category="list-text">를 클릭합니다<block ref="39e7fa5a13dbc25a4aa8c4b323cd657c" prefix=" " category="inline-code"></block> Kubernetes 클러스터 구성을 가리키도록 설정된 환경 변수입니다.</block>
  <block id="f73c8e5f81fc3213cf0bc8c399979852" category="admonition">에 익숙하지 않은 경우 <block ref="0342248ee22d08eaf42465a29ddd67ec" category="inline-link-macro-rx"></block>이제 아주 좋은 시간입니다.</block>
  <block id="a24b4ef46f44c1b54b99e62f49bef9af" category="section-title">설치 방법을 선택합니다</block>
  <block id="dcb987a2d08ee1a9198d1183b1a63a96" category="inline-link-macro">방법 간 이동</block>
  <block id="e11c9248bc5d43c6663f67955adbc53b" category="paragraph">적합한 설치 방법을 선택합니다. 의 고려 사항도 검토해야 합니다 <block ref="e6ce874bf5f421a383109cc222a74763" category="inline-link-macro-rx"></block> 결정을 내리기 전에</block>
  <block id="bd1cc9ebdb33ed22a54815219f97af08" category="section-title">Trident 연산자 사용</block>
  <block id="b2ad529645b5bea51c4bcd516a5c5c8f" category="inline-link-macro">Trident 운영자 배포를 사용자 지정합니다</block>
  <block id="938620f641cb8e0eead448105ff52780" category="paragraph">수동으로 배포하든 Hrom을 사용하건 Trident 운영자는 설치를 단순화하고 Astra Trident 리소스를 동적으로 관리할 수 있는 훌륭한 방법입니다. 물론 가능합니다 <block ref="5290e5312b651716bedf8a83ec5a6467" category="inline-link-macro-rx"></block> 의 속성을 사용합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사용자 지정 리소스(CR).</block>
  <block id="9d2c1d92b0ecb606394b40e3553d07d2" category="paragraph">Trident 연산자를 사용하면 다음과 같은 이점이 있습니다.</block>
  <block id="636fc797e6d4f9b558107df8ad867cc7" category="example-title">&lt;strong&gt; Astra Trident 객체 생성 &lt;/strong&gt;</block>
  <block id="9bb09894435f05fa667865ab4c45ace7" category="paragraph">Trident 운영자가 Kubernetes 버전에 대해 다음 오브젝트를 자동으로 생성합니다.</block>
  <block id="839be275cd4b0f32a2c3e0278ce6d568" category="list-text">운영자용 ServiceAccount입니다</block>
  <block id="f330ead337ce41659c5526de118cdac3" category="list-text">ServiceAccount에 대한 ClusterRole 및 ClusterRoleBinding</block>
  <block id="02c7e9dd319d7284e2200c673387dfdc" category="list-text">전용 PodSecurityPolicy(Kubernetes 1.25 이하)</block>
  <block id="504dabdcc3051fc4c1b7a92eb22fad82" category="example-title">&lt;strong&gt; 자동 복구 기능 &lt;/strong&gt;</block>
  <block id="1505039bc5aa0b8285d451e49fba843e" category="paragraph">운영자는 Astra Trident 설치를 모니터링하고 구축이 삭제되거나 실수로 수정된 경우와 같은 문제를 해결하기 위한 조치를 적극적으로 수행합니다. A<block ref="6088362e783ede60a64ba91287dc58c1" prefix=" " category="inline-code"></block> 를 연결하는 POD가 생성됩니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Astra Trident가 설치된 CR. 이렇게 하면 클러스터에 Astra Trident 인스턴스가 하나만 있고 설치가 제어되므로 설치가 매우 강력합니다. 설치 변경(예: 배포 또는 노드 반점 삭제)이 수행되면 운영자가 이를 식별하고 개별적으로 수정합니다.</block>
  <block id="0bfe7abd2878a67d5ff26746df309f8c" category="example-title">&lt;strong&gt; 기존 설치에 대한 간편한 업데이트 &lt;/strong&gt;</block>
  <block id="cbbeebc91e4ea4f1960f7a74b5b14c23" category="paragraph">기존 배포를 운영자로 쉽게 업데이트할 수 있습니다. 를 편집하기만 하면 됩니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> CR을 사용하여 설치를 업데이트합니다.</block>
  <block id="561b04cbccb34a376c360e7325ad76d0" category="paragraph">예를 들어, Astra Trident를 활성화하여 디버그 로그를 생성해야 하는 시나리오를 생각해 보십시오. 이렇게 하려면 에 패치를 적용합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 를 눌러 설정합니다<block ref="8cddd364bfd0d68f21e3a9ba1123b849" prefix=" " category="inline-code"></block> 를 선택합니다<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block>:</block>
  <block id="f72ba1a3a498489a96fd8774bfa9ea9d" category="example-title">&lt;/strong&gt;를 처리하는 &lt;strong&gt; 자동 Kubernetes 업그레이드</block>
  <block id="c3b2fe84f143129d7a18ad12df229bc6" category="example-title">BlueXP(이전의 Cloud Manager) &lt;/strong&gt;를 사용한 &lt;strong&gt; Kubernetes 클러스터 관리</block>
  <block id="4c24a3b9facf2ea9fc7ed2ca52dab45d" category="inline-link-macro">&lt;block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category='inline-code'/&gt; 설치를 사용자 지정합니다</block>
  <block id="40beff6895ce0eeff65f9568dd5c7247" category="paragraph">가능합니다 <block ref="d16089dfa270d6679e80d43ec8b5c378" category="inline-link-macro-rx"></block> Trident 리소스에 대한 매니페스트를 생성합니다. 여기에는 구축, 개발/제거, 서비스 계정, Astra Trident가 설치의 일부로 생성한 클러스터 역할 등이 포함됩니다.</block>
  <block id="cb024a74bf03f9ba7a9433337492808e" category="admonition">22.04 릴리즈부터는 Astra Trident가 설치될 때마다 AES 키가 더 이상 다시 생성되지 않습니다. 이 릴리즈를 통해 Astra Trident는 설치 전반에 걸쳐 유지되는 새로운 비밀 객체를 설치합니다. 즉,<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 22.04에서는 Trident의 이전 버전을 제거할 수 있지만 이전 버전에서는 22.04 설치를 제거할 수 없습니다. 적절한 installation_method_를 선택합니다.</block>
  <block id="84721e18f913ae71c91ded91f5eb0ccc" category="section-title">설치 모드를 선택합니다</block>
  <block id="ecafb217c7f4e740b9f654a4f2d90d83" category="paragraph">조직에서 요구하는 _installation mode_(Standard, Offline 또는 Remote)를 기반으로 배포 프로세스를 결정합니다.</block>
  <block id="e0090e5eeb1da23a2924e8a8913a9bf8" category="open-title">표준 설치</block>
  <block id="2de7b81fa5e55c649aed923c069d97fa" category="paragraph">이것은 Astra Trident를 설치하는 가장 쉬운 방법이며 네트워크 제한이 없는 대부분의 환경에서 작동합니다. 표준 설치 모드에서는 기본 레지스트리를 사용하여 필요한 Trident를 저장합니다 <block ref="0b505db73d92bac18356fa3feb3cf7e3" prefix="(" category="inline-code"></block>)와 CSI를 참조하십시오 <block ref="95d6355f896a633ab07c528c03b44c8e" prefix="(" category="inline-code"></block>) 이미지.</block>
  <block id="bed44ad15130067b96b51ba770e3e821" category="paragraph">표준 모드를 사용하는 경우 Astra Trident 설치 프로그램이 다음을 수행합니다.</block>
  <block id="ca02732ace7c24d10b82abb835861fa8" category="list-text">인터넷을 통해 컨테이너 이미지를 가져옵니다</block>
  <block id="2a35874c002d31bf8a669cf5f15508f2" category="list-text">Kubernetes 클러스터의 모든 적격 노드에서 Astra Trident Pod를 가동하는 구축 또는 노드 데모시작을 생성합니다</block>
  <block id="6c09f957f6dd5f1b3287dacfabe8711a" category="open-title">오프라인 설치</block>
  <block id="559e73031b36e6693dcd5724b5ec9488" category="paragraph">오프라인 설치 모드는 공기 박수나 안전한 위치에 필요할 수 있습니다. 이 시나리오에서는 필요한 Trident 및 CSI 이미지를 저장하기 위해 단일 전용 미러된 레지스트리 또는 두 개의 미러링된 레지스트리를 만들 수 있습니다.</block>
  <block id="37f28a5a50507d5cf12665008632572f" category="admonition">레지스트리 구성에 관계없이 CSI 이미지는 하나의 레지스트리에 있어야 합니다.</block>
  <block id="8e9a94c9655a1b4aac478f836ff8dde6" category="open-title">원격 설치</block>
  <block id="3937570b6000a2f24b3066af230f4546" category="paragraph">다음은 원격 설치 프로세스에 대한 상위 수준의 개요입니다.</block>
  <block id="8be61d7ba452354892142828445281d0" category="section-title">방법 및 모드에 따라 프로세스를 선택합니다</block>
  <block id="667af34faf4c2e74b377bbe7608ca481" category="paragraph">결정을 내린 후 적절한 프로세스를 선택합니다.</block>
  <block id="4c3880bb027f159e801041b1021e88e8" category="cell">방법</block>
  <block id="f8a17e31b9d98082aa01aa0b41f63a01" category="cell">설치 모드</block>
  <block id="e633d636fff46ea0b0998da525b2fba2" category="cell">Trident 운영자(수동)</block>
  <block id="8f923c676fa6a52b7729476fc0d5f245" category="paragraph"><block ref="8f923c676fa6a52b7729476fc0d5f245" category="inline-link-macro-rx"></block></block>
  <block id="d295bad40364c9511c0d7b6a18e9557b" category="paragraph"><block ref="d295bad40364c9511c0d7b6a18e9557b" category="inline-link-macro-rx"></block></block>
  <block id="b9267203f04d91a5fcda0041ad2b3b64" category="cell">Trident 운영자(제어)</block>
  <block id="c197c2a4864a9d7a8190b1988d1e5885" category="paragraph"><block ref="c197c2a4864a9d7a8190b1988d1e5885" category="inline-link-macro-rx"></block></block>
  <block id="8dc52e4e0ca84a69e954b9b7a21c2bfc" category="paragraph"><block ref="8dc52e4e0ca84a69e954b9b7a21c2bfc" category="inline-link-macro-rx"></block></block>
  <block id="0b9d702360fb60f9b8b477339ca03a7b" category="cell"><block ref="c67fd1b99934afa248dfeb285a9a4191" prefix="" category="inline-code"></block></block>
  <block id="be686de0390e44f3981b994e059dfcb7" category="inline-link-macro">표준 또는 오프라인 설치</block>
  <block id="9e244fc5020d1137289c0c34c2944ac4" category="paragraph"><block ref="9e244fc5020d1137289c0c34c2944ac4" category="inline-link-macro-rx"></block></block>
  <block id="dd341f866eaefb939dc86608773c909d" category="section-title">설치 방법 간 이동</block>
  <block id="84dfae02381a00cf11d01c571e3e3e0f" category="paragraph">설치 방법을 변경할 수 있습니다. 이렇게 하기 전에 다음 사항을 고려하십시오.</block>
  <block id="a2f9fc61dcbb8d315328956b20ee41f8" category="list-text">Astra Trident를 설치 및 제거할 때는 항상 동일한 방법을 사용하십시오. 을(를) 배포한 경우<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>, 의 해당 버전을 사용해야 합니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> Astra Trident를 제거하는 바이너리. 마찬가지로 연산자를 사용하여 를 배포하는 경우에는 를 편집해야 합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> CR 및 SET<block ref="f41a95848a012f4f1a6550ce79c588aa" prefix=" " category="inline-code"></block> Astra Trident를 제거합니다.</block>
  <block id="aa7d43663995cc5a82e0608e61443ac2" category="list-text">대신 를 제거하고 대신 사용할 운영자 기반 배포가 있는 경우<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> Astra Trident를 배포하려면 먼저 편집해야 합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 그리고 설정합니다<block ref="f41a95848a012f4f1a6550ce79c588aa" prefix=" " category="inline-code"></block> Astra Trident를 제거합니다. 그런 다음 삭제합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 및 작업자 배포. 그런 다음 를 사용하여 를 설치할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>.</block>
  <block id="e77325ac6e155cf5d14c756f1d64333f" category="list-text">작업자 기반의 수동 배포를 사용하고 H제어 기반 Trident 연산자 배포를 사용하려는 경우 먼저 수동으로 연산자를 제거한 다음 Helm 설치를 수행해야 합니다. 이를 통해 Helm은 필요한 레이블 및 주석을 사용하여 Trident 연산자를 배포할 수 있습니다. 이렇게 하지 않으면 레이블 유효성 검사 오류 및 주석 유효성 검사 오류와 함께 H제어 기반 Trident 연산자 배포가 실패합니다. 가 있는 경우<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>기반 배포에서는 문제 없이 Helm 기반 배포를 사용할 수 있습니다.</block>
  <block id="901977c62370814085e1228ede1e5919" category="summary">Astra Trident를 설치하기 전에 이러한 일반 시스템 요구 사항을 검토해야 합니다. 특정 백엔드에 추가 요구 사항이 있을 수 있습니다.</block>
  <block id="40d52435469b4eba3a63775d6170cf3e" category="list-text">Kubernetes 1.21-1.26</block>
  <block id="020762714bd7a4355a1abeca3c382c18" category="list-text">OpenShift 4.9-4.12</block>
  <block id="0ffed9ae8c0b8e64c5dc8cba81c4fe34" category="list-text">FAS/AFF/9.5 이상을 선택합니다</block>
  <block id="6286d1b386e84c92fae11f2bcb9ceecd" category="paragraph">아래 표에는 Astra Trident의 이번 릴리즈와 함께 사용할 수 있는 기능과 지원하는 Kubernetes 버전이 요약되어 있습니다.</block>
  <block id="db9435acb142577b87827261ece9f934" category="paragraph">1.21-1.26</block>
  <block id="6726c1f070eb0e4315bf3ec874a13f78" category="paragraph">Astra Trident가 공식적으로 특정 운영 체제를 지원하지 않지만 다음과 같은 운영 체제가 작동하는 것으로 알려져 있습니다.</block>
  <block id="f8b1c66e563136ad12055c2d31964acc" category="paragraph">Kubernetes 클러스터의 모든 작업자 노드는 Pod용으로 프로비저닝된 볼륨을 마운트할 수 있어야 합니다. 작업자 노드를 준비하려면 드라이버 선택에 따라 NFS 또는 iSCSI 도구를 설치해야 합니다.</block>
  <block id="f36d25716a4b2c466ddcb8065bef3ae6" category="paragraph"><block ref="f36d25716a4b2c466ddcb8065bef3ae6" category="inline-link-macro-rx"></block></block>
  <block id="0d25ed458cdfc3817973631b0b776a34" category="paragraph">Astra Trident는 백엔드 구성에서 사용하기 전에 스토리지 시스템을 변경해야 할 수 있습니다.</block>
  <block id="50823ee9226376c44bfb71c334ee2f3f" category="paragraph"><block ref="50823ee9226376c44bfb71c334ee2f3f" category="inline-link-macro-rx"></block></block>
  <block id="29dcef620f05a3eaaf13d29d1f14e860" category="paragraph">Astra Trident는 통신을 위해 특정 포트에 액세스해야 합니다.</block>
  <block id="b2dabe4b341f1e163a7ba3f3553d6b1b" category="paragraph"><block ref="b2dabe4b341f1e163a7ba3f3553d6b1b" category="inline-link-macro-rx"></block></block>
  <block id="9f523c82aa6c2773a498c832177d2ae0" category="list-text">NetApp/트리덴트 - AutoSupport: 23.01</block>
  <block id="3cfdc4b11ed575c2d8bbcea1746d0976" category="list-text">K8s.IO/SIG - 스토리지/CSI - 공급자: v3.4.0</block>
  <block id="57ad3884258dc4fe04c11750b8222daa" category="list-text">K8s.IO/SIG-storage/CSI-attacher:v4.1.0</block>
  <block id="7f7b6bf613e5a94b472dc4003c3c9d47" category="list-text">K8s.IO/SIG-storage/CSI-resizer: v1.7.0</block>
  <block id="bc5a94d13573ba35693929cfc2df5614" category="list-text">K8s.IO/SIG-storage/CSI-snapshotter:v6.2.1</block>
  <block id="938a05d206d8fc8b1d8a4342f0a74da0" category="list-text">K8s.IO/SIG-storage/CSI-node-driver-registrar: v2.7.0</block>
  <block id="725cbb3a0d4bcdf2e5483f06a14ffc8a" category="cell">v1.26.0</block>
  <block id="a54af9f6f0bee26551da0258c438d6b9" category="admonition">Kubernetes 버전 1.21 이상에서는 검증된 을 사용합니다<block ref="40f3a80e171b33f08017cecd592672f1" prefix=" " category="inline-code"></block> ?곸긽??<block ref="6654c734ccab8f440ff0825eb443dc7f" prefix=" " category="inline-code"></block> 에서 지원하는 버전입니다<block ref="ab003b1d43edbe8a5b9d3e8baef8790c" prefix=" " category="inline-code"></block> CRD 를 누릅니다<block ref="ee21100dace47d83bcefcb7dea09cdd3" prefix=" " category="inline-code"></block> 에서 CRD를 지원하는 버전입니다<block ref="6654c734ccab8f440ff0825eb443dc7f" prefix=" " category="inline-code"></block> 버전, 검증된 을 사용합니다<block ref="fdb913c5472aa018b449f65e38beb9e0" prefix=" " category="inline-code"></block> 이미지.</block>
  <block id="4bdf9319fbd791503ac6c31b80a89220" category="summary">Trident 연산자를 수동으로 구축하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장된 설치에 적용됩니다.</block>
  <block id="44e21d73aa8bd7200fceac6671723524" category="doc">Trident 연산자 수동 배포(오프라인 모드)</block>
  <block id="11ad6eeb0e6095efdbf4599d71303b0e" category="inline-link-macro">표준 배포 프로세스</block>
  <block id="3410d56c3ae45b01726f4f271693484f" category="paragraph">Trident 연산자를 수동으로 구축하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장된 설치에 적용됩니다. 개인 이미지 레지스트리가 없는 경우 를 사용합니다 <block ref="0d70fdec6fbaf15c3c460970c31207c9" category="inline-link-macro-rx"></block>.</block>
  <block id="8ff1bc8a7ac69f081f871e9e2a8c0d0f" category="section-title">Trident 연산자를 수동으로 구축하고 Trident를 설치합니다</block>
  <block id="bcc71769dd00af93bb067088094d9b0b" category="paragraph">Linux 호스트에 로그인하여 작업 및 을 관리하고 있는지 확인합니다 <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 필요한 권한이 있어야 합니다.</block>
  <block id="92e83bca2bb40324de35154f8c95083d" category="list-text">Kubernetes 버전 확인:</block>
  <block id="b17eef151a74252395aad7db4b148b57" category="list-text">클러스터 관리자 권한 확인:</block>
  <block id="987c560d773c81bc59f0fa11370626f5" category="list-text">Docker Hub의 이미지를 사용하는 Pod를 시작하고 Pod 네트워크를 통해 스토리지 시스템에 연결할 수 있는지 확인합니다.</block>
  <block id="d868f4f0026c532dcfdb417dde3174c2" category="section-title">1단계: Trident 설치 프로그램 패키지를 다운로드합니다</block>
  <block id="e0a7ed284b169328627ba69adfc9350d" category="paragraph">Astra Trident 설치 프로그램 패키지에는 Trident 운영자를 구축하고 Astra Trident를 설치하는 데 필요한 모든 것이 들어 있습니다. 에서 최신 버전의 Trident 설치 프로그램을 다운로드하고 압축을 풉니다 <block ref="6a7c34d1e7545bd3ab5abc336e61eb7f" category="inline-link-macro-rx"></block>.</block>
  <block id="e0755e6cf0a80c2d8535ac3b7eae0b4b" category="section-title">2단계: 을 작성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> CRD</block>
  <block id="04bed90b9e7d65b6d7dd48211e0a9f6c" category="paragraph">를 생성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사용자 정의 리소스 정의(CRD). 을(를) 생성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 나중에 사용자 지정 리소스. 에서 적절한 CRD YAML 버전을 사용하십시오<block ref="91ff3926f7c7983bb4a56689f631e6c9" prefix=" " category="inline-code"></block> 를 작성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> CRD:</block>
  <block id="ad9aaefb573cd08d43c2b039449b1f0e" category="section-title">3단계: 운영자의 레지스트리 위치를 업데이트합니다</block>
  <block id="7e1c8354fb2b2ecb65abfa6a63e08970" category="section-title">3단계: Trident 연산자를 배포합니다</block>
  <block id="bb336dd58b442c31f8bab7909d55dd42" category="paragraph">Trident 설치 관리자는 에 연산자를 배포합니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block> 네임스페이스. 를 누릅니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block> 네임스페이스가 없습니다. 를 사용하십시오<block ref="fd71c571b96c493189b63aa659012e87" prefix=" " category="inline-code"></block> 를 눌러 만듭니다.</block>
  <block id="81ba9d708af383a3ede5475fabdd91bf" category="paragraph">를 제외한 네임스페이스에 연산자를 배포합니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block> 네임스페이스, 업데이트<block ref="8610cac3beb01fb0b43bc94c587a807d" prefix=" " category="inline-code"></block>,<block ref="a3df76a4fb69b2a5e9ec42d242e90ea3" prefix=" " category="inline-code"></block> 및<block ref="9fa80de5781893b057ff1d535201893b" prefix=" " category="inline-code"></block> 오퍼레이터 배치 전.</block>
  <block id="05cb480f9344b60f5eeaed25c5e230d1" category="list-text">리소스를 생성하고 연산자를 배포합니다.</block>
  <block id="4488449936bc789dc4dfb6a7887b3533" category="paragraph">Astra Trident 설치 관리자는 연산자를 설치하고 관련 개체를 만드는 데 사용할 수 있는 번들 파일을 제공합니다. 번들 파일은 기본 구성을 사용하여 운영자를 구축하고 Astra Trident를 설치하는 간편한 방법입니다.</block>
  <block id="e8972e07c1fa789317997dff35db7e78" category="list-text">Kubernetes 1.24 이하 를 실행하는 클러스터의 경우, 를 사용합니다<block ref="bd2cc8575fe69c7f775292759380c838" prefix=" " category="inline-code"></block>.</block>
  <block id="a615299877ce0660ab19510814b9dedd" category="list-text">Kubernetes 1.25 이상을 실행하는 클러스터의 경우 를 사용합니다<block ref="5a02ebff4889c2de0379a0fb10bed282" prefix=" " category="inline-code"></block>.</block>
  <block id="64458d8f3e4ba02b2bf50e5a1ad00c81" category="list-text">작업자가 배치되었는지 확인합니다.</block>
  <block id="69301f05825d437597b636d8b7e9d918" category="paragraph">추가해야 합니다<block ref="4134d52569bb4a6545ebff1e4c83f2bc" prefix=" " category="inline-code"></block> 를 누릅니다<block ref="990dc1a09e10c7b5378e6bc8a1956cb8" prefix=" " category="inline-code"></block> 다른 레지스트리 위치를 사용합니다.</block>
  <block id="78f538d1739cfd8c70698ec72269da17" category="inline-link-macro">Trident 설치를 사용자 지정합니다</block>
  <block id="60b02b15eaf058a3b9da12633792321f" category="paragraph">이제 를 만들 수 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Astra Trident를 설치합니다. 원하는 경우 더 추가할 수 있습니다 <block ref="af79c767b326b6188dbe7366c85a8007" category="inline-link-macro-rx"></block> 의 속성을 사용합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사양 다음 예에서는 Trident 및 CSI 이미지가 다른 레지스트리에 있는 설치를 보여 줍니다.</block>
  <block id="9c0f95d6de9186b24cce94c1c19ad0bb" category="section-title">설치를 확인합니다</block>
  <block id="f33407040f00668c9fe98aa95119654b" category="paragraph">설치를 확인하는 방법에는 여러 가지가 있습니다.</block>
  <block id="1ee1b78e8a634a10be54657432d990c0" category="section-title">사용<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 상태</block>
  <block id="59331c774767b9695025c001ca75a1f6" category="inline-link-macro">로그를 확인합니다</block>
  <block id="4b3e10870e70ff689f8c7d5c4470bb56" category="paragraph">의 상태입니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 설치가 성공적으로 완료되었는지 여부를 나타내고 설치된 Trident의 버전을 표시합니다. 설치하는 동안 의 상태입니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 변경 시작<block ref="2763f33c904a183bd0ef06f9c4fb4403" prefix=" " category="inline-code"></block> 를 선택합니다<block ref="98dd43dfae05b11befe1f140e0ec787a" prefix=" " category="inline-code"></block>. 을(를) 관찰하면<block ref="d7c8c85bf79bbe1b7188497c32c3b0ca" prefix=" " category="inline-code"></block> 상태 및 운영자가 자체적으로 복구할 수 없습니다. <block ref="b02c5b645df4a829ba2f9c98296d4b15" category="inline-link-macro-rx"></block>.</block>
  <block id="474d9cf1b4e7f826154b0e1f35c59f5a" category="section-title">POD 생성 상태 사용</block>
  <block id="726f87e7b7987ccf71570849c59ae750" category="paragraph">생성된 Pod의 상태를 검토하여 Astra Trident 설치가 완료되었는지 확인할 수 있습니다.</block>
  <block id="8492a795a07bc459d58808ef0ab73c36" category="section-title">사용<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="af78a296b63187cfcb391c6b5b7ab9ae" category="paragraph">을 사용할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 설치된 Astra Trident의 버전을 확인합니다.</block>
  <block id="3c70f31b6cfd2fccfef3e715c4c4cabb" category="doc">tridentctl 설치를 사용자 지정합니다</block>
  <block id="1925260c2cac73df14e8b004bfbabd67" category="paragraph">Astra Trident 설치 프로그램을 사용하여 설치를 사용자 지정할 수 있습니다.</block>
  <block id="9023b4b442239b429817bc22fb401e02" category="summary">Trident 연산자를 구축하고 Hrom을 사용하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장된 설치에 적용됩니다.</block>
  <block id="3e8935de45b1559e2ec2b01c1bbb06c2" category="doc">H제어(오프라인 모드)를 사용하여 Trident 연산자 배포</block>
  <block id="dc0316b52aa2ab6526bdaee13c162530" category="paragraph">Trident 연산자를 구축하고 Hrom을 사용하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장된 설치에 적용됩니다. 개인 이미지 레지스트리가 없는 경우 를 사용합니다 <block ref="2230544d14bc4ba0c61a5a1b2030a1d4" category="inline-link-macro-rx"></block>.</block>
  <block id="3d289dfc040026f9fd5fd0d307821b6c" category="doc">tridentctl을 사용하여 설치합니다</block>
  <block id="61697702c419c08b19643e7defded065" category="section-title">를 사용하여 Astra Trident를 설치합니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block></block>
  <block id="953aeeea088f5f969f2eba121ae81f15" category="paragraph">설치를 시작하기 전에 Linux 호스트에 로그인하여 작업 관리 여부를 확인합니다. <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 필요한 권한이 있어야 합니다.</block>
  <block id="8e00e0acac84eb708bf35882acdffca9" category="paragraph">Astra Trident 설치 프로그램 패키지는 Trident Pod를 생성하고 상태를 유지하는 데 사용되는 CRD 객체를 구성하며, CSI 사이드카를 초기화하여 클러스터 호스트에 볼륨 프로비저닝 및 연결과 같은 작업을 수행합니다. 에서 최신 버전의 Trident 설치 프로그램을 다운로드하고 압축을 풉니다 <block ref="6a7c34d1e7545bd3ab5abc336e61eb7f" category="inline-link-macro-rx"></block>. 선택한 Astra Trident 버전을 사용하여 예제에서 update_&lt;trident-installer-XX.XX.X.tar.gz&gt;_를 선택합니다.</block>
  <block id="4fba6bba4e54639c0f1d19c0a5679833" category="section-title">2단계: Astra Trident 설치</block>
  <block id="c0e89c01626a7378d795a618051fccbf" category="paragraph">를 실행하여 원하는 네임스페이스에 Astra Trident를 설치합니다<block ref="430bf77bee6c59d385d4194f84c21b16" prefix=" " category="inline-code"></block> 명령. 추가 인수를 추가하여 이미지 레지스트리 위치를 지정할 수 있습니다.</block>
  <block id="53c512e9599c71e1a585d636a5229820" category="open-title">표준 모드</block>
  <block id="ca5380881d4e3b38f359d5d05acd6163" category="paragraph">설치 상태는 다음과 같습니다.</block>
  <block id="c5e8fc3926c956e64487a70aa036ec8c" category="paragraph">POD 생성 상태 또는 를 사용하여 설치를 확인할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>.</block>
  <block id="5ba19178fb1b2111306714e923b35945" category="inline-link-macro">디버그 모드를 켭니다</block>
  <block id="43e7d51a6323aabe7af3d192e157f5ed" category="admonition">설치 프로그램이 성공적으로 완료되지 않거나<block ref="ce3abad3e11d6a43c5178e20a0c7d64b" prefix=" " category="inline-code"></block> <block ref="2903817a25b5de1e17a06122d71c5cf9" prefix="(" category="inline-code"></block> 23.01 이전 버전에서는 * Running * 상태가 없으며 플랫폼이 설치되지 않았습니다. 사용<block ref="9b017020b9d48d433ec90c548e6b5c70" prefix=" " category="inline-code"></block> 를 선택합니다 <block ref="82f062b46969132d4baf9d002395a676" category="inline-link-macro-rx"></block> 문제를 해결합니다.</block>
  <block id="f032a385b0ce5fcf6464cead04cd3018" category="summary">Trident 연산자를 수동으로 구축하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되어 있지 않은 설치에 적용됩니다.</block>
  <block id="5d8f25140dde9344f1318b1319929306" category="doc">Trident 연산자 수동 배포(표준 모드)</block>
  <block id="b6d3bf16e1407232f27db7edf1b1aeb2" category="paragraph">Trident 연산자를 수동으로 구축하여 Astra Trident를 설치할 수 있습니다. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되어 있지 않은 설치에 적용됩니다. 개인 이미지 레지스트리가 있는 경우 를 사용합니다 <block ref="3fd9bb28718715a2d036f0ab9d9239b8" category="inline-link-macro-rx"></block>.</block>
  <block id="baa9ad279e74fa4534c3259cbc91b518" category="paragraph">를 생성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사용자 정의 리소스 정의(CRD). 을(를) 생성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 나중에 사용자 지정 리소스. 에서 적절한 CRD YAML 버전을 사용하십시오<block ref="91ff3926f7c7983bb4a56689f631e6c9" prefix=" " category="inline-code"></block> 를 작성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> CRD</block>
  <block id="79c29acc224312444adad50c5e0c66d5" category="paragraph">를 제외한 네임스페이스에 연산자를 배포합니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block> 네임스페이스, 업데이트<block ref="8610cac3beb01fb0b43bc94c587a807d" prefix=" " category="inline-code"></block>,<block ref="a3df76a4fb69b2a5e9ec42d242e90ea3" prefix=" " category="inline-code"></block> 및<block ref="9fa80de5781893b057ff1d535201893b" prefix=" " category="inline-code"></block> 을 사용하여 번들 파일을 생성합니다<block ref="67b2cc1cd5b1570014463995fb2ada61" prefix=" " category="inline-code"></block>:</block>
  <block id="c35c65e4cd4cef23559781ed63709eb0" category="section-title">4단계: 을 작성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Trident를 설치합니다</block>
  <block id="70e42312f50f2ab1f64d8045ef7bee39" category="paragraph">이제 를 만들 수 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Astra Trident를 설치합니다. 필요에 따라 할 수 있습니다 <block ref="af79c767b326b6188dbe7366c85a8007" category="inline-link-macro-rx"></block> 의 속성을 사용합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사양</block>
  <block id="7911fdf4657d2e334f854a18bd855d10" category="paragraph">관리 LIF는 필수입니다. 데이터 LIF는 다양합니다.</block>
  <block id="0f118344f15151d321a269948a521caf" category="list-text">ONTAP SAN: iSCSI에 대해 지정하지 마십시오. Astra Trident가 사용합니다 <block ref="2de2f329c45219df280af5a70ed7a17c" category="inline-link-macro-rx"></block> 다중 경로 세션을 설정하는 데 필요한 iSCI LIF를 검색하려면 경고 발생 시<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> 명시적으로 정의됩니다. 을 참조하십시오 <block ref="823b6e1f172888081aece7b5cdeb0e03" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="f09a3c9e4e8e8413b0a9e74e8e29bcdd" category="list-text">ONTAP NAS: 을 지정하는 것이 좋습니다<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block>. 제공되지 않는 경우 Astra Trident는 SVM에서 데이터 LIF를 가져옵니다. NFS 마운트 작업에 사용할 FQDN(정규화된 도메인 이름)을 지정하면 여러 데이터 LIF에서 로드 밸런싱을 위해 라운드 로빈 DNS를 생성할 수 있습니다. 을 참조하십시오 <block ref="879dc93198c7c5e8ce7148b6d1205d73" category="inline-link-macro-rx"></block> 를 참조하십시오</block>
  <block id="cb16cfa78684ba0c7fc9cff3e67df72b" category="paragraph">Astra Trident는 다음에 대한 IPv6 주소 정의를 지원합니다.</block>
  <block id="a24e915be64ce870d285c6e28a6df3f5" category="list-text"><block ref="a6ea6092cb7b9c5f31909eb4be8fa5ea" prefix="" category="inline-code"></block> 및<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> ONTAP NAS 백엔드의 경우</block>
  <block id="fb250da700173f245f4c10d2970cfba8" category="list-text"><block ref="a6ea6092cb7b9c5f31909eb4be8fa5ea" prefix="" category="inline-code"></block> ONTAP SAN 백엔드의 경우 지정할 수 없습니다<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> ONTAP SAN 백엔드에서</block>
  <block id="26c2fac45b391513484ac592dfbd2e11" category="paragraph">을 사용하여 Astra Trident를 설치해야 합니다<block ref="0612dd31fddbea26c732fa571ce36adc" prefix=" " category="inline-code"></block> IPv6를 통해 작동할 플래그입니다.</block>
  <block id="f53ad7a29c3832e7ce3b551fa5add12d" category="paragraph">에서 데이터 LIF를 업데이트할 수 있습니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 및<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block> 만 해당.</block>
  <block id="18e52eb5a60f4ee8d6f1fb37ab3e3781" category="paragraph">플래그: *<block ref="60072fc2fad0d30fc656850e04c7433f" prefix=" " category="inline-code"></block>: 제거 도움말입니다. *<block ref="61bce13717a9d6da0266dbc3e2b1e642" prefix=" " category="inline-code"></block>: 제거 중 대부분의 출력을 비활성화합니다.</block>
  <block id="741970ef3d523752ab543427956bb1b8" category="cell">1.19-1.26</block>
  <block id="66163e38dd4a6a2a3e01f422ce501b1b" category="paragraph">Astra Trident가 통신에 사용하는 포트에 대해 자세히 알아보십시오.</block>
  <block id="2a531c1a1d290bb0e5f5a511bb48ad45" category="admonition">을 사용하여 설치하는 동안 활성/준비 프로브 포트를 변경할 수 있습니다<block ref="d2090696319f15a4c659a414db8cd2cd" prefix=" " category="inline-code"></block> 깃발. 이 포트가 작업자 노드의 다른 프로세스에서 사용되지 않도록 하는 것이 중요합니다.</block>
  <block id="1a87abd79c966e67f73bbe738ffa4e59" category="inline-link-macro">문제 #783, #794</block>
  <block id="3e45ffbc961fc6c429b6e91f16331ee5" category="list-text">Kubernetes: Helm(<block ref="f91cf268a0811064670bc9d51a6e2016" category="inline-link-macro-rx"></block>)를 클릭합니다.</block>
  <block id="a47f012619aa18f9e2c0fbb53d5878d9" category="list-text">Kubernetes 1.26에 대한 지원이 추가되었습니다.</block>
  <block id="d87b63603588c1795f58658ee14e505f" category="inline-link-macro">문제 #757</block>
  <block id="8e3bb4ae68afca021f39502f7954a450" category="list-text">전체 Trident RBAC 리소스 활용률 향상(<block ref="92a5fe29b2be509e7db5f2091f236ee0" category="inline-link-macro-rx"></block>)를 클릭합니다.</block>
  <block id="2508a7d2b2da760ab909b40a284aff9f" category="list-text">호스트 노드에서 손상되거나 유효하지 않은 iSCSI 세션을 감지하고 수정하는 자동화 기능 추가</block>
  <block id="80a9d5ab26eec41d6d6967415e991c91" category="list-text">LUKS 암호화 볼륨 확장을 위한 지원이 추가되었습니다.</block>
  <block id="1e209dc1ac5964d0a9b1f9c2e9f2fc83" category="list-text">Kubernetes: LUKS 암호화 볼륨에 대한 자격 증명 회전 지원 추가.</block>
  <block id="c8f16bbec47a1722c0f16f173cf64d21" category="list-text">ONTAP용 Amazon FSx를 사용하는 SMB 볼륨에 대한 지원을 ONTAP-NAS 스토리지 드라이버에 추가했습니다.</block>
  <block id="8ce5e316405255bac435287fc5b61f0e" category="list-text">SMB 볼륨을 사용할 때 NTFS 권한에 대한 지원이 추가되었습니다.</block>
  <block id="e67f9f12d1f7c510d94da478c87b7d19" category="list-text">CVS 서비스 수준이 있는 GCP 볼륨에 대한 스토리지 풀에 대한 지원이 추가되었습니다.</block>
  <block id="493569102442ea9186ac1061bb527388" category="list-text">ONTAP-NAS-flexgroup 스토리지 드라이버를 사용하여 FlexGroups를 생성할 때 flexgroupAggregateList의 선택적 사용에 대한 지원이 추가되었습니다.</block>
  <block id="af2331cf2d8ade7bb48e4d540510db26" category="list-text">여러 개의 FlexVols를 관리할 때 ONTAP-NAS-이코노미 스토리지 드라이버의 성능이 향상되었습니다.</block>
  <block id="c26c6c796afe3b5c10e0c830715daf3a" category="list-text">모든 ONTAP NAS 스토리지 드라이버에 대해 데이터 LIF 업데이트를 사용하도록 설정했습니다.</block>
  <block id="56f71deb4744b8ffc7a92bde36d3f4d4" category="list-text">호스트 노드 OS를 반영하도록 Trident 배포 및 DemonSet 명명 규칙을 업데이트했습니다.</block>
  <block id="6ea33f83a7d973b1fa7de807364662d4" category="list-text">Kubernetes: 지원되는 최소 Kubernetes를 1.21로 업데이트했습니다.</block>
  <block id="25854d9b7e460f2667b773a052ff6830" category="list-text">구성 시 데이터 LIF를 더 이상 지정하지 않아야 합니다<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 또는<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block> 드라이버.</block>
  <block id="562840ed450b90bfe87c70479237a8da" category="section-title">22.10의 변경 사항</block>
  <block id="816cf1fb2aa5f808ab09b4740f8ec199" category="list-text">추가되었습니다 <block ref="d387032e9d71b36f3d6219f60f33a659" category="inline-link-macro-rx"></block> 용<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 및<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block> 스토리지 드라이버.</block>
  <block id="001bb59b1bc94ca13afb90cc0e7a4ed5" category="admonition">지정할 수 없습니다<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> ONTAP SAN 백엔드에서 Astra Trident는 사용 가능한 모든 iSCSI LIF를 검색하여 다중 경로 세션을 설정하는 데 사용합니다.</block>
  <block id="c5fbf8cba91fd09257dab41143773a09" category="paragraph">Astra Trident는 분기별 릴리스 케이던스를 따르며, 매년 4개의 주요 릴리즈를 제공합니다. 각 새로운 릴리스는 이전 릴리즈를 기반으로 하며 새로운 기능과 성능 향상, 버그 수정 및 개선 기능을 제공합니다. Astra Trident의 새로운 기능을 이용하려면 1년에 한 번 이상 업그레이드하시기 바랍니다.</block>
  <block id="61f660050f0deffc4b168fe9b8118e83" category="section-title">버전을 선택합니다</block>
  <block id="ecab08714a2cb76336fb5fe50c888c56" category="paragraph">Astra Trident 버전은 날짜를 기반으로 합니다<block ref="fb6921a005d395f9482cdac0306d4935" prefix=" " category="inline-code"></block> 이름 지정 규칙. 여기서 "YY"는 연도의 마지막 두 자리이고 "MM"은 월입니다. DOT 릴리스는 a를 따릅니다<block ref="d93ec759c4a0e8c1cf9c7653b2939656" prefix=" " category="inline-code"></block> 규칙. 여기서 "X"는 패치 수준입니다. 업그레이드할 버전에 따라 업그레이드할 버전을 선택합니다.</block>
  <block id="b6d54dfe9998fc2d718d82ced3bad520" category="list-text">설치된 버전의 4 릴리스 창 내에 있는 모든 대상 릴리스에 대해 직접 업그레이드를 수행할 수 있습니다. 예를 들어 22.01에서 23.01로 직접 업그레이드할 수 있습니다(22.01.1과 같은 도트 릴리스 포함).</block>
  <block id="3c64b9fcc6316f2fb3e86bb37ec1e046" category="list-text">이전 버전이 설치되어 있는 경우, 특정 지침은 해당 릴리스의 설명서를 사용하여 다단계 업그레이드를 수행해야 합니다. 따라서 먼저 4개의 릴리즈 창에 맞는 최신 릴리즈로 업그레이드해야 합니다. 예를 들어 18.07을 실행하고 20.07 릴리스로 업그레이드하려는 경우 다음과 같이 다단계 업그레이드 프로세스를 따르십시오.</block>
  <block id="b42882f59822357cae71c7deef14a306" category="list-text">첫 번째 업그레이드는 18.07에서 19.07로 가능합니다.</block>
  <block id="3cf66ab24f2bf4b09d48a150a9e60aff" category="list-text">버전 19.04 및 이전 버전의 모든 업그레이드를 수행하려면 IT에서 Astra Trident 메타데이터를 마이그레이션해야 합니다<block ref="a226e9fbdfc1c8dd7e7fef4d333f86ed" prefix=" " category="inline-code"></block> CRD 개체. 업그레이드 작동 방식을 이해하려면 릴리즈 설명서를 확인하십시오.</block>
  <block id="c3873e2dee9ada344b692e03e1bf404e" category="list-text">업그레이드할 때 제공하는 것이 중요합니다<block ref="f6e7f85d8aee15940665bf722f7afac2" prefix=" " category="inline-code"></block> 인치<block ref="f652904c3bfb48fb25a0a75f485f0ff6" prefix=" " category="inline-code"></block> Astra Trident에서 사용 삭제하고 다시 만들 수 있습니다<block ref="f652904c3bfb48fb25a0a75f485f0ff6" prefix=" " category="inline-code"></block> 기존 볼륨을 그대로 사용합니다. 이것은 시행에 대한 ** 요구 사항입니다<block ref="cafe4c6014d8c45aaac70e49318f1a2a" category="inline-link-rx"></block> SAN 볼륨: 를 클릭합니다<block ref="25daec0b57549a6ad43dbc62a9e717ca" category="inline-link-rx"></block> 디렉토리에는 과 같은 예가 포함되어 있습니다<block ref="3429ee01166c85cb486f96c0c39d0367" category="inline-link-rx"></block><block ref="9abb8c7777ddb413820ee07d5d93aa4a" prefix="[" category="inline-code"></block>^] 및<block ref="13fed3b986d34b99295dff6b8b392a8b" category="inline-link-rx"></block><block ref="69ae2d9a6d831af7488e53fec053b77e" prefix="[" category="inline-code"></block>^]. 자세한 내용은 을 참조하십시오 <block ref="04cf7258a315ca08f4b436c194fef69d" category="inline-link-macro-rx"></block>.</block>
  <block id="b25ad87a3048ecb578a165aaa0940af4" category="section-title">업그레이드 옵션을 선택합니다</block>
  <block id="74652b96889938fdef1037f82abf39b0" category="inline-link-macro">설치 방법 간에 이동합니다</block>
  <block id="afa7d449a278b7e589e89144d31fc078" category="paragraph">Astra Trident를 업그레이드할 수 있는 두 가지 옵션이 있습니다. 일반적으로 초기 설치에 사용한 옵션과 동일한 옵션을 사용할 수 있지만 <block ref="e34c010032791417159012a5e31d7540" category="inline-link-macro-rx"></block>.</block>
  <block id="441b9a0ce7113f17c0021f9922b1c865" category="inline-link-macro">Trident 연산자를 사용하여 업그레이드합니다</block>
  <block id="672218727121432fb7209f42c6a00514" category="list-text"><block ref="672218727121432fb7209f42c6a00514" category="inline-link-macro-rx"></block></block>
  <block id="a18aa1b83c1605570c9c2911c5180a7b" category="inline-link-macro">&lt;block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category='inline-code'/&gt;를 사용하여 업그레이드합니다</block>
  <block id="3b2fa532fe7cebc94d245316f8af8ab4" category="list-text"><block ref="fd3f4a100d968c915adb11c8797ef5d2" category="inline-link-macro-rx"></block></block>
  <block id="589143858f045594979d5d3cf5289bf6" category="paragraph">을 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>.</block>
  <block id="bca2eb4bec5bace37cdb69b0fd31ca43" category="paragraph">연산자를 사용하여 업그레이드하려면 다음 조건이 충족되어야 합니다.</block>
  <block id="73ffdc13d91aaa406d444e626bd45834" category="list-text">CSI 기반 Astra Trident가 설치되어 있어야 합니다. 의 19.07에서 모든 릴리스는 CSI 기반입니다. Trident 네임스페이스에서 Pod를 검사하여 확인할 수 있습니다.</block>
  <block id="5480fb0d97fbe0edb891d7cbcf84f11c" category="list-text">23.01 이전 버전의 POD 이름 지정은 A 뒤에 옵니다<block ref="2a7e27932de693ec351736e1dc1a1e7f" prefix=" " category="inline-code"></block> 컨벤션.</block>
  <block id="25539301bffff1d4cf6a627ea13251c4" category="list-text">23.01 이상에서 포드 이름 지정 시 사용:<block ref="ce3abad3e11d6a43c5178e20a0c7d64b" prefix=" " category="inline-code"></block> 컨트롤러 포드의 경우<block ref="6d08e3ec5faec812864d5435fcc88eeb" prefix=" " category="inline-code"></block> 노드 포드의 경우,<block ref="3dbf42aee8b5d0bf538865dedf2cc4dc" prefix=" " category="inline-code"></block> 작업자 포드의 경우</block>
  <block id="e80f51ef458c129a7b9bfdf322bf210a" category="list-text">를 실행하는 Kubernetes 클러스터를 사용해야 합니다 <block ref="d502dc64864e79085bee32826e6fe213" category="inline-link-macro-rx"></block>.</block>
  <block id="859a2a5da9db99d70a5e6ec2213b1f17" category="list-text">OpenShift Container Platform에서 연산자를 사용하여 Trident를 업그레이드할 때는 Trident 21.01.1 이상으로 업그레이드해야 합니다. 21.01.0으로 릴리스된 Trident 연산자에는 21.01.1에서 해결된 알려진 문제가 포함되어 있습니다. 자세한 내용은 를 참조하십시오<block ref="bcebcdd21adcbb3d7c640d63a711c6fb" category="inline-link-rx"></block>.</block>
  <block id="f13957ecd6365c8afd32f7cf0a6127ce" category="section-title">클러스터 범위 Trident 운영자 설치를 업그레이드합니다</block>
  <block id="50bfc8fc0d5fc544b43965b0746d1411" category="paragraph">클러스터 범위 Trident 운영자 설치를 업그레이드하려면 다음 단계를 수행하십시오. Astra Trident 버전 21.01 이상에서는 클러스터 범위 연산자를 사용합니다.</block>
  <block id="811eaf5a7a011a3e3c605acd9ea6d5fb" category="list-text">현재 Astra Trident 인스턴스를 설치하는 데 사용된 Trident 연산자를 삭제합니다. 예를 들어, 22.01에서 업그레이드하는 경우 다음 명령을 실행합니다.</block>
  <block id="bdae3121e140e5325fd05919c86dd97f" category="list-text">를 사용하여 초기 설치를 사용자 지정한 경우<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 속성을 편집할 수 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 설치 매개 변수를 수정하는 개체입니다. 여기에는 오프라인 모드에 대해 미러링된 Trident 및 CSI 이미지 레지스트리를 지정하는 변경 사항, 디버그 로그 활성화 또는 이미지 풀 비밀을 지정하는 변경 사항이 포함될 수 있습니다.</block>
  <block id="bd4060a8e80dfbd6f1540226cbeae99b" category="list-text">사용자 환경과 Astra Trident 버전에 맞는 올바른 번들 YAML 파일을 사용하여 Astra Trident를 설치합니다. 예를 들어, Kubernetes 1.26용 Astra Trident 23.01을 설치하는 경우 다음 명령을 실행합니다.</block>
  <block id="40b88899eb3616ad98776b847e919324" category="paragraph">Trident는 운영자를 설치하고 Kubernetes 버전용 관련 개체를 생성하는 데 사용할 수 있는 번들 파일을 제공합니다.</block>
  <block id="c80acc2d3549dd5f3d193892334b8fae" category="paragraph">Trident 운영자는 기존 Astra Trident 설치를 식별하고 운영자와 동일한 버전으로 업그레이드합니다.</block>
  <block id="1e09cc3768e537466d645c037041bffc" category="paragraph">네임스페이스 범위 연산자(버전 20.07 ~ 20.10)를 사용하여 설치된 Astra Trident의 인스턴스에서 업그레이드하려면 다음 단계를 수행하십시오.</block>
  <block id="3495ebcecdbf5bcb8ffcf1bbffd70d23" category="list-text">매니페스트를 사용하여 네임스페이스 범위 연산자를 삭제합니다. 이 단계를 완료하려면 에서 네임스페이스 범위 연산자를 배포하는 데 사용되는 번들 YAML 파일이 필요합니다<block ref="79243f20ce3e723d13bf0774e8348ca2" prefix=" " category="inline-code"></block> 위치<block ref="7d2e512472107955c1b3fb2ce2e19bc4" prefix=" " category="inline-code"></block> 은(는) 버전 번호입니다<block ref="32f68f45f3f6badcd1aa2343bbbce67c" prefix=" " category="inline-code"></block> 번들 YAML 파일 이름입니다.</block>
  <block id="6f1180c77ee2686760a77b1025459802" category="list-text">Trident 연산자를 설치합니다.</block>
  <block id="a5cb00e4346504487c7421a4880366cb" category="admonition">Trident 연산자를 사용하여 Astra Trident를 업그레이드하면 가 마이그레이션됩니다<block ref="ecd4f8050193d4ec7e3added385b49a6" prefix=" " category="inline-code"></block> A로<block ref="04058ba3436aa631a94f8271262cde75" prefix=" " category="inline-code"></block> 같은 이름의 개체입니다. 이 작업은 작업자가 자동으로 처리합니다. 업그레이드에는 이전과 동일한 네임스페이스에 Astra Trident도 설치됩니다.</block>
  <block id="ecf33c5dc36c692f3a828a7e7755b03a" category="admonition">를 클릭합니다<block ref="1043da3d0f6135a3085a7e59f7e2c6cd" prefix=" " category="inline-code"></block> 및 POD 이름은 23.01에 도입된 명명 규칙을 반영합니다.</block>
  <block id="b0f8c567e856516aabf80f916e995d4f" category="paragraph">초기 설치 중에 기본값이 아닌 옵션을 설정한 경우(예: Trident 및 CSI 이미지에 대한 전용, 미러 레지스트리 지정) 를 사용합니다<block ref="8b5806248570dbb13e7d3bc5e6c0ee37" prefix=" " category="inline-code"></block> 이러한 옵션이 업그레이드 명령에 포함되도록 하려면 값이 기본값으로 재설정됩니다.</block>
  <block id="3d0107bfa0874592e9dc04f9869b604b" category="list-text">실행<block ref="cd4140d3de30b520500459331d08d2bf" prefix=" " category="inline-code"></block> 차트와 앱 버전이 모두 업그레이드되었는지 확인합니다. 실행<block ref="3e725291d4b17065fdcd321172fcfae3" prefix=" " category="inline-code"></block> 디버그 메시지를 검토합니다.</block>
  <block id="d72f42539c286d006f46f1ddbcfc9ad0" category="paragraph">에서 Trident 운영자의 최신 릴리즈로 업그레이드할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 설치:</block>
  <block id="ce56959e2e76e7128bc8744171874942" category="paragraph">Astra Trident 23.01을 실행하지 않는 경우 이전 릴리스에 대한 문서를 사용할 수 있습니다. 버전 선택기를 사용하여 최신 버전과 이전 버전 4개를 탐색하거나 아래 링크를 사용할 수 있습니다.</block>
  <block id="3fe5d266a33f137293c314a2e334b611" category="inline-link">Astra Trident 22.10</block>
  <block id="9fefe9ff51badc61edd8a36c8240aa29" category="list-text"><block ref="9fefe9ff51badc61edd8a36c8240aa29" category="inline-link-rx"></block></block>
  <block id="55559f520040667d3f8931728b37ef07" category="paragraph">21.07 이전의 릴리스는 기존 문서 사이트로 리디렉션합니다.</block>
  <block id="79126799d841fcc6275e2d0dd60f9d39" category="paragraph">Astra Trident를 통합하려면 다음과 같은 설계 및 아키텍처 요소를 통합해야 합니다. 드라이버 선택 및 배포, 스토리지 클래스 설계, 가상 풀 설계, PVC(Persistent Volume Claim)가 Astra Trident를 사용한 스토리지 프로비저닝, 볼륨 운영, OpenShift 서비스 구축에 미치는 영향</block>
  <block id="d7f3ab8ebe0633127c883b84d0b2bc4a" category="section-title">Cloud Volumes Service on Google Cloud 백엔드 드라이버</block>
  <block id="dbdb93270c6038ae53d21c36a0ec3a06" category="paragraph">Astra Trident가 을 사용합니다<block ref="5935ea92cdd7d975b4e764b429f21c01" prefix=" " category="inline-code"></block> Google Cloud에서 Cloud Volumes Service와 연결할 드라이버.</block>
  <block id="6615bc816ef19ce9b090bf84cb2577e8" category="paragraph">를 클릭합니다<block ref="5935ea92cdd7d975b4e764b429f21c01" prefix=" " category="inline-code"></block> 드라이버는 가상 풀을 사용하여 백엔드를 추상화하고 Astra Trident가 볼륨 배치를 결정할 수 있도록 합니다. 관리자는 에서 가상 풀을 정의합니다<block ref="9c15d32711e9ef8c6f76deda35452e13" prefix=" " category="inline-code"></block> 파일. 스토리지 클래스는 선택기를 사용하여 레이블별로 가상 풀을 식별합니다.</block>
  <block id="88e5e1ee5a287a3e1e8bcd0bd36d4405" category="list-text">백엔드에 가상 풀이 정의되어 있는 경우, Astra Trident는 Google Cloud 스토리지 풀에서 해당 가상 풀이 제한되는 볼륨을 생성하려고 시도합니다.</block>
  <block id="350ba3703a7557f9470ce37c01800b89" category="list-text">백엔드에 가상 풀이 정의되지 않은 경우 Astra Trident는 해당 지역의 사용 가능한 스토리지 풀에서 Google Cloud 스토리지 풀을 선택합니다.</block>
  <block id="1c6765c31de34eaa48e2dc86edefdb85" category="paragraph">Astra Trident에서 Google Cloud 백엔드를 구성하려면 을 지정해야 합니다<block ref="80ef6899136dfcff295c16caa93c2138" prefix=" " category="inline-code"></block>,<block ref="1e9c0fd1beef5ff8ed3bef2ae3b7e560" prefix=" " category="inline-code"></block>, 및<block ref="c9ff119073ea2567730fb42e3a4fe805" prefix=" " category="inline-code"></block> 백엔드 파일 Google Cloud 콘솔에서 프로젝트 번호를 찾을 수 있습니다. API 키는 Google Cloud에서 Cloud Volumes Service에 대한 API 액세스를 설정할 때 생성한 서비스 계정 개인 키 파일에서 가져옵니다.</block>
  <block id="2d081c5748fc9d24a176594dfdff1ed6" category="paragraph">Cloud Volumes Service on Google Cloud 서비스 유형 및 서비스 수준에 대한 자세한 내용은 를 참조하십시오 <block ref="5b5fd03722abab2c395288a6ee42ad11" category="inline-link-macro-rx"></block>.</block>
  <block id="b8777f333c4d18731d4e5746513dc8eb" category="cell">Google Cloud용 Cloud Volumes Service 드라이버</block>
  <block id="e8257e01d592104a99a17c192f84e86a" category="cell">CVS에서 사용 가능 - 성능 서비스 유형만 해당</block>
  <block id="e6f7c10d8c16eee55f72ce71c4b10a2f" category="list-title">복제 참고 사항</block>
  <block id="6b0213ecbd17731dba9697d0053bee09" category="list-text">Astra Trident에서 복제를 관리하지 않습니다.</block>
  <block id="706c8ebf7645c5a984d080882f157905" category="list-text">클론이 소스 볼륨과 동일한 스토리지 풀에 생성됩니다.</block>
  <block id="aa3a2f2908114304b0a2fa7847f52c52" category="section-title">가상 풀</block>
  <block id="f68e83b9ec275643f0ddf455710de4a0" category="paragraph">모든 Astra Trident 백엔드에 가상 풀을 사용할 수 있습니다. Astra Trident가 제공하는 모든 드라이버를 사용하여 백엔드에 대한 가상 풀을 정의할 수 있습니다.</block>
  <block id="fcda845207c8bb4d447496c11173c0af" category="paragraph">가상 풀을 사용하면 관리자가 저장소 클래스를 통해 참조할 수 있는 백엔드에 대한 추상화 수준을 생성하여 백엔드에 볼륨을 보다 유연하고 효율적으로 배치할 수 있습니다. 동일한 서비스 클래스로 다른 백엔드를 정의할 수 있습니다. 또한 동일한 백엔드에서 여러 스토리지 풀을 생성할 수 있지만 특성이 다릅니다. 특정 레이블이 있는 선택기로 스토리지 클래스를 구성한 경우 Astra Trident는 볼륨을 배치할 모든 선택기 레이블과 일치하는 백엔드를 선택합니다. 스토리지 클래스 선택기 레이블이 여러 스토리지 풀과 일치하면 Astra Trident가 볼륨 용량을 할당할 스토리지 풀 중 하나를 선택합니다.</block>
  <block id="46eefe0a9f18e4edef4d602d3868ad26" category="section-title">가상 풀 설계</block>
  <block id="b8c8132a188c589a80147f1e0b22bf92" category="paragraph">백엔드를 생성하는 동안 일반적으로 매개 변수 집합을 지정할 수 있습니다. 관리자가 동일한 스토리지 자격 증명을 사용하여 다른 매개 변수 집합을 가진 다른 백엔드를 생성할 수 없었습니다. 가상 풀이 도입됨에 따라 이 문제가 완화되었습니다. 가상 풀은 백엔드 및 Kubernetes 스토리지 클래스 간에 도입된 레벨 추상화입니다. 따라서 관리자는 Kubernetes 스토리지 클래스를 통해 백엔드에 독립적인 방식으로 Selector로 참조할 수 있는 레이블과 함께 매개 변수를 정의할 수 있습니다. Astra Trident를 사용하여 지원되는 모든 NetApp 백엔드에 가상 풀을 정의할 수 있습니다. 해당 목록에는 SolidFire/NetApp HCI, ONTAP, Cloud Volumes Service on GCP 및 Azure NetApp Files가 포함됩니다.</block>
  <block id="e531eef4bc68547759b647c917ac2567" category="admonition">가상 풀을 정의할 때는 백엔드 정의에서 기존 가상 풀의 순서를 재정렬하지 않는 것이 좋습니다. 또한 기존 가상 풀의 속성을 편집/수정하고 대신 새 가상 풀을 정의하는 것이 좋습니다.</block>
  <block id="12a04174d46f1d73ff741b222e009596" category="paragraph">서비스 클래스를 에뮬레이트하기 위한 가상 풀을 설계할 수 있습니다. Azure NetApp Files용 Cloud Volume Service에 대한 가상 풀 구현을 사용하여 다양한 서비스 클래스를 설정하는 방법을 살펴보겠습니다. 다양한 성능 수준을 나타내는 여러 레이블을 사용하여 ANF 백엔드를 구성합니다. 설정<block ref="28277e44c5db61612accdf326d137e96" prefix=" " category="inline-code"></block> 적절한 성과 수준에 맞게 종횡비를 지정하고 각 레이블 아래에 다른 필요한 요소를 추가합니다. 이제 다른 가상 풀에 매핑할 다른 Kubernetes 스토리지 클래스를 생성합니다. 를 사용합니다<block ref="bed471c4a88e25ac9a7e4a7b980700a8" prefix=" " category="inline-code"></block> 필드에서 각 StorageClass는 볼륨을 호스팅하는 데 사용할 수 있는 가상 풀을 호출합니다.</block>
  <block id="f274bdd304a8c3825a2766a1f8ff8fa7" category="paragraph">특정 측면의 여러 가상 풀을 단일 스토리지 백엔드에서 설계할 수 있습니다. 이를 위해 백엔드에 여러 레이블을 구성하고 각 레이블 아래에 필요한 측면을 설정합니다. 이제 를 사용하여 다양한 Kubernetes Storage 클래스를 생성할 수 있습니다<block ref="bed471c4a88e25ac9a7e4a7b980700a8" prefix=" " category="inline-code"></block> 다른 가상 풀에 매핑될 필드입니다. 백엔드에서 프로비저닝되는 볼륨에는 선택한 가상 풀에 정의된 측면이 있습니다.</block>
  <block id="77392d80c7d8caad401b2619f5dd4581" category="paragraph">요청된 스토리지 클래스 이외의 일부 매개 변수는 PVC 생성 시 Astra Trident 프로비저닝 결정 프로세스에 영향을 줄 수 있습니다.</block>
  <block id="5425c134e042a4473f453cbfaaf776df" category="summary">LUKS(Linux 통합 키 설정)를 활성화하여 Astra Trident에서 ONTAP SAN 및 ONTAP SAN 경제 볼륨을 암호화할 수 있습니다. Astra Trident는 LUKS 암호화 볼륨에 대한 볼륨 크기 조정 및 키(암호) 회전을 지원합니다.</block>
  <block id="b6969fa89b54a37ee3628194aebbbea3" category="doc">Linux 통합 키 설정(LUKS)</block>
  <block id="a5a1aad62aa2cbb5ff9f9547c24671f4" category="paragraph">LUKS(Linux 통합 키 설정)를 활성화하여 Astra Trident에서 ONTAP SAN 및 ONTAP SAN 경제 볼륨을 암호화할 수 있습니다. Astra Trident는 LUKS 암호화 볼륨에 대한 암호 순환 및 볼륨 확장을 지원합니다.</block>
  <block id="b1597f08149b233ec5901eb1dc041042" category="paragraph">Astra Trident에서 LUKS 암호화 볼륨은 에서 권장하는 대로 AES-XTS-ai64 cypher 및 모드를 사용합니다 <block ref="79a538d5fda32e1565131ca044d589f6" category="inline-link-macro-rx"></block>.</block>
  <block id="525588be7f6bc2cf7b3b257ced2b19c7" category="list-text">작업자 노드에는 Cryptsetup 2.1 이상(3.0 이하)이 설치되어 있어야 합니다. 자세한 내용은 를 참조하십시오 <block ref="39c06d5570d5dfd5c63abe15a0d8d2fb" category="inline-link-macro-rx"></block>.</block>
  <block id="83f59a8c99f92feae93c90d4f7bd0d68" category="section-title">LUKS 암호화를 사용합니다</block>
  <block id="b9a97083b1f9ee5d9d6fd1ec4025a836" category="paragraph">ONTAP SAN 및 ONTAP SAN 이코노미 볼륨에 대해 Linux 통합 키 설정(LUKS)을 사용하여 볼륨별 호스트 측 암호화를 활성화할 수 있습니다.</block>
  <block id="d197aff07a41df5dbefcace33058435c" category="list-text">백엔드 구성에서 LUKS 암호화 속성을 정의합니다. ONTAP SAN의 백엔드 구성 옵션에 대한 자세한 내용은 을 참조하십시오 <block ref="e87ded5ef8bc8adbc3c135528636f4f2" category="inline-link-macro-rx"></block>.</block>
  <block id="a99f022d7515cf14d9d2e49a72198c5c" category="list-text">LUKS 암호를 포함하는 암호를 생성합니다. 예를 들면 다음과 같습니다.</block>
  <block id="6d8e596656bc0dc6684415f94bee7e6a" category="paragraph">LUKS - 암호화된 볼륨은 ONTAP 중복 제거 및 압축을 활용할 수 없습니다.</block>
  <block id="f9d3cd939395358ac0f0bd3a1043656c" category="section-title">LUKS 암호를 회전합니다</block>
  <block id="5173c14a913aecabc2aa4a398abfd3a1" category="paragraph">LUKS 암호를 회전하고 회전을 확인할 수 있습니다.</block>
  <block id="870809044094847738d2e3b2d3490240" category="admonition">볼륨, 스냅샷 또는 비밀이 더 이상 참조하지 않음을 확인할 때까지 암호문을 잊지 마십시오. 참조된 암호가 손실된 경우 볼륨을 마운트할 수 없으며 데이터가 암호화된 상태로 유지되고 액세스할 수 없게 됩니다.</block>
  <block id="bbe48fb854ea022537208eeeff822f91" category="paragraph-title">이 작업에 대해</block>
  <block id="0887b239ebf59802cdd0acb89f746b66" category="paragraph">LUKS 암호 회전은 새 LUKS 암호를 지정한 후 볼륨을 마운트하는 POD가 생성될 때 발생합니다. 새 POD를 생성할 때 Astra Trident는 볼륨의 LUKS 암호를 비밀의 활성 패스프레이즈(passphrase)와 비교합니다.</block>
  <block id="a09edd6ec72e24ea93fe0643001ce09b" category="list-text">볼륨의 암호가 비밀의 활성 암호와 일치하지 않으면 회전이 발생합니다.</block>
  <block id="85341a765feac19c14ddb5733a16bb0f" category="list-text">볼륨의 암호가 비밀의 활성 암호와 일치하면 가 됩니다<block ref="4146f2b31b5baccc1599d6209e20b87f" prefix=" " category="inline-code"></block> 매개 변수는 무시됩니다.</block>
  <block id="e11fe3d05d72f7812c946ac80ae339ed" category="list-text">를 추가합니다<block ref="c774c2255b7e3b1f75cd200c366d4148" prefix=" " category="inline-code"></block> 및<block ref="59ab79bfd6177f0b40d74d58d4a94d89" prefix=" " category="inline-code"></block> StorageClass 매개 변수입니다. 예를 들면 다음과 같습니다.</block>
  <block id="7fe288bcd08368971a3839f1de636c7c" category="list-text">볼륨 또는 스냅숏에서 기존 암호를 식별합니다.</block>
  <block id="bd7a9717d29c5ddcab1bc175eda1e298" category="listing-title">볼륨</block>
  <block id="d4e2713d1b1725a1592f9268589f990d" category="listing-title">스냅샷</block>
  <block id="c0526adc9b28d758d8fab9d4a5b998ef" category="list-text">볼륨에 대한 LUKS 암호를 업데이트하여 새 암호 및 이전 암호 문구를 지정합니다. 확인합니다 <block ref="119d124de86f53dbdf015ff1809c10e1" prefix=" " category="inline-code"></block> 및<block ref="4146f2b31b5baccc1599d6209e20b87f" prefix=" " category="inline-code"></block> 이전 패스프레이즈를 일치시킵니다.</block>
  <block id="4f8a79fea6c3cc09f49769b8473808f7" category="list-text">볼륨을 마운트하는 새 포드를 생성합니다. 이 작업은 회전을 시작하는 데 필요합니다.</block>
  <block id="bcf837455c951c49bd9138ead166c489" category="list-text">패스프레이즈가 회전되었는지 확인합니다.</block>
  <block id="0c7eac961f50eef2d0c82d382fdd18b3" category="paragraph">볼륨과 스냅샷에 새 암호문만 반환되면 암호가 회전되었습니다.</block>
  <block id="6ff457ceee4568584dc3fd66c1ae658a" category="admonition">예를 들어, 두 개의 암호 구문이 반환되는 경우<block ref="b5b0f81d5dbb45d3dd031f1b02af8bf3" prefix=" " category="inline-code"></block>, 회전이 완료되지 않았습니다. 새 포드를 트리거하여 회전을 완료할 수 있습니다.</block>
  <block id="b3f9d5f1e12f2ba5ecd2ece1e9084f3f" category="section-title">볼륨 확장을 설정합니다</block>
  <block id="e5307495a3aec6528b42d3f3e835a761" category="paragraph">LUKS 암호화 볼륨에서 볼륨 확장을 활성화할 수 있습니다.</block>
  <block id="aeec1a5a7dc7624995570096ce8156ef" category="inline-link-macro">Kubernetes 1.25: CSI 볼륨의 노드 기반 확장에 비밀을 사용합니다</block>
  <block id="1282398415278cc77bc47970640d4188" category="list-text">를 활성화합니다<block ref="b0e105de2a2f0820528649fee8d2e331" prefix=" " category="inline-code"></block> 기능 게이트(베타 1.25+). 을 참조하십시오 <block ref="35e3bd84b2522e04fd4ead86130c9227" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="e4de718025be845e2dec22064bb4eece" category="list-text">를 추가합니다<block ref="91985ce21cd787a6ab2a13cc97f58968" prefix=" " category="inline-code"></block> 및<block ref="641c8d6753dd78e60ebb61a20e6a2742" prefix=" " category="inline-code"></block> StorageClass 매개 변수입니다. 예를 들면 다음과 같습니다.</block>
  <block id="e718558948d1441cf3873df6fb7b10c3" category="paragraph">온라인 저장소 확장을 시작할 때 kubelet은 적절한 자격 증명을 드라이버에 전달합니다.</block>
  <block id="a0070e4b4fc7fef456d0f1d1f6cec158" category="list-text">이전 백엔드를 정리하고 Trident에 새 백엔드를 만듭니다. 새 관리 LIF, 새 SVM 이름 및 대상 SVM의 암호를 지정합니다.</block>
  <block id="8a6112da5167fe6f44136715f1d86c36" category="paragraph">전용 인프라 노드(예: OpenShift) 또는 사용자 애플리케이션을 예약할 수 없는 다른 노드를 구축하는 경우, 별도의 엑스포트 정책을 사용하여 스토리지 리소스에 대한 액세스를 더욱 제한해야 합니다. 여기에는 해당 인프라 노드에 배포된 서비스(예: OpenShift Metrics 및 Logging 서비스)에 대한 엑스포트 정책과 비인프라 노드에 배포되는 표준 애플리케이션이 포함됩니다.</block>
  <block id="a330e835c41b0ff1dfc7e483e7e7f70e" category="summary">가상 풀은 Astra Trident의 스토리지 백엔드와 Kubernetes의 StorageClasses 간의 추상화 계층을 제공합니다. 관리자는 StorageClass를 만들지 않고도 각 백엔드에 대한 위치, 성능 및 보호와 같은 측면을 백엔드에 관계없이 공통된 방식으로 정의할 수 있습니다. 원하는 기준을 충족하는 데 사용할 물리적 백엔드, 백엔드 풀 또는 백엔드 유형을 지정할 수 있습니다.</block>
  <block id="9f77ac8822dd45ff19910e0170669eb7" category="paragraph">가상 풀은 Astra Trident 스토리지 백엔드와 Kubernetes 간의 추상화 계층을 제공합니다<block ref="f652904c3bfb48fb25a0a75f485f0ff6" prefix=" " category="inline-code"></block>. 관리자는 을 만들지 않고 각 백엔드에 대한 위치, 성능 및 보호와 같은 측면을 일반적인 백엔드 방식으로 정의할 수 있습니다<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 원하는 기준을 충족하는 데 사용할 물리적 백엔드, 백엔드 풀 또는 백엔드 유형을 지정합니다.</block>
  <block id="c395d1a6e14d73fb73663b1198b0b134" category="section-title">가상 풀에 대해 알아보십시오</block>
  <block id="f66146f5a5a305009d0129474f6fc10e" category="paragraph">스토리지 관리자는 Astra Trident 백엔드의 가상 풀을 JSON 또는 YAML 정의 파일로 정의할 수 있습니다.</block>
  <block id="6293784c303cb134632b85dc06f372df" category="image-alt">에는 가상 풀의 개념적 다이어그램이 나와 있습니다.</block>
  <block id="e26346b2afab61526141ea7275a77ba3" category="list-text">가상 풀을 정의할 때 백엔드 정의에서 기존 가상 풀의 순서를 재정렬하지 마십시오.</block>
  <block id="92aa2031bb642a0c5c916142f725400d" category="list-text">기존 가상 풀에 대한 속성을 수정하지 않는 것이 좋습니다. 변경하려면 새 가상 풀을 정의해야 합니다.</block>
  <block id="43d41b472d09879b85f78a3b8e487fd1" category="paragraph">대부분의 측면은 백엔드 관련 용어로 지정됩니다. 결정적으로, Aspect 값은 백엔드의 드라이버 외부에 노출되지 않으며 에서 일치시킬 수 없습니다<block ref="f652904c3bfb48fb25a0a75f485f0ff6" prefix=" " category="inline-code"></block>. 대신 관리자는 각 가상 풀에 대해 하나 이상의 레이블을 정의합니다. 각 레이블은 키, 즉 값 쌍이며 레이블은 고유한 백엔드에서 공통일 수 있습니다. 측면과 마찬가지로 레이블을 풀별로 지정하거나 백엔드에 대해 전역으로 지정할 수 있습니다. 미리 정의된 이름과 값이 있는 측면과 달리 관리자는 필요에 따라 레이블 키와 값을 정의할 수 있습니다. 편의를 위해 스토리지 관리자는 가상 풀 및 그룹 볼륨별로 레이블을 레이블별로 정의할 수 있습니다.</block>
  <block id="e084f7ea866c7ad616e67a911925c850" category="paragraph">A<block ref="e1e2a331ab1d8dccfea06fc8e04e2f5d" prefix=" " category="inline-code"></block> 선택기 매개 변수 내의 레이블을 참조하여 사용할 가상 풀을 식별합니다. 가상 풀 선택기는 다음 연산자를 지원합니다.</block>
  <block id="0b62778604e11f72525f5a82bbd26c6a" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block> NetApp ONTAP 스토리지 운영 체제가 제공하는 파일 시스템을 실행하고 실행할 수 있도록 완벽하게 관리되는 AWS 서비스입니다. ONTAP용 FSX를 사용하면 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에, AWS에 데이터를 저장하는 데 따른 단순성, 민첩성, 보안, 확장성을 활용할 수 있습니다. ONTAP용 FSX는 ONTAP 파일 시스템 기능 및 관리 API를 지원합니다.</block>
  <block id="9b85b10750f4b0e98b7853ee468d8bd5" category="list-text">SMB 볼륨:</block>
  <block id="cf201a9e802aa6e35997590206919b1a" category="list-text">SMB 볼륨은 를 사용하여 지원됩니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 드라이버만 해당.</block>
  <block id="b184cfad0a2d14c9220db3d72006958c" category="list-text">자동 백업이 설정된 Amazon FSx 파일 시스템에서 생성된 볼륨은 Trident에서 삭제할 수 없습니다. PVC를 삭제하려면 ONTAP 체적에 대한 PV 및 FSx를 수동으로 삭제해야 합니다. 이 문제를 방지하려면:</block>
  <block id="867730e819742e7e493081f160c42c61" category="paragraph">다음 드라이버를 사용하여 Astra Trident를 NetApp ONTAP용 Amazon FSx와 통합할 수 있습니다.</block>
  <block id="90e87fa57067732a25774f917230f72b" category="paragraph">드라이버 세부 정보는 를 참조하십시오 <block ref="5222b6b9484ba2027cf88dd24062e5fc" category="inline-link-macro-rx"></block>.</block>
  <block id="676f29c1b0b3626bc959bdc6ebc8953b" category="paragraph">Astra Trident는 두 가지 인증 모드를 제공합니다.</block>
  <block id="2dc4717be6b9cdf676df17aa86465f02" category="admonition">Astra Trident는 한 대로 실행될 것으로 예상합니다<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> SVM 사용자 또는 동일한 역할을 가진 다른 이름의 사용자 NetApp ONTAP용 Amazon FSx에는 가 있습니다<block ref="679500f227997b45be97e3ca8115c678" prefix=" " category="inline-code"></block> ONTAP의 제한된 교체인 사용자입니다<block ref="21232f297a57a5a743894a0e4a801fc3" prefix=" " category="inline-code"></block> 클러스터 사용자. 을 사용하는 것이 좋습니다<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> Astra Trident와 함께.</block>
  <block id="43c502a16d6b21dc6eb26a2067154e11" category="paragraph">자격 증명 기반 방법과 인증서 기반 방법 간에 이동하도록 백엔드를 업데이트할 수 있습니다. 그러나 * 자격 증명 및 인증서 * 를 제공하려고 하면 백엔드 생성이 실패합니다. 다른 인증 방법으로 전환하려면 백엔드 구성에서 기존 방법을 제거해야 합니다.</block>
  <block id="994eaa47aad78cae857818e1655e2800" category="paragraph">인증 활성화에 대한 자세한 내용은 드라이버 유형에 대한 인증을 참조하십시오.</block>
  <block id="57e00ef3eabad47fc79d0ef1319f989c" category="inline-link-macro">ONTAP NAS 인증</block>
  <block id="840db27e4fe9967e908b8b101ca72198" category="list-text"><block ref="840db27e4fe9967e908b8b101ca72198" category="inline-link-macro-rx"></block></block>
  <block id="562276ffa617658595d5e6df35ef971c" category="inline-link-macro">ONTAP SAN 인증</block>
  <block id="4a5e4254b1862ddbff7f81ed84e87125" category="list-text"><block ref="4a5e4254b1862ddbff7f81ed84e87125" category="inline-link-macro-rx"></block></block>
  <block id="d2aae26c4b1e25027872b1df4cee2081" category="paragraph">Azure NetApp Files 백엔드를 구성하기 전에 다음 요구 사항이 충족되는지 확인해야 합니다.</block>
  <block id="53ba532dfa04fe29152221a3efb3e98f" category="doc">Google Cloud용 Cloud Volumes Service 백엔드를 구성합니다</block>
  <block id="c891939fd67dfe2cdc8d8bd5a1404644" category="paragraph">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 NetApp Cloud Volumes Service for Google Cloud를 구성하는 방법을 알아보십시오.</block>
  <block id="ac7ba403929463ebd2aabb621c443399" category="section-title">Cloud Volumes Service for Google Cloud를 위한 Astra Trident 지원에 대해 알아보십시오</block>
  <block id="f391d05be666574cba6a6b88827e5766" category="paragraph">Astra Trident는 두 개 중 하나로 Cloud Volumes Service 볼륨을 생성할 수 있습니다 <block ref="a3cd55e5a9ff014b76f6953040234c24" category="inline-link-macro-rx"></block>:</block>
  <block id="3671a5060127094ad405aad9295e6609" category="inline-link-macro">3가지 서비스 레벨</block>
  <block id="9b44bc41471d2c2cc25eb7a9e5e01b49" category="list-text">* CVS - 성능 *: 기본 Astra Trident 서비스 유형입니다. 이처럼 성능에 최적화된 서비스 유형은 성능을 중요시하는 운영 워크로드에 가장 적합합니다. CVS - 성능 서비스 유형은 최소 100GiB 크기의 볼륨을 지원하는 하드웨어 옵션입니다. 다음 중 하나를 선택할 수 있습니다 <block ref="87d12cea36129673eb9128fd986958c5" category="inline-link-macro-rx"></block>:</block>
  <block id="1b3b34a1280074ca8311ff50bbacac6c" category="list-text"><block ref="c00f0c4675b91fb8b918e4079a0b1bac" prefix="" category="inline-code"></block></block>
  <block id="3f27980baf5bae9c9c40df09c54f6f23" category="list-text"><block ref="a288195832f8717bca4671416014a464" prefix="" category="inline-code"></block></block>
  <block id="091d891c1f040cef1072e2593b7f1f3b" category="list-text"><block ref="287e9593819b2fcdf9945e7ccacd637d" prefix="" category="inline-code"></block></block>
  <block id="1048ee58172376b84dda9c7505d858ea" category="inline-link-macro">서비스 레벨 2개</block>
  <block id="6c62a8c68facf167a61fbd54e9cceb5f" category="list-text">CVS *: CVS 서비스 유형은 높은 조널 가용성을 제공하며, 성능은 중간 수준으로 제한됩니다. CVS 서비스 유형은 스토리지 풀을 사용하여 1GiB의 작은 볼륨을 지원하는 소프트웨어 옵션입니다. 스토리지 풀에는 최대 50개의 볼륨이 포함될 수 있으며 이 볼륨에서 풀의 용량과 성능을 공유할 수 있습니다. 다음 중 하나를 선택할 수 있습니다 <block ref="21d52e1e64b94d45bea308be30f5a76a" category="inline-link-macro-rx"></block>:</block>
  <block id="277d5dd64fbcc2dbcd79252b41d6113e" category="list-text"><block ref="317ec56a799e879712bbd2d0fcbd3b93" prefix="" category="inline-code"></block></block>
  <block id="4bfd77bf3278584b71bc8c9deef39ca9" category="list-text"><block ref="75b65576cc4a19f0836b73610ad5957a" prefix="" category="inline-code"></block></block>
  <block id="66d7ad821e261a4b5099f37ced19ebb1" category="list-text">NetApp Cloud Volumes Service로 구성된 Google Cloud 계정</block>
  <block id="f56a3add505b7e123b55b814f7acc26b" category="list-text">Cloud Volumes Service 계정에 대한 API 키 파일입니다</block>
  <block id="82409a3ea24b043087a2159a3e1f9f74" category="cell">CVS 서비스 유형을 지정하는 데 사용되는 선택적 매개 변수입니다. 사용<block ref="f9fa10ba956cacf91d7878861139efb9" prefix=" " category="inline-code"></block> CVS 서비스 유형을 선택합니다. 그렇지 않으면 Astra Trident가 CVS - 성능 서비스 유형을 가정합니다 <block ref="3ca14c518d1bf901acc339e7c9cd6d7f" prefix="(" category="inline-code"></block>)를 클릭합니다.</block>
  <block id="5782f9a9357b5678058d6d3ceed21988" category="cell"><block ref="c614017642b6cfd9e6a25c7df122d917" prefix="" category="inline-code"></block></block>
  <block id="4efa10ec47c98c5ed67e1a72f7515240" category="cell">CVS 서비스 유형만 볼륨 생성을 위한 스토리지 풀을 지정하는 데 사용되는 선택적 매개 변수입니다.</block>
  <block id="4149383e1cf45a36b373c5bded2ff6ba" category="cell">Google Cloud 계정 프로젝트 번호입니다. 이 값은 Google Cloud 포털 홈 페이지에서 확인할 수 있습니다.</block>
  <block id="f0559497c76611a262c1a6fa93592cd7" category="cell">공유 VPC 네트워크를 사용하는 경우 필요합니다. 이 시나리오에서는<block ref="80ef6899136dfcff295c16caa93c2138" prefix=" " category="inline-code"></block> 은(는) 서비스 프로젝트입니다<block ref="b5caf2c58446baec75b83bf637a98d1b" prefix=" " category="inline-code"></block> 는 호스트 프로젝트입니다.</block>
  <block id="dbac640079c94d4a257a3513191a1ad6" category="cell">Astra Trident가 Cloud Volumes Service 볼륨을 생성하는 Google 클라우드 영역 지역 간 Kubernetes 클러스터를 생성할 때 에서 생성된 볼륨입니다<block ref="1e9c0fd1beef5ff8ed3bef2ae3b7e560" prefix=" " category="inline-code"></block> 여러 Google Cloud 지역의 노드에 예약된 워크로드에 사용할 수 있습니다. 지역 간 트래픽에는 추가 비용이 발생합니다.</block>
  <block id="665f1a07bc016a07fdc13ef823fcdb03" category="cell">를 사용하여 Google Cloud 서비스 계정에 대한 API 키입니다<block ref="4a5395c87dd91b3242056f83b7cedb9b" prefix=" " category="inline-code"></block> 역할. 여기에는 Google Cloud 서비스 계정의 개인 키 파일(백엔드 구성 파일에 verbatim 복사)의 JSON 형식 콘텐츠가 포함됩니다.</block>
  <block id="3430995d97c2d987bf88dfb93ddb34f7" category="cell">프록시 서버가 CVS 계정에 연결해야 하는 경우 프록시 URL입니다. 프록시 서버는 HTTP 프록시 또는 HTTPS 프록시일 수 있습니다. HTTPS 프록시의 경우 프록시 서버에서 자체 서명된 인증서를 사용할 수 있도록 인증서 유효성 검사를 건너뜁니다. 인증이 활성화된 프록시 서버는 지원되지 않습니다.</block>
  <block id="4d9239a7fce916964ba8529021ab535f" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다.</block>
  <block id="c4105759a421b56f4e5aa47752aa6812" category="cell">새 볼륨에 대한 CVS - 성능 또는 CVS 서비스 수준 CV - 성능 값은 입니다<block ref="c00f0c4675b91fb8b918e4079a0b1bac" prefix=" " category="inline-code"></block>,<block ref="a288195832f8717bca4671416014a464" prefix=" " category="inline-code"></block>, 또는<block ref="287e9593819b2fcdf9945e7ccacd637d" prefix=" " category="inline-code"></block>. CV 값은 입니다<block ref="317ec56a799e879712bbd2d0fcbd3b93" prefix=" " category="inline-code"></block> 또는<block ref="75b65576cc4a19f0836b73610ad5957a" prefix=" " category="inline-code"></block>.</block>
  <block id="5c3d9364df4807427e3297a90edf2831" category="cell">CV - 성능 기본값은 "표준"입니다. CV 기본값은 "standardsw"입니다.</block>
  <block id="5715e76155b75e9062107ef13c0576ed" category="cell">Cloud Volumes Service 볼륨에 사용되는 Google Cloud 네트워크</block>
  <block id="ad438db80cb3bcd5f6fccdb1010b02f1" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예:<block ref="9b8710f6da218ae915e4ba2ae63f23d0" prefix=" " category="inline-code"></block>. 문제 해결 중이 아니며 자세한 로그 덤프가 필요한 경우가 아니면 이 방법을 사용하지 마십시오.</block>
  <block id="a5f4597012dd7af2b717fd4cc2f687fe" category="cell"><block ref="df6ccab784b5892507a7d11443254dc8" prefix="" category="inline-code"></block></block>
  <block id="d2e98deb07632de971600ae032776fe8" category="cell">지역 간 액세스를 설정하려면 에 대한 StorageClass 정의를 사용합니다<block ref="df6ccab784b5892507a7d11443254dc8" prefix=" " category="inline-code"></block> 모든 지역을 포함해야 합니다. 예를 들면 다음과 같습니다.<block ref="3e7c75911911d149520dd40104fd92d7" prefix=" " category="inline-code"></block></block>
  <block id="eb60cd2c0cff094ad0ecbe9d6fededcf" category="section-title">볼륨 프로비저닝 옵션</block>
  <block id="afe8445a326424c54dfec7cc20994e8f" category="paragraph">에서 기본 볼륨 프로비저닝을 제어할 수 있습니다<block ref="a4a918a45181164207929d52aec36aec" prefix=" " category="inline-code"></block> 구성 파일의 섹션입니다.</block>
  <block id="fdcd5d79603b7f7c0f9b4525dd19b6ab" category="cell">새 볼륨의 내보내기 규칙. CIDR 표기법을 사용하여 IPv4 주소 또는 IPv4 서브넷의 조합을 쉼표로 구분해야 합니다.</block>
  <block id="d5c8102144978e060556ba194e006d1e" category="cell">새 볼륨의 크기입니다. CVS - 최소 성능은 100GiB입니다. CV 최소값은 1GiB입니다.</block>
  <block id="400f2f53e7d26564783ac50a601d32cb" category="cell">CVS - 성능 서비스 유형의 기본값은 "100GiB"입니다. CVS 서비스 유형은 기본값을 설정하지 않지만 최소 1GiB가 필요합니다.</block>
  <block id="94e5c486f56b72f4237fe801615b4406" category="section-title">CVS - 성능 서비스 유형의 예</block>
  <block id="dea6ff4202a54251e04f7b84647690b6" category="paragraph">다음 예에서는 CVS - 성능 서비스 유형에 대한 샘플 구성을 제공합니다.</block>
  <block id="ae174742813090d1ddbc3ed75d27f7f2" category="paragraph">기본 CVS - 성능 서비스 유형과 기본 "표준" 서비스 수준을 사용하는 최소 백엔드 구성입니다.</block>
  <block id="8228a8de88271b4a6a07d5021ae4ff7c" category="example-title">예 2: 서비스 수준 구성</block>
  <block id="38a24bdf59c77f7705c407c60f3ea81e" category="paragraph">이 샘플에서는 서비스 수준 및 볼륨 기본값을 포함한 백엔드 구성 옵션을 보여 줍니다.</block>
  <block id="4565a2282ee3312eddd091b3a3f6a263" category="example-title">예 3: 가상 풀 구성</block>
  <block id="ed7c2c2093c7c8deca88a6580c82633a" category="paragraph">이 샘플은 를 사용합니다<block ref="ddecebdea58b5f264d27f1f7909bab74" prefix=" " category="inline-code"></block> 가상 풀 및 를 구성합니다<block ref="f652904c3bfb48fb25a0a75f485f0ff6" prefix=" " category="inline-code"></block> 다시 언급한다는 것입니다. 을 참조하십시오 <block ref="f986c11e10e5f3c768f256080a1f3f99" category="inline-xref-macro-rx"></block> 스토리지 클래스를 정의한 방법을 확인합니다.</block>
  <block id="935927e4b464388790a08251e1c2254d" category="paragraph">이 경우 를 설정하는 모든 가상 풀에 대해 특정 기본값이 설정됩니다<block ref="bb0d75280f9b683f2f1f0767fd0aff9b" prefix=" " category="inline-code"></block> 5% 및 에서<block ref="c72971f17465d2a32345bc872af62a34" prefix=" " category="inline-code"></block> 를 0.0.0.0/0으로 설정합니다. 가상 풀은 에 정의되어 있습니다<block ref="ddecebdea58b5f264d27f1f7909bab74" prefix=" " category="inline-code"></block> 섹션을 참조하십시오. 각 개별 가상 풀은 고유한 가상 풀을 정의합니다<block ref="f1d0ae63f2e948a9e43dcc60303d595d" prefix=" " category="inline-code"></block>그리고 일부 풀은 기본값을 덮어씁니다. 가상 풀 레이블을 사용하여 에 따라 풀을 구분했습니다<block ref="c05f6c233521207f6fe311afef550c3c" prefix=" " category="inline-code"></block> 및<block ref="152f5dc0f7ac734f8e8ee17d4a482462" prefix=" " category="inline-code"></block>.</block>
  <block id="857fa84eb2e850753da87c8599addab3" category="section-title">스토리지 클래스 정의</block>
  <block id="5b797cdb3913e416eaea99109620eb0d" category="paragraph">다음 StorageClass 정의는 가상 풀 구성 예에 적용됩니다. 사용<block ref="bed471c4a88e25ac9a7e4a7b980700a8" prefix=" " category="inline-code"></block>볼륨을 호스팅하는 데 사용되는 가상 풀을 각 StorageClass에 대해 지정할 수 있습니다. 볼륨은 선택한 풀에 정의된 측면을 갖습니다.</block>
  <block id="ea7cdbae94b0329e6731e1f3ae9fc4fc" category="example-title">스토리지 클래스 예</block>
  <block id="48bbf2b27d410d92674b0f8f5d3447a0" category="list-text">첫 번째 StorageClass입니다 <block ref="d3b08f69c5bb5aadd45b7ba9391c7447" prefix="(" category="inline-code"></block>)가 첫 번째 가상 풀에 매핑됩니다. 이 풀은 스냅샷 예약 공간이 10%인 최고 성능을 제공하는 유일한 풀입니다.</block>
  <block id="c218d6520025e93f73bb7b0b289f3ebe" category="list-text">마지막 StorageClass입니다 <block ref="92c87bc6be7db462499a5a2258aa7ba9" prefix="(" category="inline-code"></block>) 10%의 스냅샷 예약 공간을 제공하는 스토리지 풀을 호출합니다. Astra Trident는 선택된 가상 풀을 결정하고 스냅샷 예약 요구 사항이 충족되는지 확인합니다.</block>
  <block id="d371b8466ee11b2a14782e343e3ed344" category="section-title">CVS 서비스 유형 예</block>
  <block id="f7a4e685ebf6839fc43b3bbaeff96c33" category="paragraph">다음 예에서는 CVS 서비스 유형에 대한 샘플 구성을 제공합니다.</block>
  <block id="96899a80429985fe87db6dedf997357e" category="example-title">예 1: 최소 구성</block>
  <block id="2bab01748045e624b36f643d0a50b1c2" category="paragraph">을 사용하는 최소 백엔드 구성입니다<block ref="78ec9b60245b46a4f05158076962ace9" prefix=" " category="inline-code"></block> CVS 서비스 유형과 기본값을 지정합니다<block ref="317ec56a799e879712bbd2d0fcbd3b93" prefix=" " category="inline-code"></block> 서비스 레벨:</block>
  <block id="d1f5fcc31a1c5bb592600c9f986af71c" category="example-title">예 2: 스토리지 풀 구성</block>
  <block id="879b7d1da5135e7d94358584a7245e33" category="paragraph">이 백엔드 구성은 를 사용합니다<block ref="c614017642b6cfd9e6a25c7df122d917" prefix=" " category="inline-code"></block> 스토리지 풀을 구성하려면 다음을 수행합니다.</block>
  <block id="4a9c2b6feb83a77f2806513226f33d05" category="summary">Amazon Elastic Kubernetes Service(EKS)에서 실행되는 Kubernetes 클러스터가 ONTAP에서 지원하는 블록 및 파일 영구 볼륨을 프로비저닝할 수 있도록 NetApp ONTAP 파일 시스템용 Amazon FSx를 Astra Trident와 통합할 수 있습니다.</block>
  <block id="8373fe009c8ffdbdda12cfedf744172c" category="doc">NetApp ONTAP용 Amazon FSx를 통합합니다</block>
  <block id="0629fb104936d0fb60cc736b6cb01caa" category="inline-link-macro">Astra Trident 요구사항</block>
  <block id="241f2511660937482446bd41efeac638" category="paragraph">또한 <block ref="1615f1c495dc4acc1bb5bea393c7532b" category="inline-link-macro-rx"></block>, ONTAP용 FSx와 Astra Trident를 통합하려면 다음이 필요합니다.</block>
  <block id="288b1cbb87d08c32abf3084c28636e5c" category="inline-link-macro">NFS 또는 iSCSI</block>
  <block id="d7481875afa061fb651628b2597d52ec" category="list-text">에 대해 준비된 작업자 노드입니다 <block ref="966ed3bab2d39ae1014ad2eb34527e0f" category="inline-link-macro-rx"></block>.</block>
  <block id="d0341760d873a30f82a310a6eab0ba9c" category="admonition">Amazon Linux 및 Ubuntu에 필요한 노드 준비 단계를 따라야 합니다<block ref="70013ee128d5437b3d9579d66ece4066" category="inline-link-rx"></block> (AMI) EKS AMI 유형에 따라 다릅니다.</block>
  <block id="8df63c807f3c78b6087ad0d6ee434fb2" category="list-text">Active Directory 자격 증명이 포함된 Astra Trident 암호가 하나 이상 있어야 합니다. 암호를 생성합니다<block ref="e47a193687dde960f6b6f80d394142a3" prefix=" " category="inline-code"></block>:</block>
  <block id="9303b8f40cf82f5e37702c7a6387e725" category="section-title">ONTAP SAN 및 NAS 드라이버 통합</block>
  <block id="83d1f963158732d2aedc5119f242bcff" category="admonition">SMB 볼륨에 대해 를 구성하는 경우 을 읽어야 합니다 <block ref="688177e6b45c5d27a545463079c58d82" category="inline-xref-macro-rx"></block> 백엔드를 생성하기 전에</block>
  <block id="c8aecc44e726368f30c6757e9ab5b64b" category="list-text">SVM 관리 LIF DNS 이름을 수집합니다. 예를 들어, AWS CLI를 사용하여 를 찾습니다<block ref="a3c3b30ab91f2501f21058ee87f27a4f" prefix=" " category="inline-code"></block> 에 입력<block ref="b8724da75fb917e992576b17378e66b3" prefix=" " category="inline-code"></block> -&gt;<block ref="fe4dbcab9b910577e5035e97ac068dae" prefix=" " category="inline-code"></block> 다음 명령을 실행한 후:</block>
  <block id="ed625a73c7dbbe8b3d51e643adb7ddfd" category="inline-link-macro">NAS 백엔드 인증</block>
  <block id="cac491bba67bb09dddb8fa935c0ed9d6" category="inline-link-macro">SAN 백엔드 인증</block>
  <block id="2c4646cfa545b727f14a7ee6560b41b8" category="list-text">에 대한 인증서를 만들고 설치합니다 <block ref="e0dfdc1f3574886f1078f7699f0f57f0" category="inline-link-macro-rx"></block> 또는 <block ref="2ba00bd5ff04f92ed7b3b69e76174936" category="inline-link-macro-rx"></block>.</block>
  <block id="7d7eb1dca2ce4d155167358b4768de14" category="paragraph">배포 후에는 을 만들 수 있습니다 <block ref="71dee6d7db1737892d8ac3c68402b3c3" category="inline-link-macro-rx"></block>.</block>
  <block id="fc4e16be02eac62a40d8ba5714cbeda1" category="section-title">SMB 볼륨 프로비저닝을 위한 준비</block>
  <block id="fbf3304d2358758ea71475804b2cbeae" category="paragraph">를 사용하여 SMB 볼륨을 프로비저닝할 수 있습니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 드라이버. 를 누릅니다 <block ref="24f26185e00986318dc562523d4edbf6" category="inline-xref-macro-rx"></block> 다음 단계를 완료합니다.</block>
  <block id="d98f239eeb5789a80cb4b247e5be144d" category="inline-link-macro">Microsoft 관리 콘솔</block>
  <block id="8e6249724e4eef8026e47829f03f9e67" category="list-text">SMB 공유를 생성합니다. 다음 두 가지 방법 중 하나로 SMB 관리자 공유를 생성할 수 있습니다 <block ref="364bc251e9c8cfbf6ce258767d17d682" category="inline-link-macro-rx"></block> 공유 폴더 스냅인 또는 ONTAP CLI 사용 ONTAP CLI를 사용하여 SMB 공유를 생성하려면 다음을 따르십시오.</block>
  <block id="c9e9c2bb32e43693c4687ec082488811" category="list-text">필요한 경우 공유에 대한 디렉토리 경로 구조를 생성합니다.</block>
  <block id="8a19300a396203718795b4620552b59c" category="paragraph">를 클릭합니다<block ref="293a1aaca0a542f4f1b1dc1a3ad95728" prefix=" " category="inline-code"></block> 명령은 공유를 생성하는 동안 -path 옵션에 지정된 경로를 확인합니다. 지정한 경로가 없으면 명령이 실패합니다.</block>
  <block id="a968d0620b250ca44da661cadac02e42" category="list-text">지정된 SVM과 연결된 SMB 공유를 생성합니다.</block>
  <block id="e172e0c83051eb537305571585af294a" category="list-text">공유가 생성되었는지 확인합니다.</block>
  <block id="a6e62ff657f01a7df2d91d1ea0d3e76c" category="inline-link-macro">SMB 공유를 생성합니다</block>
  <block id="39026ea2687a8de2a318f8245aceb992" category="admonition">을 참조하십시오 <block ref="2b8c6fb4597e9bb000d4d88db3769c9a" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="e4f84f59067aa8e22119bf499379385a" category="inline-link-macro">ONTAP 구성 옵션 및 예제용 FSX</block>
  <block id="ca088cbb36bbab4b23e57d63d95a628c" category="list-text">백엔드를 생성할 때 SMB 볼륨을 지정하려면 다음을 구성해야 합니다. 모든 ONTAP 백엔드 구성 옵션에 대한 자세한 내용은 을 참조하십시오 <block ref="dd05fa371cf4b2c8377b8b4b261a8edd" category="inline-link-macro-rx"></block>.</block>
  <block id="7bb910e3cf11d0b34ca215aa399d3f23" category="cell"><block ref="5910159ef86741f119f7574a9064b5b0" prefix="" category="inline-code"></block></block>
  <block id="7a17b79b33ad0814114d5c433d21f0e8" category="cell">공유 폴더 Microsoft 관리 콘솔을 사용하여 생성한 SMB 공유의 이름입니다. 예: "smb-share". * SMB 볼륨에 필요합니다. *</block>
  <block id="595b9128da266e4c0415d8a11362e974" category="cell">"SMB 공유"</block>
  <block id="3b84c7b88317953423192c633a83db9f" category="cell">* 를 로 설정해야 합니다<block ref="79e0f325804dafbdaef73b3b17c0fd8d" prefix=" " category="inline-code"></block>. * null인 경우 기본값은 로 설정됩니다<block ref="2521ef5d58fc027d3121662b7d8f9ac2" prefix=" " category="inline-code"></block>.</block>
  <block id="1928bae58ae496b53ef1a163c3dbeeb4" category="cell">모드를 선택합니다. SMB 볼륨에 대해서는 * 를 비워 두어야 합니다. *</block>
  <block id="ded47128219e64b5f24343dab357151b" category="admonition">Astra Trident가 공백을 적용합니다<block ref="7cfbb6f07899c8071ff38e69dca190e2" prefix=" " category="inline-code"></block> 볼륨에 대해 생성할 수 있습니다. iSCSI 백엔드의 경우 적용하는 것이 좋습니다<block ref="01cd995fd9a843d3ca767e057de28873" prefix=" " category="inline-code"></block> StorageClass에 있습니다. 기존 StorageClasses를 삭제하고 를 사용하여 다시 생성해야 합니다<block ref="01cd995fd9a843d3ca767e057de28873" prefix=" " category="inline-code"></block> 지정됨.</block>
  <block id="5b7532a7b48ec4e7b24ef0f5977589de" category="cell">클러스터 또는 SVM 관리 LIF의 IP 주소 MetroCluster의 원활한 전환을 위해 SVM 관리 LIF를 지정해야 합니다. FQDN(정규화된 도메인 이름)을 지정할 수 있습니다. 을 사용하여 Astra Trident가 설치된 경우 IPv6 주소를 사용하도록 설정할 수 있습니다<block ref="4a4ef9f92e69acc000120379678aadcf" prefix=" " category="inline-code"></block> 깃발. IPv6 주소는 대괄호로 묶어야 합니다(예: [28e8:d9fb:a825:b7bf:69a8:d02f:9e7b:3555]).</block>
  <block id="dccf51176372af70ec697fc2b11f83d8" category="cell">프로토콜 LIF의 IP 주소입니다. * iSCSI에 대해서는 지정하지 마십시오. * Astra Trident가 사용합니다 <block ref="2de2f329c45219df280af5a70ed7a17c" category="inline-link-macro-rx"></block> 다중 경로 세션을 설정하는 데 필요한 iSCI LIF를 검색하려면 경고 발생 시<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> 명시적으로 정의됩니다.</block>
  <block id="3418e818bbbe397a49b7096a5ed87929" category="cell">SVM에서 파생됩니다</block>
  <block id="1545a9d9aae1b8b83497bbe9185d348b" category="cell">CHAP를 사용하여 ONTAP SAN 드라이버에 대한 iSCSI 인증 [Boolean]. 를 로 설정합니다<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block> Astra Trident에서 백엔드에 제공된 SVM에 대한 기본 인증으로 양방향 CHAP를 구성하고 사용합니다. 을 참조하십시오 <block ref="866e591dc2a03ecc454dad25a664ca86" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="2da9f60cc5b99a5987580c38e6db0842" category="cell">Base64 - 신뢰할 수 있는 CA 인증서의 인코딩된 값입니다. 선택 사항. 인증서 기반 인증에 사용됩니다.</block>
  <block id="394d848f17683e31e21f6cde5fd9e3e4" category="cell">ONTAP 클러스터와 통신하는 데 필요한 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다.</block>
  <block id="6f0acf4836d44b03512e1caa0d774777" category="cell">ONTAP 클러스터와 통신하는 데 필요한 암호입니다. 자격 증명 기반 인증에 사용됩니다.</block>
  <block id="389db483158927a67353b09e0ce89d85" category="cell">사용할 SAN 볼륨에 대한 igroup의 이름입니다. 을 참조하십시오 <block ref="6e67b5ef9818d5ee50372d568636cd92" category="inline-xref-macro-rx"></block> 를 참조하십시오.</block>
  <block id="a0de2cc0c77c388210e1f48423eea29c" category="cell">SVM에서 새 볼륨을 프로비저닝할 때 사용되는 접두사 나중에 수정할 수 없습니다. 이 매개 변수를 업데이트하려면 새 백엔드를 생성해야 합니다.</block>
  <block id="e54cbd8ca5da26dc7e4be3bbfd23467e" category="cell">사용량이 이 비율을 초과하면 프로비저닝이 실패합니다. NetApp ONTAP 백엔드에 Amazon FSx를 사용하는 경우 를 지정하지 마십시오 <block ref="d57551b1efacf8a7be84b4d10c5a6e99" prefix=" " category="inline-code"></block>. 제공<block ref="679500f227997b45be97e3ca8115c678" prefix=" " category="inline-code"></block> 및<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> 애그리게이트 사용을 검색하고 Astra Trident를 사용하여 제한하는 데 필요한 권한이 포함되어 있지 않습니다.</block>
  <block id="f804cd6668c0728e26448509210268d3" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다. 또한 qtree 및 LUN에 대해 관리하는 볼륨의 최대 크기도 제한합니다.</block>
  <block id="b3a74fee006256ec5d63fe251b553f1d" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: {“api”:false, “method”:true} 문제 해결 및 자세한 로그 덤프가 필요한 경우가 아니면 사용하지 마십시오.</block>
  <block id="cc30671ec52693851659adb7020e02b1" category="cell">ONTAP REST API를 사용하는 부울 매개 변수입니다. * 기술 미리 보기 *<block ref="14d839191d1ecf387a15b5b0c802a8ae" prefix=" " category="inline-code"></block> 프로덕션 작업 부하가 아닌 테스트 환경에 권장되는** 기술 미리 보기로 제공됩니다**. 를 로 설정한 경우<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block>, Astra Trident는 ONTAP REST API를 사용하여 백엔드와 통신합니다. 이 기능을 사용하려면 ONTAP 9.11.1 이상이 필요합니다. 또한 사용되는 ONTAP 로그인 역할에 에 대한 액세스 권한이 있어야 합니다<block ref="a9ba4dc88fa11d44cc7c0c918d174778" prefix=" " category="inline-code"></block> 응용 프로그램. 이는 사전 정의된 에 의해 충족됩니다<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> 및<block ref="fdb6ba311fad29ec53069808f10ebef4" prefix=" " category="inline-code"></block> 역할.<block ref="14d839191d1ecf387a15b5b0c802a8ae" prefix=" " category="inline-code"></block> 는 MetroCluster에서 지원되지 않습니다.</block>
  <block id="ceff62705abadd1abc0e2d8f1a40ea35" category="section-title">에 대한 세부 정보<block ref="9d8592d88bbb76c68c01d830f091dacc" prefix=" " category="inline-code"></block></block>
  <block id="7038c8ee6b987228eae45aa3f990a3de" category="paragraph"><block ref="9d8592d88bbb76c68c01d830f091dacc" prefix="" category="inline-code"></block> ONTAP 클러스터에서 이미 생성된 igroup으로 설정할 수 있습니다. 지정되지 않은 경우 Astra Trident가 이름이 인 igroup을 자동으로 생성합니다<block ref="7c79ab6d4da823d54e29bcbb64f38eef" prefix=" " category="inline-code"></block>.</block>
  <block id="60f33a20147fc20d3d7707e50d1c0a9a" category="paragraph">미리 정의된 횟수 이름을 제공하는 경우 환경 간에 SVM을 공유하려면 Kubernetes 클러스터 당 하나의 igroup을 사용하는 것이 좋습니다. 이는 Astra Trident가 IQN 추가 및 삭제를 자동으로 유지 관리하는 데 필요합니다.</block>
  <block id="3f4c75b40f8732fcb4f838d7f1b21a76" category="list-text"><block ref="9d8592d88bbb76c68c01d830f091dacc" prefix="" category="inline-code"></block> Astra Trident 외부의 SVM에서 생성 및 관리되는 새로운 igroup을 가리키도록 업데이트할 수 있습니다.</block>
  <block id="1b4b9a9a67369e93e8c38ee61a36dd5d" category="list-text"><block ref="9d8592d88bbb76c68c01d830f091dacc" prefix="" category="inline-code"></block> 생략할 수 있습니다. 이 경우 Astra Trident가 이름을 가진 igroup을 생성하고 관리합니다<block ref="7c79ab6d4da823d54e29bcbb64f38eef" prefix=" " category="inline-code"></block> 자동으로.</block>
  <block id="c59183b2f668b355e81e7bb1256f92b3" category="paragraph">에서 이러한 옵션을 사용하여 기본 프로비저닝을 제어할 수 있습니다<block ref="a4a918a45181164207929d52aec36aec" prefix=" " category="inline-code"></block> 섹션을 참조하십시오. 예를 들어, 아래 구성 예제를 참조하십시오.</block>
  <block id="d4fbfa2dd496728ba6294eb840ce25eb" category="cell">생성된 볼륨에 할당할 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다. Astra Trident와 함께 QoS 정책 그룹을 사용하려면 ONTAP 9.8 이상이 필요합니다. 비공유 QoS 정책 그룹을 사용하고 정책 그룹이 각 구성요소별로 적용되도록 하는 것이 좋습니다. 공유 QoS 정책 그룹은 모든 워크로드의 총 처리량에 대해 상한을 적용합니다.</block>
  <block id="b71ccf1062cee8c376a7eb37e3c42603" category="cell">LUKS 암호화를 사용합니다. 을 참조하십시오 <block ref="569f9f91cdcc19909b8acbf6f423daf7" category="inline-link-macro-rx"></block>.</block>
  <block id="e62f5d0a5a95571e25197caafe78cd98" category="section-title">볼륨 프로비저닝의 예</block>
  <block id="1b9ef354b22d8a8b125247fd538da4b2" category="section-title">가상 풀의 백엔드 예</block>
  <block id="15b57a79ac72161839107ffc66c3cd5b" category="paragraph">아래 표시된 샘플 백엔드 정의 파일에서 와 같은 모든 스토리지 풀에 대한 특정 기본값이 설정됩니다<block ref="cae77b049bf504af7afc43b99b6c5213" prefix=" " category="inline-code"></block> 없음,<block ref="45922ba6ba8428764f22ed06f814c762" prefix=" " category="inline-code"></block> 거짓일 경우, 및<block ref="5bdf74912a51c34815f11e9a3d20b609" prefix=" " category="inline-code"></block> 거짓일 때. 가상 풀은 스토리지 섹션에 정의됩니다.</block>
  <block id="dbd1f003df542a684d9c10246dc8a88f" category="paragraph">Astra Trident는 "Comments" 필드에 제공 레이블을 설정합니다. FlexVol에 주석이 설정됩니다. Astra Trident는 프로비저닝할 때 가상 풀에 있는 모든 레이블을 스토리지 볼륨에 복사합니다. 편의를 위해 스토리지 관리자는 가상 풀 및 그룹 볼륨별로 레이블을 레이블별로 정의할 수 있습니다.</block>
  <block id="615c9f89b360c50cfba2b2de02584387" category="paragraph">다음 StorageClass 정의는 위의 가상 풀을 참조합니다. 를 사용합니다<block ref="bed471c4a88e25ac9a7e4a7b980700a8" prefix=" " category="inline-code"></block> 필드에서 각 StorageClass는 볼륨을 호스팅하는 데 사용할 수 있는 가상 풀을 호출합니다. 선택한 가상 풀에 볼륨이 정의되어 있습니다.</block>
  <block id="6967d2f650cb483604470074babc7e49" category="list-text">첫 번째 StorageClass입니다 <block ref="63f9100803e1f67a5e33cbd5da9dbb33" prefix="(" category="inline-code"></block>)는 의 첫 번째, 두 번째 가상 풀에 매핑됩니다<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block> 백엔드 및 의 첫 번째 가상 풀<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 백엔드. 골드 레벨 보호 기능을 제공하는 유일한 풀입니다.</block>
  <block id="fbec52fab850807a16609bbdc348a22c" category="list-text">두 번째 StorageClass입니다 <block ref="afbfe298fa275e5fff1aca9b2f213d9a" prefix="(" category="inline-code"></block>)는 에서 세 번째, 네 번째 가상 풀에 매핑됩니다<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block> 백엔드 및 에서 세 번째 가상 풀입니다<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 백엔드. 금 이외의 보호 수준을 제공하는 유일한 풀입니다.</block>
  <block id="1e5b2ff70009afbcceab93e3227617bd" category="list-text">세 번째 StorageClass입니다 <block ref="65846755494383158592c748f74421ec" prefix="(" category="inline-code"></block>)는 에서 네 번째 가상 풀에 매핑됩니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 에 있는 백엔드 및 세 번째 가상 풀입니다<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block> 백엔드. mysqldb 유형 앱에 대한 스토리지 풀 구성을 제공하는 유일한 풀입니다.</block>
  <block id="52b4b6b0859604e480b790040aafe0d3" category="list-text">네 번째 StorageClass입니다 <block ref="2e63b2ff91d4aeb88b54db5c90b71443" prefix="(" category="inline-code"></block>)는 의 세 번째 가상 풀에 매핑됩니다<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block> 의 백엔드 및 두 번째 가상 풀입니다<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 백엔드. 20000 크레딧 포인트에서 골드 레벨 보호 기능을 제공하는 유일한 풀입니다.</block>
  <block id="67ce738597c25b9a15f0eafcd519fcfc" category="list-text">다섯 번째 StorageClass입니다 <block ref="a96bee9dd30f3ea0af93b4c64ca1e4a4" prefix="(" category="inline-code"></block>)는 의 두 번째 가상 풀에 매핑됩니다<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block> 에 있는 백엔드 및 세 번째 가상 풀입니다<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 백엔드. 5000 크레딧 포인트에 있는 유일한 풀 서비스입니다.</block>
  <block id="065b7cc24b33be7af1e15f59024402d2" category="paragraph">Astra Trident가 선택한 가상 풀을 결정하고 스토리지 요구 사항을 충족시킵니다.</block>
  <block id="c632eed28bf53466df8b8a33aedab3af" category="list-text">가상 풀(있는 경우)은 원래 백엔드와 동일한 순서를 유지해야 합니다.</block>
  <block id="87a522ecb9df14bf978f6f1da8a654a8" category="list-text">를 제거하여 원본 PVC에 대한 액세스를 취소할 수 없습니다<block ref="287f26e3328f9ac0f3f4da2cdaddd3e2" prefix=" " category="inline-code"></block> 또는<block ref="11650d25d20af47978d85fd6e19c89aa" prefix=" " category="inline-code"></block> 주석 또는 삭제<block ref="d6995f631b22fb3f8e94aad1b40d1280" prefix=" " category="inline-code"></block> 있습니다. 액세스 권한을 취소하려면 하위 PVC를 삭제해야 합니다.</block>
  <block id="1b9b62ce5b41c05a88e439d4ddbaf2c3" category="paragraph">Astra Trident의 백엔드로 Azure NetApp Files(ANF)를 구성할 수 있습니다. ANF 백엔드를 사용하여 NFS 및 SMB 볼륨을 연결할 수 있습니다.</block>
  <block id="41a45a3b55b7354dab0d81bb0ad06493" category="cell">프로토콜 LIF의 IP 주소입니다. 지정할 것을 권장합니다<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block>. 제공되지 않는 경우 Astra Trident는 SVM에서 데이터 LIF를 가져옵니다. NFS 마운트 작업에 사용할 FQDN(정규화된 도메인 이름)을 지정하면 여러 데이터 LIF에서 로드 밸런싱을 위해 라운드 로빈 DNS를 생성할 수 있습니다. 초기 설정 후에 변경할 수 있습니다. 을 참조하십시오 <block ref="b2c939cb81e81d99a25f4be74f517f2f" category="inline-xref-macro-rx"></block>. 을 사용하여 Astra Trident가 설치된 경우 IPv6 주소를 사용하도록 설정할 수 있습니다<block ref="4a4ef9f92e69acc000120379678aadcf" prefix=" " category="inline-code"></block> 깃발. IPv6 주소는 대괄호로 묶어야 합니다(예: [28e8:d9fb:a825:b7bf:69a8:d02f:9e7b:3555]).</block>
  <block id="ae8df8316f5c485b7db4e7141e899701" category="cell">지정되지 않은 경우 SVM에서 지정 주소 또는 파생(권장하지 않음)</block>
  <block id="ad898a5f5863162f9c13e958485877d5" category="cell">자동 엑스포트 정책 생성 및 업데이트 [Boolean] 활성화 를 사용합니다<block ref="323e871cfe2e70ead9c713e8f3164f8f" prefix=" " category="inline-code"></block> 및<block ref="b9c40fbe9daa81e40e06509d5bbd5a6c" prefix=" " category="inline-code"></block> 옵션, Astra Trident는 엑스포트 정책을 자동으로 관리할 수 있습니다.</block>
  <block id="61d28c885ea44666257b77069a1c5c61" category="cell">Kubernetes 노드 IP를 언제 기준으로 필터링하는 CIDR 목록입니다<block ref="323e871cfe2e70ead9c713e8f3164f8f" prefix=" " category="inline-code"></block> 가 활성화됩니다. 를 사용합니다<block ref="323e871cfe2e70ead9c713e8f3164f8f" prefix=" " category="inline-code"></block> 및<block ref="b9c40fbe9daa81e40e06509d5bbd5a6c" prefix=" " category="inline-code"></block> 옵션, Astra Trident는 엑스포트 정책을 자동으로 관리할 수 있습니다.</block>
  <block id="82530dd92610570d634788e7fac29c1b" category="cell">사용량이 이 비율을 초과하면 프로비저닝이 실패합니다. ONTAP * 용 아마존 FSx에는 * 가 적용되지 않습니다</block>
  <block id="9f0e1cc91ea4107261588e8f1bd02d07" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다. 또한 qtree 및 LUN에 대해 관리하는 볼륨의 최대 크기 및 을 제한합니다<block ref="8b08152c170e621ffcc8bfac7c4d6785" prefix=" " category="inline-code"></block> 옵션을 사용하면 FlexVol당 최대 qtree 수를 사용자 지정할 수 있습니다.</block>
  <block id="5c8b39f8ec19acb1fddb0b5c021f090d" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: {“api”:false, “method”:true} 사용하지 마십시오<block ref="effa2d809c72dcb6cce15a1e0b040e63" prefix=" " category="inline-code"></block> 문제 해결 및 자세한 로그 덤프가 필요한 경우를 제외하고</block>
  <block id="b660669829d401dc613c20939ed01e6e" category="cell">쉼표로 구분된 NFS 마운트 옵션 목록입니다. Kubernetes 영구 볼륨의 마운트 옵션은 일반적으로 스토리지 클래스에서 지정되지만, 스토리지 클래스에 마운트 옵션을 지정하지 않으면 Astra Trident가 스토리지 백엔드의 구성 파일에 지정된 마운트 옵션을 사용하여 로 돌아갑니다. 스토리지 클래스 또는 구성 파일에 마운트 옵션이 지정되지 않은 경우 Astra Trident는 연결된 영구 볼륨에 마운트 옵션을 설정하지 않습니다.</block>
  <block id="a2b63939d1ced2a10bc8dec4d3ef2604" category="cell">NFS 볼륨의 경우 "777", SMB 볼륨의 경우 비어 있음(해당 없음</block>
  <block id="97ff13c76d92207c0bae60ad6c586e7e" category="example-title">&lt;code&gt; ONTAP의 기본 옵션 - NAS - 이코노미 &lt;/code&gt;</block>
  <block id="e7a2472a002479764cade728d64dcd9e" category="example-title">인증서 기반 인증입니다</block>
  <block id="30cc3e263c594cde4b2a573283348bb1" category="example-title">자동 엑스포트 정책</block>
  <block id="41dfe08f09251bf83a4f15ec1a47eebe" category="paragraph">다음 예에서는 Astra Trident가 동적 엑스포트 정책을 사용하여 엑스포트 정책을 자동으로 생성하고 관리하도록 지시하는 방법을 보여 줍니다. 이 기능은 에 대해서도 동일하게 작동합니다<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block> 및<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block> 드라이버.</block>
  <block id="0491780b1bb26f4feb8296034f975c9e" category="listing-title">&lt;code&gt; ONTAP - NAS - flexgroup &lt;/code&gt; 드라이버</block>
  <block id="85435c5aae5ecdb04ef9ad8f7d48e88a" category="example-title">IPv6 주소 사용</block>
  <block id="0275de02c3bba722f4540469d23cc535" category="paragraph">이 예에서는 를 보여 줍니다<block ref="a6ea6092cb7b9c5f31909eb4be8fa5ea" prefix=" " category="inline-code"></block> IPv6 주소 사용.</block>
  <block id="258c5f2b91a253fe5e571b9c11f63b78" category="section-title"><block ref="8321592ce24c8a122ecf26a63cfca407" prefix="" category="inline-code"></block> SMB 볼륨을 사용하는 ONTAP용 Amazon FSx 드라이버입니다</block>
  <block id="bc0c77920482bbcdc79d8f24445101e0" category="paragraph">Astra Trident는 "Comments" 필드에 제공 레이블을 설정합니다. 설명은 FlexVol for에서 설정됩니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 또는 FlexGroup for<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block>. Astra Trident는 프로비저닝할 때 가상 풀에 있는 모든 레이블을 스토리지 볼륨에 복사합니다. 편의를 위해 스토리지 관리자는 가상 풀 및 그룹 볼륨별로 레이블을 레이블별로 정의할 수 있습니다.</block>
  <block id="433d360055061e28891915649702a7dc" category="example-title">&lt;code&gt; ONTAP - NAS &lt;/code&gt; 드라이버</block>
  <block id="5564b8ae7f180399e8901d4ea051ce57" category="example-title">&lt;code&gt; ONTAP - NAS - 경제적인 &lt;/code&gt; 드라이버</block>
  <block id="0bd54df5242a2a2e9eca045fc695b41f" category="section-title">업데이트<block ref="ea76b2438eb5996eb2c347e7341ed59a" prefix=" " category="inline-code"></block> 초기 구성 후</block>
  <block id="d0b121ba3c5e39bba858ccfcf5a75957" category="paragraph">다음 명령을 실행하여 초기 구성 후에 데이터 LIF를 변경할 수 있으며, 업데이트된 데이터 LIF가 포함된 새 백엔드 JSON 파일을 제공할 수 있습니다.</block>
  <block id="3fa13ec46a3746ee36c97d65fa53f096" category="admonition">PVC가 하나 이상의 포드에 연결된 경우 해당 포드를 모두 내린 다음 다시 불러와서 새 데이터 LIF가 적용되도록 해야 합니다.</block>
  <block id="a84a64b02579dc14f89cbfdf30b6e938" category="list-text">을 사용하여 로그 보존 기간을 지정할 수 있습니다<block ref="86339c2ed773d5bd944b82d3086d3477" prefix=" " category="inline-code"></block> 깃발. 예를 들면 다음과 같습니다.<block ref="e238339d491d4840f7d8e509bdbb7b63" prefix=" " category="inline-code"></block>. 이 정보는 를 통해 수집 및 전송됩니다<block ref="9d80ca17f097c8e365550f4036ccf0e3" prefix=" " category="inline-code"></block> Astra Trident와 함께 설치되는 컨테이너입니다. 에서 컨테이너 이미지를 얻을 수 있습니다<block ref="1b00454f0ab35dcec2ee1a0061efc6e5" category="inline-link-rx"></block>.</block>
  <block id="76b4586b7207f884c66397194b773e14" category="summary">Amazon FSx for ONTAP의 백엔드 구성 옵션에 대해 알아보십시오. 이 섹션에서는 백엔드 구성 예를 제공합니다.</block>
  <block id="bf432628a3769cd379c6784688db312f" category="cell">프로토콜 LIF의 IP 주소입니다. * ONTAP NAS 드라이버 *: 데이터 LIF를 지정하는 것이 좋습니다. 제공되지 않는 경우 Astra Trident는 SVM에서 데이터 LIF를 가져옵니다. NFS 마운트 작업에 사용할 FQDN(정규화된 도메인 이름)을 지정하면 여러 데이터 LIF에서 로드 밸런싱을 위해 라운드 로빈 DNS를 생성할 수 있습니다. 초기 설정 후에 변경할 수 있습니다. 을 참조하십시오 <block ref="b2c939cb81e81d99a25f4be74f517f2f" category="inline-xref-macro-rx"></block>. * ONTAP SAN 드라이버 *: iSCSI에 대해 지정하지 마십시오. Astra Trident는 ONTAP 선택적 LUN 맵을 사용하여 다중 경로 세션을 설정하는 데 필요한 iSCI LIF를 검색합니다. 데이터 LIF가 명시적으로 정의되어 있으면 경고가 생성됩니다. 을 사용하여 Astra Trident가 설치된 경우 IPv6 주소를 사용하도록 설정할 수 있습니다<block ref="4a4ef9f92e69acc000120379678aadcf" prefix=" " category="inline-code"></block> 깃발. IPv6 주소는 대괄호로 묶어야 합니다(예: [28e8:d9fb:a825:b7bf:69a8:d02f:9e7b:3555]).</block>
  <block id="508e91a481a0d10be716ae1a501447d0" category="cell">"["0.0.0.0/0", "::/0"]"</block>
  <block id="b8c7e19ba614c29878588409008e29c6" category="cell">클러스터 또는 SVM에 연결할 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다. 예: vsadmin.</block>
  <block id="9a2486a943ad2a4c99f2797d6984f3d0" category="cell">클러스터 또는 SVM에 연결하는 암호 자격 증명 기반 인증에 사용됩니다.</block>
  <block id="6018b4c39d938c6589decae81b54c6f0" category="cell">SVM 관리 LIF가 지정된 경우에 파생됩니다.</block>
  <block id="6b249375261ddb13a77410698978d6e4" category="cell">사용할 SAN 볼륨에 대한 igroup의 이름입니다. 을 참조하십시오 <block ref="6e67b5ef9818d5ee50372d568636cd92" category="inline-xref-macro-rx"></block>.</block>
  <block id="4cba35e041b22828be7c835295ee9102" category="cell">SVM에서 새 볼륨을 프로비저닝할 때 사용되는 접두사 생성 후에는 수정할 수 없습니다. 이 매개 변수를 업데이트하려면 새 백엔드를 생성해야 합니다.</block>
  <block id="2b3e2c0490ded1bc79028dd367358b9d" category="cell">* NetApp ONTAP * 용 Amazon FSx는 지정하지 마십시오<block ref="679500f227997b45be97e3ca8115c678" prefix=" " category="inline-code"></block> 및<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> 애그리게이트 사용을 검색하고 Astra Trident를 사용하여 제한하는 데 필요한 권한이 포함되어 있지 않습니다.</block>
  <block id="86f4c9647fe8f4c500055c772753cc6f" category="cell">사용하지 마십시오.</block>
  <block id="bd4c4a75acd87c86694e9aca1e4050e2" category="cell">FlexVol당 최대 LUN 수는 [50, 200] 범위 내에 있어야 합니다. SAN만 해당.</block>
  <block id="e70237f69c6dce25fd2312b8d7f00b1e" category="cell">"100"</block>
  <block id="e939be085c2babe4ff0f08e09d0cdfd2" category="cell">NFS 또는 SMB 볼륨 생성을 구성합니다. 옵션은 입니다<block ref="2521ef5d58fc027d3121662b7d8f9ac2" prefix=" " category="inline-code"></block>,<block ref="79e0f325804dafbdaef73b3b17c0fd8d" prefix=" " category="inline-code"></block>또는 null입니다. * 를 로 설정해야 합니다<block ref="79e0f325804dafbdaef73b3b17c0fd8d" prefix=" " category="inline-code"></block> SMB 볼륨의 경우. * null로 설정하면 기본적으로 NFS 볼륨이 설정됩니다.</block>
  <block id="b993677cdfb69bee31dd375d27acbb2d" category="cell">"NFS"</block>
  <block id="89ffa293e05655bd6be9d422345be38a" category="cell">"200"</block>
  <block id="be01424702282a8710bfaa63381e0ef3" category="cell">공유 폴더 Microsoft 관리 콘솔을 사용하여 생성한 SMB 공유의 이름입니다. * SMB 볼륨에 필요합니다. *</block>
  <block id="2ab2b81dde76a2ec7ed3798f1538f823" category="cell">ONTAP REST API를 사용하는 부울 매개 변수입니다. * 기술 미리 보기 *<block ref="14d839191d1ecf387a15b5b0c802a8ae" prefix=" " category="inline-code"></block> 프로덕션 작업 부하가 아닌 테스트 환경에 권장되는** 기술 미리 보기로 제공됩니다**. 를 로 설정한 경우<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block>, Astra Trident는 ONTAP REST API를 사용하여 백엔드와 통신합니다. 이 기능을 사용하려면 ONTAP 9.11.1 이상이 필요합니다. 또한 사용되는 ONTAP 로그인 역할에 에 대한 액세스 권한이 있어야 합니다<block ref="a9ba4dc88fa11d44cc7c0c918d174778" prefix=" " category="inline-code"></block> 응용 프로그램. 이는 사전 정의된 에 의해 충족됩니다<block ref="6173aa5206484b5224450952747c7148" prefix=" " category="inline-code"></block> 및<block ref="fdb6ba311fad29ec53069808f10ebef4" prefix=" " category="inline-code"></block> 역할.</block>
  <block id="f9d8bcec134b3ae3cb7aaac7048373ee" category="cell">생성된 볼륨에 할당할 QoS 정책 그룹입니다. 스토리지 풀 또는 백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다. Astra Trident와 함께 QoS 정책 그룹을 사용하려면 ONTAP 9.8 이상이 필요합니다. 비공유 QoS 정책 그룹을 사용하고 정책 그룹이 각 구성요소별로 적용되도록 하는 것이 좋습니다. 공유 QoS 정책 그룹은 모든 워크로드의 총 처리량에 대해 상한을 적용합니다.</block>
  <block id="a8fe789c9febc6b76736fb83c90df2b7" category="cell">생성된 볼륨에 할당할 적응형 QoS 정책 그룹입니다. 스토리지 풀 또는 백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다. ONTAP에서 지원되지 않음 - NAS - 이코노미</block>
  <block id="8336fb38c3b943161d5d6e73af8f4a12" category="cell">LUKS 암호화를 사용합니다. 을 참조하십시오 <block ref="3646c7a69a11bdd94c010bf856bda313" category="inline-link-macro-rx"></block>. SAN만 해당.</block>
  <block id="8ba802b52dc84f4e82bfbbf2e2d4a807" category="cell">모드를 선택합니다. * SMB 볼륨의 경우 비워 둡니다. *</block>
  <block id="ce627e1ba8a6bccff2793f66b44012fa" category="cell">""</block>
  <block id="88b0b88c998957f004af42563d5e5b40" category="paragraph">사용<block ref="296026821ada2ab8aebcf13547a63df5" prefix=" " category="inline-code"></block>,<block ref="e12fdd044232e643620eed06bf33c7af" prefix=" " category="inline-code"></block>, 및<block ref="1ad68a6a046942b7c1666aed825df70a" prefix=" " category="inline-code"></block>, SMB 볼륨을 지정하고 필요한 Active Directory 자격 증명을 제공할 수 있습니다. SMB 볼륨은 를 사용하여 지원됩니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 드라이버만 해당.</block>
  <block id="98e45a92edd75cce26a32a68de45f178" category="summary">백엔드는 Astra Trident와 스토리지 시스템 간의 관계를 정의합니다. Astra Trident가 스토리지 시스템과 통신하는 방법과 Astra Trident가 스토리지 시스템에서 볼륨을 프로비저닝하는 방법을 알려줍니다.</block>
  <block id="a576cff5a76e67426a0051b7e1b93331" category="paragraph">Astra Trident는 스토리지 클래스에 정의된 요구 사항과 일치하는 백엔드에서 스토리지 풀을 자동으로 제공합니다. 스토리지 시스템에 대한 백엔드를 구성하는 방법에 대해 알아봅니다.</block>
  <block id="92c602e77579e8a5989f77c799538f4e" category="paragraph">CSI Trident의 20.04 릴리스는 ONTAP 백엔드에 대한 엑스포트 정책을 동적으로 관리할 수 있는 기능을 제공합니다. 따라서 스토리지 관리자는 명시적 규칙을 수동으로 정의하는 대신 작업자 노드 IP에 허용되는 주소 공간을 지정할 수 있습니다. 엑스포트 정책 관리를 크게 간소화하므로, 엑스포트 정책을 수정하면 더 이상 스토리지 클러스터에 대한 수동 작업이 필요하지 않습니다. 또한 스토리지 클러스터에 대한 액세스를 지정된 범위의 IP가 있는 작업자 노드에만 제한함으로써 세분화된 자동 관리를 지원합니다.</block>
  <block id="82e9e9b5fadbd07fd12a8a3291248581" category="admonition">이 기능을 사용할 때는 SVM의 루트 교차점에 노드 CIDR 블록(예: 기본 엑스포트 정책)을 허용하는 엑스포트 규칙과 함께 이전에 생성된 엑스포트 정책이 있는지 확인해야 합니다. Astra Trident를 위한 SVM 전용 NetApp의 권장 모범 사례를 항상 따르십시오.</block>
  <block id="262309361fe5b6dcda3a2eae08a48c2d" category="section-title">올바른 도구 선택</block>
  <block id="82ee439808998e63e6868ec2c2945ec9" category="paragraph">드라이버를 함께 사용하는 경우 NFS 및 iSCSI 도구를 설치해야 합니다.</block>
  <block id="2cb4ed05fbad97efb755e294c572862d" category="paragraph-title">NFS 툴</block>
  <block id="a9e67ed867ad461570158dca74719f75" category="paragraph">다음을 사용 중인 경우 NFS 툴을 설치합니다.<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block>,<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block>,<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block>,<block ref="bc5779a2d33eeb1304bae57f15920cfc" prefix=" " category="inline-code"></block>,<block ref="5935ea92cdd7d975b4e764b429f21c01" prefix=" " category="inline-code"></block></block>
  <block id="0172151d0fbf6ae973feaaaf8a2c1b3a" category="paragraph-title">iSCSI 툴</block>
  <block id="b7ebd185ede5c83487cb4ac908bab891" category="paragraph">다음을 사용하는 경우 iSCSI 도구를 설치합니다.<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block>,<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block>,<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block></block>
  <block id="d3d338d650fae8dd20bbce45831b41a9" category="admonition">최신 버전의 RedHat CoreOS에는 기본적으로 NFS 및 iSCSI가 설치되어 있습니다.</block>
  <block id="b5a99bc586551f60f1fa102fcf3a90de" category="paragraph">Astra Trident는 노드가 iSCSI 또는 NFS 서비스를 실행할 수 있는지 자동으로 감지하려고 시도합니다.</block>
  <block id="6a9c3f120f628091afbdc5343cbbe0e1" category="paragraph-title">이벤트를 검토합니다</block>
  <block id="331ef15228e3a5548d228c3aea284e38" category="paragraph">Astra Trident는 검색된 서비스를 식별하기 위해 노드에 대한 이벤트를 생성합니다. 이러한 이벤트를 검토하려면 다음을 실행합니다.</block>
  <block id="70db3e5b82bc8c7ce4389fe8a025df28" category="paragraph-title">검색된 서비스를 검토합니다</block>
  <block id="ce31bc8e7fc118dd3b337bcf4c41e399" category="paragraph">Astra Trident는 Trident 노드 CR의 각 노드에 대해 활성화된 서비스를 식별합니다. 검색된 서비스를 보려면 다음을 실행합니다.</block>
  <block id="eeacf148d8ecc80cfae337218dd81f43" category="paragraph">운영 체제의 명령을 사용하여 NFS 툴을 설치합니다. 부팅 중에 NFS 서비스가 시작되었는지 확인합니다.</block>
  <block id="7b05c6f5db7b1690970d79c209e667fc" category="admonition">볼륨에 연결할 때 오류가 발생하지 않도록 NFS 툴을 설치한 후 작업자 노드를 재부팅합니다.</block>
  <block id="66ccc45f9958fe5f1a0ef0427d36d4c3" category="paragraph">Astra Trident는 iSCSI 세션을 자동으로 설정하고, LUN을 검색하고, 다중 경로 장치를 검색하고, 포맷하고, 포드에 마운트할 수 있습니다.</block>
  <block id="e81b5ef34c686914f0cc58204241cace" category="section-title">iSCSI 자동 복구 기능</block>
  <block id="f0621bdb4caa030dcd0bb9924891842e" category="paragraph">ONTAP 시스템의 경우, Astra Trident가 5분마다 iSCSI 자동 복구를 실행하여 다음을 수행합니다.</block>
  <block id="432fa9215202553559f7b2d4d10ef5ee" category="list-text">* 원하는 iSCSI 세션 상태와 현재 iSCSI 세션 상태를 식별합니다.</block>
  <block id="fdb53d548f3fa1b93129b49ad4bc7990" category="list-text">* 원하는 상태를 현재 상태와 비교 * 하여 필요한 수리를 확인합니다. Astra Trident는 수리 우선 순위 및 수리 시기를 결정합니다.</block>
  <block id="587fcf25ecbc5ff7cf19f7b1a159b5e9" category="list-text">* 현재 iSCSI 세션 상태를 원하는 iSCSI 세션 상태로 되돌리는 데 필요한 복구 수행 *</block>
  <block id="aa66c6c24f8a8540d1582c79e4534c94" category="admonition">자동 복구 작업의 로그는 에 있습니다<block ref="7883e3d8f80ff24d70c49bd975fb3f75" prefix=" " category="inline-code"></block> 각 드로포드에 있는 용기. 로그를 보려면 을(를) 설정해야 합니다<block ref="ad42f6697b035b7580e4fef93be20b4d" prefix=" " category="inline-code"></block> Astra Trident를 설치하는 동안 "참"으로 표시합니다.</block>
  <block id="0be81019f18cde342a2e6728cbcb66cc" category="paragraph">Astra Trident iSCSI 자동 복구 기능을 사용하면 다음과 같은 문제를 방지할 수 있습니다.</block>
  <block id="4b42deda281d95aafb0896a44484007a" category="list-text">네트워크 연결 문제가 발생한 후 발생할 수 있는 오래되거나 비정상적인 iSCSI 세션. 오래된 세션의 경우 Astra Trident는 로그아웃하기 7분 전에 대기하여 포털과의 연결을 다시 설정합니다.</block>
  <block id="39460cb84da78b4a87c2014972b2f901" category="admonition">예를 들어, 스토리지 컨트롤러에서 CHAP 암호를 회전시키고 네트워크에서 연결이 끊어지면 이전의 (_stale_) CHAP 암호가 지속될 수 있습니다. 자동 복구 기능은 이 문제를 인식하고 업데이트된 CHAP 암호를 적용하기 위해 세션을 자동으로 다시 설정할 수 있습니다.</block>
  <block id="9e9d382760025434fdf113f91e894cf4" category="list-text">iSCSI 세션이 누락되었습니다</block>
  <block id="3f7bf0ef305a15c68efdc95a50750bd0" category="list-text">LUN이 없습니다</block>
  <block id="15ffa30c3d1ab6322e5ff52935a86a50" category="section-title">iSCSI 도구를 설치합니다</block>
  <block id="10ff9e1b33974d06317ff739498154ce" category="paragraph">운영 체제의 명령을 사용하여 iSCSI 도구를 설치합니다.</block>
  <block id="10cb395bb5e153418168602ad95831fb" category="list-text">iSCSI PVS에서 RHEL/RedHat CoreOS를 실행하는 작업자 노드를 사용하는 경우 를 지정합니다<block ref="70f68bb2f748b85de6526bfe236ea1e9" prefix=" " category="inline-code"></block> StorageClass의 mountOption을 사용하여 인라인 공간 재확보를 수행합니다. 을 참조하십시오<block ref="166e862efdc516354d90f75a38532ddd" category="inline-link-rx"></block>.</block>
  <block id="0dfbc86ddb50cb439c7039bbf012a2b6" category="admonition">컨테이너에 볼륨을 연결할 때 오류가 발생하지 않도록 iSCSI 도구를 설치한 후 작업자 노드를 재부팅합니다.</block>
  <block id="3aa4918283a3160586bdbe1e76a338f3" category="example-title">예 4: 가상 풀 구성</block>
  <block id="baca3a42ff523348689308c7bd411b38" category="paragraph">이 백엔드 구성은 단일 파일에 여러 스토리지 풀을 정의합니다. 다양한 서비스 수준을 지원하는 여러 용량 풀이 있고 이를 나타내는 Kubernetes의 스토리지 클래스를 생성하려는 경우에 유용합니다. 가상 풀 레이블을 사용하여 에 따라 풀을 구분했습니다<block ref="c05f6c233521207f6fe311afef550c3c" prefix=" " category="inline-code"></block>.</block>
  <block id="6d0abb9b77cb1a57bf68282003ad11b9" category="list-text">모든 Kubernetes 작업자 노드에 적절한 iSCSI 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="073953144b84efd85603bb3d49521e06" category="inline-link-macro-rx"></block>.</block>
  <block id="bfd7bf04b3d28a42267e8d1b30a05f01" category="section-title">예 2: 에 대한 백엔드 및 스토리지 클래스 구성<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block> 가상 풀이 있는 드라이버</block>
  <block id="418ff75ccabac38370cc8570721746a3" category="paragraph">이 예에서는 가상 풀과 이를 다시 참조하는 StorageClasses와 함께 구성된 백엔드 정의 파일을 보여 줍니다.</block>
  <block id="d0f8c7d1b12ede190acf9656da99c079" category="paragraph">Astra Trident는 스토리지 풀에 있는 레이블을 프로비저닝할 때 백엔드 스토리지 LUN에 복사합니다. 편의를 위해 스토리지 관리자는 가상 풀 및 그룹 볼륨별로 레이블을 레이블별로 정의할 수 있습니다.</block>
  <block id="8a6b9ec0e0eb9c6a3e520af66cffd466" category="paragraph">아래 표시된 샘플 백엔드 정의 파일에서 특정 기본값은 를 설정하는 모든 스토리지 풀에 대해 설정됩니다<block ref="599dcce2998a6b40b1e38e8c6006cb0a" prefix=" " category="inline-code"></block> 실버. 가상 풀은 에 정의되어 있습니다<block ref="ddecebdea58b5f264d27f1f7909bab74" prefix=" " category="inline-code"></block> 섹션을 참조하십시오. 이 예에서는 일부 스토리지 풀이 자체 유형을 설정하고 일부 풀은 위에 설정된 기본값을 덮어씁니다.</block>
  <block id="d17a2942ee77aa1532660a5f0cf0d6e5" category="paragraph">첫 번째 StorageClass입니다 <block ref="166028d9a95f5465a6ae917e6e089ce6" prefix="(" category="inline-code"></block>)는 첫 번째 가상 풀에 매핑합니다. 이 수영장은 골드 성능을 제공하는 유일한 수영장입니다<block ref="89bf6c97f9a3eaea76c86df0086361bc" prefix=" " category="inline-code"></block> 않습니다. 마지막 StorageClass입니다 <block ref="b4457b3eeca98cadb51648f8fcef36cb" prefix="(" category="inline-code"></block>) 은 뛰어난 성능을 제공하는 스토리지 풀을 호출합니다. Astra Trident가 선택한 가상 풀을 결정하고 스토리지 요구 사항을 충족시킵니다.</block>
  <block id="7ac6994e44af62a9075fd956e72ee6fb" category="paragraph">백엔드 정의는 자격 증명이 일반 텍스트로 저장되는 유일한 위치라는 점에 유의하십시오. 백엔드가 생성된 후 사용자 이름/암호는 Base64로 인코딩되어 Kubernetes 암호로 저장됩니다. 백엔드의 생성 또는 업데이트는 자격 증명에 대한 지식이 필요한 유일한 단계입니다. 따라서 Kubernetes/스토리지 관리자가 수행할 수 있는 관리 전용 작업입니다.</block>
  <block id="35bcb7d2979b78f60085f17523608cf1" category="paragraph">Astra Trident가 CSI Provisioner로 작동하도록 구성된 경우 Kubernetes 노드 IQN이 igroup에 자동으로 추가/제거됩니다. Kubernetes 클러스터에 노드를 추가할 경우,<block ref="d9585690fd147c34fbd50c487a3520de" prefix=" " category="inline-code"></block> DemonSet가 포드를 전개합니다 <block ref="0acec1d7908eca40437167858e728fbb" prefix="(" category="inline-code"></block> 23.01 또는 이전 버전<block ref="15c091a8dab608815c71eeaab69b4bef" prefix=" " category="inline-code"></block> 23.01 이상에서)를 새로 추가한 노드에 추가하고 볼륨을 연결할 수 있는 새 노드를 등록합니다. 노드 IQN도 백엔드의 igroup에 추가됩니다. 이와 유사한 일련의 단계에서는 Kubernetes에서 노드에 코드로닝, 드레이닝 및 삭제가 발생하는 경우 IQN 제거를 처리합니다.</block>
  <block id="f94dd4e5d427f6c27039ff57630f0cac" category="list-text">에 이니시에이터 추가 관리<block ref="9d8592d88bbb76c68c01d830f091dacc" prefix=" " category="inline-code"></block> 백엔드에서 제공됩니다. 지정되지 않은 경우 이 기본값은 입니다<block ref="47cb44be55a0dffa15dfc900a4c687be" prefix=" " category="inline-code"></block>.</block>
  <block id="02ef3639dafcd40b1745b539a10d1cae" category="sidebar">23.01 릴리스에 대한 중요 정보입니다</block>
  <block id="f1fe71442cd08e74d342114df7ee1551" category="sidebar">Astra Trident를 설치합니다</block>
  <block id="46921a75e8534ad7d1c379a9e3aec033" category="sidebar">설치 개요</block>
  <block id="3183dc3907c0b67930b221a316c94cb2" category="sidebar">Trident 연산자를 사용하여 설치합니다</block>
  <block id="ca19905e19a036badc8a33897130382d" category="sidebar">Trident 연산자 수동 배포(표준)</block>
  <block id="ef39c7f15f2671234f3264999cce5679" category="sidebar">Trident 연산자 수동 배포(오프라인)</block>
  <block id="0f441bb0252fa34f85fc82a08f2db0c7" category="sidebar">Trident 제어 차트(표준) 사용</block>
  <block id="70eb578fbddf25c465d8f4886be750b7" category="sidebar">Trident 제어 차트(오프라인) 사용</block>
  <block id="71f5771dab663d80ba4dad1627e3386a" category="sidebar">업그레이드 개요</block>
  <block id="301ebdf8067a213d5a55c65fbb488290" category="sidebar">보안 권장 사항</block>
  <block id="58834b137fd6fa7a9ca23468a5c91fd6" category="sidebar">구성 준비</block>
  <block id="6fc0b7515ecca271c88eae4a685da613" category="sidebar">NetApp HCI 또는 SolidFire</block>
  <block id="60be48bb4b3314965bf50e88e7ae728c" category="sidebar">ONTAP용 Amazon FSx를 통합합니다</block>
  <block id="ea3d51fb2b16acb7cb260f25bc8965b1" category="sidebar">Astra Trident는 NetApp에서 관리하는 오픈 소스 스토리지 공급자 및 오케스트레이터입니다. Docker 및 Kubernetes에서 관리하는 컨테이너식 애플리케이션을 위한 스토리지 볼륨을 생성할 수 있습니다.</block>
  <block id="784060ce5e49eff75eaca62337b5ff53" category="list-text">Ubuntu 22.04 이상</block>
  <block id="e267c2490c7d73d0ffa909b77267cfaf" category="inline-link-macro">Astra Control 복제 사전 요구 사항</block>
  <block id="9814801b0db6e324ebd72f671418de64" category="paragraph">Astra Control은 로 생성한 볼륨을 위해 원활한 보호, 재해 복구, 이동성(Kubernetes 클러스터 간에 볼륨 이동)을 제공합니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block>,<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block>, 및<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block> 드라이버. 을 참조하십시오 <block ref="dfc981ac97be73172a3119f3b831eaf8" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="783c2760a502e1f1537de458c9dceb7a" category="list-text">를 사용해야 합니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block> 데이터 보호, 재해 복구 및 이동성을 필요로 하는 운영 워크로드에 적합합니다.</block>
  <block id="a743248a7032cdf1d468935cf180bdee" category="list-text">사용<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block> 예상되는 볼륨 사용량이 ONTAP가 지원하는 것보다 훨씬 많을 것으로 예상됩니다.</block>
  <block id="0655cc918eb576b740cfd35bbff9c8ac" category="list-text">사용<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block> 예상되는 볼륨 사용량이 ONTAP에서 지원하는 것보다 훨씬 많을 것으로 예상되는 경우에만 및 입니다<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block> 드라이버를 사용할 수 없습니다.</block>
  <block id="df7dec428425115b59101028bbebe58c" category="list-text">사용하지 마십시오<block ref="caafdf62a2c609bfa5316118231a1007" prefix=" " category="inline-code"></block> 데이터 보호, 재해 복구 또는 이동성이 필요할 것으로 예상되는 경우</block>
  <block id="f5d176b3de4662ca3603a69ab08bc166" category="paragraph">프로비저닝된 NFS 볼륨에 액세스하기 위한 NAS 옵션입니다.</block>
  <block id="053b422d907cb55ac105c173adde1080" category="paragraph">NFS를 지원합니다<block ref="1d770934d44de09b0d24f04fd01708ba" prefix=" " category="inline-code"></block> 및<block ref="4913a9178621eadcdf191db17915fbcb" prefix=" " category="inline-code"></block> 보안 스타일. 기본값은 입니다<block ref="4913a9178621eadcdf191db17915fbcb" prefix=" " category="inline-code"></block>.</block>
  <block id="69f25314e2d927ebcaa0f19c9f2a57da" category="paragraph"><block ref="4913a9178621eadcdf191db17915fbcb" prefix="" category="inline-code"></block></block>
  <block id="2bd69c3354973375e1abed3c9beb1eff" category="cell"><block ref="f777ab485270937cd9b9efc63021484f" prefix="" category="inline-code"></block></block>
  <block id="767b06b78582b463da02281e05c82e45" category="cell"><block ref="79e0f325804dafbdaef73b3b17c0fd8d" prefix="" category="inline-code"></block></block>
  <block id="11d7f0efe30199fc66cbc43c427e147d" category="cell">새로운 볼륨에 대한 보안 스타일 * 를 로 설정해야 합니다<block ref="68e98b83f5bd746f1468dff89f529d1b" prefix=" " category="inline-code"></block> 또는<block ref="1d770934d44de09b0d24f04fd01708ba" prefix=" " category="inline-code"></block> SMB 볼륨용. *</block>
  <block id="e76ea7f2be658dc914f9c95fe8d14fcf" category="cell"><block ref="68e98b83f5bd746f1468dff89f529d1b" prefix="" category="inline-code"></block> 또는<block ref="1d770934d44de09b0d24f04fd01708ba" prefix=" " category="inline-code"></block> SMB 볼륨용</block>
  <block id="375aa0b790f300787cdecf0f896b97f5" category="cell">새로운 볼륨에 대한 보안 스타일 NFS를 지원합니다<block ref="1d770934d44de09b0d24f04fd01708ba" prefix=" " category="inline-code"></block> 및<block ref="4913a9178621eadcdf191db17915fbcb" prefix=" " category="inline-code"></block> 보안 스타일. SMB 지원<block ref="1d770934d44de09b0d24f04fd01708ba" prefix=" " category="inline-code"></block> 및<block ref="68e98b83f5bd746f1468dff89f529d1b" prefix=" " category="inline-code"></block> 보안 스타일.</block>
  <block id="4a359bdcdb3ce547581bdea3ce6c5bd7" category="cell">NFS 기본값은 입니다<block ref="4913a9178621eadcdf191db17915fbcb" prefix=" " category="inline-code"></block>. SMB 기본값은 입니다<block ref="68e98b83f5bd746f1468dff89f529d1b" prefix=" " category="inline-code"></block>.</block>
  <block id="15bee4120a83692e1e575f756f0259e2" category="admonition"><block ref="ed48900d86ac476d7fed80ae1701877f" prefix="" category="inline-code"></block> SMB 볼륨을 지원하는 풀에 대한 필터입니다.<block ref="7b2498fa5e66ef102dc531d0bf5c27a4" prefix=" " category="inline-code"></block> 또는<block ref="45e1f49760c85197cd1d0fb6ee50f180" prefix=" " category="inline-code"></block> NFS 풀에 대한 필터입니다.</block>
  <block id="36b8e64fc53799e09b318940d0d01c3b" category="admonition">Astra Trident가 설치된 Kubernetes 클러스터를 1.24에서 1.25 이상으로 업그레이드하기 전에 을 참조하십시오 <block ref="b78a528fa331707807c1d5b493daab09" category="inline-link-macro-rx"></block>.</block>
  <block id="e69dee79b2104ff7c08b095e6212f492" category="list-text">Astra Trident가 설치된 Kubernetes 클러스터를 1.24에서 1.25 이상으로 업그레이드할 경우 Values.YAML을 업데이트해야 합니다<block ref="94ef2a130a825358ab3002442d6e5145" prefix=" " category="inline-code"></block> 를 선택합니다<block ref="b326b5062b2f0e69046810717534cb09" prefix=" " category="inline-code"></block> 또는 을 추가합니다<block ref="96d5d0b9a6e3e01b2ae2ed889f75d22e" prefix=" " category="inline-code"></block> 를 누릅니다<block ref="cd01e1bae83933b9c59c914bc71332ac" prefix=" " category="inline-code"></block> 명령을 먼저 실행한 후 클러스터를 업그레이드하십시오.</block>
  <block id="412b252fa44d1a73e3e7bf22113f99a2" category="listing-title">ONTAP - NAS 드라이버</block>
  <block id="b3735f022036728c24121c449da97183" category="inline-link-macro">Trident 및 CSI 이미지</block>
  <block id="c4ffea098f78924a9b9331b8f5e9c8b4" category="open-title">하나의 레지스트리에 있는 이미지</block>
  <block id="4847c552b2ff9251806e41c8fa907e19" category="open-title">다른 레지스트리의 이미지</block>
  <block id="7a958030f69f08aa24ff2b440556c305" category="summary">을 사용하여 Astra Trident를 설치할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되거나 저장되지 않은 설치에 적용됩니다.</block>
  <block id="9b809d56a3bb0caddcd0793e74d8e636" category="paragraph">을 사용하여 Astra Trident를 설치할 수 있습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block>. 이 프로세스는 Astra Trident에 필요한 컨테이너 이미지가 개인 레지스트리에 저장되거나 저장되지 않은 설치에 적용됩니다. 를 사용자 지정합니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 구축 방법은 을 참조하십시오 <block ref="8e7a26c9800a78fa0b68fb2423ba3fb4" category="inline-link-macro-rx"></block>.</block>
  <block id="7a79f435dcaa0ca2322cde1d80c13868" category="section-title">4단계: Trident 연산자를 배포합니다</block>
  <block id="579b44412770c0d6b65bc3fd9bf7c61c" category="section-title">5단계: 에서 이미지 레지스트리 위치를 업데이트합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block></block>
  <block id="d0ebde94f92d8c1bae0c6660a5847bba" category="paragraph">귀사의 <block ref="57de9a35aeedde82408b1e047030d221" category="inline-link-macro-rx"></block> 하나의 레지스트리 또는 다른 레지스트리에 있을 수 있지만 모든 CSI 이미지는 동일한 레지스트리에 있어야 합니다. 업데이트<block ref="7b4b81fb05ca7f2a09fe73526ac95482" prefix=" " category="inline-code"></block> 레지스트리 구성에 따라 추가 위치 사양을 추가하려면 다음을 수행합니다.</block>
  <block id="5295ac8fb520b71deb8a1b57857b2562" category="section-title">6단계: 을 작성합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Trident를 설치합니다</block>
  <block id="4498f168dfd139c5a90c6acd3ab09109" category="summary">PVS(Persistent Volumes)의 Kubernetes VolumeSnapshots(볼륨 스냅샷)을 생성하여 Astra Trident 볼륨의 시점 복제본을 유지할 수 있습니다. 또한 기존 볼륨 스냅샷에서 _clone_이라고도 하는 새 볼륨을 생성할 수 있습니다. 에서 볼륨 스냅샷을 지원합니다<block ref="8321592ce24c8a122ecf26a63cfca407" prefix=" " category="inline-code"></block>,<block ref="844e84da8e822b4a33c4d8188da97937" prefix=" " category="inline-code"></block>,<block ref="73a3350a1b91aeb6e2836fdf5975672c" prefix=" " category="inline-code"></block>,<block ref="3016c12c1db45f14c80c9c1731b9c26a" prefix=" " category="inline-code"></block>,<block ref="c0d2a793e71b152662b3e8cd2da00620" prefix=" " category="inline-code"></block>,<block ref="5935ea92cdd7d975b4e764b429f21c01" prefix=" " category="inline-code"></block>, 및<block ref="bc5779a2d33eeb1304bae57f15920cfc" prefix=" " category="inline-code"></block> 드라이버.</block>
  <block id="92b68d4329b2a9fc7b9ee50887fa9ec6" category="list-text">Kubernetes 1.24 이하 를 실행하는 클러스터의 경우, 를 사용합니다 <block ref="2c09ae1e37416ff80fc94f3f18fdf365" category="inline-link-macro-rx"></block>.</block>
  <block id="03b6416b48c9b688f320942620efba7e" category="list-text">Kubernetes 1.25 이상을 실행하는 클러스터의 경우 를 사용합니다 <block ref="5ca76d6130b1f129b38438a336b9aeba" category="inline-link-macro-rx"></block>.</block>
  <block id="6ec38de91afa570e5d065616a4c39792" category="admonition">클러스터 범위 연산자를 설치하면 마이그레이션이 시작됩니다<block ref="4cb15aa30ce0ec4747b372d6d2a5e637" prefix=" " category="inline-code"></block> 개체 대상<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 오브젝트, 삭제<block ref="4cb15aa30ce0ec4747b372d6d2a5e637" prefix=" " category="inline-code"></block> 개체 및<block ref="297dc4adc64c26ae2fd6a1039d00ccb0" prefix=" " category="inline-code"></block> CRD를 사용하여 Astra Trident를 사용 중인 클러스터 범위 운영자 버전으로 업그레이드합니다. 다음 예제에서 Trident는 23.01.1로 업그레이드됩니다.</block>
  <block id="612553699f2d5ae7962eb8012bc5c571" category="list-text">를 사용합니다<block ref="cd01e1bae83933b9c59c914bc71332ac" prefix=" " category="inline-code"></block> 명령 위치<block ref="66cf366135b1928fa4812c3e0e41d022" prefix=" " category="inline-code"></block> 업그레이드하려는 버전을 반영합니다.</block>
  <block id="a6074ca03f6e3e76478b45e15e021b31" category="list-text">를 실행합니다<block ref="9936810e5a43f0fece4628cd1a22fb4d" prefix=" " category="inline-code"></block> 레거시 Astra Trident 볼륨을 CSI 사양으로 업그레이드하는 명령입니다.</block>
  <block id="ea7cc85727ac6a0761c52685cce336be" category="list-text">이전 버전의 Trident로 다운그레이드하려는 경우 먼저 을 실행합니다<block ref="ac8650577d1b744589a6a11b60ac38c7" prefix=" " category="inline-code"></block> Trident를 제거하는 명령입니다. 원하는 를 다운로드합니다<block ref="f3d78353f8dac3e49bbefeb5f6a2383b" category="inline-link-rx"></block> 를 사용하여 를 설치합니다<block ref="430bf77bee6c59d385d4194f84c21b16" prefix=" " category="inline-code"></block> 명령. 새로 생성된 PVS가 없고 기존 PVS/백엔드/스토리지 클래스가 변경되지 않은 경우에만 다운그레이드를 고려하십시오. 이제 Trident는 CRD를 사용하여 상태를 유지하므로 생성된 모든 스토리지 요소(백엔드, 스토리지 클래스, PVS 및 볼륨 스냅샷)에는 가 있습니다<block ref="816158c49c5f4417bf3b0f9c644e722e" prefix=" " category="inline-code"></block> 이전의 설치된 Trident 버전에서 사용한 PV에 기록된 데이터 대신 * 이전 버전으로 되돌릴 때 새로 생성된 PVS를 사용할 수 없습니다. * * 다운그레이드 시 백엔드, PVS, 스토리지 클래스 및 볼륨 스냅샷(생성/업데이트/삭제)과 같은 객체에 대한 변경 사항은 Trident에 표시되지 않습니다 *. 설치된 Trident의 이전 버전에서 사용된 PV는 여전히 Trident에 표시됩니다. 이전 버전으로 돌아가면 업그레이드되지 않은 경우 이전 릴리즈를 사용하여 이미 생성된 PVS에 대한 액세스가 중단되지 않습니다.</block>
  <block id="1ee41f7caab6c354f41f4a101afa7e89" category="summary">Astra Trident는 NetApp에서 관리하는 오픈 소스 스토리지 공급자 및 오케스트레이터입니다. Docker 및 Kubernetes에서 관리하는 컨테이너식 애플리케이션을 위한 스토리지 볼륨을 생성할 수 있습니다. ** Astra Trident 23.01.1로 업그레이드하는 데 대한 중요 정보는 릴리스 노트를 참조하십시오.**</block>
  <block id="386e03ca533890432e529f451049f72e" category="doc">Astra Trident 23.01.1 설명서</block>
  <block id="f312617dd7f60d9446faf3c7633872e1" category="cell">"NetApp/트리덴트 - AutoSupport: 23.01"</block>
  <block id="7cbcc2cc19b88ed72e268f9d84bb67af" category="list-text">사용<block ref="0562418e6d9a76d0dd22b2f186a2203d" prefix=" " category="inline-code"></block> 배포 및 이미지 레지스트리 위치의 이름을 지정합니다. 귀사의 <block ref="57de9a35aeedde82408b1e047030d221" category="inline-link-macro-rx"></block> 하나의 레지스트리 또는 다른 레지스트리에 있을 수 있지만 모든 CSI 이미지는 동일한 레지스트리에 있어야 합니다. 예를 들어,<block ref="5035e9d03d7081c7c67f5a557f1b864f" prefix=" " category="inline-code"></block> 는 설치 중인 Astra Trident의 버전입니다.</block>
  <block id="a6427845d2f49762a708df9e6cda9fea" category="paragraph">예를 들어, 의 기본값을 변경합니다<block ref="ad42f6697b035b7580e4fef93be20b4d" prefix=" " category="inline-code"></block>에서 다음을 실행합니다<block ref="8b5806248570dbb13e7d3bc5e6c0ee37" prefix=" " category="inline-code"></block> 명령 위치<block ref="5035e9d03d7081c7c67f5a557f1b864f" prefix=" " category="inline-code"></block> 설치 중인 Astra Trident의 버전입니다.</block>
  <block id="43e6c0a141c1737a96917c56c7e22a73" category="inline-link-macro">&lt;block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category='inline-code'/&gt;를 사용하여 설치</block>
  <block id="1a2de31d648d8c09e5c2a9257a5ad67b" category="paragraph">업그레이드해야 하는 기존 배포가 있거나 배포를 사용자 지정하려는 경우 고려해야 합니다 <block ref="e214bf159dbaf6573cfe15f1373b92db" category="inline-link-macro-rx"></block>. Astra Trident를 구축하는 기존 방법입니다.</block>
  <block id="71611ffeb9c4b65c1c227f6f6840db4e" category="paragraph">인치<block ref="02f3115b006f7541a477d52ea8c0f861" prefix=" " category="inline-code"></block>, 업데이트<block ref="82a0d8d270200f472862eabbfab72b13" prefix=" " category="inline-code"></block> 이미지 레지스트리의 위치를 반영합니다. 귀사의 <block ref="57de9a35aeedde82408b1e047030d221" category="inline-link-macro-rx"></block> 하나의 레지스트리 또는 다른 레지스트리에 있을 수 있지만 모든 CSI 이미지는 동일한 레지스트리에 있어야 합니다. 예를 들면 다음과 같습니다.</block>
  <block id="938ddddcbba42304d938dc5b673d0202" category="list-text"><block ref="e76c7fdd8a19469fd094094b1b37cd96" prefix="" category="inline-code"></block> 이미지가 모두 하나의 레지스트리에 있는 경우</block>
  <block id="4072e310ea82b48de23cd7a2e5dd7f30" category="list-text"><block ref="73f61ffa3e846a43a284493b64e0b302" prefix="" category="inline-code"></block> Trident 이미지가 CSI 이미지와 다른 레지스트리에 있는 경우</block>
  <block id="3b8d0cc1623ab5e024e4c6c92a96c0a3" category="list-text">사용<block ref="0562418e6d9a76d0dd22b2f186a2203d" prefix=" " category="inline-code"></block> 다음 예제에서와 같이 배포 이름을 지정합니다<block ref="5035e9d03d7081c7c67f5a557f1b864f" prefix=" " category="inline-code"></block> 는 설치 중인 Astra Trident의 버전입니다.</block>
  <block id="5e3673cc108f69c1b1e37872c6e40a61" category="list-text">NetApp/트리덴트: 23.01.1</block>
  <block id="f4be622ffc379faa9b3471e5e49fce94" category="list-text">NetApp/트리덴트 - 운영자: 23.01.1(선택 사항)</block>
  <block id="76013b8f9b5c6b4b507fa479343e856f" category="section-title">23.01.1의 새로운 기능</block>
  <block id="19466ff921af5aa01da62b42cdaaf617" category="list-text">SPEC에 지정된 경우 설치에 IPv6 localhost를 사용하도록 고정 Trident Operator가 수정되었습니다.</block>
  <block id="5b313836498a7a26e99e4f084ee1baec" category="inline-link-macro">문제 #799</block>
  <block id="b2fc842cefdc715af09b8d184e09db56" category="list-text">번들 권한과 동기화되는 고정 Trident 운영자 클러스터 역할 권한 <block ref="25d51e363866fb30c759c73e05114b0d" category="inline-link-macro-rx"></block>.</block>
  <block id="97848233b9fe6ae43be1728a4e603020" category="list-text">외부 프로세스가 완료될 때까지 실행되도록 하는 수정 사항이 추가되었습니다.</block>
  <block id="3a35c66b59df0fa02e2490983b964261" category="list-text">rwx 모드에서 여러 노드에 원시 블록 볼륨을 연결하는 문제 해결</block>
  <block id="21b2b5bca26be7b23af4468b85c68b34" category="list-text">SMB 볼륨에 대한 FlexGroup 클론 복제 지원 및 볼륨 가져오기 수정</block>
  <block id="190a9f9a8311c8a23bff1fd7a5693342" category="section-title">23.01의 변경 사항</block>
  <block id="8b418db90259290a719e83f1a2509366" category="admonition">이제 Trident에서 Kubernetes 1.26이 지원됩니다. Kubernetes를 업그레이드하기 전에 Astra Trident를 업그레이드하십시오.</block>
  <block id="1cb76b1c7887cad1e077a4cbdc765b9b" category="list-text">Astra Trident 버전 확인:</block>
  <block id="705dbdc50888270bf4b0230d75c7ae1d" category="paragraph">Trident 운영자는 의 특성을 사용하여 Astra Trident 설치를 사용자 지정할 수 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 사양 설치를 사용자 지정하려면 다음을 선택합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 인수를 사용할 수 있습니다. 을 사용하는 것이 좋습니다<block ref="c67fd1b99934afa248dfeb285a9a4191" prefix=" " category="inline-code"></block> 필요에 따라 수정할 사용자 지정 YAML 매니페스트를 생성합니다.</block>
  <block id="a5199cf0d9f113491f9efa18f3bee2e1" category="section-title">컨트롤러 Pod 및 노드 포드 이해</block>
  <block id="f412c056318f78edc1cce01ed98e751b" category="paragraph">Astra Trident는 단일 컨트롤러 POD와 클러스터의 각 작업자 노드에 노드 POD를 더한 형태로 실행됩니다. Astra Trident 볼륨을 마운트하려는 호스트에서 노드 포드가 실행되고 있어야 합니다.</block>
  <block id="30735a308956ec6de6caa328d0d5b43b" category="inline-link-macro">노드 선택기</block>
  <block id="1db653cf6745dd1e6aa8d6e843ea5e96" category="inline-link-macro">관용과 오해</block>
  <block id="0897b2b75e3d0217c2f6994605a2cae7" category="paragraph">쿠버네티스 <block ref="219288b06ade6fd51c16efe605941441" category="inline-link-macro-rx"></block> 및 <block ref="9466cd429d8630101055a8fd14904bd9" category="inline-link-macro-rx"></block> 포드를 특정 노드 또는 기본 노드에서 실행하도록 제한하는 데 사용됩니다. ControllerPlugin과 을 사용합니다<block ref="96687552cc4dff10038a1b07a8bf3bd3" prefix=" " category="inline-code"></block>구속 조건과 덮어쓰기를 지정할 수 있습니다.</block>
  <block id="e3826c3aea0bf8502f2ba8ff27eeef19" category="list-text">컨트롤러 플러그인은 스냅샷 및 크기 조정과 같은 볼륨 프로비저닝 및 관리를 처리합니다.</block>
  <block id="361d997e700d422835e56b644784bb7e" category="list-text">노드 플러그인은 스토리지에 노드를 연결하는 작업을 처리합니다.</block>
  <block id="1736b3823517cc62395e05494b09ddb9" category="admonition"><block ref="b2c66bca748ffde67c7b6817cb8dd795" prefix="" category="inline-code"></block> 에 지정됩니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> Astra Trident가 설치된 네임스페이스를 나타냅니다. Astra Trident가 설치된 후에는 이 매개 변수 * 를 업데이트할 수 없습니다. 이렇게 하려고 하면 가 발생합니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 변경할 상태입니다<block ref="d7c8c85bf79bbe1b7188497c32c3b0ca" prefix=" " category="inline-code"></block>. Astra Trident는 네임스페이스 간에 마이그레이션되지 않습니다.</block>
  <block id="a739aa7f082abebdf65f4b114dd3ad7d" category="paragraph">이 표에 자세히 나와 있습니다<block ref="ae61bf6af1a7406b62c72a4bef1ab62d" prefix=" " category="inline-code"></block> 속성.</block>
  <block id="b520e4144a27e0f45e8e22d5ccd8328d" category="cell">Pod용 추가 노드 선택기 pod.spec.nodeSelector 과 동일한 형식을 따릅니다.</block>
  <block id="e138e2a410035dad85499a3dabe692d5" category="cell">Pod에 대한 Kubernetes 허용 설정을 재정의합니다. pod.spec.Tolerations와 같은 형식을 따릅니다.</block>
  <block id="d4cc4428c9a6422247c8ff288ea4b5eb" category="cell">Pod용 추가 노드 선택기 pod.spec.nodeSelector 과 동일한 형식을 따릅니다.</block>
  <block id="a5353a10ead2905c577659fdd805af0a" category="summary">Astra Trident가 Kubernetes 클러스터에서 실행되는 방법을 알아보십시오.</block>
  <block id="c350769115c3c8e4132e9c428b166b12" category="doc">Astra Trident 아키텍처</block>
</blocks>