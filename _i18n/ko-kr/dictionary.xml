<?xml version="1.0" encoding="UTF-8"?>
<blocks>
  <block id="ae8e28c37a725c4bb4a74663ac8615ea" category="summary">Astra Trident가 볼륨 액세스 그룹을 사용하는 방법에 대해 자세히 알아보십시오.</block>
  <block id="b4621305109716b02eed0cf25fabab13" category="doc">볼륨 액세스 그룹</block>
  <block id="33911b1eec54b4b5a7fbc504e6569989" category="inline-link">볼륨 액세스 그룹</block>
  <block id="649833006ff7b612c3d988173b6417d5" category="paragraph">Astra Trident가 사용하는 방법에 대해 자세히 알아보십시오<block ref="783dd6ea9e0b09c84db9ccd072a61c55" category="inline-link-rx"></block>.</block>
  <block id="e93c18adf30bc91499234d0ec7863499" category="admonition">CHAP를 사용하는 경우 이 섹션을 무시하십시오. CHAP는 관리를 단순화하고 아래 설명된 배율 제한을 피하는 것이 좋습니다. 또한 CSI 모드에서 Astra Trident를 사용하는 경우 이 섹션을 무시할 수 있습니다. Astra Trident는 향상된 CSI 구축 기능으로 설치된 경우 CHAP를 사용합니다.</block>
  <block id="3c56a859b413098b6bf2c54aff32a842" category="paragraph">Astra Trident는 볼륨 액세스 그룹을 사용하여 프로비저닝하는 볼륨에 대한 액세스를 제어할 수 있습니다. CHAP를 비활성화하면 구성에 하나 이상의 액세스 그룹 ID를 지정하지 않는 한 "트리덴트"라는 액세스 그룹을 찾을 수 있습니다.</block>
  <block id="025d19ee81e813e3ba40553cd4908638" category="paragraph">Astra Trident는 새 볼륨을 구성된 액세스 그룹에 연결하지만 액세스 그룹 자체를 생성하거나 관리하지 않습니다. 스토리지 백엔드를 Astra Trident에 추가하기 전에 액세스 그룹이 있어야 하며, 해당 백엔드에서 프로비저닝한 볼륨을 마운트할 수 있는 Kubernetes 클러스터의 모든 노드에서 iSCSI IQN을 포함해야 합니다. 대부분의 설치에서는 클러스터의 모든 작업자 노드를 포함합니다.</block>
  <block id="6c92285fa6d3e827b198d120ea3ac674" category="inline-link">여기</block>
  <block id="dff8ca466bae899e4dbc68c3a552033f" category="paragraph">64개 이상의 노드가 있는 Kubernetes 클러스터의 경우 다중 액세스 그룹을 사용해야 합니다. 각 액세스 그룹에는 최대 64개의 IQN이 포함될 수 있으며 각 볼륨은 4개의 액세스 그룹에 속할 수 있습니다. 최대 4개의 액세스 그룹이 구성되어 있는 경우, 클러스터의 모든 노드에서 최대 256개의 노드 크기로 모든 볼륨에 액세스할 수 있습니다. 볼륨 액세스 그룹에 대한 최신 제한은 를 참조하십시오<block ref="ac4000c3a85e5909daa6593f9f0617fd" category="inline-link-rx"></block>.</block>
  <block id="4f5254b466f691d7b0c50fb0d8286075" category="paragraph">기본 '트리덴트' 액세스 그룹을 사용하는 설정을 다른 액세스 그룹에도 사용하는 설정으로 수정하는 경우 목록에 '트리덴트' 액세스 그룹의 ID를 포함합니다.</block>
  <block id="4d5445eb6c70cdab8d3ad5e71367f42a" category="summary">Astra Trident가 드라이버를 위한 볼륨 스냅샷 생성을 어떻게 처리하는지 자세히 알아보십시오.</block>
  <block id="e9c3828cd06711f9036bb4ce862a32c5" category="doc">볼륨 스냅숏</block>
  <block id="4fb7e6ff3b63c56522fdea39e41d701e" category="list-text">ONTAP-NAS, ONTAP-SAN, AWS-CV, GCP-CV, Azure-NetApp-파일 드라이버의 경우, 각 PV(영구 볼륨)는 FlexVol에 매핑됩니다. 따라서 볼륨 스냅샷이 NetApp 스냅샷으로 생성됩니다. NetApp의 스냅샷 기술은 경쟁 스냅샷 기술보다 뛰어난 안정성, 확장성, 복구 가능성 및 성능을 제공합니다. 이러한 스냅샷 복사본은 생성하는 데 필요한 시간과 스토리지 공간 모두에서 매우 효율적입니다.</block>
  <block id="98c670ffe759cc20cd8a31d49bd0b4fc" category="list-text">'ONTAP-SAN-이코노미' 드라이버의 경우 PVS는 공유된 FlexVol에 매핑됩니다. PVS의 볼륨 스냅샷은 연결된 LUN의 FlexClone을 수행하여 구현됩니다. ONTAP의 FlexClone 기술을 사용하면 최대 규모의 데이터 세트의 복사본을 거의 즉시 생성할 수 있습니다. 복사본은 데이터 블록을 부모님과 공유하므로 메타데이터에 필요한 것만 빼고 스토리지를 사용하지 않습니다.</block>
  <block id="9dbabbadda024bb7b1d0db43ab31b45f" category="list-text">'솔라이드산' 드라이버의 경우, 각 PV는 NetApp Element 소프트웨어/NetApp HCI 클러스터에서 생성된 LUN에 매핑됩니다. 볼륨 스냅샷은 기본 LUN의 요소 스냅샷으로 표시됩니다. 이러한 스냅샷은 특정 시점 복제본이며 소량의 시스템 리소스와 공간만 차지합니다.</block>
  <block id="34f731018ae783f70901b14b4950c3a7" category="list-text">ONTAP-NAS와 ONTAP-SAN 드라이버를 함께 사용할 경우 ONTAP 스냅샷은 FlexVol의 시점 복사본으로 FlexVol 자체의 공간을 사용합니다. 따라서 스냅샷이 생성/예약될 때 시간이 경과함에 따라 볼륨의 쓰기 가능한 공간이 줄어들 수 있습니다. 이 문제를 해결하는 간단한 방법 중 하나는 Kubernetes를 통해 크기를 조정하여 볼륨을 늘리는 것입니다. 또 다른 옵션은 더 이상 필요하지 않은 스냅샷을 삭제하는 것입니다. Kubernetes를 통해 생성된 VolumeSnapshot이 삭제되면 Astra Trident가 연결된 ONTAP 스냅샷을 삭제합니다. Kubernetes를 통해 생성되지 않은 ONTAP 스냅샷도 삭제할 수 있습니다.</block>
  <block id="1eb824f8d9b30b3f4e089938e719fefe" category="paragraph">Astra Trident를 사용하면 VolumeSnapshots을 사용하여 새 PVS를 생성할 수 있습니다. 이러한 스냅샷에서 PVS를 생성하는 작업은 지원되는 ONTAP 및 CVS 백엔드에 FlexClone 기술을 사용하여 수행됩니다. 스냅샷으로부터 PV를 생성할 때, 백업 볼륨은 스냅샷의 상위 볼륨의 FlexClone입니다. '솔드파이어-SAN' 드라이버는 Element 소프트웨어 볼륨 클론을 사용하여 스냅샷에서 PVS를 생성합니다. 여기서 Element 스냅샷으로부터 클론을 생성합니다.</block>
  <block id="d00888bc1409d1c598b90af117bd3551" category="summary">Astra Trident의 프로비저닝에는 두 가지 주요 단계가 있습니다. 첫 번째 단계에서는 스토리지 클래스를 적절한 백엔드 스토리지 풀 세트와 연결하고 용량 할당 전에 필요한 준비 작업으로 수행됩니다. 두 번째 단계에서는 볼륨 생성 자체를 포함하며 보류 중인 볼륨의 스토리지 클래스와 연결된 스토리지 풀에서 스토리지 풀을 선택해야 합니다.</block>
  <block id="89c3bcf0ecc1114f8d19734d9156cb40" category="doc">프로비저닝</block>
  <block id="2bd42f922a8c0b54b90557eba2071a76" category="paragraph">백엔드 스토리지 풀을 스토리지 클래스와 연결하려면 스토리지 클래스의 요청된 속성과 해당 'toragePools', 'additionalStoragePools' 및 'excludeStoragePools' 목록이 모두 필요합니다. 스토리지 클래스를 생성할 때 Trident는 각 백엔드에서 제공하는 특성과 풀을 스토리지 클래스에서 요청한 속성과 비교합니다. 스토리지 풀의 속성과 이름이 요청된 모든 속성 및 풀 이름과 일치하면 Astra Trident는 해당 스토리지 클래스에 적합한 스토리지 풀 세트에 해당 스토리지 풀을 추가합니다. 또한 Astra Trident는 "additionalStoragePools" 목록에 나열된 모든 스토리지 풀을 해당 집합에 추가합니다. 이는 특성이 스토리지 클래스의 요청된 속성 중 일부 또는 전부를 충족하지 못하는 경우에도 마찬가지입니다. 스토리지 클래스에 사용할 스토리지 풀을 재정의하고 제거하려면 'excludeStoragePools' 목록을 사용해야 합니다. Astra Trident는 새 백엔드를 추가할 때마다 유사한 프로세스를 수행하여 스토리지 풀이 기존 스토리지 클래스의 풀을 충족하는지 확인하고 제외로 표시된 항목을 제거합니다.</block>
  <block id="668ccb4dd1c284f07a3062637c57d21a" category="paragraph">그런 다음 Astra Trident는 스토리지 클래스와 스토리지 풀 간의 연결을 사용하여 볼륨을 프로비저닝할 위치를 결정합니다. 볼륨을 생성할 때 Astra Trident는 먼저 해당 볼륨의 스토리지 클래스에 대한 스토리지 풀 세트를 가져옵니다. 볼륨의 프로토콜을 지정한 경우 Astra Trident는 요청된 프로토콜을 제공할 수 없는 스토리지 풀을 제거합니다(예: NetApp HCI/SolidFire 백엔드는 파일 기반 볼륨을 제공할 수 없고 ONTAP NAS 백엔드는 블록 기반 볼륨을 제공할 수 없음). Astra Trident는 이 결과 집합의 순서를 무작위로 생성하여 볼륨을 균일하게 분산시킨 다음 이를 반복함으로써 각 스토리지 풀에서 볼륨을 차례로 프로비저닝합니다. 이 오류가 1에서 성공하면 프로세스에서 발생한 모든 오류를 로깅하여 성공적으로 반환됩니다. Astra Trident는 * 요청된 스토리지 클래스 및 프로토콜에 대해 사용 가능한 모든 * 스토리지 풀을 프로비저닝하지 못한 경우에만 실패 * 를 반환합니다.</block>
  <block id="8a7354f894ef62fb3f076510315bf206" category="doc">Astra Trident 소개</block>
  <block id="7c738d9c13e4e5770c6b455ab345afd7" category="paragraph">또한 Astra Trident는 NetApp Astra의 기본 기술로서 스냅샷, 백업, 복제 및 복제를 위한 NetApp의 업계 최고 데이터 관리 기술을 활용하여 Kubernetes 워크로드의 데이터 보호, 재해 복구, 이동성 및 마이그레이션 사용 사례를 다룹니다.</block>
  <block id="4bd05efa612e48dd723de2bdd29f88e2" category="section-title">지원되는 Kubernetes 클러스터 아키텍처</block>
  <block id="85b179f2c10f76f0171b4d9d3f2d5171" category="paragraph">Astra Trident는 다음 Kubernetes 아키텍처에서 지원됩니다.</block>
  <block id="c91cda04d3ac5ae2da327d347d4bbefe" category="cell">Kubernetes 클러스터 아키텍처</block>
  <block id="eaa4dc5078017a5c5bebf383ab6f5124" category="cell">지원</block>
  <block id="c0057eecd4b1a67d11dc801b8992a574" category="cell">기본 설치</block>
  <block id="0c69c79a8788e0e4572d0c4838e69401" category="cell">단일 마스터, 컴퓨팅</block>
  <block id="93cba07454f06a4a960172bbd6e2a435" category="cell">예</block>
  <block id="d41d8cd98f00b204e9800998ecf8427e" category="doc"></block>
  <block id="1fc3441370ae575a64d605fcd15a05fd" category="cell">다중 마스터, 컴퓨팅</block>
  <block id="7cb2eb9488f3532834f7ef233ae894dd" category="cell">마스터, "etcd", 컴퓨팅</block>
  <block id="5e5f49db20e29f6377e57e98932dae57" category="cell">마스터, 인프라, 컴퓨팅</block>
  <block id="ae663d0d321764bd88b8d864cd3afc9e" category="section-title">아스트라(Astra)란?</block>
  <block id="dd91e88f9a6ec30684f494c41baeeee0" category="paragraph">Astra를 사용하면 퍼블릭 클라우드와 온프레미스 모두에서 Kubernetes에서 실행되는 데이터 기반의 컨테이너 워크로드를 손쉽게 관리, 보호 및 이동할 수 있습니다. Astra는 퍼블릭 클라우드 및 온프레미스에 있는 NetApp의 검증되고 광범위한 스토리지 포트폴리오의 Astra Trident를 사용하여 영구 컨테이너 스토리지를 프로비저닝하고 제공합니다. 또한, 스냅샷, 백업 및 복원, 활동 로그, 데이터 보호, 재해/데이터 복구, 데이터 감사, Kubernetes 워크로드의 마이그레이션 사용 사례를 위한 액티브 클론 복제와 같은 풍부한 고급 애플리케이션 인식 데이터 관리 기능을 제공합니다.</block>
  <block id="02030c8e07c049062fbbba9a32b01067" category="summary">가상 스토리지 풀은 Astra Trident의 스토리지 백엔드와 Kubernetes 스토리지 풀 간의 추상화 계층을 제공합니다. 관리자는 StorageClass를 만들지 않고도 각 백엔드에 대한 위치, 성능 및 보호와 같은 측면을 백엔드에 관계없이 공통된 방식으로 정의할 수 있습니다. 원하는 기준을 충족하는 데 사용할 물리적 백엔드, 백엔드 풀 또는 백엔드 유형을 지정할 수 있습니다.</block>
  <block id="9f802733184b3e0fb080eddcf9ffeaef" category="doc">가상 스토리지 풀</block>
  <block id="9f4406586d4a2343f2a5289e16131b3e" category="paragraph">가상 스토리지 풀은 Astra Trident의 스토리지 백엔드와 Kubernetes의 'storageClades' 간의 추상화 계층을 제공합니다. 관리자는 'torageClass'를 만들지 않고 각 백엔드에 대한 위치, 성능 및 보호와 같은 측면을 일반적인 백엔드 방식으로 정의할 수 있으므로 원하는 기준을 충족하는 데 사용할 물리적 백엔드, 백엔드 풀 또는 백엔드 유형을 지정할 수 있습니다.</block>
  <block id="a4ff8f21d8d1ba289de3b08d19afbeab" category="paragraph">스토리지 관리자는 Astra Trident 백엔드의 가상 스토리지 풀을 JSON 또는 YAML 정의 파일로 정의할 수 있습니다.</block>
  <block id="1c65ff50dcc9738f0ae4169e4f66589c" category="image-alt">에는 가상 스토리지 풀의 개념적 다이어그램이 나와 있습니다.</block>
  <block id="2a778cf7220cdde142651975e1bcd90f" category="paragraph">가상 풀 목록 외부에서 지정된 모든 측면은 백엔드에 대해 전역적이며 모든 가상 풀에 적용되지만, 각 가상 풀은 하나 이상의 측면을 개별적으로 지정할 수 있습니다(백엔드-글로벌 측면 재정의).</block>
  <block id="6aefc2a02fa1ec1f6ac8e9dbd5104efe" category="admonition">가상 스토리지 풀을 정의할 때 백엔드 정의에서 기존 가상 풀의 순서를 재정렬하지 마십시오. 또한 기존 가상 풀의 속성을 편집/수정하고 대신 새 가상 풀을 정의하는 것이 좋습니다.</block>
  <block id="5a53576f0ba98311e845ad0243bed6b7" category="paragraph">대부분의 측면은 백엔드 관련 용어로 지정됩니다. 결정적으로, 종횡값은 백엔드 드라이버의 외부에 노출되지 않으며 'torageClaes'에서 일치시킬 수 없습니다. 대신 관리자는 각 가상 풀에 대해 하나 이상의 레이블을 정의합니다. 각 레이블은 키, 즉 값 쌍이며 레이블은 고유한 백엔드에서 공통일 수 있습니다. 측면과 마찬가지로 레이블을 풀별로 지정하거나 백엔드에 대해 전역으로 지정할 수 있습니다. 미리 정의된 이름과 값이 있는 측면과 달리 관리자는 필요에 따라 레이블 키와 값을 정의할 수 있습니다.</block>
  <block id="a4d6bfb65b6541e04772c0d5180e726e" category="paragraph">'torageClass'는 선택기 매개 변수 내의 레이블을 참조하여 사용할 가상 풀을 식별합니다. 가상 풀 선택기는 6개의 연산자를 지원합니다.</block>
  <block id="e1b3ec89ead7f83a9245ed5c9cacfdbf" category="cell">운영자</block>
  <block id="0a52730597fb4ffa01fc117d9e71e3a9" category="cell">예</block>
  <block id="b5a7adde1af5c87d7fd797b6245c2a39" category="cell">설명</block>
  <block id="499badcb6f450c7f46c51d873eb84286" category="cell">`='</block>
  <block id="354653142ec321459dfd6d71444e992e" category="cell">성능 = 프리미엄</block>
  <block id="d2c49c25d96d87e40bc641b9d5302b36" category="cell">풀의 레이블 값이 일치해야 합니다</block>
  <block id="5a5292b0a0d0379f0f1b12801b09b266" category="cell">`!='</block>
  <block id="eccde6822783bd75209c9b6a2d357f6c" category="cell">성능!=최고</block>
  <block id="2944853a5f146abd2671adbecd5c25a3" category="cell">풀의 레이블 값이 일치하지 않아야 합니다</block>
  <block id="ae2bef277194f73d24a36a78009aac1e" category="cell">"IN"입니다</block>
  <block id="f8cf8c23afb5459dbf7c24b685caf85b" category="cell">위치(동쪽, 서쪽)</block>
  <block id="26aac934d614b1b3e5db46d8fc664ec6" category="cell">풀의 레이블 값은 값 집합에 있어야 합니다</block>
  <block id="1a031eecbce49366e550273b9321b909" category="cell">노신입니다</block>
  <block id="b5585f3f9b45f391fee5dd15e6516450" category="cell">성능 노트(실버, 브론즈)</block>
  <block id="499fec8ad2646f2de982559111e26a4c" category="cell">풀의 레이블 값은 b가 아니어야 합니다</block>
  <block id="48dec026afe488df8faca35c5c3a39ea" category="summary">Trident 설치에서 Element 백엔드를 만들고 사용하는 방법에 대해 알아보십시오.</block>
  <block id="f58e95baa778c9a2bd1a4597fb49d9b7" category="doc">ONTAP 드라이버</block>
  <block id="0e842f431ce1b4dfb57598e5682e3adc" category="paragraph">Astra Trident는 ONTAP 클러스터와 통신할 수 있도록 5개의 고유한 ONTAP 스토리지 드라이버를 제공합니다. 각 드라이버가 볼륨 생성, 액세스 제어 및 해당 기능을 처리하는 방법에 대해 자세히 알아보십시오.</block>
  <block id="48cf24486d9a8e65a142b25682f19949" category="cell">드라이버</block>
  <block id="888a77f5ac0748b6c8001822417df8b6" category="cell">프로토콜</block>
  <block id="1b5e109e8afd1f9b7f5bbf951eea3442" category="cell">볼륨 모드</block>
  <block id="d5e2d9f8d8f10044e38b71b49e675d2e" category="cell">액세스 모드가 지원됩니다</block>
  <block id="15971126972a002fcddb2c507534e371" category="cell">지원되는 파일 시스템</block>
  <block id="00055dac2ba112b87a95a368075b9561" category="cell">'ONTAP-NAS'</block>
  <block id="1d1a594959ec615f56516f5d0f5e8ddb" category="paragraph">NFS 를 참조하십시오</block>
  <block id="ac52cf637478f3656a1fdee5c02324fd" category="paragraph">파일 시스템</block>
  <block id="0d3a79885df431b0b67b50b9479e2fee" category="paragraph">RWO, rwx, ROX</block>
  <block id="9f47e55b538b64923f2ee8c19bc6887a" category="paragraph">"", NFS</block>
  <block id="cecdaed309330a9e7dea16b2076957ee" category="cell">ONTAP-NAS-이코노미</block>
  <block id="2b8ac774302bd45e0ad531e434d8cd6d" category="cell">'ONTAP-NAS-Flexgroup'</block>
  <block id="cd17e7ed84c40a0ff5ecb8b625b1f186" category="cell">'ONTAP-SAN'</block>
  <block id="e4e1c13bb0b14f6cb7608cbecea948ef" category="paragraph">iSCSI</block>
  <block id="e1e4c8c9ccd9fc39c391da4bcd093fb2" category="paragraph">블록</block>
  <block id="aa91b58ced7ef060eb0e27ac4e1d18a8" category="paragraph">RWO, ROX, rwx</block>
  <block id="bc2e0aeb951ff36e6703a1ff5419eb02" category="paragraph">파일 시스템이 없습니다. 원시 블록 장치</block>
  <block id="0b86d82002caac6130185da4ef1be67e" category="paragraph">RWO, ROX</block>
  <block id="a029cca698cbf05f07897f86c43cf9e8" category="paragraph">xfs, ext3, ext4</block>
  <block id="73b781a615cea2647a87ff2035e296b1" category="cell">ONTAP-SAN-이코노미</block>
  <block id="4ff78ba07210a8b4db65f6ef62b4e1b4" category="admonition">ONTAP 백엔드는 보안 역할(사용자 이름/암호)에 대한 로그인 자격 증명을 사용하거나 ONTAP 클러스터에 설치된 개인 키와 인증서를 사용하여 인증할 수 있습니다. tridentctl 업데이트 백엔드를 사용하여 기존 백엔드를 업데이트하여 인증 모드 간에 이동할 수 있습니다.</block>
  <block id="1e209c07680392db2505687941188c9f" category="summary">Astra Trident의 이전 버전으로 다운그레이드하는 데 필요한 단계에 대해 알아보십시오.</block>
  <block id="9b51b245233e60555d569a43ebaa1b8d" category="doc">Astra Trident를 다운그레이드하십시오</block>
  <block id="f58ee9343b12a3276981187a42480ba7" category="paragraph">다음과 같은 다양한 이유로 다운그레이드를 고려할 수 있습니다.</block>
  <block id="e930f1fff9365ca35f55f1e61bef69a9" category="list-text">비상 계획</block>
  <block id="235115784feaabab0df1d64a2019b176" category="list-text">업그레이드로 인해 발견된 버그를 즉시 수정합니다</block>
  <block id="41768ab308324d6b4a49e2e225427666" category="list-text">종속성 문제, 실패 및 불완전한 업그레이드</block>
  <block id="9bb6c30b6b6e3a9fbbd83b458a3556eb" category="section-title">다운그레이드 시점</block>
  <block id="97442cfde1061a7c844e8d4c06f79720" category="paragraph">CRD를 사용하는 Astra Trident 릴리즈로 이전할 때는 다운그레이드를 고려해야 합니다. Astra Trident는 이제 CRD를 사용하여 상태를 유지하기 때문에 생성된 모든 스토리지 요소(백엔드, 스토리지 클래스, PV 및 볼륨 스냅샷)는 '삼등급' PV에 기록된 데이터 대신 CRD 객체를 연결합니다(이전 버전의 Astra Trident에서 사용). 새로 생성된 PVS, 백엔드 및 스토리지 클래스는 모두 CRD 객체로 유지됩니다. 다운그레이드가 필요한 경우 CRD를 사용하여 실행되는 Astra Trident 버전(19.07 이상)에만 다운그레이드를 시도해야 합니다. 이는 다운그레이드가 발생한 후 현재 Astra Trident 릴리스에 대해 수행된 모든 작업을 볼 수 있도록 하기 위한 것입니다.</block>
  <block id="cb4d3c8706ed4dd2a49a007f19e8b30a" category="section-title">다운그레이드를 하지 않는 경우</block>
  <block id="7be40d1b43eccf7d81bd7ad70a7cee5b" category="paragraph">상태를 유지하기 위해 "etcd"를 사용하는 Trident 릴리스로 다운그레이드하면 안 됩니다(19.04 이하). 현재 Astra Trident 릴리즈를 통해 수행된 모든 작업은 다운그레이드 후 반영되지 않습니다. 새로 생성된 PVS는 이전 버전으로 되돌릴 때 사용할 수 없습니다. 이전 버전으로 돌아갈 때 Astra Trident에서 백엔드, PVS, 스토리지 클래스 및 볼륨 스냅샷(생성/업데이트/삭제)과 같은 객체에 대한 변경 사항을 볼 수 없습니다. 이전 버전으로 돌아가도 업그레이드되지 않은 경우 이전 릴리즈를 사용하여 이미 생성된 PVS에 대한 액세스가 중단되지 않습니다.</block>
  <block id="716e6c4d72b03c2b5b4503d5e968e654" category="section-title">운영자를 통해 Astra Trident가 설치된 경우의 다운그레이드 프로세스</block>
  <block id="286ac65245e7b7508f3cdf1dea1c60eb" category="paragraph">Trident 연산자를 사용하여 설치한 경우 다운그레이드 프로세스가 다르며 "tridentctl"을 사용할 필요가 없습니다.</block>
  <block id="41cc548b7b7993679e555423a014ca5c" category="paragraph">Trident 연산자를 사용하여 설치한 경우 Astra Trident를 다음 중 하나로 다운그레이드할 수 있습니다.</block>
  <block id="c3d92c281c17e41ffac420b45790ecbf" category="list-text">네임스페이스 범위 연산자를 사용하여 설치된 버전(20.07-20.10).</block>
  <block id="69f5b5f7aa4a5f07267b9c758e2580e6" category="list-text">클러스터 범위 연산자(21.01 이상)를 사용하여 설치된 버전입니다.</block>
  <block id="0d8778040c29d89141a733b060314da3" category="section-title">클러스터 범위 연산자로 다운그레이드</block>
  <block id="12a3bd4ff105bed8650ca128636a078f" category="paragraph">Astra Trident를 클러스터 범위 운영자를 사용하는 릴리즈로 다운그레이드하려면 아래에 설명된 단계를 따르십시오.</block>
  <block id="f3a29486bed19a90f2da6d007818b427" category="list-title">단계</block>
  <block id="43f17763173fe230bdd78477152f5f7d" category="inline-link-macro">Astra Trident를 제거합니다</block>
  <block id="f472e2d2602fec8483b064616fa5f543" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>. ** 기존 설치를 완전히 제거하지 않는 한 CRD를 휘두리지 마십시오.**</block>
  <block id="3864c0c37bf26f8a7686e5c04435974c" category="inline-link">Trident Hub 저장소</block>
  <block id="78a26b79451266c6562d8d11cdb86ad0" category="list-text">클러스터 범위 연산자를 삭제합니다. 이렇게 하려면 연산자를 배포하는 데 사용되는 매니페스트가 필요합니다. 에서 구할 수 있습니다<block ref="08fa9926a4347665a77bd7911809a1ce" category="inline-link-rx"></block>. 필요한 분기를 사용해야 합니다.</block>
  <block id="44d9737dc7f423d188a4b34663c5f06e" category="list-text">원하는 버전의 Astra Trident를 설치하여 다운그레이드를 계속합니다. 원하는 릴리스에 대한 설명서를 따릅니다.</block>
  <block id="0e792058c21e7156d25e8ae8f2d784a0" category="section-title">네임스페이스 범위 연산자로 다운그레이드합니다</block>
  <block id="8ad79c030a4ebdd2f446157ba529561e" category="paragraph">이 섹션에서는 네임스페이스 범위 연산자를 사용하여 설치되는 20.07 ~ 20.10 범위의 Astra Trident 릴리스로 다운그레이드하는 단계를 요약합니다.</block>
  <block id="a7c80f52f9be4831ca776b56dc642a45" category="list-text"><block ref="e6c6ebb45af4a1845e181c2b5544dbb0" category="inline-link-macro-rx"></block>. ** 기존 설치를 완전히 제거하려는 경우가 아니면 CRD를 휘두리지 마십시오. ** 트라이덴오케스트레이터(trident오케스트레이터)가 삭제되었는지 확인합니다.</block>
  <block id="141ed8ae2dd3c3efac0c25f12b058c87" category="list-text">클러스터 범위 연산자를 삭제합니다. 이렇게 하려면 연산자를 배포하는 데 사용되는 매니페스트가 필요합니다. 여기에서 얻을 수 있습니다<block ref="08fa9926a4347665a77bd7911809a1ce" category="inline-link-rx"></block>. 필요한 분기를 사용해야 합니다.</block>
  <block id="2389eabedca3341193952356ec53cd0c" category="list-text">트라이덴오케스트레이터 CRD를 삭제한다.</block>
  <block id="2982be9f91f77222d75873452bfc7696" category="paragraph">Astra Trident가 제거되었습니다.</block>
  <block id="0f46a51f24c3700da8c74b9a5294a22f" category="list-text">원하는 버전을 설치하여 다운그레이드를 계속합니다. 원하는 릴리스에 대한 설명서를 따릅니다.</block>
  <block id="5f7d982e216126a476d4ca0051837e2a" category="section-title">H제어 를 사용하여 다운그레이드합니다</block>
  <block id="fe0182349853dde39c65151b592bc343" category="paragraph">다운그레이드하려면 'helm rollback' 명령을 사용합니다. 다음 예를 참조하십시오.</block>
  <block id="6506fb901be776a97bf61f4f21fb84ce" category="section-title">tridentctl을 사용하여 Astra Trident가 설치된 경우의 다운그레이드 프로세스</block>
  <block id="d1008d4e2b1eb300375d48496c96e8b0" category="paragraph">'tridentctl'을 사용하여 Astra Trident를 설치한 경우 다운그레이드 프로세스는 다음 단계를 포함합니다. 이 시퀀스는 Astra Trident 21.07에서 20.07로 이동하는 다운그레이드 프로세스를 안내합니다.</block>
  <block id="e08f959c89cb36ec887089ce4a7c1bcc" category="admonition">다운그레이드를 시작하기 전에 Kubernetes 클러스터의 "etcd"에 대한 스냅샷을 만들어야 합니다. 이를 통해 Astra Trident의 CRD의 현재 상태를 백업할 수 있습니다.</block>
  <block id="e36e921de70428b33bb0e5c22f4f1d03" category="list-text">tridentctl을 사용하여 Trident가 설치되었는지 확인합니다. Astra Trident의 설치 방법을 잘 모르는 경우 다음 간단한 테스트를 실행하십시오.</block>
  <block id="d7c7b52356c18ead4409ef4ca7e2eac8" category="list-text">Trident 네임스페이스에 있는 포드를 나열합니다.</block>
  <block id="225b7f623c2562a1ed24395fd3852b70" category="list-text">클러스터에서 실행 중인 Astra Trident의 버전을 확인합니다. tridentctl을 사용하거나 Trident 포드에 사용된 이미지를 볼 수 있습니다.</block>
  <block id="46da6852e307b4f4a0e965c9c18fe576" category="list-text">"tridentOrchestrator", (또는) "trident-operator-xxxxxxxxxx-xxxxx"라는 이름의 포드가 표시되지 않으면 * "tridentctl"과 함께 Astra Trident * 가 설치됩니다.</block>
  <block id="72b739b65841b5d903e9ec216f0c4fd1" category="list-text">기존 'tridentctl' 바이너리를 사용하여 Astra Trident를 제거합니다. 이 경우 21.07 바이너리로 를 제거합니다.</block>
  <block id="6445365d100b18e233ebf2d08d116aee" category="inline-link-macro">맞춤형 설치</block>
  <block id="ca35ad40c102410833ee6b7227e3cfcc" category="list-text">이 작업이 완료되면 원하는 버전의 Trident 바이너리(이 예: 20.07)를 얻고 이를 사용하여 Astra Trident를 설치합니다. 에 대한 사용자 지정 YAML을 생성할 수 있습니다 <block ref="e519c8a747d0bcd553094af015469d7d" category="inline-link-macro-rx"></block> 필요한 경우</block>
  <block id="03347682a0c8323a17a17933bbf4e18c" category="paragraph">다운그레이드 프로세스가 완료되었습니다.</block>
  <block id="f71fd95d4de4797557e6830c1448c945" category="summary">tridentctl을 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다.</block>
  <block id="2a21586f7990f8cb0f8951cd2ef7bc3b" category="doc">tridentctl로 업그레이드하십시오</block>
  <block id="6224e22d5a77816dd8b659c25a3f88a5" category="paragraph">Astra Trident의 최신 릴리즈로 업그레이드할 때 다음 사항을 고려하십시오.</block>
  <block id="98c7e2ecbd5f5a638272ee366b25b6a1" category="inline-link">볼륨 스냅숏</block>
  <block id="8f9f7d64f0943a9bec25cdd7b786022a" category="list-text">Trident 20.01부터 베타 릴리즈만 제공됩니다<block ref="0b290b7ed02de23dc49888d0fa4fc114" category="inline-link-rx"></block> 가 지원됩니다. Kubernetes 관리자는 알파 스냅샷 개체를 베타로 안전하게 백업하거나 변환하여 레거시 알파 스냅샷을 유지하도록 주의해야 합니다.</block>
  <block id="ec35126af255fdfac3b9a8e16e971389" category="list-text">볼륨 스냅샷의 베타 릴리스에는 수정된 CRD 세트와 스냅샷 컨트롤러가 도입되며, 이 두 가지 모두 Astra Trident를 설치하기 전에 설정해야 합니다.</block>
  <block id="a4155944ba4eeb0c41401ab7bb85d3d9" category="inline-link">블로그입니다</block>
  <block id="06f3d92245489ff0e9444c95095ed61b" category="admonition"><block ref="d0e35df46eec7926f0d8844193807dad" category="inline-link-rx"></block> 알파 볼륨 스냅샷을 베타 형식으로 마이그레이션하는 단계에 대해 설명합니다.</block>
  <block id="4ff0a9f6065b24ce3d325bad3223f4e2" category="paragraph">Astra Trident를 제거하고 다시 설치하면 업그레이드 역할을 합니다. Trident를 제거할 때 Astra Trident 배포에 사용되는 영구 볼륨 클레임(PVC) 및 영구 볼륨(PV)은 삭제되지 않습니다. 이미 프로비저닝된 PVS는 Astra Trident가 오프라인 상태인 동안 계속 사용할 수 있으며, Astra Trident는 다시 온라인 상태가 되면 중간 기간 동안 생성된 모든 PVC에 대해 볼륨을 프로비저닝합니다.</block>
  <block id="398a8bf92020ed0b4edb1445d1380971" category="admonition">Astra Trident를 업그레이드할 때 업그레이드 프로세스를 중단하지 마십시오. 설치 프로그램이 완료될 때까지 실행되는지 확인합니다.</block>
  <block id="068051b0ea15e91fd236b514c8b35ffe" category="section-title">업그레이드 후 다음 단계</block>
  <block id="ba79ef627bc5ee010211ca922024f9e4" category="paragraph">새로운 Trident 릴리즈(예: 주문형 볼륨 스냅샷)에서 사용할 수 있는 다양한 기능을 사용하려면 "tridentctl upgrade" 명령을 사용하여 볼륨을 업그레이드할 수 있습니다.</block>
  <block id="1f97048c5a9c81e85e588044b15b51c8" category="paragraph">레거시 볼륨이 있는 경우 Astra Trident의 새로운 기능 세트를 모두 사용하려면 NFS/iSCSI 유형에서 CSI 유형으로 업그레이드해야 합니다. Trident에서 프로비저닝한 레거시 PV는 기존 기능 세트를 지원합니다.</block>
  <block id="aae0cab55b3d14012cfc61ef5ad46105" category="paragraph">볼륨을 CSI 유형으로 업그레이드하기로 결정할 때 다음 사항을 고려하십시오.</block>
  <block id="9407b572db9501134ce92167448428fb" category="list-text">모든 볼륨을 업그레이드할 필요는 없습니다. 이전에 생성된 볼륨은 계속 액세스할 수 있으며 정상적으로 작동합니다.</block>
  <block id="35127b2fd7c387c56305575dfafe2a97" category="list-text">업그레이드할 때 배포/StatefulSet 의 일부로 PV를 마운트할 수 있습니다. deployment/StatefulSet 을 아래로 가져올 필요는 없습니다.</block>
  <block id="260eeb1b0c4ec05a9788dc485ed03d36" category="list-text">업그레이드 시 독립 실행형 POD에 PV를 * 첨부할 수 없습니다. 볼륨을 업그레이드하기 전에 포드를 종료해야 합니다.</block>
  <block id="2d59c3aee4c9fe757980153c65e922d0" category="list-text">PVC에 바인딩된 볼륨만 업그레이드할 수 있습니다. PVC에 바인딩되지 않은 용적은 업그레이드 전에 제거 및 가져와야 합니다.</block>
  <block id="f2e9d80774fbee2a6152ad9c7db8e0ee" category="section-title">볼륨 업그레이드의 예</block>
  <block id="eff342caa8bb47fc3653d7b149aa91d4" category="paragraph">다음은 볼륨 업그레이드를 수행하는 방법을 보여 주는 예입니다.</block>
  <block id="fbc477673a43a428e429fe6902c6e36a" category="list-text">KUBectl Get PV를 실행하여 PVS를 나열합니다.</block>
  <block id="09d5f690bff68f8b4ffeeed3dac1f534" category="paragraph">현재 Trident 20.07에 의해 'NetApp.IO/트리덴트'를 사용하여 PVS를 4개 생성했습니다.</block>
  <block id="581ee670123fe76ff75275867ef06bcc" category="list-text">PV에 대한 자세한 내용을 보려면 kubeck tl t설명해 PV를 실행하십시오.</block>
  <block id="a20b570eccfacf0ac4684823643f91a1" category="paragraph">PV는 NetApp.IO/트리덴트(triment) 프로비저닝을 사용하여 생성되었으며 NFS 유형입니다. Astra Trident에서 제공하는 모든 새로운 기능을 지원하려면 이 PV를 CSI 유형으로 업그레이드해야 합니다.</block>
  <block id="5be1e244815de403bf79074735c2621f" category="list-text">'tridenctl upgrade volume &lt;name-of-trident-volume&gt;' 명령을 실행하여 레거시 Astra Trident 볼륨을 CSI 사양으로 업그레이드합니다.</block>
  <block id="c18e246999f594d4fb39c857bcdd1e09" category="list-text">kubeck tl t설명해 PV를 실행하여 볼륨이 CSI 볼륨인지 확인합니다.</block>
  <block id="fb741f44b40455e466443f8f96ace85e" category="paragraph">이러한 방식으로 Astra Trident에서 생성한 NFS/iSCSI 유형의 볼륨을 볼륨별로 CSI 유형으로 업그레이드할 수 있습니다.</block>
  <block id="3bda6d3452a50ffddd40bb74b05d6c50" category="summary">Astra Trident는 분기별 릴리스 케이던스를 따르며, 매년 4개의 주요 릴리즈를 제공합니다. 각 새로운 릴리스는 이전 릴리즈를 기반으로 하며 새로운 기능과 성능 향상, 버그 수정 및 개선 기능을 제공합니다. Astra Trident의 새로운 기능을 이용하려면 1년에 한 번 이상 업그레이드하는 것이 좋습니다.</block>
  <block id="3386987a97643481040e99019808e020" category="doc">Astra Trident를 업그레이드합니다</block>
  <block id="66bc438a5af66629e5b414e233cb5834" category="admonition">향후 5개 릴리즈인 릴리즈로 업그레이드하려면 다단계 업그레이드를 수행해야 합니다.</block>
  <block id="d442f21894fbfe232b6d52b52a10ec35" category="section-title">업그레이드할 버전을 확인합니다</block>
  <block id="fd6a74b5e363eaa218988afd6ae5140b" category="list-text">YY-1.mm 릴리스 및 모든 중간 릴리스에서 YY.mm 릴리스로 업그레이드할 수 있습니다. 예를 들어, 19.07 이상에서 20.07 이상으로 직접 업그레이드할 수 있습니다(19.07.1 등의 DOT 릴리스 포함).</block>
  <block id="daf61148013081df2c82930a3a46feb6" category="list-text">이전 릴리스를 사용하는 경우 다단계 업그레이드를 수행해야 합니다. 따라서 먼저 4개의 릴리즈 창에 맞는 최신 릴리즈로 업그레이드해야 합니다. 예를 들어, 18.07을 실행하고 20.07 릴리스로 업그레이드하려는 경우 다음과 같이 다단계 업그레이드 프로세스를 따르십시오.</block>
  <block id="6ed2af44865aa9f6dddcebd57d996cf1" category="list-text">첫 번째 업그레이드는 18.07에서 19.07로 가능합니다. 업그레이드에 대한 자세한 내용은 각 릴리스의 설명서를 참조하십시오.</block>
  <block id="ff115c7087db60c699cccdb21f39ea66" category="list-text">그런 다음 19.07에서 20.07로 업그레이드합니다.</block>
  <block id="8d66ed6671344ec6017707c38250329c" category="admonition">19.04 이전 버전의 모든 업그레이드를 수행하려면 Astra Trident의 메타데이터를 자체 "etcd"에서 CRD 개체로 마이그레이션해야 합니다. 업그레이드 작동 방식을 이해하려면 릴리즈 설명서를 확인하십시오.</block>
  <block id="558ab0bef1894a7a726109d36632d09d" category="inline-link-macro">알려진 문제</block>
  <block id="33966eba1ed0cde6afda5a97ffaffb09" category="inline-link">보안 컨텍스트</block>
  <block id="ceb268093ddd5aa9df1769eda5d1c8cd" category="inline-link">샘플 입력</block>
  <block id="9d267d893296d1b56789c03ad196afc8" category="inline-link">"토리지 클래스 기본형.YAML.템블"</block>
  <block id="4e4578e23d9d48bd9338b1581f884392" category="inline-link">'Storage-class-bronze-default.YAML'을 선택합니다</block>
  <block id="1ca02e26ff81cefae18a0a8d994ca94a" category="admonition">업그레이드 시 Astra Trident가 사용하는 scorageClades에 parameter.fsType을 제공하는 것이 중요합니다. 기존 볼륨을 방해하지 않고 'torageClasses'를 삭제하고 다시 생성할 수 있습니다. 이것은 시행에 대한 ** 요구 사항입니다<block ref="cafe4c6014d8c45aaac70e49318f1a2a" category="inline-link-rx"></block> SAN 볼륨: 를 클릭합니다<block ref="25daec0b57549a6ad43dbc62a9e717ca" category="inline-link-rx"></block> 디렉토리에는 과 같은 예가 포함되어 있습니다<block ref="d308f4d12b21bf269d64643e1eceeeb2" category="inline-link-rx"></block> 및<block ref="b6ff3ec2ac914a047085c08d5843e316" category="inline-link-rx"></block>. 자세한 내용은 을 참조하십시오 <block ref="139a59f2208174d2bf825b80dc580275" category="inline-link-macro-rx"></block>.</block>
  <block id="17cfb8bd7f378fa26b63ee73d467cb82" category="section-title">어떤 업그레이드 경로를 선택해야 합니까?</block>
  <block id="46940159293e259bcf0bb4df75448100" category="paragraph">다음 경로 중 하나를 사용하여 업그레이드할 수 있습니다.</block>
  <block id="dc1a9a8ad35cc8aa946e0a2e3f959e2b" category="list-text">Trident 연산자 사용</block>
  <block id="4b78e512c67306c61715208417a1cfd7" category="list-text">트리덴ctl 사용.</block>
  <block id="f5d517b06fc0b1af5d599776e2f6f1d6" category="inline-link">블로그입니다</block>
  <block id="756bc985c24584ee6c7338b28f771da8" category="admonition">CSI 볼륨 스냅샷은 이제 Kubernetes 1.20부터 시작되는 GA 기능입니다. Astra Trident를 업그레이드할 때 업그레이드를 수행하기 전에 이전의 모든 알파 스냅샷 CRS 및 CRD(볼륨 스냅샷 클래스, 볼륨 스냅샷 및 볼륨 스냅샷 콘텐츠)를 제거해야 합니다. 을 참조하십시오<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block> 알파 스냅샷을 베타/GA 스펙으로 마이그레이션하는 단계에 대해 이해합니다.</block>
  <block id="6958a3036b19c13782ecd0024d772b5f" category="paragraph">다음 조건이 충족될 경우 Trident 연산자를 사용하여 업그레이드할 수 있습니다.</block>
  <block id="9f5cdec8485f67ded88c50f021a562e1" category="list-text">CSI Trident(19.07 이상)를 실행하고 있습니다.</block>
  <block id="e682693c5c270204af79541caa0e63ba" category="list-text">CRD 기반 Trident 릴리스가 있습니다(19.07 이상).</block>
  <block id="4a0e21a0d69199588534154f29f4af94" category="list-text">사용자 지정 설치를 수행하지 않습니다(사용자 지정 YAML 사용).</block>
  <block id="3814df1eaf856112f1f0b22f7f0600e5" category="admonition">"etcd" 기반의 Trident 릴리즈(19.04 이하)를 사용하는 경우 Trident를 업그레이드할 때 연산자를 사용하지 마십시오.</block>
  <block id="773f6f7f15c751e861d5494e4d510675" category="paragraph">운용자를 사용하지 않거나 운용자가 지원할 수 없는 사용자 정의 설치가 있는 경우 tridentctl을 사용하여 업그레이드할 수 있습니다. Trident 릴리즈 19.04 및 이전 버전에서 선호되는 업그레이드 방법입니다.</block>
  <block id="152a676ac450f5b96a35605dde352607" category="section-title">조작자에 대한 변경</block>
  <block id="fc7e892a21e797d0592360430a5deedd" category="paragraph">Astra Trident의 21.01 릴리스에는 다음과 같은 몇 가지 주요 아키텍처 변경 사항이 작업자에게 도입되었습니다.</block>
  <block id="4d1b9ac70f0037098e345cb389ea45d9" category="list-text">이제 연산자가 * 클러스터 범위 * 가 됩니다. Trident 연산자(버전 20.04 - 20.10)의 이전 인스턴스는 * 네임스페이스 범위 * 였습니다. 클러스터 범위의 연산자는 다음과 같은 이유로 유용합니다.</block>
  <block id="d898743d222c4e0e5e333941bee1ed57" category="list-text">리소스 책임: 이제 운영자는 클러스터 수준에서 Astra Trident 설치와 관련된 리소스를 관리합니다. Astra Trident를 설치하는 과정에서 운영자는 ownerReferences를 사용하여 여러 리소스를 생성하고 유지합니다. 클러스터 범위 리소스의 ownerReferences를 유지하면 OpenShift와 같은 Kubernetes 일부 배포판에서 오류가 발생할 수 있습니다. 이 문제는 클러스터 범위 운영자를 통해 완화됩니다. Trident 리소스의 자동 복구 및 패칭은 필수 요구사항입니다.</block>
  <block id="375aa3155c54339a366f23cdb01301e5" category="list-text">제거 중 정리: Astra Trident를 완전히 제거하려면 모든 관련 리소스를 삭제해야 합니다. 네임스페이스 범위 연산자는 클러스터 범위 리소스(예: clusterRole, ClusterRoleBinding 및 PodSecurityPolicy)를 제거하는 데 문제가 있을 수 있으며 불완전한 정리 작업을 초래할 수 있습니다. 클러스터 범위 연산자로 인해 이 문제가 발생하지 않습니다. 사용자는 Astra Trident를 완전히 제거하고 필요한 경우 새로 설치할 수 있습니다.</block>
  <block id="6d68e880fd5e5254e122e99a78417abd" category="list-text">아스트라 트리덴트(Astra Trident)를 설치 및 관리하는 데 사용되는 맞춤형 리소스인 트리젠테시너(트리젠오케스트레이터)가 교체됐습니다. 또 트리엔오케스트레이터 사양에 새로운 필드가 도입된다. 사용자는 'pec.namespace` 필드를 사용하여 네임스페이스 Trident를 설치/업그레이드하도록 지정할 수 있습니다. 예를 들어 보겠습니다<block ref="2890210b17eb9668a60ececdebcd5910" category="inline-link-rx"></block>.</block>
  <block id="9c83e144e5481ac6766f4055e566594d" category="section-title">자세한 내용을 확인하십시오</block>
  <block id="7d224494dc0d22edaed4c965cdddffe6" category="inline-link-macro">Trident 연산자를 사용하여 업그레이드합니다</block>
  <block id="85f4fc5b4c12e5ede408e45a6d484dc1" category="list-text"><block ref="85f4fc5b4c12e5ede408e45a6d484dc1" category="inline-link-macro-rx"></block></block>
  <block id="b41f68e89b7b02a9077fb800d31a2fbe" category="inline-link-macro">tridentctl을 사용하여 업그레이드합니다</block>
  <block id="efb20f59615d4d5ee0437ba57aecbe50" category="list-text"><block ref="efb20f59615d4d5ee0437ba57aecbe50" category="inline-link-macro-rx"></block></block>
  <block id="dec54888538ac86f51d29a3d043e6bf6" category="summary">운영자를 사용하여 기존 Astra Trident 설치를 쉽게 업그레이드할 수 있습니다.</block>
  <block id="5ff3faebb0ff710340bdbee89a4667ad" category="doc">운영자와 함께 업그레이드하십시오</block>
  <block id="b8ce48f9165ac0cead930cd72b36b5ac" category="paragraph">연산자를 사용하여 업그레이드하려면 다음 조건이 충족되어야 합니다.</block>
  <block id="933c98c07c43994c690a4d57fff2fd1f" category="list-text">CSI 기반 Astra Trident가 설치되어 있어야 합니다. CSI Trident를 실행 중인지 확인하려면 Trident 네임스페이스의 Pod를 확인하십시오. '트리덴트-CSI- *' 명명 패턴을 따르면 CSI Trident를 실행하고 있는 것입니다.</block>
  <block id="b53958f3b6708eb5412679540db1febc" category="list-text">CRD 기반 Trident가 설치되어 있어야 합니다. 이는 19.07 이후의 모든 릴리스를 나타냅니다. CSI 기반 설치가 있는 경우 CRD 기반 설치가 있을 가능성이 높습니다.</block>
  <block id="ba45a58fb6371fc5a91fb8a5d399becd" category="list-text">CSI Trident를 제거한 후 설치 시 메타데이터가 지속되는 경우 연산자를 사용하여 업그레이드할 수 있습니다.</block>
  <block id="33deedceb6eaeb2f124b7ce830e212a8" category="list-text">주어진 Kubernetes 클러스터의 모든 네임스페이스에 하나의 Astra Trident 설치만 존재해야 합니다.</block>
  <block id="f6c44c912e06b8221085c219600c6387" category="inline-link-macro">버전 1.17 이상</block>
  <block id="0805928cc4c4b801e682a6cd2006e692" category="list-text">를 실행하는 Kubernetes 클러스터를 사용해야 합니다 <block ref="b1e96583006584730c41f3baa3725240" category="inline-link-macro-rx"></block>.</block>
  <block id="093e1971a4b17fce7e3e4d94854a46ba" category="list-text">알파 스냅샷 CRD가 있는 경우 'tridentctl oblividate alpha-snapshot-CRD'로 제거해야 합니다. 그러면 알파 스냅샷 사양에 대한 CRD가 삭제됩니다. 삭제/마이그레이션해야 하는 기존 스냅샷의 경우 를 참조하십시오<block ref="ddf3864130a7be37c683b2fe21303201" category="inline-link-rx"></block>.</block>
  <block id="199ed8c975e8bb544d18428ba17adbc3" category="inline-link">GitHub에 대한 발행 세부 정보</block>
  <block id="398b69b685d2969c9e5d2f8cfbff3972" category="admonition">OpenShift Container Platform에서 연산자를 사용하여 Trident를 업그레이드할 때는 Trident 21.01.1 이상으로 업그레이드해야 합니다. 21.01.0으로 릴리스된 Trident 연산자에는 21.01.1에서 해결된 알려진 문제가 포함되어 있습니다. 자세한 내용은 를 참조하십시오<block ref="bcebcdd21adcbb3d7c640d63a711c6fb" category="inline-link-rx"></block>.</block>
  <block id="2f6881ec6a84d1ac9ef2e551f3ca8466" category="section-title">클러스터 범위 운영자 설치를 업그레이드하십시오</block>
  <block id="532223fc600c8862511462ff30738c55" category="paragraph">Trident 21.01 및 이후 * 에서 업그레이드하려면 다음 단계를 따르십시오.</block>
  <block id="238e63aecc23c1bc2611ca883f075f1f" category="list-text">현재 Astra Trident 인스턴스를 설치하는 데 사용된 Trident 연산자를 삭제합니다. 예를 들어, 21.01에서 업그레이드하는 경우 다음 명령을 실행합니다.</block>
  <block id="caa6267a6d2c9b631544a2ce0d5e4180" category="list-text">(선택 사항) 설치 매개 변수를 수정하려면 Trident를 설치할 때 설정한 'Trident Orchestrator' 개체를 편집합니다. 컨테이너 이미지를 가져올 사용자 지정 Trident 이미지 수정, 디버그 로그 활성화 또는 이미지 풀 비밀 지정 등의 변경 사항이 있을 수 있습니다.</block>
  <block id="09b615e18699c6675b3705c00a495375" category="list-text">새로운 버전의 Trident 운영자를 설정하는 bundle.YAML 파일을 사용하여 Astra Trident를 설치합니다. 다음 명령을 실행합니다.</block>
  <block id="d06b5297af318d2581021098f6b0d44d" category="section-title">네임스페이스 범위 연산자 설치를 업그레이드합니다</block>
  <block id="ddfa75d059a999aedec16392aae03bc4" category="paragraph">네임스페이스 범위 연산자(버전 20.07 ~ 20.10)를 사용하여 설치된 Astra Trident의 인스턴스에서 업그레이드하려면 다음 단계를 따라야 합니다.</block>
  <block id="edf5c542759186ded2c7eeaae6b340a5" category="list-text">기존 Trident 설치의 상태를 확인합니다. 이렇게 하려면 '트리펜Provisioner'의 * 상태 * 를 확인하십시오. 상태는 '설치됨'이어야 합니다.</block>
  <block id="f14a1d8e56a0cbd2826edd38778371f7" category="admonition">상태가 '업데이트 중'으로 표시되면 계속하기 전에 이를 해결해야 합니다. 가능한 상태 값 목록은 를 참조하십시오<block ref="6aefd1c9ce8e43313a8c7c92e2fac4f3" category="inline-link-rx"></block>.</block>
  <block id="683d018a2f7c70469fd74ba0eeae2a79" category="list-text">Trident 설치 프로그램과 함께 제공된 매니페스트를 사용하여 'Trident Orchestrator' CRD를 만듭니다.</block>
  <block id="ede3d39a1c5211985b126b3f166cf601" category="inline-link">Trident 저장소</block>
  <block id="af39f09efb6e7b7133433dff92d0fffe" category="list-text">매니페스트를 사용하여 네임스페이스 범위 연산자를 삭제합니다. 이 단계를 완료하려면 네임스페이스 범위의 운영자를 배포하는 데 사용되는 "bundle.YAML" 파일이 필요합니다. 에서 Bundle.YAML을 얻을 수 있습니다<block ref="1403b813895a8a78c447fca96240f2ac" category="inline-link-rx"></block>. 해당 분기를 사용해야 합니다.</block>
  <block id="5451265740f1553dff7af7814faa5277" category="inline-link-macro">매개 변수 목록입니다</block>
  <block id="8afea862003d4f613fcffecc022fb20c" category="admonition">네임스페이스 범위 연산자를 삭제한 후 클러스터 범위 연산자를 설치하기 전에 Trident 설치 매개 변수(예: "tridentImage", "autostsupportImage", 개인 이미지 리포지토리 및 "imagePullSecrets" 제공)를 변경해야 합니다. 업데이트할 수 있는 전체 매개 변수 목록은 를 참조하십시오 <block ref="e5ef433069537d0999d9cf3f906affdb" category="inline-link-macro-rx"></block>.</block>
  <block id="5fbede7820945c99130183fd2fd0f4b3" category="paragraph">이 단계에서 트리덴트 - operator - xxxxxxxxxx - xxxxx'POD가 삭제됩니다.</block>
  <block id="86463d362af5835ff8c3fd6587fbd24f" category="list-text">(선택 사항) 설치 매개변수를 수정해야 하는 경우 ' TERentProvisioner' 사양을 업데이트합니다. 컨테이너 이미지를 가져올 전용 이미지 레지스트리를 수정하거나, 디버그 로그를 사용하거나, 이미지 풀 비밀을 지정하는 등의 변경 사항이 있을 수 있습니다.</block>
  <block id="df486b34cec5fdfba24de79fe6b388d4" category="list-text">클러스터 범위 연산자를 설치합니다.</block>
  <block id="d5eded1a43812da779b35ffbffedf46b" category="admonition">클러스터 범위 운영자를 설치하면 '트리펜테너' 객체가 트리펜터레이터 객체로 마이그레이션되고, 트리펜서너 CRD와 트리펜서너 객체를 삭제하고, 아스트라 Trident를 사용 중인 클러스터 범위 연산자로 업그레이드합니다. 다음 예제에서 Trident는 21.07.1로 업그레이드됩니다.</block>
  <block id="cb84f171610775cc6f9d39511d6acee9" category="admonition">클러스터 범위 연산자를 사용하여 Astra Trident를 업그레이드하면 tridentProvisioner가 같은 이름의 tridentOrchestrator 객체로 마이그레이션됩니다. 이 작업은 작업자가 자동으로 처리합니다. 업그레이드에는 이전과 동일한 네임스페이스에 Astra Trident도 설치됩니다.</block>
  <block id="61d74cfa0c3f53abef0b4694fba0522f" category="section-title">제어 기반 작업자 설치를 업그레이드합니다</block>
  <block id="7734dd866cc8c135256bad90520fa719" category="paragraph">제어 기반 운영자 설치를 업그레이드하려면 다음 단계를 수행하십시오.</block>
  <block id="3002cfcea36b7fb4d87da4d413730851" category="list-text">최신 Astra Trident 릴리스를 다운로드하십시오.</block>
  <block id="2171a3791b6ac570c7910a5d1d7f4d89" category="list-text">'helm upgrade' 명령어를 사용한다. 다음 예를 참조하십시오.</block>
  <block id="00bca5f1181617a563b71b78a27434d0" category="paragraph">여기서 trident-operator-21.07.1.tgz는 업그레이드하려는 버전을 나타냅니다.</block>
  <block id="1869e61179995eed8692bfc705434d2b" category="list-text">'Helm list'를 실행하여 차트와 앱 버전이 모두 업그레이드되었는지 확인합니다.</block>
  <block id="1d0b5ffc29a6dba36314ccbba6a46038" category="admonition">업그레이드 중에 구성 데이터를 전달하려면 '--set'을 사용합니다.</block>
  <block id="4a6b869a481b52472aa62cfa4d9d255e" category="paragraph">예를 들어, 기본값인 tridentDebug를 변경하려면 다음 명령을 실행합니다.</block>
  <block id="6b30e95bff9143b45494dd9486e9515d" category="paragraph">'$tridentctl logs'를 실행하면 디버그 메시지가 표시됩니다.</block>
  <block id="ad00f75f90e86259efc5e8512fe4c23a" category="admonition">초기 설치 중에 기본값이 아닌 옵션을 설정하는 경우 업그레이드 명령에 옵션이 포함되어 있는지 확인하십시오. 그렇지 않으면 값이 기본값으로 재설정됩니다.</block>
  <block id="5c83dd886f5edc620e809e7800bc225f" category="section-title">비운영자 설치에서 업그레이드</block>
  <block id="69f43f0aadf9091408f80d6d1e0fdd45" category="paragraph">위에 나열된 필수 조건을 충족하는 CSI Trident 인스턴스가 있는 경우 Trident 운영자의 최신 릴리즈로 업그레이드할 수 있습니다.</block>
  <block id="4ab464bddccdcbc36fab4cea802025f9" category="list-text">매니페스트에서 트라이디오케스트레이터 CRD를 만듭니다.</block>
  <block id="835fd860290737b70acf870a253c3549" category="list-text">연산자를 전개합니다.</block>
  <block id="06da281bf5e01c3c59892dc886cd0067" category="list-text">Astra Trident를 설치할 '트리젠오케스트레이터' CR을 만듭니다.</block>
  <block id="f420eb91a420c03f1792a6504b30277b" category="paragraph">기존 백엔드 및 PVC는 자동으로 사용할 수 있습니다.</block>
  <block id="3a90bea856daf0616bcbdde1b9d9ad0b" category="summary">Astra Trident의 설치 방식에 따라 여러 옵션을 사용하여 제거할 수 있습니다.</block>
  <block id="bdcf993f8f3d91925d60754cd864f3c0" category="section-title">Helm을 사용하여 제거합니다</block>
  <block id="8656f6a3d04342ff6248bd7d32949c2a" category="paragraph">Helm을 사용하여 Astra Trident를 설치한 경우 'helm uninstall'을 사용하여 제거할 수 있습니다.</block>
  <block id="e2a3593a8e9900eadda10d47bc2ff47c" category="section-title">Trident 연산자를 사용하여 제거합니다</block>
  <block id="c416a70504ae36e8cfbf555ad0d13ab9" category="paragraph">운영자를 사용하여 Astra Trident를 설치한 경우 다음 중 하나를 수행하여 제거할 수 있습니다.</block>
  <block id="1159b3a6f6975215eaff7b18f9fdbe8e" category="list-text">** 제거 플래그를 설정하려면 '트리젠터레이터'를 편집하여 '트리젠터레이터'를 편집하고 'Spec.uninstall=true'를 설정할 수 있습니다. 다음 그림과 같이 '트리엔오케스트레이터' CR을 편집하고 '제거' 플래그를 설정합니다.</block>
  <block id="245e84de93b9b41f643f9e737c17e702" category="paragraph">'uninstall' 플래그가 'true'로 설정되어 있으면 Trident 운영자가 Trident를 제거하지만 Trident 자체 자체를 제거하지 않습니다. Trident를 다시 설치하려면 해당 Trident를 정리하고 새 AgentOrchestrator를 생성해야 합니다.</block>
  <block id="a5e00cb8c456b8892f7af2349fe6e10a" category="list-text">** "트리펜터레이터" 삭제: ** Astra Trident를 배포하는 데 사용된 '트리엔오케스트레이터' CR을 제거하여 운영자에게 Trident를 제거하도록 지시합니다. 운영자는 '트리펜터레이터'의 제거를 처리하고 Astra Trident 구축 및 디포드를 제거하여 설치의 일부로 생성한 Trident 포드를 삭제합니다. Astra Trident(CRD 생성 포함)를 완전히 제거하고 슬레이트 클린을 효과적으로 닦기 위해 '트리펜터레이터'를 편집하여 '와이프아웃' 옵션을 통과할 수 있습니다. 다음 예를 참조하십시오.</block>
  <block id="8aaaff274ba10c527c6bf8facd1c9092" category="paragraph">그러면 Astra Trident가 완전히 설치 제거되며, 백엔드 및 관리하는 볼륨과 관련된 모든 메타데이터가 지워집니다. 이후 설치는 새로 설치하는 것으로 처리됩니다.</block>
  <block id="1f119048e6c0b2f219b28b7efae30285" category="admonition">전체 제거를 수행할 때에만 CRD를 지우는 것을 고려해야 합니다. 이 작업은 취소할 수 없습니다. ** 처음부터 새로 Astra Trident 설치를 생성하기 위해 사용하지 않는 한 CRD를 지우지 마십시오**.</block>
  <block id="ed116003561aef0bea77cb4c5f6fe418" category="section-title">tridentctl을 사용하여 제거합니다</block>
  <block id="20402206432f6b6e75899e8f585ae984" category="paragraph">다음과 같이 tridentctl에서 'uninstall' 명령을 실행하면 CRD 및 관련 객체를 제외한 Astra Trident와 관련된 모든 리소스가 제거되므로 설치 프로그램을 다시 쉽게 실행하여 최신 버전으로 업데이트할 수 있습니다.</block>
  <block id="1b600643682d5a3280681ef82d7e6ae4" category="paragraph">Astra Trident를 완전히 제거하려면 Astra Trident에서 생성한 CRD의 종료자를 제거하고 CRD를 삭제해야 합니다.</block>
  <block id="34c4dac14496e9c45d92f345d9392fc8" category="summary">최신 버전을 실행하지 않는 경우 Astra Trident의 이전 릴리스에 대한 문서를 사용할 수 있습니다.</block>
  <block id="ba09ee47d11962c1ccd13d7e1f10e6c5" category="doc">이전 버전의 문서</block>
  <block id="0c141ec81d4107f4c63fb0deb2531c0d" category="inline-link">Astra Trident 21.04</block>
  <block id="193bfae1ebda99fb7289c66fa69395a0" category="list-text"><block ref="193bfae1ebda99fb7289c66fa69395a0" category="inline-link-rx"></block></block>
  <block id="cba2c660d905f83e39a0d1771286c9e7" category="inline-link">Astra Trident 21.01</block>
  <block id="97f32ab1a5165dc49105dca53b9f4de7" category="list-text"><block ref="97f32ab1a5165dc49105dca53b9f4de7" category="inline-link-rx"></block></block>
  <block id="727d2d1e15a5c7260e90c50b1c250a4c" category="inline-link">Astra Trident 20.10</block>
  <block id="8a0315074645cbbab67a7445dcdf42f2" category="list-text"><block ref="8a0315074645cbbab67a7445dcdf42f2" category="inline-link-rx"></block></block>
  <block id="bad2b8fa41c05085668e48d7c14968dc" category="inline-link">Astra Trident 20.07</block>
  <block id="449d7e957347de63ee3d9841c40b4e7f" category="list-text"><block ref="449d7e957347de63ee3d9841c40b4e7f" category="inline-link-rx"></block></block>
  <block id="7c0a09ca9ea4472728e4661755a43c6b" category="inline-link">Astra Trident 20.04</block>
  <block id="8a72b28486832ed8c725617460afbdcb" category="list-text"><block ref="8a72b28486832ed8c725617460afbdcb" category="inline-link-rx"></block></block>
  <block id="1dc5429c6c86712d7628beb5652a0e2e" category="inline-link">Astra Trident 20.01</block>
  <block id="23204facdc38bad335a6afce81db0827" category="list-text"><block ref="23204facdc38bad335a6afce81db0827" category="inline-link-rx"></block></block>
  <block id="5b2d210bf907d26b59abbaa0e22fbbe6" category="inline-link">아스트라 트리덴트 19.10</block>
  <block id="3377906a52734323c44c8f31b2d29e63" category="list-text"><block ref="3377906a52734323c44c8f31b2d29e63" category="inline-link-rx"></block></block>
  <block id="f1d7fe87216a18ff3ffcfa98d6065689" category="inline-link">Astra Trident 19.07</block>
  <block id="12e29d431cea2700aa9d89e0c89e67bc" category="list-text"><block ref="12e29d431cea2700aa9d89e0c89e67bc" category="inline-link-rx"></block></block>
  <block id="fe4bdabecc64b786523a3d86bb1f9cfd" category="inline-link">아스트라 트리덴트 19.04</block>
  <block id="e43783d5a51a10670edf444f0b58b6af" category="list-text"><block ref="e43783d5a51a10670edf444f0b58b6af" category="inline-link-rx"></block></block>
  <block id="5e152ff33f3262612abc4b942db27ad1" category="inline-link">아스트라 트리덴트 19.01</block>
  <block id="977636e26059252def0425dca74811ef" category="list-text"><block ref="977636e26059252def0425dca74811ef" category="inline-link-rx"></block></block>
  <block id="d59b86d1714966230da7a00672e40912" category="summary">여기에 나열된 권장 사항을 사용하여 Astra Trident 설치가 안전한지 확인합니다.</block>
  <block id="2fae32629d4ef4fc6341f1751b405e45" category="doc">보안</block>
  <block id="44a736677691eaca5e5d3d6b5c770b22" category="section-title">자체 네임스페이스에서 Astra Trident를 실행합니다</block>
  <block id="347d4c35796a862cf20cdcdebfe59e57" category="paragraph">애플리케이션, 애플리케이션 관리자, 사용자 및 관리 애플리케이션에서 Astra Trident 객체 정의 또는 Pod에 액세스하여 안정적인 스토리지를 보장하고 잠재적인 악성 활동을 차단하는 것이 중요합니다.</block>
  <block id="47d7f9fac441e60d9523d256d02aa8ba" category="paragraph">다른 애플리케이션과 사용자를 Astra Trident에서 분리하려면 항상 고유한 Kubernetes 네임스페이스('트리덴트')에 Astra Trident를 설치하십시오. Astra Trident를 자체 네임스페이스에 두면 Kubernetes 관리 담당자만 Astra Trident POD와 이름이 같은 CRD 객체에 저장된 아티팩트(예: 백엔드 및 CHAP 암호)에 액세스할 수 있습니다. 관리자만이 Astra Trident 네임스페이스에 액세스할 수 있도록 하고 "tridentctl" 응용 프로그램에 액세스할 수 있도록 해야 합니다.</block>
  <block id="f40aef657c875e42158050f63dcfbb6f" category="section-title">ONTAP SAN 백엔드에 CHAP 인증을 사용합니다</block>
  <block id="2738c60dc60977d9eb6af2bf2a98c193" category="paragraph">Astra Trident는 ONTAP SAN 워크로드에 대한 CHAP 기반 인증(ONTAP-SAN과 ONTAP-SAN 절약 드라이버 사용)을 지원합니다. 호스트와 스토리지 백엔드 간의 인증을 위해 Astra Trident와 양방향 CHAP를 사용하는 것이 좋습니다.</block>
  <block id="c34904efabe33827baaa88ebf031ffab" category="paragraph">SAN 스토리지 드라이버를 사용하는 ONTAP 백엔드의 경우 Astra Trident는 양방향 CHAP를 설정하고 "tridentctl"을 통해 CHAP 사용자 이름과 암호를 관리할 수 있습니다. 을 참조하십시오 <block ref="eda040c33c51e3cee067cf2f06789687" category="inline-link-macro-rx"></block> Astra Trident가 ONTAP 백엔드에서 CHAP를 구성하는 방법을 이해합니다.</block>
  <block id="97f83fd51c89f4f9d3fc271b9f7291ab" category="admonition">ONTAP 백엔드에 대한 CHAP 지원은 Trident 20.04 이상에서 사용할 수 있습니다.</block>
  <block id="d4e0ad8fd8e11d87eb431051692db344" category="section-title">NetApp HCI 및 SolidFire 백엔드에서 CHAP 인증을 사용합니다</block>
  <block id="b6a8ac29724d88dfaec657edda424d98" category="paragraph">양방향 CHAP를 구축하여 호스트와 NetApp HCI 및 SolidFire 백엔드 간의 인증을 보장하는 것이 좋습니다. Astra Trident는 테넌트당 2개의 CHAP 암호를 포함하는 비밀 객체를 사용합니다. Trident를 CSI 구축 담당자로 설치하면 CHAP 암호를 관리하고 해당 PV의 "tridentvolume" CR 객체로 저장합니다. PV를 생성할 때 CSI Astra Trident는 CHAP 암호를 사용하여 iSCSI 세션을 시작하고 CHAP를 통해 NetApp HCI 및 SolidFire 시스템과 통신합니다.</block>
  <block id="19cde2e69238c98382d677e2583cbc46" category="admonition">CSI Trident에서 생성한 볼륨은 볼륨 액세스 그룹과 연결되지 않습니다.</block>
  <block id="3179d8563cd49690a141c34c045dfab8" category="paragraph">CSI가 아닌 프런트엔드에서는 작업자 노드의 디바이스로 볼륨을 연결하는 작업을 Kubernetes에서 처리합니다. 볼륨 생성 후 Astra Trident는 NetApp HCI/SolidFire 시스템에 API 호출을 통해 해당 테넌트의 암호가 아직 없는 경우 비밀을 검색합니다. 그런 다음 Astra Trident가 Kubernetes에 비밀을 전달합니다. 각 노드에 위치한 kubelet은 Kubernetes API를 통해 기밀에 액세스하고 이를 사용하여 볼륨에 액세스하는 각 노드와 볼륨이 있는 NetApp HCI/SolidFire 시스템 간에 CHAP를 실행/사용하도록 설정합니다.</block>
  <block id="698aa9df4c2c5470599821c3d10620dd" category="summary">Kubernetes 클러스터는 일반적으로 두 가지 유형의 노드로 구성되며, 각 노드는 다양한 기능의 측면을 담당합니다.</block>
  <block id="748c130a6179b02d614cf9a027294302" category="doc">Astra Trident 통합</block>
  <block id="463c6e3deb27d776ba0302b5b90f6607" category="paragraph">Astra Trident를 통합하려면 다음과 같은 설계 및 아키텍처 요소를 통합해야 합니다. 드라이버 선택 및 배포, 스토리지 클래스 설계, 가상 스토리지 풀 설계, PVC(Persistent Volume Claim)는 Astra Trident를 사용한 스토리지 프로비저닝, 볼륨 운영, OpenShift 서비스 구축에 영향을 줍니다.</block>
  <block id="1fdc23c8579638d050b7b219da011f2b" category="section-title">운전자 선택 및 전개</block>
  <block id="150d96898b109ac670a955fd616679fe" category="section-title">ONTAP용 백엔드 드라이버를 선택합니다</block>
  <block id="3b81f3dbce48d5a5e5f6f338de47bb44" category="paragraph">ONTAP 시스템에는 4개의 서로 다른 백엔드 드라이버를 사용할 수 있습니다. 이러한 드라이버는 사용 중인 프로토콜과 스토리지 시스템에서 볼륨을 프로비저닝하는 방법에 따라 다릅니다. 따라서 어떤 드라이버를 배포할지 신중하게 고려해야 합니다.</block>
  <block id="815a377da65ae5b66c84438c43416d82" category="paragraph">상위 레벨에서는 애플리케이션에 공유 스토리지가 필요한 구성 요소(동일한 PVC에 액세스하는 여러 Pod)가 있는 경우 NAS 기반 드라이버가 기본 선택이고 블록 기반 iSCSI 드라이버는 비공유 스토리지의 요구를 충족합니다. 애플리케이션의 요구사항 및 스토리지 및 인프라 팀의 편안함 수준을 기준으로 프로토콜을 선택합니다. 일반적으로 대부분의 애플리케이션에서 두 서버 간에 차이가 거의 없기 때문에 공유 스토리지(둘 이상의 POD에 동시 액세스가 필요한 경우)가 필요한지 여부에 따라 결정하는 경우가 많습니다.</block>
  <block id="3e5fda6b2fdf8b78a529ee58e0289c8d" category="paragraph">ONTAP 백 엔드에 대한 5개의 드라이버가 아래에 나열되어 있습니다.</block>
  <block id="c2c889ded63fbe94cf7f1d5fe4747b2d" category="list-text">ONTAP-NAS: 프로비저닝되는 각 PV는 ONTAP FlexVolume입니다.</block>
  <block id="9418583a1b7e700d24bcc735aa4682b5" category="list-text">ONTAP-NAS-이코노미: 각 PV 프로비저닝은 qtree이며 FlexVolume당 qtree(기본값 200)를 구성할 수 있습니다.</block>
  <block id="bc8f11db54909209ba09d55ee0b46990" category="list-text">ONTAP-NAS-flexgroup: 각 PV는 전체 ONTAP FlexGroup로 프로비저닝되고 SVM에 할당된 모든 애그리게이트가 사용됩니다.</block>
  <block id="5e587346b7a212ee6429303276a1578b" category="list-text">ONTAP-SAN: 각 PV는 자체 FlexVolume 내의 LUN입니다.</block>
  <block id="85f6f5093b037b5bde3201d8136ee585" category="list-text">ONTAP-SAN-이코노미: 각 PV는 LUN으로 프로비저닝되며 FlexVolume당 구성 가능한 LUN 수(기본값 100)가 있습니다.</block>
  <block id="f1d8371af632688748db007c98766ded" category="paragraph">세 개의 NAS 드라이버 중 하나를 선택할 경우 해당 기능에 약간의 영향을 줍니다. 이 기능은 응용 프로그램에서 사용할 수 있습니다.</block>
  <block id="8a1187760a2c55e422a454a64e160291" category="paragraph">아래 표에서 모든 기능이 Astra Trident를 통해 표시되는 것은 아닙니다. 용량 할당 후 기능을 적용하려면 스토리지 관리자가 일부 기능을 적용해야 합니다. 위 첨자 각주는 기능 및 드라이버별 기능을 구별합니다.</block>
  <block id="6252699c8e049f40eaf187092727a531" category="cell">ONTAP NAS 드라이버</block>
  <block id="9147e5e61a7b9260dec09f3a6eb3e5be" category="cell">스냅샷 수</block>
  <block id="999cc42b236c7aee1157ff02d6f1bcd5" category="cell">복제</block>
  <block id="13bc190bfed9f972b3e33e3656737cdd" category="cell">동적 엑스포트 정책</block>
  <block id="ab0c646b4c5e36d9bcf8239d97fd1843" category="cell">다중 연결</block>
  <block id="8f2db90dd4a6fbd95ba8f0bc54fd6b27" category="cell">QoS를 참조하십시오</block>
  <block id="9d723d04c40bfd81835c0766a698cf63" category="cell">크기 조정</block>
  <block id="8c340dc334134096f68b880b42a8692c" category="cell">복제</block>
  <block id="6bfc395e3d384b30d9f43ca45b1eeff7" category="cell">Yesfootnote: 5[]</block>
  <block id="7c078cb746c3dd22969c07747fd7f3fc" category="cell">Yesfootnote: 1[]</block>
  <block id="e4e9da2a7bd5e2b5b29c51299a1b787f" category="cell">Yesfootnote: 3[]</block>
  <block id="bafd7322c6e97d25b6299b5d6fe8920b" category="cell">아니요</block>
  <block id="15861eb7768c6587d321b6010008930e" category="paragraph">Astra Trident는 ONTAP용 SAN 드라이버 2개를 제공하며 해당 기능은 아래에 나와 있습니다.</block>
  <block id="f916141465c67326e5d7d980bff2880b" category="cell">ONTAP SAN 드라이버</block>
  <block id="4f546cdc5f90f7d264cde89d14c6e015" category="cell">양방향 CHAP</block>
  <block id="e78e01b4457814be0584f80618e4659a" category="cell">Yesfootnote: 4[]</block>
  <block id="708ee6a923f9b4b3f2213d57632eaadc" category="verse-content-simple">위 표의 각주: Yesfootnote:1[]: Astra Trident에서 관리하지 않음 Yesfootnote:2[]: Astra Trident에서 관리하지만 PV 세분화되지는 않음 Yesfootnote:3[]: Astra Trident에서 관리하지 않음, PV 세분화됨 Yesfootnote:4[]: 원시 블록 볼륨에서 지원됨 Yesfootnote:5[]: CSI Trident에서 지원</block>
  <block id="74b4b41be17ac9897921032dfd4e94a8" category="paragraph">PV 세분화되지 않은 기능은 전체 FlexVolume에 적용되고 모든 PVS(즉, 공유 FlexVol의 qtree 또는 LUN)는 공통 스케줄을 공유합니다.</block>
  <block id="b483d59c54aea739f0806cf2f30c057e" category="paragraph">위 표에서 볼 수 있듯이, ONTAP-NAS와 ONTAP-NAS-이코노미 간의 기능 대부분은 동일합니다. 그러나 ONTAP-NAS-이코노미 드라이버는 PV 단위의 일정 제어 기능을 제한하므로 특히 재해 복구 및 백업 계획에 영향을 줄 수 있습니다. ONTAP 스토리지에서 PVC 클론 기능을 활용하고자 하는 개발팀은 ONTAP-NAS, ONTAP-SAN 또는 ONTAP-SAN 절약 드라이버를 사용할 때만 가능합니다.</block>
  <block id="45f7f2e55c0930a28d1a9e481e602a09" category="admonition">졸idfire-san의 드라이버도 PVC를 클로닝할 수 있습니다.</block>
  <block id="5ea8a1263c170a1b26153c03919a84f2" category="section-title">Cloud Volumes ONTAP용 백엔드 드라이버를 선택합니다</block>
  <block id="20743b3fe5b4d69360557b02168b12ea" category="paragraph">Cloud Volumes ONTAP은 NAS 및 SAN 프로토콜(NFS, SMB/CIFS 및 iSCSI)을 지원하는 파일 공유 및 블록 레벨 스토리지 등 다양한 활용 사례에 맞게 엔터프라이즈급 스토리지 기능과 함께 데이터 제어를 제공합니다. Cloud Volume ONTAP와 호환되는 드라이버는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-SAN, ONTAP-SAN 경제입니다. Cloud Volume ONTAP for AWS, Cloud Volume ONTAP for Azure, Cloud Volume ONTAP for GCP에 적용할 수 있습니다.</block>
  <block id="6b1a08ddb7e74488a9039997d4961ff8" category="section-title">ONTAP용 Amazon FSx의 백엔드 드라이버를 선택합니다</block>
  <block id="168b96624733268bb4b4ebfbebea0449" category="paragraph">ONTAP용 Amazon FSx를 사용하면 고객이 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에, AWS에 데이터를 저장하는 간편성, 민첩성, 보안, 확장성을 활용할 수 있습니다. ONTAP용 FSX는 ONTAP의 다양한 파일 시스템 기능과 관리 API를 지원합니다. Cloud Volume ONTAP와 호환되는 드라이버는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN입니다.</block>
  <block id="d0030e26d7e1baf13ad36649449f3689" category="section-title">NetApp HCI/SolidFire의 백엔드 드라이버를 선택합니다</block>
  <block id="e040ac9827d856d3ad8ae9ac0da92295" category="paragraph">NetApp HCI/SolidFire 플랫폼과 함께 사용되는 'olidfire-SAN' 드라이버는 관리자가 QoS 제한을 기반으로 Trident에 대한 Element 백엔드를 구성하는 데 도움이 됩니다. Trident에서 프로비저닝한 볼륨에 대한 특정 QoS 제한을 설정하기 위해 백엔드를 설계하려면 백엔드 파일에 'type' 매개 변수를 사용하십시오. 또한 관리자는 'limitVolumeSize' 매개 변수를 사용하여 스토리지에 생성할 수 있는 볼륨 크기를 제한할 수 있습니다. 현재 볼륨 크기 조정 및 볼륨 복제와 같은 Element 스토리지 기능은 'olidfire-SAN' 드라이버를 통해 지원되지 않습니다. 이러한 작업은 Element 소프트웨어 웹 UI를 통해 수동으로 수행해야 합니다.</block>
  <block id="77e9d6f249e4626d5b5c3aec863459d3" category="cell">SolidFire 드라이버</block>
  <block id="9ef2bbb12ff72558472202561a25058d" category="cell">CHAP</block>
  <block id="57ee8ed0b2796ea5f35b10f9ae5d68cd" category="cell">'솔더불-산'</block>
  <block id="0929973a1c9993903f6193add75b3fcf" category="cell">Yesfootnote:2[]</block>
  <block id="bccbad684880808562152ac1d82d7b73" category="verse-content-simple">각주: Yesfootnote: 1 [ ]: Astra Trident Yesfootnote: 2 [ ]: 원시 블록 볼륨에서 지원됩니다</block>
  <block id="bb1da85f123c0dbedeb19d1f5c676112" category="section-title">Azure NetApp Files용 백엔드 드라이버를 선택합니다</block>
  <block id="7450cfde7058dc5e1f7909d0280fd7ae" category="inline-link-macro">Azure NetApp Files</block>
  <block id="657e0fa57d574227dd7520919f55ff92" category="paragraph">Astra Trident는 'Azure-NetApp-files' 드라이버를 사용하여 를 관리합니다 <block ref="d617d79fbb5ee3bc8bd280353eeb1349" category="inline-link-macro-rx"></block> 서비스.</block>
  <block id="1f65578a7accdff5ca6ff9f8dc42d9c6" category="inline-link-macro">Azure NetApp Files를 위한 Astra Trident 백엔드 구성입니다</block>
  <block id="e4eb3683baaad2a9ce9e264a37fb519e" category="paragraph">이 드라이버 및 구성 방법에 대한 자세한 내용은 에서 찾을 수 있습니다 <block ref="452e5754c64fc2b52b13e03114bfeff6" category="inline-link-macro-rx"></block>.</block>
  <block id="4da613089cbda3d7c19cb4b3f67c1f5d" category="cell">Azure NetApp Files 드라이버</block>
  <block id="8098b34f582537833b36b58273c3545b" category="cell">비즈니스</block>
  <block id="e228843381960c06d1035c4219901307" category="cell">'Azure-NetApp-파일'</block>
  <block id="2fdc8a66565228c15d355a7849997337" category="verse-content-simple">각주: Yesfootnote: 1 [ ]: Astra Trident에서 관리하지 않습니다</block>
  <block id="08a2e51877cfee5806cf83c6d30fbefe" category="section-title">Cloud Volumes Service with AWS의 백엔드 드라이버를 선택합니다</block>
  <block id="01d0b26a2d16d5fb475e224d7705b56d" category="paragraph">Astra Trident는 AWS-CVS 드라이버를 사용하여 AWS 백엔드의 Cloud Volumes Service와 연결합니다. Trident에서 AWS 백엔드를 구성하려면 백엔드 파일에 apiRegion, apiURL, apiKey, s ecretKey를 지정해야 합니다. 이러한 값은 CVS 웹 포털의 계정 설정/API 액세스에서 확인할 수 있습니다. 지원되는 서비스 수준은 CVS에 맞춰 조정되며 '표준', '프리미엄', '익스트림'도 포함됩니다. 현재 100G는 프로비저닝할 최소 볼륨 크기입니다. CVS의 향후 릴리스에서는 이 제한이 적용되지 않을 수 있습니다.</block>
  <block id="f5619cf78c5af29a1223fb34ef1361ce" category="cell">AWS 드라이버에 대한 CV</block>
  <block id="b69ca6e3662048fc46e2e4f8adc185a1" category="cell">'AWS-CV'</block>
  <block id="c7fdaa4c02d33ea744bd0e39a9e89956" category="paragraph">AWS-CV 드라이버는 가상 스토리지 풀을 사용합니다. 가상 스토리지 풀은 백엔드를 추상화하여 Trident가 볼륨 배치를 결정할 수 있도록 합니다. 관리자는 backend.json 파일에 있는 가상 스토리지 풀을 정의합니다. 스토리지 클래스는 레이블을 사용하여 가상 스토리지 풀을 식별합니다.</block>
  <block id="88d040295b5885489339e969bf92517c" category="section-title">Cloud Volumes Service with GCP의 백엔드 드라이버를 선택합니다</block>
  <block id="1d326a2a7f267c800fe3eafb89e5c7cd" category="inline-link-macro">서비스 유형</block>
  <block id="f888f12905dbaabc09dd3e50073d862f" category="paragraph">Astra Trident는 GCP-cvs 드라이버를 사용하여 GCP 백엔드의 Cloud Volumes Service와 연결합니다. Trident에서 GCP 백엔드를 구성하려면 백엔드 파일에 projectNumber, apiRegion 및 apiKey를 지정해야 합니다. GCP 웹 포털에서 프로젝트 번호를 확인할 수 있으며, GCP에서 Cloud Volumes에 대한 API 액세스를 설정하는 동안 생성한 서비스 계정 프라이빗 키 파일에서 API 키를 가져와야 합니다. Astra Trident는 두 가지 중 하나로 CVS 볼륨을 생성할 수 있습니다 <block ref="a3cd55e5a9ff014b76f6953040234c24" category="inline-link-macro-rx"></block>:</block>
  <block id="3481817b04a40b0420a940c0c9c1f82d" category="list-text">* CVS *: 기본 CVS 서비스 유형으로, 제한된/중간 수준의 성능으로 높은 조널 가용성을 제공합니다.</block>
  <block id="19de6287eaf342572d94a5e0b99c2823" category="list-text">* CVS - 성능 *: 성능이 중요한 운영 워크로드에 가장 적합한 성능 최적화 서비스 유형입니다. 세 가지 서비스 수준('Standard', 'Premium', 'Extreme')을 선택할 수 있습니다. 현재 100GiB는 프로비저닝할 최소 CVS 성능 볼륨 크기이고 CVS 볼륨은 300GiB 이상이어야 합니다. CVS의 향후 릴리스에서는 이 제한이 적용되지 않을 수 있습니다.</block>
  <block id="4525f6e1d5124cd80f38341d78e8a67d" category="inline-link-macro">이 양식입니다</block>
  <block id="51e6e54f894aa900f8a1822598ef3c5a" category="admonition">기본 CVS 서비스 유형 ['storageClass=software']를 사용하여 백엔드를 배포할 때 사용자 * 는 해당 프로젝트 번호 및 프로젝트 ID에 대해 GCP의 1TiB 미만의 볼륨 기능에 대한 액세스 * 를 얻어야 합니다. Trident에서 1TiB 미만의 볼륨을 프로비저닝하는 데 이 작업이 필요합니다. 그렇지 않은 경우, 600GiB 미만의 PVC에 대해 체적 생성 * 이 실패합니다. 사용 <block ref="0c921b807a9a638a24dd843d24ed0800" category="inline-link-macro-rx"></block> 1TiB 미만의 볼륨에 대한 액세스 권한 얻기</block>
  <block id="6219f23a135db2efc679d38117420cf0" category="cell">GCP 드라이버에 대한 CVS</block>
  <block id="949a374fc5a78d436e3067ee2de19cbe" category="cell">GCP-CV</block>
  <block id="439d990c21037b37b51c4373a7aa9811" category="paragraph">GCP-CV 드라이버는 가상 스토리지 풀을 사용합니다. 가상 스토리지 풀은 백엔드를 추상화하여 Astra Trident가 볼륨 배치를 결정할 수 있도록 합니다. 관리자는 backend.json 파일에 있는 가상 스토리지 풀을 정의합니다. 스토리지 클래스는 레이블을 사용하여 가상 스토리지 풀을 식별합니다.</block>
  <block id="3af6198d49c40c18f13c73c5ce15cf34" category="section-title">스토리지 클래스 설계</block>
  <block id="388bdf78cbb5b6bf4248ddf5613f7cc3" category="paragraph">Kubernetes Storage Class 객체를 생성하려면 개별 스토리지 클래스를 구성 및 적용해야 합니다. 이 섹션에서는 애플리케이션에 대한 스토리지 클래스를 설계하는 방법에 대해 설명합니다.</block>
  <block id="964c7dcda39ec7b9c8717c3369e2fc25" category="section-title">특정 백엔드 사용률을 위한 스토리지 클래스 설계</block>
  <block id="a09acd5f665bdf96b6dce47f8d4265e3" category="paragraph">특정 스토리지 클래스 객체 내에서 필터링을 사용하여 해당 스토리지 클래스에 사용할 스토리지 풀 또는 풀 세트를 결정할 수 있습니다. Storage Class에서 'toragePools', 'additionalStoragePools', 'excludeStoragePools' 등의 세 가지 필터를 설정할 수 있습니다.</block>
  <block id="fc01760e8c283c2f128543ae8b8a67cc" category="paragraph">'toragePools' 매개 변수는 지정된 속성과 일치하는 풀 세트로 스토리지를 제한하는 데 도움이 됩니다. 추가 StoragePools 매개변수는 Astra Trident가 프로비저닝에 사용할 풀 세트를 속성 및 'toragePools' 매개 변수로 선택한 풀 세트와 함께 확장하는 데 사용됩니다. 매개 변수만 사용하거나 둘 모두를 함께 사용하여 적절한 스토리지 풀 세트가 선택되었는지 확인할 수 있습니다.</block>
  <block id="74476e892d2681775eb41ec00a11e8da" category="paragraph">excludeStoragePools 매개 변수는 속성과 일치하는 나열된 풀 세트를 명시적으로 제외하는 데 사용됩니다.</block>
  <block id="072c88043b516dbbbadd8bb0182445c7" category="section-title">QoS 정책을 에뮬레이트하기 위한 스토리지 클래스 설계</block>
  <block id="ab807e6bd2f9cb9872eed98161bdd4e1" category="paragraph">서비스 품질 정책을 에뮬레이트하기 위해 스토리지 클래스를 설계하려면 '미디어' 속성을 HDD 또는 'SSD'로 사용하여 스토리지 클래스를 생성합니다. 스토리지 클래스에 언급된 미디어 특성에 따라, Trident는 미디어 속성과 일치하도록 HDD 또는 SSD 애그리게이트를 제공하는 적절한 백엔드를 선택한 다음 볼륨 프로비저닝을 특정 애그리게이트로 전달합니다. 따라서 프리미엄 QoS 정책으로 분류될 수 있는 '미디어' 속성이 'SD'로 설정된 스토리지 클래스 Premium을 생성할 수 있습니다. 표준 QoS 정책으로 분류될 수 있는 미디어 속성을 'HDD'로 설정하는 또 다른 스토리지 클래스 표준을 생성할 수 있습니다. 또한 스토리지 클래스에서 ""IOPS"" 속성을 사용하여 QoS 정책으로 정의할 수 있는 Element 어플라이언스로 프로비저닝을 리디렉션할 수도 있습니다.</block>
  <block id="eb47104f276a8955680299ff2f4bd39d" category="section-title">특정 기능을 기반으로 백엔드를 활용하는 스토리지 클래스 설계</block>
  <block id="0bc0e72aefbf8f8ec0b28cc0486f98a2" category="paragraph">스토리지 클래스는 씬 및 일반 프로비저닝, 스냅샷, 클론 및 암호화와 같은 기능이 설정된 특정 백엔드에서 볼륨 프로비저닝을 수행하도록 설계되었습니다. 사용할 스토리지를 지정하려면 필요한 기능이 설정된 적절한 백엔드를 지정하는 스토리지 클래스를 생성합니다.</block>
  <block id="f45e814b7c305f5341f031df78bf2f07" category="section-title">가상 스토리지 풀을 위한 스토리지급 설계</block>
  <block id="bd755d43092fcea772b8e9ab21e9951e" category="paragraph">모든 Astra Trident 백엔드에 가상 스토리지 풀을 사용할 수 있습니다. Astra Trident가 제공하는 드라이버를 사용하여 백엔드에 대한 가상 스토리지 풀을 정의할 수 있습니다.</block>
  <block id="365b4529a5f01ced729944db23d237a5" category="paragraph">가상 스토리지 풀을 사용하면 관리자가 저장소 클래스를 통해 참조할 수 있는 백엔드에 대한 추상화 수준을 생성할 수 있으므로 백엔드에 볼륨을 보다 유연하고 효율적으로 배치할 수 있습니다. 동일한 서비스 클래스로 다른 백엔드를 정의할 수 있습니다. 또한 동일한 백엔드에서 여러 스토리지 풀을 생성할 수 있지만 특성이 다릅니다. 특정 레이블이 있는 선택기로 스토리지 클래스를 구성한 경우 Astra Trident는 볼륨을 배치할 모든 선택기 레이블과 일치하는 백엔드를 선택합니다. 스토리지 클래스 선택기 레이블이 여러 스토리지 풀과 일치하면 Astra Trident가 볼륨 용량을 할당할 스토리지 풀 중 하나를 선택합니다.</block>
  <block id="830a7882918fba200333b9c6ea7db363" category="section-title">가상 스토리지 풀 설계</block>
  <block id="65f970319bb8b6ede33a2d975be3693d" category="paragraph">백엔드를 생성하는 동안 일반적으로 매개 변수 집합을 지정할 수 있습니다. 관리자가 동일한 스토리지 자격 증명을 사용하여 다른 매개 변수 집합을 가진 다른 백엔드를 생성할 수 없었습니다. 가상 스토리지 풀의 도입으로 이 문제가 완화되었습니다. 가상 스토리지 풀은 백엔드 및 Kubernetes 스토리지 클래스 간에 도입된 레벨 추상화입니다. 따라서 관리자는 Kubernetes 스토리지 클래스를 통해 백엔드에 독립적인 방식으로 Selector로 참조할 수 있는 레이블과 함께 매개 변수를 정의할 수 있습니다. Astra Trident를 사용하여 지원되는 모든 NetApp 백엔드에 대해 가상 스토리지 풀을 정의할 수 있습니다. 해당 목록에는 SolidFire/NetApp HCI, ONTAP, Cloud Volumes Service on AWS, GCP 및 Azure NetApp Files가 포함됩니다.</block>
  <block id="3c4f3a478663d0f7aab5180da0b1356a" category="admonition">가상 스토리지 풀을 정의할 때는 백엔드 정의에서 기존 가상 풀의 순서를 재정렬하지 않는 것이 좋습니다. 또한 기존 가상 풀의 속성을 편집/수정하고 대신 새 가상 풀을 정의하는 것이 좋습니다.</block>
  <block id="d96c9f641b35ec82dabdc46092afe1d0" category="section-title">다양한 서비스 수준/QoS를 에뮬레이트할 수 있도록 가상 스토리지 풀을 설계합니다</block>
  <block id="9e44f014bb0976e50892e95fed1ed5b5" category="paragraph">서비스 클래스를 에뮬레이트하기 위해 가상 스토리지 풀을 설계할 수 있습니다. Cloud Volume Service for AWS를 위한 가상 풀 구축을 사용하여 다양한 서비스 클래스를 설정하는 방법을 살펴봅시다. 다양한 성능 수준을 나타내는 여러 레이블을 사용하여 AWS-CVS 백엔드를 구성합니다. '레벨 11'을 적절한 성과 수준으로 설정하고 각 레이블 아래에 다른 필수 요소를 추가합니다. 이제 다른 가상 스토리지 풀에 매핑할 다른 Kubernetes 스토리지 클래스를 생성합니다. parameters.selector` 필드를 사용하여 각 StorageClass는 볼륨을 호스팅하는 데 사용할 수 있는 가상 풀을 호출합니다.</block>
  <block id="85d73d477f633146bd32af7aaedd54da" category="section-title">특정 측면을 할당할 수 있도록 가상 풀을 설계합니다</block>
  <block id="c011d5d6ca18de1df954b81c6bb49d4a" category="paragraph">특정 측면의 여러 가상 스토리지 풀을 단일 스토리지 백엔드에서 설계할 수 있습니다. 이를 위해 백엔드에 여러 레이블을 구성하고 각 레이블 아래에 필요한 측면을 설정합니다. 이제 다른 가상 스토리지 풀에 매핑될 ' parameters.selector` ' 필드를 사용하여 다른 Kubernetes 스토리지 클래스를 만들 수 있습니다. 백엔드에서 프로비저닝되는 볼륨에는 선택한 가상 스토리지 풀에 정의된 측면이 있습니다.</block>
  <block id="421f7dd5bb37a6401aa6326ad33dae20" category="section-title">스토리지 프로비저닝에 영향을 미치는 PVC 특성</block>
  <block id="3800921d8c248cc0de59c64d110e570a" category="paragraph">요청된 스토리지 클래스 이외의 일부 매개 변수는 PVC를 생성할 때 Astra Trident의 프로비저닝 결정 프로세스에 영향을 줄 수 있습니다.</block>
  <block id="5ab83f35784f154d55ea7ab58c8e503b" category="section-title">액세스 모드</block>
  <block id="f3882c83b41b76a9fac2c57407f3ac2b" category="paragraph">PVC를 통한 저장 요청 시 필수 필드 중 하나가 액세스 모드입니다. 원하는 모드는 스토리지 요청을 호스팅하기 위해 선택한 백엔드에 영향을 줄 수 있습니다.</block>
  <block id="b72ab56468fdf0df298a89c3339b82c0" category="paragraph">Astra Trident는 다음 매트릭스에 따라 지정된 액세스 방법과 사용된 스토리지 프로토콜을 일치시키려고 시도합니다. 이는 기본 스토리지 플랫폼과 무관합니다.</block>
  <block id="cac415feda213697b27d3b6fce10d33a" category="cell">ReadWriteOnce 를 참조하십시오</block>
  <block id="c24ad3d99a666c95edd149419c958ee0" category="cell">ReadOnlyMany 를 참조하십시오</block>
  <block id="caa8dc1f4bb28d2d11226494cd05a123" category="cell">ReadWriteMany 를 참조하십시오</block>
  <block id="cefb8ccdebef1940174b22e9d0ab530b" category="cell">예(원시 블록)</block>
  <block id="823f2153adc2211a0777560eafdcbad6" category="paragraph">NFS 백엔드가 구성되지 않은 상태로 Trident 배포에 제출된 ReadWriteMany PVC에 대한 요청은 볼륨이 프로비저닝되지 않습니다. 이러한 이유로 요청자는 자신의 응용 프로그램에 적합한 액세스 모드를 사용해야 합니다.</block>
  <block id="5a51acb2538e54805c54d37ebb49c75d" category="section-title">볼륨 작업입니다</block>
  <block id="26fad327e23b6b08dcc94300bfe1ed04" category="section-title">영구 볼륨 수정</block>
  <block id="3b69d471bb98837ae6e267593bb38882" category="paragraph">영구 볼륨은 Kubernetes에서 두 가지 예외, 영구적 객체입니다. 생성된 후에는 부가세 반환 청구액 정책 및 크기를 수정할 수 있습니다. 그러나 이렇게 해서 Kubernetes 외부에서 볼륨의 일부 측면이 수정되지 않도록 할 수는 없습니다. 특정 애플리케이션에 맞게 볼륨을 사용자 지정하거나, 실수로 용량이 소비되지 않도록 하거나, 어떠한 이유로든 볼륨을 다른 스토리지 컨트롤러로 이동하는 것이 좋을 수 있습니다.</block>
  <block id="f82b5505d8def4abda0bec52275bd411" category="admonition">현재 Kubernetes 트리 프로비저닝 시 NFS 또는 iSCSI PVS의 볼륨 크기 조정 작업은 지원되지 않습니다. Astra Trident는 NFS 및 iSCSI 볼륨 확장을 지원합니다.</block>
  <block id="b1d1874782626fe3f391628ea493e6ef" category="paragraph">PV의 접속 세부 정보는 생성 후 수정할 수 없습니다.</block>
  <block id="e68591655c8031177206e1e75728853f" category="section-title">주문형 볼륨 스냅샷을 생성합니다</block>
  <block id="f557ce2b38683c13c1c1a070ce58a33d" category="paragraph">Astra Trident는 CSI 프레임워크를 사용하여 필요 시 볼륨 스냅샷 생성 및 스냅샷에서 PVC 생성을 지원합니다. 스냅샷은 편리한 데이터 시점 복사본을 유지 관리하는 방법을 제공하며 Kubernetes의 소스 PV와 독립적인 라이프사이클을 갖고 있습니다. 이러한 스냅샷을 사용하여 PVC를 복제할 수 있습니다.</block>
  <block id="f007c56a8eb121e8a696105e69aefa68" category="section-title">스냅샷으로부터 볼륨을 생성합니다</block>
  <block id="e005d448313cdc2848d923f4c754e467" category="paragraph">Astra Trident는 볼륨 스냅샷으로부터 PersistentVolumes 생성을 지원합니다. 이를 위해 PersistentVolumeClaim을 생성하고 볼륨을 생성해야 하는 필수 스냅샷으로 "소스"를 언급하기만 하면 됩니다. Astra Trident는 스냅샷에 데이터가 있는 볼륨을 생성하여 이 PVC를 처리합니다. 이 기능을 사용하면 지역 간에 데이터를 복제하거나 테스트 환경을 생성하거나 손상되거나 손상된 운영 볼륨을 전체적으로 교체하거나 특정 파일 및 디렉토리를 검색하여 연결된 다른 볼륨으로 전송할 수 있습니다.</block>
  <block id="55a3309b0b6646e0ea6b47195bd3d4bd" category="section-title">클러스터에서 볼륨 이동</block>
  <block id="925b814524908630c07d45fc5a80028a" category="paragraph">스토리지 관리자는 ONTAP 클러스터의 Aggregate와 컨트롤러 간에 볼륨을 스토리지 소비자로 중단 없이 이동할 수 있습니다. 대상 애그리게이트는 Astra Trident가 사용하는 SVM이 액세스할 수 있는 경우, 이 작업은 Astra Trident 또는 Kubernetes 클러스터에 영향을 주지 않습니다. 여기서 중요한 점은 애그리게이트를 SVM에 새로 추가한 경우, Astra Trident에 다시 추가하여 백엔드를 새로 고쳐야 한다는 것입니다. 그러면 Astra Trident가 SVM의 인벤토리를 다시 만들어 새 애그리게이트를 인식할 수 있습니다.</block>
  <block id="033dcaefcc578c987d32d4bdb6f6b1e2" category="paragraph">그러나 Astra Trident는 백엔드에서 볼륨을 이동하는 기능을 자동으로 지원하지 않습니다. 여기에는 동일한 클러스터, 클러스터 간 또는 다른 스토리지 플랫폼(스토리지 시스템이 Astra Trident에 연결된 SVM인 경우에도 해당 스토리지 플랫폼)에 있는 SVM이 포함됩니다.</block>
  <block id="302be77289f337115411c01846d9a489" category="paragraph">볼륨이 다른 위치에 복사되면 볼륨 가져오기 기능을 사용하여 현재 볼륨을 Astra Trident로 가져올 수 있습니다.</block>
  <block id="2243e252be826d6ec5e767668d9f961d" category="section-title">볼륨 확장</block>
  <block id="a059bca2035a0befa11f641fdabde223" category="paragraph">Astra Trident는 NFS 및 iSCSI PVS 크기를 조정할 수 있도록 지원합니다. 따라서 사용자는 Kubernetes 계층을 통해 직접 볼륨의 크기를 조정할 수 있습니다. ONTAP, SolidFire/NetApp HCI 및 Cloud Volumes Service 백엔드를 포함한 모든 주요 NetApp 스토리지 플랫폼에서 볼륨 확장이 가능합니다. 나중에 확장을 허용하려면 볼륨과 연관된 StorageClass에서 allowVolumeExpansion을 true로 설정합니다. 영구 볼륨의 크기를 조정해야 할 때마다 영구 볼륨 클레임의 'pec.resources.requests.storage' 주석을 필요한 볼륨 크기로 편집합니다. Trident는 스토리지 클러스터의 볼륨 크기를 자동으로 조정합니다.</block>
  <block id="40a28a40c11a193f8911cf4143a6ae6a" category="section-title">기존 볼륨을 Kubernetes로 임포트</block>
  <block id="911dcebca8f00bd038d697c0c5b9f99d" category="paragraph">볼륨 가져오기를 사용하면 기존 스토리지 볼륨을 Kubernetes 환경으로 가져올 수 있습니다. 이는 현재 ONTAP-NAS, ONTAP-NAS-flexgroup, solidfire-san, Azure-NetApp-files, AWS-CV가 지원하고 있습니다. 그리고 “GCP-CV”의 드라이버도 있습니다. 이 기능은 기존 애플리케이션을 Kubernetes로 포팅하거나 재해 복구 시나리오에서 유용합니다.</block>
  <block id="5d9f64103cac7a58da69304bc3320e98" category="paragraph">ONTAP 및 'solidfire-san' 드라이버를 사용하는 경우, 'tridentctl import volume &lt;backend-name&gt;&lt;volume-name&gt; -f/path/PVC.YAML' 명령을 사용하여 Astra Trident에서 관리할 기존 볼륨을 Kubernetes로 가져옵니다. 볼륨 가져오기 명령에 사용되는 PVC YAML 또는 JSON 파일은 Astra Trident를 프로비저닝자로 식별하는 스토리지 클래스를 가리킵니다. NetApp HCI/SolidFire 백엔드를 사용할 경우 볼륨 이름이 고유한지 확인합니다. 볼륨 이름이 중복되면 볼륨을 고유한 이름으로 복제하여 볼륨 가져오기 기능에서 볼륨 이름을 구분할 수 있도록 합니다.</block>
  <block id="5c7a693958891a764b947da44bbeb122" category="paragraph">'AWS-CV', 'Azure-NetApp-files' 또는 'GCP-CV' 드라이버를 사용하는 경우, 'tridentctl import volume &lt;backend-name&gt;&lt;volume path&gt; -f/path/PVC.YAML' 명령을 사용하여 Astra Trident에서 관리할 Kubernetes로 볼륨을 가져오십시오. 이렇게 하면 고유한 볼륨 참조가 보장됩니다.</block>
  <block id="cb619cd0109686b5f82562b63e44a107" category="paragraph">위 명령을 실행하면 Astra Trident가 백엔드에서 볼륨을 찾고 해당 크기를 읽습니다. 구성된 PVC의 볼륨 크기를 자동으로 추가(필요한 경우 덮어쓰기)합니다. 그런 다음 Astra Trident가 새로운 PV를 생성하고 Kubernetes가 PVC를 PV에 결합합니다.</block>
  <block id="3a8b25f50e2dcc298175abc8f6a71f82" category="paragraph">특정 가져온 PVC가 필요한 컨테이너를 배포한 경우 PVC/PV 쌍이 볼륨 가져오기 프로세스를 통해 바인딩될 때까지 보류 상태로 유지됩니다. PVC/PV 쌍이 바인딩되면 다른 문제가 없는 한 컨테이너가 나타나야 합니다.</block>
  <block id="41603705958b86c3ec4ff21cfce13a5b" category="section-title">OpenShift 서비스를 배포합니다</block>
  <block id="7e3c623b48b608f4c6380c2994ae5aa9" category="paragraph">OpenShift 부가 가치 클러스터 서비스는 클러스터 관리자와 호스팅 중인 애플리케이션에 중요한 기능을 제공합니다. 이러한 서비스가 사용되는 스토리지는 노드 로컬 리소스를 사용하여 프로비저닝할 수 있지만, 이로 인해 서비스의 용량, 성능, 복구 가능성 및 지속 가능성이 제한되기도 합니다. 엔터프라이즈 스토리지 어레이를 활용하여 이러한 서비스에 필요한 용량을 제공하면 서비스를 대폭 향상시킬 수 있습니다. 그러나 모든 애플리케이션과 마찬가지로 OpenShift와 스토리지 관리자는 긴밀하게 협력하여 각 애플리케이션에 가장 적합한 옵션을 결정해야 합니다. Red Hat 문서는 요구 사항을 결정하고 사이징 및 성능 요구 사항을 충족할 수 있도록 적극 활용해야 합니다.</block>
  <block id="6dd8f6c286b8e1a8c96c6309099f0003" category="section-title">레지스트리 서비스</block>
  <block id="68ee1c4c0da20bfd1e946df20351d4b9" category="inline-link-macro">NetApp.IO를 참조하십시오</block>
  <block id="126ac9f6149081eb0e97c2e939eaad52" category="inline-link-macro">블로그</block>
  <block id="34d357a7f8cc47e860d5fb0a317cf22d" category="paragraph">레지스트리의 스토리지 배포 및 관리는 에 설명되어 있습니다 <block ref="d5e1883ebd095c0eda96c44469e8197d" category="inline-link-macro-rx"></block> 에 있습니다 <block ref="ceb73d0582d40281d79011a1e5343e89" category="inline-link-macro-rx"></block>.</block>
  <block id="62ac236856a5a6aefd15133e967514c6" category="section-title">로깅 서비스</block>
  <block id="2f3052b6a2858bec8355ec56150f6a38" category="paragraph">다른 OpenShift 서비스와 마찬가지로 로깅 서비스는 Ansible을 사용하여 인벤토리 파일에서 제공하는 구성 매개 변수로 배포됩니다 호스트가 플레이북에 제공됩니다. OpenShift를 설치한 후 초기 OpenShift 설치 중에 로깅을 배포하고 로깅을 배포하는 두 가지 설치 방법이 제공됩니다.</block>
  <block id="541c717d8d2998609c0970b5e43c7401" category="admonition">Red Hat OpenShift 버전 3.9를 기준으로 공식 문서는 데이터 손상 관련 우려 때문에 로깅 서비스에 NFS를 사용할 것을 권장합니다. 이는 제품에 대한 Red Hat 테스트를 기반으로 합니다. ONTAP의 NFS 서버에는 이러한 문제가 없으며 로깅 구축을 쉽게 되돌릴 수 있습니다. 궁극적으로, 로깅 서비스를 위한 프로토콜을 선택할 수 있습니다. 두 가지 모두 NetApp 플랫폼을 사용할 때 효과가 있으며 원할 경우 NFS를 피할 이유가 없습니다.</block>
  <block id="57cad4852c9c2e439f61728e0391fe7b" category="paragraph">로깅 서비스에서 NFS를 사용하도록 선택한 경우 설치 관리자의 실패를 방지하려면 Ansible 변수 "openshift_enable_unsupported_configurations"를 "true"로 설정해야 합니다.</block>
  <block id="be11c74c1dd7f307bb80183a90dc2067" category="section-title">시작하십시오</block>
  <block id="16e90b2336fdfec64b19194247422194" category="paragraph">로깅 서비스는 필요에 따라 두 애플리케이션 및 OpenShift 클러스터 자체의 핵심 운영에 구축할 수 있습니다. 작업 로깅을 배포하려는 경우 변수 "openshift_logging_use_ops"를 "true"로 지정하면 서비스의 인스턴스 두 개가 만들어집니다. 작업에 대한 로깅 인스턴스를 제어하는 변수에는 "ops"가 포함되어 있지만 응용 프로그램의 인스턴스는 그렇지 않습니다.</block>
  <block id="a9ccaa810b97a00e75bb1ea4100d0a9f" category="paragraph">기본 서비스에서 올바른 스토리지를 활용할 수 있도록 구축 방법에 따라 Ansible 변수를 구성하는 것이 중요합니다. 각 배포 방법에 대한 옵션을 살펴보겠습니다.</block>
  <block id="c5c09113a6a6ae4b75868a9e96ea3cc3" category="inline-link-macro">RedHat OpenShift 로깅 설명서</block>
  <block id="bc468c28ba57dbcb58de37265cd02436" category="admonition">아래 표에는 로깅 서비스와 관련된 스토리지 구성과 관련된 변수만 포함되어 있습니다. 에서 다른 옵션을 찾을 수 있습니다 <block ref="e81826ec3b15492352776daada114990" category="inline-link-macro-rx"></block> 배포 내용에 따라 검토, 구성 및 사용해야 합니다.</block>
  <block id="02098b11f876fe10c40b6106bd9864da" category="paragraph">아래 표의 변수는 제공된 세부 정보를 사용하여 로깅 서비스에 대한 PV 및 PVC를 생성하는 Ansible 플레이북을 만듭니다. 이 방법은 OpenShift 설치 후 구성 요소 설치 플레이북을 사용하는 것보다 훨씬 덜 유연하지만, 기존 볼륨을 사용할 수 있는 경우 옵션으로 제공됩니다.</block>
  <block id="47c14840d8e15331fa420b9b2f757cd9" category="cell">변수</block>
  <block id="3ec365dd533ddb7ef3d1c111186ce872" category="cell">세부 정보</block>
  <block id="9aa2fd43742cd5ed36b406b3f4b0fd8c" category="cell">"openshift_logging_storage_kind"</block>
  <block id="3260b06ea72e4931f5fb5106001fcc28" category="cell">설치 프로그램이 로깅 서비스에 대한 NFS PV를 생성하도록 'NFS'로 설정합니다.</block>
  <block id="e95f43173c69a9ca544d4aaef28a4d90" category="cell">"openshift_logging_storage_host"를 선택합니다</block>
  <block id="3a262c1d9bdec02b241c16b2c5f6dbbe" category="cell">NFS 호스트의 호스트 이름 또는 IP 주소입니다. 이 경우 가상 머신의 데이터 LIF로 설정해야 합니다.</block>
  <block id="41aae586bb7044d7741fe9412aa81e03" category="cell">'openshift_logging_storage_nfs_directory</block>
  <block id="bf2d137d8c669b07aae26040c7e5c0e0" category="cell">NFS 내보내기의 마운트 경로입니다. 예를 들어 볼륨이 '/openshift_logging'으로 가정되는 경우 이 변수에 해당 경로를 사용합니다.</block>
  <block id="88a9f7d18fabb82d63ac43c64ae6e735" category="cell">'openshift_logging_storage_volume_name'</block>
  <block id="6f8782c23f3cb958d0de4fad76dabaed" category="cell">생성할 PV의 이름(예: PV_ose_logs)입니다.</block>
  <block id="789e0dc4bfc00f5c885a698d6ab34dff" category="cell">"openshift_logging_storage_volume_size"</block>
  <block id="b68f05ea52c8c80c07e6a4c0671c75bf" category="cell">NFS 내보내기의 크기(예: 100Gi)입니다.</block>
  <block id="2ab80b6965298dc6a178995bbedebe88" category="paragraph">OpenShift 클러스터가 이미 실행 중이고 Trident가 배포 및 구성된 경우 설치 관리자는 동적 프로비저닝을 사용하여 볼륨을 생성할 수 있습니다. 다음 변수를 구성해야 합니다.</block>
  <block id="c2aecf833d743cbc47969cd85c67101e" category="cell">"openshift_logging_es_pvc_dynamic"</block>
  <block id="540ad9a52084720ddb7f364fa8b304c6" category="cell">동적으로 프로비저닝된 볼륨을 사용하려면 true로 설정합니다.</block>
  <block id="45a481a75749c5331e7e9fd7d89e473d" category="cell">'openshift_logging_es_pvc_storage_class_name'</block>
  <block id="837ffa1e281409660ed25582c5b1963f" category="cell">PVC에 사용될 스토리지 클래스의 이름입니다.</block>
  <block id="cd3daa927272b5624e96d283365d5500" category="cell">"openshift_logging_es_pvc_size"를 선택합니다</block>
  <block id="8f80d278a79cbc84b80a091713006022" category="cell">PVC에서 요청된 체적의 크기입니다.</block>
  <block id="1bb0c7eeef4bbbefae080a294fd554b0" category="cell">"openshift_logging_es_pvc_prefix"</block>
  <block id="f870ec92e294a018a17afe7a614fb5bb" category="cell">로깅 서비스에서 사용하는 PVC의 접두사입니다.</block>
  <block id="e8c62e1f0f0773ae5ba6a7acad696b2d" category="cell">"openshift_logging_es_ops_pvc_dynamic"</block>
  <block id="46e65a11ac398c02b8fce45a7cd5cf36" category="cell">작업 로깅 인스턴스에 동적으로 프로비저닝된 볼륨을 사용하려면 "true"로 설정합니다.</block>
  <block id="8792c7234e14325cb68c493d20ab5154" category="cell">'openshift_logging_es_ops_pvc_storage_class_name'</block>
  <block id="d016f79f0ee104f3805d61e6a379fb9b" category="cell">작업 로깅 인스턴스에 대한 스토리지 클래스의 이름입니다.</block>
  <block id="048e768365962d7d520567f92aea8355" category="cell">"openshift_logging_es_ops_pvc_size"를 선택합니다</block>
  <block id="bc367f89ac597585e52d0eb58a5929ae" category="cell">작업 인스턴스에 대한 볼륨 요청의 크기입니다.</block>
  <block id="155871626071d69cb283985a9f36bad2" category="cell">"openshift_logging_es_ops_pvc_prefix"</block>
  <block id="2a8f254749a466654f556c6466051133" category="cell">ops instance PVCs(ops 인스턴스 PVC)의 접두사입니다.</block>
  <block id="e1b2d0d3228c29c069bcd139de306709" category="section-title">로깅 스택을 배포합니다</block>
  <block id="0409a0cfdfa4f3b3033503b8309442ff" category="paragraph">초기 OpenShift 설치 프로세스의 일부로 로깅을 배포하는 경우 표준 배포 프로세스만 따르면 됩니다. Ansible이 완료되는 즉시 서비스를 이용할 수 있도록 필요한 서비스와 OpenShift 개체를 구성 및 배포합니다.</block>
  <block id="210ecadaccb6088b0dfbd2e6a0b5d0a0" category="inline-link-macro">RedHat OpenShift Container Platform 3.11 설명서</block>
  <block id="67f3e99678cc7c568f4ed29074cdc41c" category="paragraph">하지만 초기 설치 후에 구축할 경우 구성 요소 플레이북을 Ansible에서 사용해야 합니다. 이 프로세스는 다른 버전의 OpenShift에서 약간 변경될 수 있으므로 반드시 읽고 따라야 합니다 <block ref="a2226808e95b8487c66dd3b8cbea118e" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="3dbf527ac3caf41ab150ec99a1737217" category="section-title">메트릭 서비스</block>
  <block id="12a5438ab4c44c9ad4dec6edc191eb7a" category="paragraph">메트릭 서비스는 관리자에게 OpenShift 클러스터의 상태, 리소스 활용도 및 가용성에 대한 중요한 정보를 제공합니다. 또한 POD 자동 크기 조정 기능도 필요하며, 많은 조직에서 비용 청구 및/또는 애플리케이션 표시를 위해 메트릭 서비스의 데이터를 사용합니다.</block>
  <block id="d0ed828e153e9bad2da040ddf6ad8f45" category="paragraph">로깅 서비스 및 OpenShift와 마찬가지로 Ansible을 사용하여 메트릭 서비스를 배포합니다. 또한 로깅 서비스와 마찬가지로 메트릭 서비스는 클러스터의 초기 설정 중에 또는 구성 요소 설치 방법을 사용하여 작동 후에 배포될 수 있습니다. 다음 표에는 메트릭 서비스에 대한 영구 스토리지를 구성할 때 중요한 변수가 나와 있습니다.</block>
  <block id="69aa4440020e49c654aeb910f38c6bb9" category="admonition">아래 표에는 메트릭 서비스와 관련된 스토리지 구성과 관련된 변수만 포함되어 있습니다. 문서에 나와 있는 다른 많은 옵션은 배포 내용에 따라 검토, 구성 및 사용해야 합니다.</block>
  <block id="4f692d78f978a73b157571022c1d1ba7" category="cell">"openshift_metrics_storage_kind"</block>
  <block id="30da7e263c0cffc34933d24a07fb097a" category="cell">'openshift_metrics_storage_host</block>
  <block id="adba8dd7dd2b027405b815c03a05dbf1" category="cell">NFS 호스트의 호스트 이름 또는 IP 주소입니다. SVM을 위한 데이터 LIF로 설정해야 합니다.</block>
  <block id="3bafc264ad2a901d3be052a7f1cf2e44" category="cell">'openshift_metrics_storage_nfs_directory</block>
  <block id="459859e54ba90bc4145c54d1f1deecff" category="cell">NFS 내보내기의 마운트 경로입니다. 예를 들어, 볼륨이 '/openshift_metrics'로 가정되는 경우 이 변수에 해당 경로를 사용합니다.</block>
  <block id="ca0f0d82f9c7cbc36df652cddd4b2f35" category="cell">'openshift_metrics_storage_volume_name'</block>
  <block id="eb10d02b22b02d7f543f867b8d31e7b0" category="cell">생성할 PV의 이름(예: PV_ose_metrics).</block>
  <block id="a3eeeafe923ac73e75b3bf33cdadb603" category="cell">'openshift_metrics_storage_volume_size</block>
  <block id="a56c731cfe96d228c7c0bcc57bc80d3d" category="cell">'openshift_metrics_cassandra_pvc_prefix'</block>
  <block id="0da919d4045e4f38d294aaec73f5d57f" category="cell">지표 PVC에 사용할 접두사입니다.</block>
  <block id="15bb3eef0b42a93e324977c289f2fd85" category="cell">'openshift_metrics_cassandra_pvc_size</block>
  <block id="75929c9d67f1407282b5618fca4589e7" category="cell">요청할 볼륨의 크기입니다.</block>
  <block id="8ebb493e0ffdf7c1e850c67bc22f15c7" category="cell">'openshift_metrics_cassandra_storage_type'</block>
  <block id="aab0ec84a4da1dfd2b63896453f1e05d" category="cell">메트릭에 사용할 스토리지 유형으로, 적절한 스토리지 클래스로 PVC를 생성하려면 Ansible에서 이를 동적 으로 설정해야 합니다.</block>
  <block id="460aaf3805271ec2e5dc35755fe317b1" category="cell">'openshift_metrics_cassanda_pvc_storage_class_name'</block>
  <block id="0c55ca33e89539cd67eb0be3796547c5" category="cell">사용할 스토리지 클래스의 이름입니다.</block>
  <block id="6c13e62eb53f29e7794d3807369299d2" category="section-title">메트릭 서비스를 구축합니다</block>
  <block id="3e75d51468f5a99fdb50b75dafea32e8" category="paragraph">호스트/인벤토리 파일에 정의된 적절한 Ansible 변수를 사용하여 서비스를 구축하십시오. OpenShift 설치 시 배포하는 경우 PV가 자동으로 생성되고 사용됩니다. OpenShift를 설치한 후 구성 요소 플레이북을 사용하여 배포하는 경우, Ansible이 필요한 PVC를 만들고 Astra Trident가 PVC를 위한 스토리지를 프로비저닝하면 서비스를 배포합니다.</block>
  <block id="bf1cadd7aa4e541e255df26af5451d85" category="inline-link-macro">RedHat의 OpenShift 배포 가이드</block>
  <block id="eb502d6483a644e9b6f61ca4719276d8" category="paragraph">위의 변수와 배포 프로세스는 각 OpenShift 버전에 따라 변경될 수 있습니다. 검토 후 준수해야 합니다 <block ref="5ad72ffc1eda2c257c8947a0ad66dddb" category="inline-link-macro-rx"></block> 사용자 환경에 맞게 구성되도록 사용자의 버전에 대해.</block>
  <block id="6e8775bd755a8835ce86806d669677ea" category="doc">스토리지 구성</block>
  <block id="4d59d193e356ef0157daf2c1fc0a6dd6" category="paragraph">NetApp 포트폴리오의 각 스토리지 플랫폼은 컨테이너식으로 애플리케이션에 이점을 제공하는 고유한 기능을 제공합니다. Trident는 ONTAP, Element, E-Series의 각 주요 플랫폼에서 작동합니다. 모든 애플리케이션과 시나리오에 적합한 플랫폼이 한 개 있는 것은 아니지만, 플랫폼을 선택할 때 애플리케이션과 장치를 관리하는 팀의 요구 사항을 고려해야 합니다.</block>
  <block id="ac5112696fd64ee051846c666ebebebe" category="paragraph">활용 중인 프로토콜을 사용하여 호스트 운영 체제의 기준 모범 사례를 따라야 합니다. 필요에 따라 특정 애플리케이션에 맞게 스토리지를 최적화할 수 있도록 백엔드, 스토리지 클래스 및 PVC 설정과 함께 사용 가능한 경우 애플리케이션 Best Practice를 통합하는 것을 고려할 수 있습니다.</block>
  <block id="efc9d085ca2f3a152c786357e9359c03" category="section-title">ONTAP 및 Cloud Volumes ONTAP 모범 사례</block>
  <block id="a3f99d5d44515cf922e6b525de736173" category="paragraph">Trident를 위한 ONTAP 및 Cloud Volumes ONTAP를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="76d50c7d0f100e6264e0d57727d099f1" category="paragraph">다음 권장 사항은 Trident에서 동적으로 프로비저닝되는 볼륨을 사용하는 컨테이너식 워크로드에 대한 ONTAP 구성 지침입니다. 각 항목을 고려하여 작업 환경의 적절성을 판단해야 합니다.</block>
  <block id="3fb21976d2729216782dd61ffed84a54" category="section-title">Trident 전용 SVM을 사용하십시오</block>
  <block id="fa4e21d3612a3f737c7a4ac7ebf24950" category="paragraph">SVM(스토리지 가상 시스템)은 ONTAP 시스템의 테넌트 간에 격리하고 관리를 제공합니다. SVM을 애플리케이션 전용으로 사용하면 권한을 위임하고 리소스 사용을 제한하는 모범 사례를 적용할 수 있습니다.</block>
  <block id="3dc5510a67688b81f0d6d0db440da909" category="paragraph">SVM 관리를 위해 몇 가지 옵션을 사용할 수 있습니다.</block>
  <block id="fe425a9419fa4d05d42131c26306e4f1" category="list-text">백엔드 구성에서 클러스터 관리 인터페이스를 적절한 자격 증명과 함께 제공하고 SVM 이름을 지정합니다.</block>
  <block id="e2160df70bcda0ee43cb3c66dc22c719" category="list-text">ONTAP System Manager 또는 CLI를 사용하여 SVM을 위한 전용 관리 인터페이스를 생성합니다.</block>
  <block id="2bf2fa2c1c3a6e10095db72759cc9983" category="list-text">관리 역할을 NFS 데이터 인터페이스와 공유합니다.</block>
  <block id="5cf4c2e89b362842d77f4e4209c4ef99" category="paragraph">각 경우 인터페이스가 DNS에 있어야 하며, Trident를 구성할 때 DNS 이름을 사용해야 합니다. 이렇게 하면 네트워크 ID 보존을 사용하지 않고 SVM-DR과 같은 일부 DR 시나리오를 간편하게 수행할 수 있습니다.</block>
  <block id="6a392b5e005fffe32231c94dc96a1605" category="inline-link">SVM-DR</block>
  <block id="2b4a6ee2db063653d6076884295a3854" category="paragraph">SVM에 전용 또는 공유 관리 LIF를 사용하는 것이 더 이상 선호되지 않지만, 선택한 접근 방식에 맞게 네트워크 보안 정책을 조정해야 합니다. 관리 LIF는 DNS를 통해 액세스할 수 있어야 하며, 유연성을 극대화해야 합니다<block ref="f5e9502989ce78934689806ebb69606a" category="inline-link-rx"></block> Trident와 함께 사용합니다.</block>
  <block id="4a0ee008d3379206a925ade3a9e707dd" category="section-title">최대 볼륨 수를 제한합니다</block>
  <block id="e5e09031843479ef9ef8cbbd4c2f404c" category="inline-link">NetApp Hardware Universe를 참조하십시오</block>
  <block id="400a5d259a812effb5b7df506bf020ef" category="paragraph">ONTAP 스토리지 시스템의 최대 볼륨 수는 소프트웨어 버전과 하드웨어 플랫폼에 따라 다릅니다. 을 참조하십시오<block ref="bb9c67b5a4c15a85b5e6aa6c9afd0285" category="inline-link-rx"></block> 정확한 제한을 결정하는 특정 플랫폼 및 ONTAP 버전. 볼륨 수가 소진되면 프로비저닝 작업이 Trident뿐 아니라 모든 스토리지 요청에 대해 실패합니다.</block>
  <block id="39da19b7dd55941b6cdabf34befc0b4c" category="paragraph">Trident의 'ONTAP-NAS' 및 'ONTAP-SAN' 드라이버는 생성되는 각 Kubernetes 영구 볼륨(PV)에 대해 FlexVolume을 프로비저닝합니다. 'ONTAP-NAS-이코노미' 드라이버는 200개의 PVS에 대해 약 1개의 FlexVolume을 생성합니다(50개에서 300개로 구성 가능). 'ONTAP-SAN-이코노미' 드라이버는 PVS 100대당 약 1개의 FlexVolume을 생성합니다(50개에서 200개로 구성 가능). Trident가 스토리지 시스템에서 사용 가능한 모든 볼륨을 사용하지 않도록 하려면 SVM에 제한을 설정해야 합니다. 이 작업은 명령줄에서 수행할 수 있습니다.</block>
  <block id="f36680e3d3cb96c74d2f1a54c3c4a0fa" category="paragraph">'최대 볼륨'의 값은 환경에 따라 몇 가지 기준에 따라 달라집니다.</block>
  <block id="5f6d1abb6889904ee0375b2fc6c8f078" category="list-text">ONTAP 클러스터에 있는 기존 볼륨의 수입니다</block>
  <block id="029383c13d9ad2c5ba18a16f8fbe2002" category="list-text">다른 애플리케이션에 대해 Trident 외부에 프로비저닝할 것으로 예상되는 볼륨 수입니다</block>
  <block id="02f4ac473b944a63551d51d727b5bb49" category="list-text">Kubernetes 애플리케이션에서 사용할 것으로 예상되는 영구 볼륨의 수입니다</block>
  <block id="1d3555f20ac0a2897a1596631b5fb27a" category="paragraph">max-volumes 값은 개별 ONTAP 노드가 아닌 ONTAP 클러스터의 모든 노드에 프로비저닝된 총 볼륨입니다. 결과적으로, ONTAP 클러스터 노드에 다른 노드보다 훨씬 더 많은 Trident 프로비저닝 볼륨이 있을 수 있는 몇 가지 조건이 발생할 수 있습니다.</block>
  <block id="46710fe77f663864a23e02a880a9ae53" category="inline-link">애그리게이트</block>
  <block id="8eb27359ed8f69eb07c318fcd224ba66" category="paragraph">예를 들어, 2노드 ONTAP 클러스터에는 최대 2000개의 FlexVolumes를 호스팅할 수 있는 기능이 있습니다. 최대 볼륨 수를 1250으로 설정하면 매우 적절합니다. 그러나, 단 인 경우<block ref="acf6cbef6ee0ef07ee3fe13269233be8" category="inline-link-rx"></block> 한 노드에서 SVM에 할당하거나, 한 노드에서 할당된 애그리게이트는 용량 등으로 인해 프로비저닝할 수 없는 경우, 다른 노드는 프로비저닝된 모든 Trident 볼륨의 타겟이 됩니다. 즉, '최대 볼륨' 값에 도달하기 전에 해당 노드에 대한 볼륨 제한에 도달하여 Trident와 해당 노드를 사용하는 다른 볼륨 작업에 영향을 줄 수 있습니다. * 클러스터의 각 노드에서 애그리게이트가 동일한 수의 Trident가 사용하는 SVM에 할당되도록 하면 이러한 상황을 방지할 수 있습니다. *</block>
  <block id="7ef3217c984ef7f973d389e434be312c" category="section-title">Trident에서 생성한 볼륨의 최대 크기를 제한합니다</block>
  <block id="031b203330c3abb94f6fa406ff721de4" category="paragraph">Trident에서 생성할 수 있는 볼륨의 최대 크기를 구성하려면 'backend.json' 정의에 있는 'limitVolumeSize' 매개 변수를 사용하십시오.</block>
  <block id="1c19414de17c9992b25b0a1b02a52715" category="paragraph">스토리지 어레이에서 볼륨 크기를 제어하는 것 외에도 Kubernetes 기능을 활용해야 합니다.</block>
  <block id="85c0f9773e01224a56713ea4e6d83b86" category="section-title">양방향 CHAP를 사용하도록 Trident를 구성합니다</block>
  <block id="8b7c80a4394c7e64aa891100d57a755f" category="paragraph">백엔드 정의에 CHAP 이니시에이터와 타겟 사용자 이름 및 암호를 지정하고 SVM에서 Trident가 CHAP를 사용하도록 설정할 수 있습니다. 백엔드 구성의 "useCHAP" 매개 변수를 사용하여 Trident는 CHAP로 ONTAP 백엔드에 대한 iSCSI 연결을 인증합니다. 양방향 CHAP 지원은 Trident 20.04 이상에서 사용할 수 있습니다.</block>
  <block id="2596e59ce5cd0d1b0066656f191365d0" category="section-title">SVM QoS 정책을 생성하고 사용합니다</block>
  <block id="560417d4f795b7e1176a40db8e4ccca8" category="inline-link">괴롭힘을 방지합니다</block>
  <block id="4870168b0713fe3089cf587858fc3b40" category="paragraph">SVM에 적용되는 ONTAP QoS 정책을 활용하여 Trident에서 프로비저닝된 볼륨에서 사용할 수 있는 IOPS 수를 제한합니다. 그러면 에 도움이 됩니다<block ref="1b59d76842e8b78d6111d3e73e9cd404" category="inline-link-rx"></block> 또는 Trident SVM 외부의 워크로드에 영향을 주지 않는 제어 컨테이너</block>
  <block id="d6ab867679686745d96bea839929a6de" category="paragraph">몇 가지 단계로 SVM에 대한 QoS 정책을 생성할 수 있습니다. 가장 정확한 정보는 사용 중인 ONTAP 버전 설명서를 참조하십시오. 아래 예는 SVM에 사용 가능한 총 IOPS를 5000으로 제한하는 QoS 정책을 생성합니다.</block>
  <block id="c790de304b7ca0097f2133cf9da4e657" category="paragraph">또한 사용하는 ONTAP 버전에서 지원하는 경우에는 최소 QoS를 사용하여 컨테이너화된 워크로드에 대한 처리량을 보장하는 것을 고려할 수 있습니다. 적응형 QoS는 SVM 레벨 정책과 호환되지 않습니다.</block>
  <block id="38c0b69f6b2ee691e1ba568134513414" category="paragraph">컨테이너화된 워크로드 전용 IOPS 수는 다양한 측면에 따라 다릅니다. 그 밖의 다른 사항으로는 다음과 같은 것들이 있습니다.</block>
  <block id="ddbd18591c9b7378c6187dbd9179e1f0" category="list-text">기타 워크로드는 스토리지 어레이를 사용합니다. 스토리지 리소스를 활용하여 Kubernetes 구축과 관련되지 않은 다른 워크로드가 있는 경우, 해당 워크로드가 실수로 영향을 받지 않도록 주의해야 합니다.</block>
  <block id="5da5727b396cee5b024364d989fe253b" category="list-text">컨테이너에서 실행 중인 예상 워크로드 IOPS 요구사항이 높은 워크로드를 컨테이너에서 실행할 경우 QoS 정책이 낮으면 잘못된 경험이 될 수 있습니다.</block>
  <block id="e6f229b5d5d2421c4306920759828212" category="paragraph">SVM 레벨에서 할당된 QoS 정책을 사용하면 동일한 IOPS 풀을 공유하는 SVM에 프로비저닝된 모든 볼륨이 생성된다는 점을 기억해야 합니다. 컨테이너화된 애플리케이션 중 하나 또는 그 수가 적은 경우 높은 IOPS 요구사항이 있으면 다른 컨테이너화된 워크로드에 문제가 될 수 있습니다. 이 경우 외부 자동화를 사용하여 볼륨당 QoS 정책을 할당하는 것을 고려할 수 있습니다.</block>
  <block id="ac2167b1e02d575eb6ddfe4e58f5cdcf" category="admonition">ONTAP 버전이 9.8 이전인 경우 SVM * 에만 QoS 정책 그룹을 할당해야 합니다.</block>
  <block id="9992cae6c17055c750a849c5f6135eb2" category="section-title">Trident에 대한 QoS 정책 그룹을 생성합니다</block>
  <block id="76a3e54f72b3a7224429f111e58f836c" category="inline-link">QoS를 통해 처리량 보장</block>
  <block id="edb2313b52b4c42008f0531bd6a05e49" category="paragraph">QoS(서비스 품질)는 경쟁 워크로드로부터 주요 워크로드의 성능이 저하되지 않도록 보장합니다. ONTAP QoS 정책 그룹은 볼륨에 대한 QoS 옵션을 제공하고 사용자가 하나 이상의 워크로드에 대한 처리량 한도를 정의할 수 있도록 지원합니다. QoS에 대한 자세한 내용은 를 참조하십시오<block ref="721a1778a2025ec5868484b3888c0186" category="inline-link-rx"></block>. 백엔드에서 또는 스토리지 풀에 QoS 정책 그룹을 지정할 수 있으며, 이러한 그룹은 해당 풀 또는 백엔드에서 생성된 각 볼륨에 적용됩니다.</block>
  <block id="0394fb1288eac4cd3d40bcd991e079e9" category="paragraph">ONTAP에는 기존 QoS 정책과 적응형 서비스 두 가지 QoS 정책 그룹이 있습니다. 기존 정책 그룹은 IOPS 단위로 최대 또는 최소 단위의 고정 처리량을 제공합니다. 적응형 QoS는 워크로드 크기에 따라 처리량을 자동으로 확장하므로 워크로드 크기에 따라 IOPS와 TB|GB의 비율을 유지합니다. 따라서 대규모 구축 환경에서 수백 또는 수천 개의 워크로드를 관리할 경우 상당한 이점이 있습니다.</block>
  <block id="f5acc65a21daed9bb8e91cb5cdd0ae52" category="paragraph">QoS 정책 그룹을 생성할 때는 다음 사항을 고려하십시오.</block>
  <block id="6d5fcf300cd9e9239c26ce37b0919fca" category="list-text">백엔드 구성의 "deefaults" 블록에 qosPolicy 키를 설정해야 합니다. 다음 백엔드 구성 예를 참조하십시오.</block>
  <block id="32160c2368452bf7d86bcffae7f142be" category="list-text">각 볼륨이 정책 그룹에서 지정한 전체 처리량을 얻을 수 있도록 볼륨별로 정책 그룹을 적용해야 합니다. 공유 정책 그룹은 지원되지 않습니다.</block>
  <block id="b2365e059850d5e32885189655bf469c" category="inline-link">ONTAP 9.8 QoS 명령</block>
  <block id="23225608cf33a6c6a4aec9126514b0e1" category="paragraph">QoS 정책 그룹에 대한 자세한 내용은 을 참조하십시오<block ref="40468e984a92fba9003857701268163a" category="inline-link-rx"></block>.</block>
  <block id="d5d2a5bc92eea85a4dd11a642ed8a170" category="section-title">스토리지 리소스에 대한 액세스 권한을 Kubernetes 클러스터 구성원으로 제한합니다</block>
  <block id="0f2b74d1b972675eb3d4efe7d8c3ed16" category="paragraph">Trident에서 생성한 NFS 볼륨 및 iSCSI LUN에 대한 액세스를 제한하는 것은 Kubernetes 구축을 위한 보안 환경의 중요한 구성요소입니다. 이렇게 하면 Kubernetes 클러스터의 일부가 아닌 호스트가 볼륨에 액세스하고 예기치 않게 데이터를 수정하는 것을 방지할 수 있습니다.</block>
  <block id="9602ec8691c1a564016f9fd8086139f1" category="paragraph">네임스페이스가 Kubernetes의 리소스에 대한 논리적 경계라는 것을 이해하는 것이 중요합니다. 동일한 네임스페이스의 리소스를 공유할 수 있다고 가정하지만, 특히 상호 네임스페이스 기능이 없다는 것이 중요합니다. 즉, PVS는 글로벌 객체이지만 PVC에 바인딩되면 동일한 네임스페이스에 있는 Pod에서만 액세스할 수 있습니다. * 적절한 경우 네임스페이스를 사용하여 구분을 제공하는 것이 중요합니다. *</block>
  <block id="13d28e8dfc702e3456e0767dff9a128a" category="inline-link">네임스페이스</block>
  <block id="1162be0546226cff2cbd973cd2140d33" category="paragraph">Kubernetes 컨텍스트에서 데이터 보안과 관련하여 대부분의 조직은 컨테이너 내의 프로세스가 호스트에 마운트된 스토리지에 액세스할 수 있지만 컨테이너용 프로세스는 아닙니다. <block ref="962cfea7b49ca7b2d398d891b4313cb5" category="inline-link-rx"></block> 이러한 유형의 손상을 방지하도록 설계되었습니다. 그러나 권한 있는 컨테이너에는 한 가지 예외가 있습니다.</block>
  <block id="7b10e929cc2e0061dfb50042a0203c79" category="inline-link">POD 보안 정책</block>
  <block id="76db1afb772160283f7f86cdd67c35f8" category="paragraph">권한 있는 컨테이너는 일반적인 것보다 훨씬 더 많은 호스트 수준 권한으로 실행되는 컨테이너입니다. 이러한 기능은 기본적으로 거부되지 않으므로 을 사용하여 기능을 사용하지 않도록 설정해야 합니다<block ref="e5ab4ede40a4a6a5f5684247585b5fb0" category="inline-link-rx"></block>.</block>
  <block id="5fabba1d91abcfb09b6049897727e91c" category="paragraph">Kubernetes 및 외부 호스트 모두에서 액세스가 필요한 볼륨의 경우, Trident에서 관리하지 않고 관리자가 PV를 도입한 상태로 스토리지를 기존 방식으로 관리해야 합니다. 이렇게 하면 Kubernetes 및 외부 호스트의 연결이 모두 끊기고 볼륨을 더 이상 사용하지 않는 경우에만 스토리지 볼륨이 폐기됩니다. 또한, 맞춤형 엑스포트 정책을 적용하여 Kubernetes 클러스터 노드 및 Kubernetes 클러스터 외부의 타겟 서버에서 액세스할 수 있습니다.</block>
  <block id="4b4f0cfc14f082f2397c1c96efa18fc1" category="paragraph">전용 인프라 노드(예: OpenShift) 또는 사용자 애플리케이션을 위해 스케줄링할 수 없는 다른 노드가 있는 배포의 경우 별도의 엑스포트 정책을 사용하여 스토리지 리소스에 대한 액세스를 더욱 제한해야 합니다. 여기에는 해당 인프라 노드에 배포된 서비스(예: OpenShift Metrics 및 Logging 서비스)에 대한 엑스포트 정책과 비인프라 노드에 배포되는 표준 애플리케이션이 포함됩니다.</block>
  <block id="e38f5be5ff6a8a362870a032acdf5d2f" category="section-title">전용 엑스포트 정책을 사용하십시오</block>
  <block id="2f05855ad489343ae535c8f17eaa6f34" category="paragraph">Kubernetes 클러스터에 있는 노드에만 액세스할 수 있도록 각 백엔드에 대한 엑스포트 정책이 있어야 합니다. Trident는 20.04 릴리스부터 내보내기 정책을 자동으로 생성하고 관리할 수 있습니다. 이러한 방법으로 Trident는 Kubernetes 클러스터의 노드에 프로비저닝되는 볼륨에 대한 액세스를 제한하고 노드 추가/삭제를 단순화합니다.</block>
  <block id="28af9e32119f59018dd5d887ad93ccd4" category="paragraph">또는 수동으로 엑스포트 정책을 생성하여 각 노드 액세스 요청을 처리하는 하나 이상의 엑스포트 규칙으로 채울 수도 있습니다.</block>
  <block id="4ae1e64986504dce6897746ebc9d2786" category="list-text">vserver export-policy create ONTAP CLI 명령을 사용하여 엑스포트 정책을 생성합니다.</block>
  <block id="cd0a9fca1fb3ba0fcdd98d0e87cb78a9" category="list-text">vserver export-policy rule create ONTAP CLI 명령을 사용하여 엑스포트 정책에 규칙을 추가합니다.</block>
  <block id="bc3a2f6421da1e870583cfb0b9cf4a91" category="paragraph">이러한 명령을 실행하면 데이터에 액세스할 수 있는 Kubernetes 노드를 제한할 수 있습니다.</block>
  <block id="bd82c82b218c96acc3c66f92a723ce74" category="section-title">SVM 애플리케이션 쇼마운트를 해제합니다</block>
  <block id="613655fb3db9bdbe0f795ee9424fc1fe" category="paragraph">'howmount' 기능을 사용하면 NFS 클라이언트가 SVM을 쿼리하여 사용 가능한 NFS 내보내기 목록을 확인할 수 있습니다. Kubernetes 클러스터에 구축된 POD는 데이터 LIF에 대해 'howmount -e' 명령을 실행하여 액세스할 수 없는 마운트를 비롯한 사용 가능한 마운트 목록을 받을 수 있습니다. 이는 그 자체로 보안 문제가 아니라, 권한이 없는 사용자가 NFS 내보내기에 연결하는 데 도움이 될 수 있는 불필요한 정보를 제공합니다.</block>
  <block id="08f1d9a2f49f56965b640bc15796cd61" category="paragraph">SVM 레벨의 ONTAP CLI 명령을 사용하여 'howmount'를 비활성화해야 합니다.</block>
  <block id="648e0e1a6a98e76bdfe9780c42dacb6b" category="section-title">SolidFire 모범 사례</block>
  <block id="89f93e411a40f5c6365a4703e004f15b" category="paragraph">Trident를 위한 SolidFire 스토리지를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="52f311b56fcd9d4fb074918af9b7c7f9" category="section-title">SolidFire 계정을 만듭니다</block>
  <block id="b0dd2707e9f12b5e1fda314748ffa386" category="paragraph">각 SolidFire 계정은 고유한 볼륨 소유자를 나타내며 자체 CHAP(Challenge-Handshake 인증 프로토콜) 자격 증명을 받습니다. 계정 이름 및 상대 CHAP 자격 증명을 사용하거나 볼륨 액세스 그룹을 통해 계정에 할당된 볼륨에 액세스할 수 있습니다. 계정에는 최대 2천 개의 볼륨이 할당될 수 있지만 볼륨은 하나의 계정에만 속할 수 있습니다.</block>
  <block id="eaf4b71058f7db58997dfe694c62a96a" category="section-title">QoS 정책을 생성합니다</block>
  <block id="fd640dfd679c3a7e40aa99c3e08c8294" category="paragraph">여러 볼륨에 적용할 수 있는 표준화된 서비스 품질 설정을 만들어 저장하려면 SolidFire 서비스 품질(QoS) 정책을 사용하십시오.</block>
  <block id="41be5238fc563c2aac0a0e6ee4cf6e96" category="paragraph">볼륨별로 QoS 매개 변수를 설정할 수 있습니다. QoS를 정의하는 세 가지 구성 가능한 매개 변수, 즉 Min IOPS, Max IOPS, Burst IOPS를 설정하여 각 볼륨의 성능을 보장할 수 있습니다.</block>
  <block id="48e4bd34fd7a9e1233ea82bc818a3161" category="paragraph">4KB 블록 크기에 대해 가능한 최소, 최대 및 버스트 IOPS 값입니다.</block>
  <block id="8e4988a1e5f387efce6f20e4f25a8e40" category="cell">IOPS 매개 변수입니다</block>
  <block id="0b890b1926b90387673882e6ccae7fdc" category="cell">정의</block>
  <block id="96a22bf638896c990d26e043087fb6b0" category="cell">최소 값</block>
  <block id="31ce3cdcd67850870b616f75b555bbc5" category="cell">기본값</block>
  <block id="c9fb55be94277b8390352c215f32d44c" category="cell">최대 가치(4KB)</block>
  <block id="b05f9ccd772b396ac1f5a05345a9d4f8" category="paragraph">최소 IOPS</block>
  <block id="2b30c179facf62f8a2bdbd1b09b37b96" category="paragraph">볼륨에 대한 보장된 성능 수준.</block>
  <block id="c0c7c76d30bd3dcaefc96f40275bdc0a" category="cell">50</block>
  <block id="3f74a886c7f841699690962c497d4f30" category="paragraph">15000</block>
  <block id="4f5a6f8b41826526724ba294b8e056bd" category="paragraph">최대 IOPS</block>
  <block id="4e41c5ccaf1affa697729ea4d1e88554" category="paragraph">성능은 이 제한을 초과하지 않습니다.</block>
  <block id="e05695d29cb4a9339534e5a9c273fa14" category="paragraph">200,000</block>
  <block id="affd4aba1c5f696e972368c9eb698c65" category="paragraph">버스트 IOPS</block>
  <block id="2734923c054f38d8ca66133414af4469" category="paragraph">짧은 버스트 시나리오에서 허용되는 최대 IOPS입니다.</block>
  <block id="e2eb05f1ef7720127ac371ceddc6f433" category="admonition">최대 IOPS와 버스트 IOPS는 최대 200,000으로 설정할 수 있지만, 실제 볼륨의 최대 성능은 클러스터 사용량 및 노드당 성능에 의해 제한됩니다.</block>
  <block id="fa9b1a3006e0ba9ad904c059c0b9add6" category="inline-link">SolidFire 서비스 품질</block>
  <block id="7363485d4653963c22d3ed43afd0003a" category="paragraph">블록 크기와 대역폭은 IOPS 수에 직접적인 영향을 미칩니다. 블록 크기가 증가함에 따라 시스템에서 더 큰 블록 크기를 처리하는 데 필요한 수준까지 대역폭을 높일 수 있습니다. 대역폭이 증가할수록 시스템에서 달성할 수 있는 IOPS의 수가 감소합니다. 을 참조하십시오<block ref="c8976c50ed9f016849fdce232777cd31" category="inline-link-rx"></block> QoS 및 성능에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="b4657825f74ed622384dddf3a1d7d3b7" category="section-title">SolidFire 인증</block>
  <block id="9d3b5ff1cde828a63203f0465a34a967" category="paragraph">요소는 CHAP 및 vag(볼륨 액세스 그룹)의 두 가지 인증 방법을 지원합니다. CHAP는 CHAP 프로토콜을 사용하여 호스트를 백엔드에 인증합니다. 볼륨 액세스 그룹은 프로비전되는 볼륨에 대한 액세스를 제어합니다. NetApp은 CHAP를 사용하여 인증을 수행하는 것이 더 간단하고 확장 제한이 없기 때문에 CHAP를 사용하는 것이 좋습니다.</block>
  <block id="fc9e812321a3f9b0eab1b702a08bab4e" category="admonition">CSI 프로비저닝이 강화된 Trident는 CHAP 인증 사용을 지원합니다. VAG는 일반적인 비 CSI 작동 모드에서만 사용해야 합니다.</block>
  <block id="d23eaa75b7bd1405526da0e18b7290ac" category="paragraph">CHAP 인증(이니시에이터가 대상 볼륨 사용자인지 확인)은 계정 기반 액세스 제어에서만 지원됩니다. CHAP를 인증에 사용하는 경우 단방향 CHAP 및 양방향 CHAP의 두 가지 옵션을 사용할 수 있습니다. 단방향 CHAP는 SolidFire 계정 이름 및 이니시에이터 암호를 사용하여 볼륨 액세스를 인증합니다. 양방향 CHAP 옵션은 볼륨이 계정 이름과 이니시에이터 암호를 통해 호스트를 인증한 다음 호스트가 계정 이름과 타겟 암호를 통해 볼륨을 인증하기 때문에 볼륨을 인증하는 가장 안전한 방법을 제공합니다.</block>
  <block id="42d135bea104c1079cebd1543c89e970" category="paragraph">그러나 CHAP를 설정할 수 없고 VAG가 필요한 경우 액세스 그룹을 생성하고 호스트 이니시에이터 및 볼륨을 액세스 그룹에 추가합니다. 액세스 그룹에 추가하는 각 IQN은 CHAP 인증을 사용하거나 사용하지 않고 그룹의 각 볼륨에 액세스할 수 있습니다. iSCSI 이니시에이터가 CHAP 인증을 사용하도록 구성된 경우 계정 기반 액세스 제어가 사용됩니다. iSCSI 초기자가 CHAP 인증을 사용하도록 구성되지 않은 경우 볼륨 액세스 그룹 액세스 제어가 사용됩니다.</block>
  <block id="f9245b5c4618640379c5b7aca1642196" category="section-title">E-Series 모범 사례</block>
  <block id="2bd6c307c08ebf17bbd89f92953812b5" category="paragraph">Trident를 위한 E-Series 스토리지를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="c502c3645d40ca0e119a2434fc569207" category="section-title">E-Series 디스크 풀 및 볼륨 그룹</block>
  <block id="91e654e42725ff5233a96730cbb8353a" category="paragraph">요구 사항에 따라 디스크 풀 및 볼륨 그룹을 생성하고 전체 스토리지 용량을 볼륨으로 구성하고 호스트 간에 공유하는 방법을 결정합니다. 디스크 풀과 볼륨 그룹은 모두 논리적으로 그룹화되고 애플리케이션 호스트에 하나 이상의 볼륨을 제공하는 드라이브 세트로 구성되어 있습니다. 디스크 풀 또는 볼륨 그룹의 모든 드라이브는 동일한 미디어 유형이어야 합니다.</block>
  <block id="3ff82339aba03372510cbf649c88660b" category="section-title">E-Series 호스트 그룹</block>
  <block id="1d159fb9310d2d64f0e89556f5e5e92a" category="paragraph">Trident는 호스트 그룹을 사용하여 프로비저닝하는 볼륨(LUN)에 액세스합니다. 기본적으로 Trident는 구성에 다른 호스트 그룹 이름을 지정하지 않는 한 "트리덴트"라는 호스트 그룹을 사용합니다. Trident는 자체적으로 호스트 그룹을 생성하거나 관리하지 않습니다. Trident에서 E-Series 스토리지 백엔드를 설정하기 전에 호스트 그룹을 생성해야 합니다. 모든 Kubernetes 작업자 노드 iSCSI IQN 이름이 호스트 그룹에서 업데이트되었는지 확인합니다.</block>
  <block id="345b5f2b58b43a215fba679b4aff7483" category="section-title">E-Series의 스냅샷 스케줄입니다</block>
  <block id="7e496222beafc240f7c54f2e86d37419" category="paragraph">필요한 간격으로 볼륨 백업을 수행할 수 있도록 스냅샷 일정을 생성하고 Trident에서 생성한 볼륨을 스냅샷 일정에 할당합니다. 스냅샷 정책에 따라 수행된 스냅샷을 기반으로 스냅샷 이미지를 기본 볼륨으로 복원하여 볼륨에 대해 롤백 작업을 수행할 수 있습니다. SANtricity 시스템 관리자를 사용하여 스냅샷 스케줄을 생성해야 합니다.</block>
  <block id="b5dd97bf7f44d6c721a9534c1b6d4390" category="section-title">스냅샷 정합성 보장 그룹</block>
  <block id="9279a0fc4d40b361df8598208a14b586" category="paragraph">스냅샷 정합성 보장 그룹을 설정하는 것도 여러 볼륨에 걸쳐 있는 애플리케이션에 적합합니다. 정합성 보장 그룹의 목적은 여러 볼륨의 동시 스냅샷 이미지를 만들어 특정 시점에 볼륨 컬렉션 복제본의 정합성이 보장되도록 하는 것입니다. SANtricity 시스템 관리자를 사용하여 일관성 그룹을 생성해야 합니다.</block>
  <block id="1ea481e04f09f7ec7132c7773f132743" category="section-title">Cloud Volumes Service for AWS 모범 사례</block>
  <block id="17bc2586ce2fe71048cad42dbfd6049f" category="paragraph">Trident를 위한 AWS에서 Cloud Volumes Service를 구성하기 위한 모범 사례에 대해 알아보십시오.</block>
  <block id="bb53c6c29f127a298da7dd86bf00bb89" category="section-title">엑스포트 정책을 생성합니다</block>
  <block id="8e8d04641d33b2f0af7ad761af53aeb3" category="paragraph">승인된 노드 집합만 Cloud Volumes Service를 통해 프로비저닝된 볼륨에 액세스할 수 있도록 하려면 Cloud Volumes Service를 생성하는 동안 엑스포트 정책에 대한 적절한 규칙을 설정합니다. Trident를 통해 Cloud Volume Services에서 볼륨을 프로비저닝할 때 백엔드 파일의 'exportRule' 매개 변수를 사용하여 필요한 Kubernetes 노드에 대한 액세스를 제공해야 합니다.</block>
  <block id="e807ebdf213353b8a415f991a2cade81" category="section-title">스냅샷 정책을 생성합니다</block>
  <block id="07aa362ac01b2df1044db626df0e7c9b" category="paragraph">Cloud Volume Service를 통해 프로비저닝된 볼륨에 대한 스냅샷 정책을 생성하여 스냅샷이 필요한 간격으로 생성되도록 합니다. 이렇게 하면 일정한 간격으로 데이터를 백업할 수 있으며 데이터 손실이나 데이터 손상 시 데이터를 복원할 수 있습니다. 볼륨 세부 정보 페이지에서 적절한 스케줄을 선택하여 Cloud Volume Service에서 호스팅되는 볼륨에 대한 스냅샷 정책을 설정할 수 있습니다.</block>
  <block id="283a4f872d02fc8073ac706850ed948b" category="section-title">적절한 서비스 수준, 스토리지 용량 및 스토리지 대역폭을 선택합니다</block>
  <block id="3251e3b8c107f351e2d3fd9e462aba19" category="paragraph">Cloud Volume Services for AWS는 표준, 프리미엄, 익스트림 등 다양한 서비스 수준을 제공합니다. 이러한 서비스 수준은 다양한 스토리지 용량 및 스토리지 대역폭 요구 사항을 충족합니다. 비즈니스 요구 사항에 따라 적절한 서비스 수준을 선택해야 합니다.</block>
  <block id="c34374a04df0b3e2c47131fdbb5ef741" category="paragraph">애플리케이션의 특정 요구 사항에 따라 볼륨을 생성하는 동안 할당된 스토리지의 필요한 크기를 선택해야 합니다. 할당된 스토리지를 결정할 때는 다음 두 가지 요소를 고려해야 합니다.</block>
  <block id="e2ae4659e808edd54a095d9432707c2f" category="list-text">특정 애플리케이션의 스토리지 요구 사항</block>
  <block id="76ba23394d92b7a06d3ecb8582769eff" category="list-text">피크 또는 에지에 필요한 대역폭입니다</block>
  <block id="e1e4f36a86f0d5a56aa4115fed351ff5" category="paragraph">스토리지 대역폭은 선택한 서비스 수준과 할당된 용량의 조합에 따라 달라집니다. 따라서 필요한 대역폭을 염두에 두고 적절한 서비스 수준과 할당된 용량을 선택합니다.</block>
  <block id="8015d968013817a20de84963d8c695b4" category="paragraph">백엔드 구성 파일의 'limitVolumeSize' 매개 변수를 사용하여 AWS용 Cloud Volume Services의 Trident에서 생성한 볼륨의 최대 크기를 제한할 수 있습니다. 이 매개 변수를 설정하면 요청된 볼륨 크기가 설정된 값을 초과할 경우 프로비저닝이 실패합니다.</block>
  <block id="b4931a42b69dbf4e721e7b97873b1ebb" category="section-title">자세한 정보는 어디서 찾을 수 있습니까?</block>
  <block id="2c3a4d5c923121574c10ea22c0474a01" category="inline-link">NetApp 라이브러리</block>
  <block id="65840df7365892d2abe1280cb6cdb1d2" category="paragraph">다음은 몇 가지 모범 사례 문서입니다. 를 검색합니다<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 최신 버전의 경우.</block>
  <block id="d911b17f4f4cdcca62a04ad77aa9403d" category="paragraph">* ONTAP *</block>
  <block id="f9dd52d280693dc59e53b6e1fb7bd801" category="inline-link">NFS Best Practice and Implementation Guide를 참조하십시오</block>
  <block id="40bb23d54df7f59219c18f15a346d9e5" category="list-text"><block ref="40bb23d54df7f59219c18f15a346d9e5" category="inline-link-rx"></block></block>
  <block id="a76193f5d9397d9c49ca283a20ccf649" category="inline-link">SAN 관리 가이드를 참조하십시오</block>
  <block id="5bc9b097037d45aff954bf9bd632d4a4" category="list-text"><block ref="c745f55eb0c9991966e63f0608541bb1" category="inline-link-rx"></block> (iSCSI의 경우)</block>
  <block id="5ca34d6ffc2a555b689542e3fbeeb7af" category="inline-link">RHEL용 iSCSI Express 구성</block>
  <block id="36588ac65dcdb9b93916fb0ab708edb3" category="list-text"><block ref="36588ac65dcdb9b93916fb0ab708edb3" category="inline-link-rx"></block></block>
  <block id="ca7ab5ec4cba84fbef55956bb38759ce" category="paragraph">Element 소프트웨어 *</block>
  <block id="e809d9f88c2933195c4d2ab379c1b5dc" category="inline-link">Linux용 SolidFire 구성</block>
  <block id="ce0470e08aa854a8f93fa119434e8422" category="list-text"><block ref="ce0470e08aa854a8f93fa119434e8422" category="inline-link-rx"></block></block>
  <block id="d64280eb12d42bb67976ffba6d268e7b" category="paragraph">* NetApp HCI *</block>
  <block id="3bc72bedcc42d144356d4f933c48485d" category="inline-link">NetApp HCI 구축 사전 요구 사항</block>
  <block id="85bfffc1a1f7aaabd6cf58841640c308" category="list-text"><block ref="85bfffc1a1f7aaabd6cf58841640c308" category="inline-link-rx"></block></block>
  <block id="b52e411998b7d3a95ad5bd8a320bf271" category="inline-link">NetApp 배포 엔진에 액세스합니다</block>
  <block id="9d0da73b02655dd7861121905db229e2" category="list-text"><block ref="9d0da73b02655dd7861121905db229e2" category="inline-link-rx"></block></block>
  <block id="985f6a763990196218b4750275e1f3b6" category="paragraph">E-Series * 를 통해 비즈니스 운영</block>
  <block id="db06f9adb1b570484daf34ad3bf4e257" category="inline-link">Linux용 설치 및 구성</block>
  <block id="a66f5507c8942de388ae63c7a177f7ab" category="list-text"><block ref="a66f5507c8942de388ae63c7a177f7ab" category="inline-link-rx"></block></block>
  <block id="9aaca8cfd79770bc4944ccc477e37141" category="paragraph">* 응용 프로그램 모범 사례 정보 *</block>
  <block id="27a5e02bc2fadee43ace94805739a0c8" category="inline-link">ONTAP 기반 MySQL의 모범 사례</block>
  <block id="40d2eaf9adabe99a601c57eabf49e4d3" category="list-text"><block ref="40d2eaf9adabe99a601c57eabf49e4d3" category="inline-link-rx"></block></block>
  <block id="17efdd7d210511985714be299d595292" category="inline-link">SolidFire 기반 MySQL의 모범 사례</block>
  <block id="d03b53d8ec563c37e16ee8c900a75b96" category="list-text"><block ref="d03b53d8ec563c37e16ee8c900a75b96" category="inline-link-rx"></block></block>
  <block id="3aefe1a041af945f1fe8673bf775057b" category="inline-link">NetApp SolidFire 및 Cassandra</block>
  <block id="7e2b19f6f6bd1332efe1f7a698984670" category="list-text"><block ref="7e2b19f6f6bd1332efe1f7a698984670" category="inline-link-rx"></block></block>
  <block id="6e580111d3a8c12cdcd9522a4d3484c6" category="inline-link">SolidFire에 대한 Oracle 모범 사례</block>
  <block id="6db96715cefe9c4950ef722865494128" category="list-text"><block ref="6db96715cefe9c4950ef722865494128" category="inline-link-rx"></block></block>
  <block id="6448cf37496207be126495e5b05851de" category="inline-link">SolidFire에 대한 PostgreSQL Best Practice</block>
  <block id="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="list-text"><block ref="eb2c92a9d2d39fa7191d6e84d5c33bb5" category="inline-link-rx"></block></block>
  <block id="b062996d6ca590abe798d3db75561f79" category="paragraph">모든 애플리케이션에 구체적인 지침이 있는 것은 아니며 NetApp 팀과 함께 을 사용하는 것이 중요합니다<block ref="4caccef7312f2c398bfbb419629c1a78" category="inline-link-rx"></block> 최신 설명서를 참조하십시오.</block>
  <block id="d03f8f06d8317baa619ceba8c71e0be3" category="summary">NetApp 스토리지 플랫폼이 제공하는 데이터 보호 및 복구 성능 옵션에 대해 알아보십시오. Astra Trident는 이러한 기능 중 일부를 활용할 수 있는 볼륨을 프로비저닝할 수 있습니다. 지속성 요구사항이 있는 각 애플리케이션에 대해 완전한 데이터 보호 및 복구 전략을 가져야 합니다.</block>
  <block id="7e7397a7b79323762c61941fc0e6b5f9" category="doc">데이터 보호</block>
  <block id="cfee9077e497a91b77466a20f58fcdff" category="paragraph">NetApp 스토리지 플랫폼이 제공하는 데이터 보호 및 복구 성능 옵션에 대해 알아보십시오. Astra Trident는 이러한 기능 중 일부를 활용할 수 있는 볼륨을 프로비저닝할 수 있습니다. 지속성 요구사항이 있는 각 애플리케이션에 대한 데이터 보호 및 복구 전략이 있어야 합니다.</block>
  <block id="058d5afd2ccf1b3be426f9ad27ab2f41" category="section-title">etcd 클러스터 데이터를 백업합니다</block>
  <block id="26beed33bbef26c53a76c2b450d8092c" category="paragraph">Astra Trident는 Kubernetes 클러스터의 "etcd" 데이터베이스에 메타데이터를 저장합니다. 재해 시나리오에서 Kubernetes 클러스터를 복구하려면 주기적으로 "etcd" 클러스터 데이터를 백업하는 것이 중요합니다.</block>
  <block id="6b8252dd799aef1e72351975d4d39231" category="list-text">"etcctl snapshot save" 명령을 사용하면 "etcd" 클러스터의 시점 스냅샷을 만들 수 있습니다.</block>
  <block id="54466a78f910aa9c206047e0a2afdae1" category="paragraph">이 명령은 etcd 컨테이너를 스핀업하여 etcd 스냅샷을 생성하고 이를 '/backup' 디렉토리에 저장합니다.</block>
  <block id="1475db623f0eaa95e737c3463bae738f" category="list-text">재해가 발생할 경우 etcd 스냅샷을 사용하여 Kubernetes 클러스터를 사용할 수 있습니다. "etcctl snapshot restore" 명령을 사용하여 "/var/lib/etcd" 폴더에 생성된 특정 스냅샷을 복구합니다. 복원 후 '/var/lib/etcd' 폴더가 'ember' 폴더로 채워졌는지 확인합니다. 다음은 'etcctl snapshot restore' 명령의 예입니다.</block>
  <block id="79ddedac8d398dd5b0c07d4319dcc009" category="list-text">Kubernetes 클러스터를 초기화하기 전에 필요한 인증서를 모두 복사합니다.</block>
  <block id="bdad273c35514cf4ff054dc686b32002" category="list-text">''--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 클러스터를 생성합니다.</block>
  <block id="6305ecb03aa7de9ef25f8415e859ea4b" category="list-text">클러스터가 완료되면 kubbe-system 포드가 시작되었는지 확인합니다.</block>
  <block id="8c416419987890cfcc65ea9e92da3cfa" category="list-text">Trident에서 만든 사용자 지정 리소스가 있는지 확인하고 Trident 개체를 검색하여 모든 데이터를 사용할 수 있는지 확인하려면 "kubbeck get CRD" 명령을 사용합니다.</block>
  <block id="e5356885fecc2a90a54498a26b14b810" category="section-title">ONTAP 스냅샷을 사용하여 날짜를 복구합니다</block>
  <block id="c311aef86a7cd24a1d8755988091889b" category="paragraph">스냅샷은 애플리케이션 데이터에 대한 시점 복구 옵션을 제공하여 중요한 역할을 합니다. 그러나 스냅샷은 자체적으로 백업되는 것이 아니며, 스토리지 시스템 장애나 기타 재난으로부터 데이터를 보호하지 않습니다. 그러나 대부분의 경우 데이터를 쉽고 빠르고 쉽게 복구할 수 있습니다. ONTAP 스냅샷 기술을 사용하여 볼륨을 백업하는 방법과 복원하는 방법에 대해 알아보십시오.</block>
  <block id="f0587fe4869074d7cfefe4e8bf02eaeb" category="list-text">백엔드에 스냅샷 정책이 정의되지 않은 경우 기본적으로 "없음" 정책을 사용합니다. 이로 인해 ONTAP에서 자동 스냅샷이 생성되지 않습니다. 그러나 스토리지 관리자는 ONTAP 관리 인터페이스를 통해 수동 스냅샷을 생성하거나 스냅샷 정책을 변경할 수 있습니다. Trident 작업에는 영향을 주지 않습니다.</block>
  <block id="a5198a3ff669782d450e222946ec0482" category="list-text">스냅샷 디렉토리는 기본적으로 숨겨져 있습니다. 이를 통해 ONTAP-NAS와 ONTAP-NAS-이코노미 드라이버를 사용하여 프로비저닝된 볼륨의 호환성을 극대화할 수 있습니다. ONTAP-NAS 및 ONTAP-NAS-이코노미 드라이버를 사용할 경우 애플리케이션에서 스냅샷의 데이터를 직접 복구할 수 있도록 `.snapshot' 디렉터리를 활성화합니다.</block>
  <block id="d34d16e8f00776a7cc63851ebd4e9395" category="list-text">'volume snapshot restore' ONTAP CLI 명령을 사용하여 이전 스냅샷에 기록된 상태로 볼륨을 복원합니다. 스냅샷 복사본을 복구할 때 복구 작업은 기존 볼륨 구성을 덮어씁니다. 스냅샷 복사본이 생성된 후 볼륨의 데이터에 대한 모든 변경 사항은 손실됩니다.</block>
  <block id="3225a41cc13787a78ef89153b870bffe" category="section-title">ONTAP를 사용하여 데이터 복제</block>
  <block id="5bec6ef5bd67015d1da2f04dc2a24b80" category="paragraph">스토리지 시스템 장애로 인한 데이터 손실로부터 데이터를 복제하는 것은 중요한 역할을 할 수 있습니다.</block>
  <block id="eb75aeb3b4b2b9734ba3e52f5483f0b2" category="inline-link">ONTAP 설명서</block>
  <block id="40491088e02d790071b9ddbc3f95f983" category="admonition">ONTAP 복제 기술에 대한 자세한 내용은 를 참조하십시오<block ref="dd7cb2553dd5eb568b9a23ce332fc9a4" category="inline-link-rx"></block>.</block>
  <block id="541959f741a3180066a37aee2adf7d01" category="section-title">SnapMirror SVM(Storage Virtual Machines) 복제</block>
  <block id="794cb725c5631ad99b5b7c000307f0df" category="inline-link">SnapMirror를 참조하십시오</block>
  <block id="15bf9c06ed0c503c4ee904bf4b3a85a9" category="paragraph">을 사용할 수 있습니다<block ref="a2a4907c93db22784422a1bc7047ac73" category="inline-link-rx"></block> 전체 SVM을 복제하며, 여기에는 구성 설정 및 볼륨이 포함됩니다. 재해가 발생할 경우 SnapMirror 대상 SVM을 활성화하여 데이터 제공을 시작할 수 있습니다. 시스템이 복원되면 기본 시스템으로 다시 전환할 수 있습니다.</block>
  <block id="8657190fa7a98fbc200c5c90a08cac65" category="paragraph">Astra Trident는 복제 관계 자체를 구성할 수 없기 때문에 스토리지 관리자는 ONTAP의 SnapMirror SVM 복제 기능을 사용하여 DR(재해 복구) 대상에 볼륨을 자동으로 복제할 수 있습니다.</block>
  <block id="bdb161b363522f5fc614f70c10792020" category="paragraph">SnapMirror SVM 복제 기능을 사용할 계획이거나 현재 기능을 사용 중인 경우 다음을 고려하십시오.</block>
  <block id="34fb9af35ab36a2cead16ad98b140441" category="list-text">SVM-DR이 활성화된 각 SVM에 대해 별개의 백엔드를 생성해야 합니다.</block>
  <block id="1c0b44a5294fd1ebbc8e78476cf29358" category="list-text">필요한 경우를 제외하고 복제된 백엔드를 선택하지 않도록 스토리지 클래스를 구성해야 합니다. 이는 SVM-DR을 지원하는 백엔드에 복제 관계를 프로비저닝하지 않아도 되는 볼륨이 생기지 않도록 하는 데 중요합니다.</block>
  <block id="21f180602301e7ac5b6cce6b6b7399e9" category="list-text">애플리케이션 관리자는 데이터 복제와 관련된 추가 비용 및 복잡성을 이해하고 데이터 복제를 활용하기 전에 복구 계획을 결정해야 합니다.</block>
  <block id="59b50d3d22a40bf39d0e648e2d49092c" category="list-text">SnapMirror 대상 SVM을 활성화하기 전에 예약된 SnapMirror 전송을 모두 중지하고, 진행 중인 SnapMirror 전송을 모두 중단하고, 복제 관계를 중지하고, 소스 SVM을 중지한 다음, SnapMirror 대상 SVM을 시작하십시오.</block>
  <block id="7cf7bfd0b57a375894c362efd521d4a6" category="list-text">Astra Trident는 SVM 장애를 자동으로 감지하지 않습니다. 따라서 장애가 발생하면 관리자는 'tridentctl backend update' 명령을 실행하여 Trident가 새 백엔드로 장애 조치를 트리거해야 합니다.</block>
  <block id="1904adbabdda29d7a5ab43352f36c6ed" category="paragraph">다음은 SVM 설정 단계에 대한 개요입니다.</block>
  <block id="3c2f5fc4909af1c1359e564eb6db48b0" category="list-text">소스 클러스터와 타겟 클러스터 및 SVM 간 피어링을 설정합니다.</block>
  <block id="3b1329fc73441b5a106271d6f3497f1e" category="list-text">'-subtype DP-destination' 옵션을 사용하여 대상 SVM을 생성합니다.</block>
  <block id="2ce677015d60734da686668ee7962dd0" category="list-text">필요한 간격으로 복제가 수행되도록 복제 작업 스케줄을 생성합니다.</block>
  <block id="e9eeea68d62192550b641463a212f6f7" category="list-text">소스 SVM 구성과 소스 SVM 인터페이스가 타겟으로 복제되도록 '-identity-preserve true' 옵션을 사용하여 타겟 SVM에서 소스 SVM으로 SnapMirror 복제를 생성합니다. 대상 SVM에서 SnapMirror SVM 복제 관계를 초기화합니다.</block>
  <block id="fb45980442af5aaba98c4d47ae4d3bfd" category="image-alt">에는 SVM 설정과 관련된 단계가 나와 있습니다.</block>
  <block id="1e4e7c145198bb50a238b75b451a761f" category="section-title">Trident를 위한 재해 복구 워크플로우</block>
  <block id="b955e2b8063ba57e27a4ab2b5317f40c" category="paragraph">Astra Trident 19.07 이상 Kubernetes CRD를 사용하여 자체 상태를 저장 및 관리합니다. 이 경우 Kubernetes 클러스터의 etcd를 사용하여 메타데이터를 저장합니다. 여기에서는 Kubernetes "etcd" 데이터 파일과 인증서가 NetApp FlexVolume에 저장되어 있다고 가정합니다. 이 FlexVolume은 SVM에 상주하며 보조 사이트의 대상 SVM과 SnapMirror SVM-DR 관계가 있습니다.</block>
  <block id="cc457da166ae89d5689724340cb13732" category="paragraph">다음 단계에서는 재해 발생 시 Astra Trident를 사용하여 단일 마스터 Kubernetes 클러스터를 복구하는 방법을 설명합니다.</block>
  <block id="53ac5e7226086e14e63a8c160480dc72" category="list-text">소스 SVM에 장애가 발생하면 SnapMirror 타겟 SVM을 활성화합니다. 이렇게 하려면 예약된 SnapMirror 전송을 중지하고, 지속적인 SnapMirror 전송을 중단하고, 복제 관계를 중단하고, 소스 SVM을 중지하고, 타겟 SVM을 시작해야 합니다.</block>
  <block id="2e22b90c5468159621965197ed565e28" category="list-text">대상 SVM에서 Kubernetes "etcd" 데이터 파일 및 인증서가 포함된 볼륨을 마스터 노드로 설정할 호스트에 마운트합니다.</block>
  <block id="40d502a83976e38daa5473f7aa22abae" category="list-text">/etc/Kubernetes/pki 아래에 있는 Kubernetes 클러스터와 관련된 모든 필수 인증서를 복사하고, '/var/lib/etcd' 아래에 있는 etcd member 파일을 복사합니다.</block>
  <block id="ca8fc386b365ae9b5a3b4bbadae7d7f3" category="list-text">'--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 kubeadm init 명령을 사용하여 Kubernetes 클러스터를 생성합니다. Kubernetes 노드에 사용되는 호스트 이름은 소스 Kubernetes 클러스터와 동일해야 합니다.</block>
  <block id="e0e99766128c0aba0f0aa6c04f32348c" category="list-text">'kubeck get CRD' 명령을 실행하여 모든 Trident 사용자 지정 리소스가 표시되는지 확인하고 Trident 객체를 검색하여 모든 데이터를 사용할 수 있는지 확인합니다.</block>
  <block id="5a869093fda46649157b8eb12219a2f2" category="list-text">'./tridentctl update backend &lt;backend-name&gt; -f &lt;backend-json-file&gt; -n &lt;namespace&gt;' 명령을 실행하여 새 대상 SVM 이름을 반영하도록 필요한 모든 백엔드를 업데이트합니다.</block>
  <block id="dbd1e2ae426afc58b4818d42ea354b74" category="admonition">애플리케이션의 영구 볼륨의 경우, 대상 SVM이 활성화될 때 Trident가 프로비저닝한 모든 볼륨이 데이터 제공을 시작합니다. 위에서 설명한 단계를 사용하여 대상 측에 Kubernetes 클러스터를 설정한 후에는 모든 구축과 포드가 시작되고 패키지 애플리케이션은 문제 없이 실행되어야 합니다.</block>
  <block id="d384359ca03c8d46191c719c57744679" category="section-title">SnapMirror 볼륨 복제</block>
  <block id="118fa9a7e0f8d0db1e27394b81880427" category="paragraph">ONTAP SnapMirror 볼륨 복제는 재해 복구 기능으로, 볼륨 레벨의 운영 스토리지에서 대상 스토리지로 페일오버할 수 있도록 지원합니다. SnapMirror는 스냅샷을 동기화하여 보조 스토리지에 운영 스토리지의 볼륨 복제본 또는 미러를 생성합니다.</block>
  <block id="19f60a36276037e5b82b5096d2ba7a5c" category="paragraph">다음은 ONTAP SnapMirror 볼륨 복제 설정 단계에 대한 개요입니다.</block>
  <block id="c4e9d0a10c58301ad78e9e9bf74f9229" category="list-text">볼륨이 상주하는 클러스터와 볼륨의 데이터를 제공하는 SVM 간에 피어링을 설정합니다.</block>
  <block id="b1c132fa6284fd6d42f93781032cd962" category="list-text">관계의 동작을 제어하고 해당 관계에 대한 구성 특성을 지정하는 SnapMirror 정책을 생성합니다.</block>
  <block id="d9934e78a9254dde4a227181c30fa2d2" category="inline-link">'스냅샷 생성' 명령</block>
  <block id="0a30bcd5b223c18be449821765a8ec07" category="list-text">를 사용하여 타겟 볼륨과 소스 볼륨 사이에 SnapMirror 관계를 생성합니다<block ref="bfbfdbcdb00ddafcc3e3ca740d1d316b" category="inline-link-rx"></block> 적절한 SnapMirror 정책을 할당합니다.</block>
  <block id="20872623d19783e0dbe00afcdcb9ba46" category="list-text">SnapMirror 관계가 생성된 후 소스 볼륨에서 타겟 볼륨으로의 기본 전송이 완료되도록 관계를 초기화합니다.</block>
  <block id="af1fe101ed84f2b2bc465f0a9e92a35f" category="image-alt">에는 SnapMirror 볼륨 복제 설정이 나와 있습니다.</block>
  <block id="1d3ec4cce0f34c07e814ebbd88f5edd8" category="section-title">Trident를 위한 SnapMirror 볼륨 재해 복구 워크플로우</block>
  <block id="83e05258883cd6b92e2fe5b113f1ebc6" category="paragraph">다음 단계에서는 Astra Trident를 사용하여 단일 마스터 Kubernetes 클러스터를 복구하는 방법을 설명합니다.</block>
  <block id="b950aff3484c4c998d3b7a36ff1d6553" category="list-text">재해가 발생할 경우 예약된 SnapMirror 전송을 모두 중지하고 진행 중인 SnapMirror 전송을 모두 중단하십시오. 대상 볼륨이 읽기/쓰기가 되도록 대상 볼륨과 소스 볼륨 간의 복제 관계를 중단하십시오.</block>
  <block id="521637d2f234b6223688c168d29f6b72" category="list-text">대상 SVM에서 Kubernetes "etcd" 데이터 파일 및 인증서가 포함된 볼륨을 호스트에 마운트하고 마스터 노드로 설정됩니다.</block>
  <block id="d911c905c09c9615d35c97f404dd2884" category="list-text">'--ignore-preflight-errors=DirAvailable--var-lib-etcd' 플래그를 사용하여 "kubeadm init" 명령을 실행하여 Kubernetes 클러스터를 생성합니다. 호스트 이름은 소스 Kubernetes 클러스터와 같아야 합니다.</block>
  <block id="4b4d4e6a1634d2560e81a9a1821e2818" category="list-text">'kubeck get CRD' 명령을 실행하여 모든 Trident 사용자 지정 리소스가 검색되었는지 확인하고 Trident 객체를 검색하여 모든 데이터를 사용할 수 있는지 확인합니다.</block>
  <block id="4f04020fc477f4ade26e46ae0ba44688" category="list-text">이전 백엔드를 정리하고 Trident에 새 백엔드를 만듭니다. 새로운 관리 및 데이터 LIF, 새로운 SVM 이름 및 대상 SVM의 암호를 지정합니다.</block>
  <block id="f4a5d35c2f46c3a6ee69fd6aa2d1ed16" category="section-title">애플리케이션의 영구 볼륨에 대한 재해 복구 워크플로우</block>
  <block id="77983829e737f00a29b43edacbba355e" category="paragraph">다음 단계에서는 재해 발생 시 컨테이너화된 워크로드에 SnapMirror 대상 볼륨을 제공하는 방법을 설명합니다.</block>
  <block id="aefd7239e178b3ae439ae7004435bd18" category="list-text">예약된 모든 SnapMirror 전송을 중지하고 진행 중인 모든 SnapMirror 전송을 중단합니다. 대상 볼륨이 읽기/쓰기가 되도록 대상 볼륨과 소스 볼륨 간의 복제 관계를 중단하십시오. 소스 SVM의 볼륨에 연결된 PVC를 사용하는 구축을 정리합니다.</block>
  <block id="c64f364f814f31948e0882b74d5ddfe1" category="list-text">위에서 설명한 단계를 사용하여 대상 측에 Kubernetes 클러스터를 설정한 후 Kubernetes 클러스터에서 배포, PVC 및 PV를 정리합니다.</block>
  <block id="6973ba748ea89f06ab3640118969d780" category="list-text">Trident에서 새로운 관리 및 데이터 LIF, 새 SVM 이름 및 대상 SVM의 암호를 지정하여 새 백엔드를 생성합니다.</block>
  <block id="1fd415590fff525d8e3562951ed79081" category="list-text">Trident 가져오기 기능을 사용하여 새 PVC에 바인딩된 PV로 필요한 볼륨을 가져옵니다.</block>
  <block id="99a01026c124f91b08d854efa31d450b" category="list-text">새로 생성된 PVC와 함께 애플리케이션 배포를 재배포합니다.</block>
  <block id="7a183359334a99fc80b796244313284c" category="section-title">Element 스냅샷을 사용하여 데이터 복구</block>
  <block id="2d51cea50aa816e6be9c663c2ad2686a" category="paragraph">볼륨에 대한 스냅샷 스케줄을 설정하고 필요한 간격으로 스냅샷을 생성하도록 하여 Element 볼륨의 데이터를 백업합니다. Element UI 또는 API를 사용하여 스냅샷 스케줄을 설정해야 합니다. 현재 '솔드파이어-SAN' 드라이버를 통해 스냅샷 스케줄을 볼륨으로 설정할 수 없습니다.</block>
  <block id="c42cc84c1560600f6f5986a958de0735" category="paragraph">데이터가 손상된 경우 Element UI 또는 API를 사용하여 특정 스냅샷을 선택하고 볼륨을 스냅숏으로 수동으로 롤백할 수 있습니다. 이렇게 하면 스냅샷이 생성된 이후 볼륨에 대한 모든 변경 사항이 복구됩니다.</block>
  <block id="75f3d382f074f14c775efb5cf2f23c30" category="summary">Astra Trident를 배포할 때 여기에 나열된 권장 사항을 사용하십시오.</block>
  <block id="ea355214fd4bc7c57f471bd92918879b" category="doc">구축</block>
  <block id="d89d3b3161292ef0c65342cbe80e883f" category="section-title">전용 네임스페이스에 구축</block>
  <block id="79a77cdda2a2513aee654190c73f15ab" category="paragraph"><block ref="c41296e544cd0faaa4fe4e8b22535287" category="inline-link-rx"></block> 서로 다른 애플리케이션 간의 관리 분리를 제공하며 리소스 공유의 장벽입니다. 예를 들어, 한 네임스페이스의 PVC는 다른 네임스페이스에서 사용할 수 없습니다. Astra Trident는 Kubernetes 클러스터의 모든 네임스페이스에 PV 리소스를 제공하고, 결과적으로 권한이 상승된 서비스 계정을 활용합니다.</block>
  <block id="853cf568613b7eec1486421468e18b9b" category="paragraph">또한 Trident Pod에 액세스하면 사용자가 스토리지 시스템 자격 증명 및 기타 중요한 정보에 액세스할 수 있습니다. 애플리케이션 사용자 및 관리 애플리케이션에서 Trident 객체 정의 또는 POD 자체에 액세스할 수 없도록 하는 것이 중요합니다.</block>
  <block id="2c8e89de5c6bf68b180cff5fea545167" category="section-title">할당량 및 범위 제한을 사용하여 스토리지 사용량을 제어할 수 있습니다</block>
  <block id="74444eaf90c31d151645e59dcab0468d" category="inline-link">스토리지 할당량 메커니즘</block>
  <block id="1d81c150d54eae0c49d9cfeb8d493b0f" category="inline-link">범위 제한</block>
  <block id="94104e476fe547cf6237480cacae5ed5" category="paragraph">Kubernetes에는 2가지 기능이 있으며, 이 기능을 조합하여 애플리케이션의 리소스 사용을 제한하는 강력한 메커니즘을 제공합니다. 를 클릭합니다<block ref="bff513af91e6751aca3d34ef714e3b91" category="inline-link-rx"></block> 관리자가 네임스페이스별로 글로벌 및 스토리지 클래스별, 용량 및 오브젝트 수 사용 제한을 구현할 수 있도록 지원 또한 를 사용합니다<block ref="dbe9770513b0f7245f1fe016d20ebb70" category="inline-link-rx"></block> 요청이 프로비저닝 사용자에게 전달되기 전에 PVC 요청이 최소값 및 최대값 내에 있는지 확인합니다.</block>
  <block id="4f9253eda0573e387f86d7777aafff03" category="inline-link">할당량을 활용하는 방법</block>
  <block id="923169151e05d28a3474b2a033666297" category="paragraph">이러한 값은 네임스페이스 단위로 정의됩니다. 즉, 각 네임스페이스에는 리소스 요구 사항에 맞는 값이 정의되어 있어야 합니다. 에 대한 자세한 내용은 여기 를 참조하십시오<block ref="5b289b2ffde01314d8b0d038aabd709b" category="inline-link-rx"></block>.</block>
  <block id="732d0805e41f2db48aa120c357324ee4" category="summary">Trident 운영자나 tridentctl을 사용하여 Astra Trident를 배포할 수 있습니다.</block>
  <block id="42f8643eb52a942747937327c72c8361" category="doc">구축 개요</block>
  <block id="2a4a70c87489dab5d6f93148a8c11c3d" category="section-title">배포 방법을 선택합니다</block>
  <block id="c41362d320971e4e8dbaa3c6a25fbdf8" category="paragraph">사용할 배포 방법을 결정하려면 다음 사항을 고려하십시오.</block>
  <block id="6e43a74295a2af0eedc17051e56d7e1c" category="section-title">Trident 연산자를 사용해야 하는 이유는 무엇입니까?</block>
  <block id="4f5dbc74e3448e08fe0e7bfd62876fc8" category="inline-link-macro">Trident 운영자</block>
  <block id="567dcfd6302e5511c1b546a4df21a679" category="inline-link-macro">설명합니다</block>
  <block id="eed9d9604d323a4bec2ced419db3354b" category="paragraph">를 클릭합니다 <block ref="78ab30a4c6a9648b8dd64a71e4da2aa2" category="inline-link-macro-rx"></block> Astra Trident 리소스를 동적으로 관리하고 설정 단계를 자동화하는 훌륭한 방법입니다. 몇 가지 전제 조건이 충족되어야 합니다. 을 참조하십시오 <block ref="746f08a8296c9ad74e67283046d6876c" category="inline-link-macro-rx"></block>.</block>
  <block id="6f5bda8b751f36b2d937ca475d3d67ed" category="paragraph">Trident 운영자는 아래에 설명된 여러 가지 이점을 제공합니다.</block>
  <block id="ae2987cb5fe6e18d8d8713ac5616010c" category="section-title">자동 복구 기능</block>
  <block id="48b572c20004f23dbcac3e03dede686a" category="paragraph">Astra Trident 설치를 모니터링하고 구축이 삭제되거나 실수로 수정된 경우와 같은 문제를 해결하기 위한 조치를 적극적으로 취할 수 있습니다. 운용자가 deployment로 설정된 경우 trident-operator-&lt;generated-id&gt;'pod가 생성된다. 이 포드는 아스트라 트리덴트 설치와 트리젠오케스트레이터 CR을 연결하며 항상 하나의 활성 '트리젠터레이터'만 존재하도록 합니다. 즉, 운영자는 클러스터에 Astra Trident 인스턴스가 하나만 있고 설정을 제어하여 설치가 매우 강력한지 확인합니다. 설치 변경(예: 배포 또는 노드 반점 삭제)이 수행되면 운영자가 이를 식별하고 개별적으로 수정합니다.</block>
  <block id="69ef8379c893c23746ed9a34e42c57c7" category="section-title">기존 설치에 대한 손쉬운 업데이트</block>
  <block id="0f2d0458d6fc7f6d4317735207021e82" category="paragraph">기존 배포를 운영자로 쉽게 업데이트할 수 있습니다. 설치에 대한 업데이트를 하기 위해 '트리엔오케스트레이터' CR만 편집하면 됩니다. 예를 들어, Astra Trident를 활성화하여 디버그 로그를 생성해야 하는 시나리오를 생각해 보십시오.</block>
  <block id="9b5a5950e97bab4497fbaaaf8c5fadc8" category="paragraph">이렇게 하려면 '트리엔오케스트레이터'를 패치하여 'pec.debug`'를 'true'로 설정합니다.</block>
  <block id="c9534512c045771d255bf1068862beec" category="paragraph">'트리엔오케스트레이터'가 업데이트된 후, 운용자는 기존 설치 시 업데이트 및 패치를 처리한다. 이렇게 하면 새 포드가 생성되어 설치를 적절하게 수정할 수 있습니다.</block>
  <block id="1b77eea7dc5cf10bc0ad9e1c69131aae" category="section-title">Kubernetes 업그레이드 자동 처리</block>
  <block id="f456a413d0506028374e871768a5f176" category="paragraph">클러스터의 Kubernetes 버전이 지원되는 버전으로 업그레이드되면 운영자는 기존 Astra Trident 설치를 자동으로 업데이트하고 Kubernetes 버전 요구사항을 충족하도록 변경합니다.</block>
  <block id="d1aae6ea63eb5e7fe6a9fcea5f671406" category="admonition">클러스터가 지원되지 않는 버전으로 업그레이드되면 운영자는 Astra Trident를 설치할 수 없습니다. Astra Trident가 운영자와 함께 이미 설치된 경우 Astra Trident가 지원되지 않는 Kubernetes 버전에 설치되었음을 나타내는 경고가 표시됩니다.</block>
  <block id="fc6b134742229ab95b893ec9c711b3f2" category="section-title">Helm을 사용해야 하는 이유는 무엇입니까?</block>
  <block id="9326f3d9245c1501e5438ffa40011972" category="paragraph">Astra Trident 21.01부터 Helm을 사용하여 관리하는 다른 애플리케이션이 있는 경우 Helm을 사용하여 배포를 관리할 수도 있습니다.</block>
  <block id="0f22c891238a7408704280567046b005" category="section-title">Tribidenctl은 언제 사용해야 합니까?</block>
  <block id="c67fd1b99934afa248dfeb285a9a4191" category="inline-link-macro">tridentctl 을 선택합니다</block>
  <block id="5e8800ee18d9ba2737f70cf6fea5358c" category="paragraph">업그레이드해야 하는 기존 배포가 있거나 배포를 고도로 사용자 지정하려는 경우 를 사용하는 방법을 고려해야 합니다 <block ref="bbba36f756eac01f0bd418bf08e6f580" category="inline-link-macro-rx"></block>. Astra Trident를 구축하는 기존 방법입니다.</block>
  <block id="992d57abd493d38bda22d9ebcaaee856" category="section-title">배포 방법 간에 이동할 때의 고려 사항</block>
  <block id="4f4cd969ebbb49473d74a80bfd59025e" category="paragraph">배포 방법 간에 이동해야 하는 시나리오를 상상하기란 쉽지 않습니다. "tridentctl" 배포에서 연산자 기반 배포로 이동하거나 그 반대로 이동하려면 다음 사항을 고려해야 합니다.</block>
  <block id="62f2d30ac579a0d9c48f7e9af4709419" category="list-text">Astra Trident를 제거할 때는 항상 동일한 방법을 사용하십시오. tridentctl을 사용하여 배포한 경우에는 해당 버전의 tridentctl 바이너리를 사용하여 Astra Trident를 제거해야 합니다. 마찬가지로 운영자와 함께 배포하는 경우 '트리젠오케스트레이터' CR을 편집하고 '스펙트 제거=true'를 설정하여 Astra Trident를 제거해야 합니다.</block>
  <block id="6c85b80ffcdbeb3004a53881f1c1517d" category="list-text">Astra Trident를 배포하기 위해 "tridentctl"을 사용하여 제거할 운영자 기반 배포가 있는 경우 먼저 'TridentOrchestrator'를 편집하고 'csec.uninstall=true'를 설정하여 Astra Trident를 제거해야 합니다. 그런 다음 '트리엔오케스트레이터'와 운영자 구축을 삭제합니다. 그런 다음 tridentctl을 사용하여 설치할 수 있습니다.</block>
  <block id="67ccf99745298db9f1f4f60c814a2b14" category="list-text">작업자 기반의 수동 배포를 사용하고 H제어 기반 Trident 연산자 배포를 사용하려는 경우 먼저 수동으로 연산자를 제거한 다음 Helm 설치를 수행해야 합니다. 이를 통해 Helm은 필요한 레이블 및 주석을 사용하여 Trident 연산자를 배포할 수 있습니다. 이렇게 하지 않으면 레이블 유효성 검사 오류 및 주석 유효성 검사 오류와 함께 H제어 기반 Trident 연산자 배포가 실패합니다. "tridentctl" 기반 배포를 사용하는 경우 문제 없이 Helm 기반 배포를 사용할 수 있습니다.</block>
  <block id="30c8006f6e30b48cb471941d09dc21cc" category="section-title">배포 모드를 이해합니다</block>
  <block id="47bd3e1ef636594512d55b147acaaff7" category="paragraph">Astra Trident를 구축하는 방법에는 세 가지가 있습니다.</block>
  <block id="e9ae623c81f6793165935a11caf208d7" category="section-title">Standard 구축</block>
  <block id="1c116faa754a12fc9d2268596b076e8e" category="paragraph">Kubernetes 클러스터에서 Trident를 구축하면 Astra Trident 설치 관리자가 다음 두 가지 작업을 수행할 수 있습니다.</block>
  <block id="2344f699f8a17dcc73e51dd0cebc6f44" category="list-text">인터넷을 통해 컨테이너 이미지를 가져오는 중입니다</block>
  <block id="3571f2c25b314afef195d39c88bd9f51" category="list-text">Kubernetes 클러스터의 모든 유효한 노드에서 Astra Trident Pod를 가동하는 구축 및/또는 노드 데모 생성</block>
  <block id="7c3f361ece5e08ed30d45bef79680ec2" category="paragraph">이와 같은 표준 배포는 두 가지 방법으로 수행할 수 있습니다.</block>
  <block id="3ee6b5e142a466872153196fc7ef6dcc" category="list-text">tridentctl install 사용</block>
  <block id="80bede3741fe5e63f3218cf6d74c7a18" category="list-text">Trident 연산자 사용 Trident 연산자는 수동으로 또는 Helm을 사용하여 배포할 수 있습니다.</block>
  <block id="33515d7582595afb015b366316a74170" category="paragraph">이 설치 모드는 Astra Trident를 설치하는 가장 쉬운 방법이며 네트워크 제한이 없는 대부분의 환경에서 작동합니다.</block>
  <block id="2b4393c0483ca76851a031e3e29fa399" category="section-title">오프라인 배포</block>
  <block id="8b115025dda49a5d962758844e90a452" category="inline-link">Trident 이미지</block>
  <block id="72df3b7d5f8e79581be68db816189e82" category="inline-link">Trident AutoSupport 이미지</block>
  <block id="bce707f4572096decf6c60bb5636eefb" category="paragraph">"tridentctl install"을 호출할 때 '--image-registry" 플래그를 사용하여 개인 이미지 레지스트리를 가리킬 수 있습니다. Trident 연산자를 사용하여 배포하는 경우 ' Trident' 오케스트레이터에서 's.imageRegistry'를 지정할 수도 있습니다. 이 레지스트리에는 가 포함되어 있어야 합니다<block ref="2352a006645179366e38df69d0f9f618" category="inline-link-rx"></block>,<block ref="7bacde8b4a2cd45903f29d77cc1c5e5e" category="inline-link-rx"></block>및 Kubernetes 버전에서 요구하는 CSI 사이드카 이미지를 참조하십시오.</block>
  <block id="91255a4adf69521acddc8c1d55903014" category="paragraph">배포를 사용자 지정하려면 tridentctl 을 사용하여 Trident의 리소스에 대한 매니페스트를 생성할 수 있습니다. 여기에는 구축, 개발/제거, 서비스 계정, Astra Trident가 설치의 일부로 생성한 클러스터 역할 등이 포함됩니다.</block>
  <block id="4c774e8a2d80dbc16b0bf55be6c7b358" category="paragraph">배포 사용자 지정에 대한 자세한 내용은 다음 링크를 참조하십시오.</block>
  <block id="711011f15ff69da45006043e93ed8981" category="inline-link-macro">운영자 기반 배포를 사용자 지정합니다</block>
  <block id="8f863c0ccd38c8782b36eedbea08fc5b" category="list-text"><block ref="8f863c0ccd38c8782b36eedbea08fc5b" category="inline-link-macro-rx"></block></block>
  <block id="85cda507040c129ee606d4d8df583b90" category="inline-link-macro">"tridentctl" 기반 배포를 사용자 지정합니다</block>
  <block id="16486d6f9e6411719306bdb76f0b34fa" category="list-text"><block ref="16486d6f9e6411719306bdb76f0b34fa" category="inline-link-macro-rx"></block></block>
  <block id="d18dc7a4e8caf207dc9c1b49eda35b70" category="admonition">개인 이미지 저장소를 사용하는 경우 Kubernetes 버전 1.17 이전의 Kubernetes에서는 /k8scsi를, Kubernetes 버전 1.17 이후의 경우에는 개인 레지스트리 URL 끝에 '/sig-storage'를 추가해야 합니다. tridentctl 배포를 위해 개인 레지스트리를 사용할 때는 '--trident-image' 및 '--autosupport-image'를 '--image-registry'와 함께 사용해야 합니다. Trident 연산자를 사용하여 Astra Trident를 배포하는 경우 Orchestrator CR에 설치 매개변수에 "tridentImage" 및 "autostsupportImage"가 포함되어 있는지 확인합니다.</block>
  <block id="47c0166da57a75ed65ddb766c838a91c" category="section-title">원격 배포</block>
  <block id="761bf14d8b8339a8f345e63dc12c36bb" category="paragraph">다음은 원격 배포 프로세스에 대한 상위 수준의 개요입니다.</block>
  <block id="37dbca6cb8ca55a471ebc072575c0a46" category="list-text">Astra Trident를 구축하려는 원격 머신에 적절한 버전의 kubeck tl을 배포합니다.</block>
  <block id="02ed10abbc71334918b1acb54df6e3f3" category="list-text">Kubernetes 클러스터에서 구성 파일을 복사하고 원격 시스템에서 'KUBECONFIG' 환경 변수를 설정합니다.</block>
  <block id="da693b77cde91654c6296abe8f901988" category="list-text">필요한 Kubernetes 클러스터에 연결할 수 있는지 확인하려면 "kubbtl get nodes" 명령을 시작합니다.</block>
  <block id="df65ec31c6f96e95301e3c6ff8863335" category="list-text">표준 설치 단계를 사용하여 원격 컴퓨터에서 배포를 완료합니다.</block>
  <block id="ccb0658b39bdba7456d6a536d2d07732" category="summary">Trident의 설치 프로그램을 사용하여 특성을 사용자 지정할 수 있습니다.</block>
  <block id="bbe2bfefd5797bb567e3da92f68ce8d1" category="doc">tridentctl 배포를 사용자 지정합니다</block>
  <block id="eabcee1fa9f08716f26be6d1b73360fe" category="paragraph">Trident 설치 프로그램을 사용하여 특성을 사용자 지정할 수 있습니다. 예를 들어, Trident 이미지를 개인 저장소에 복사한 경우 '--trident-image'를 사용하여 이미지 이름을 지정할 수 있습니다. Trident 이미지와 필요한 CSI 사이드카 이미지를 개인 저장소에 복사한 경우 '&lt;registry FQDN&gt;[:port]' 형식을 사용하는 '--image-registry' 스위치를 사용하여 해당 리포지토리의 위치를 지정하는 것이 좋습니다.</block>
  <block id="6fdfbf3444ce4e12e3375405bdd10237" category="paragraph">Astra Trident가 작업자 노드를 자동으로 구성하도록 하려면 '--enable-node-prep'를 사용합니다. 작동 방식에 대한 자세한 내용은 을 참조하십시오 <block ref="144c3ced0f46507a846b2964eace5739" category="inline-link-macro-rx"></block>.</block>
  <block id="d924f91616fe4accc876113a346ee8ad" category="admonition">자동 작업자 노드 준비는 비생산 환경에서만 사용할 수 있는 * 베타 기능입니다.</block>
  <block id="8355509d170c8a61d236e927a5fcc6e2" category="paragraph">kubelet이 평소 하던 /var/lib/kubelet가 아닌 다른 경로에 데이터를 보관하는 Kubernetes 배포를 사용하는 경우 -kubelet-dir을 사용하여 대체 경로를 지정할 수 있습니다.</block>
  <block id="47cd697cf3c9dcf916f70a0007956c1d" category="paragraph">설치 관리자의 인수 이외에 설치를 사용자 지정해야 하는 경우 배포 파일을 사용자 지정할 수도 있습니다. '--generate-custom-YAML' 파라미터를 사용하면 설치 프로그램의 '셋업' 디렉토리에 다음과 같은 YAML 파일이 생성됩니다.</block>
  <block id="0858f0ee003d52951161848adffe1b31" category="list-text">트리덴트-클러스터롤리바인딩.YAML</block>
  <block id="af73689aedfa47bd2a7cf144917b0642" category="list-text">'트라이덴트 배포.YAML'</block>
  <block id="1d53fd876245951bb003eb47849ff39d" category="list-text">트리덴트-CRD.YAML</block>
  <block id="b17dbe8acaeca82c72d25948de03eefc" category="list-text">트리덴트-클러스터역할.YAML</block>
  <block id="ecb2b56a094cc1cbd3ac263b23d91f8b" category="list-text">트리덴트-디멘트발병 YAML</block>
  <block id="c5e462ae653234d0ea0e98a000e62a97" category="list-text">'삼류 서비스.YAML'</block>
  <block id="f1347677de6873f8ddce6d736cba9a63" category="list-text">'삼중인대.YAML'</block>
  <block id="2539c7e25ada2a2cdae0eb4c4633b893" category="list-text">트라이덴트-서비스계정.YAML</block>
  <block id="385d099ed91e83dbe20ea05fbed68e22" category="paragraph">이러한 파일을 생성한 후 필요에 따라 수정한 다음 '--use-custom-YAML'을 사용하여 사용자 지정 배포를 설치할 수 있습니다.</block>
  <block id="aa452927f1dec9709a523a0de496d6c5" category="summary">tridentctl을 사용하여 Astra Trident를 배포할 수 있습니다.</block>
  <block id="e0e3d7f1aacdf4a8196132549709430c" category="doc">tridentctl을 사용하여 배포합니다</block>
  <block id="4a052772dca278b7be31d54ca9f21831" category="inline-link-macro">기본 개념</block>
  <block id="e029dd3737acab556b62bda0be50840c" category="admonition">에 아직 익숙하지 않은 경우 <block ref="0342248ee22d08eaf42465a29ddd67ec" category="inline-link-macro-rx"></block>이제 아주 좋은 시간입니다.</block>
  <block id="be932f6f71d4b0b1a7f80c2e5b584b34" category="admonition">배포를 사용자 지정하려면 을 참조하십시오 <block ref="b336c95c8f5c7bbe82e004b1378c2302" category="inline-link-macro-rx"></block>.</block>
  <block id="df2aaa5fa27e9bdafcb6bb0a4367b7d6" category="paragraph">Astra Trident를 구축하려면 다음과 같은 사전 요구 사항을 충족해야 합니다.</block>
  <block id="6a64bc5a34f75dde015dc7dd8ece8c61" category="list-text">지원되는 Kubernetes 클러스터에 대한 모든 권한이 있습니다.</block>
  <block id="3a1ac050b1160a02cbd3c9ea84228191" category="list-text">지원되는 NetApp 스토리지 시스템에 액세스할 수 있습니다.</block>
  <block id="6a477d2ddba6ea3bc12088f821ce4e64" category="list-text">모든 Kubernetes 작업자 노드에서 볼륨을 마운트할 수 있습니다.</block>
  <block id="6d8c90e9c1152c55e27e8166d128b927" category="list-text">사용할 Kubernetes 클러스터를 관리하도록 "kubbtl"(또는 OpenShift를 사용하는 경우 OC)가 설치 및 구성된 Linux 호스트를 보유하고 있습니다.</block>
  <block id="c40e5b69838954fb37e4c3a433e341a8" category="list-text">Kubernetes 클러스터 구성을 가리키도록 'KUBECONFIG' 환경 변수를 설정했습니다.</block>
  <block id="fe116e93fbfba0aec359f5fde363784c" category="inline-link-macro">Astra Trident에서 요구하는 기능 게이트</block>
  <block id="6cb07e07cf0a13978f0d7384acc48f1a" category="list-text">을(를) 활성화했습니다 <block ref="53fb1a9f15d8db1182d68d20590366cf" category="inline-link-macro-rx"></block>.</block>
  <block id="dd3de2609b612d76ef4c71b97b8d6100" category="inline-link">다음 단계에 따라 CLI 액세스를 설정합니다</block>
  <block id="c585967fa32d82c5e3c24bd63926c6a0" category="list-text">Docker Enterprise와 함께 Kubernetes를 사용하는 경우,<block ref="57562caf1c76e1a261b7e2f8c3d113f9" category="inline-link-rx"></block>.</block>
  <block id="b430504ce0f6755a2be91a9a221c144e" category="paragraph">다 잡았나요? 좋습니다! 그럼 이제 시작하겠습니다.</block>
  <block id="ed000d2029e135f34f854fa4e820940b" category="admonition">배포 사용자 지정에 대한 자세한 내용은 을 참조하십시오 <block ref="b336c95c8f5c7bbe82e004b1378c2302" category="inline-link-macro-rx"></block>.</block>
  <block id="f7fca6c4035d50dff676b2d20fe511ba" category="section-title">1단계: Kubernetes 클러스터 검증</block>
  <block id="ea8cda06a0e70ad34c1b9ab1b7135105" category="inline-link-macro">지원되는 Kubernetes 클러스터</block>
  <block id="665cf0ff23392f7e380041a2b34a5f5a" category="paragraph">가장 먼저 해야 할 일은 Linux 호스트에 로그인하여 해당 호스트가 관리 중인 _ 작업 _ 을(를) 관리하고 있는지 확인하는 것입니다. <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 에 필요한 권한이 있어야 합니다.</block>
  <block id="8a0f5f61d4ea2fb3a2f0ee6de4b7cf40" category="admonition">OpenShift에서는 다음 모든 예제에서 kubeck 대신 OC를 사용하며 먼저 OC login-u system:admin 또는 OC login-u kubbe-admin을 실행하여 * system:admin * 으로 로그인해야 합니다.</block>
  <block id="09ea6b05f579a1e9903c54dfcd6a0dc9" category="paragraph">Kubernetes 버전을 확인하려면 다음 명령을 실행합니다.</block>
  <block id="d14fa1adb2805f01b2a616f5ef9d25be" category="paragraph">Kubernetes 클러스터 관리자 권한이 있는지 확인하려면 다음 명령을 실행합니다.</block>
  <block id="f67b776be47148789a46badee3f77607" category="paragraph">Docker Hub에서 이미지를 사용하는 Pod를 시작하고 Pod 네트워크를 통해 스토리지 시스템에 연결할 수 있는지 확인하려면 다음 명령을 실행합니다.</block>
  <block id="b80293f6b9048d95e7f975e831ef4da6" category="paragraph">Kubernetes 서버 버전을 식별하십시오. Astra Trident를 설치할 때 사용합니다.</block>
  <block id="57786106edaa9a7d85847431f0aa5559" category="section-title">2단계: 설치 프로그램을 다운로드하고 압축을 풉니다</block>
  <block id="f838f032d9e83a6229936c3a7784f752" category="admonition">Trident 설치 관리자는 Trident Pod를 생성하고 상태를 유지하는 데 사용되는 CRD 객체를 구성하며, 클러스터 호스트에 볼륨 프로비저닝 및 연결과 같은 작업을 수행하는 CSI 사이드카를 초기화합니다.</block>
  <block id="7358b1fd077fa65f88fff87888fd2547" category="inline-link">Trident 설치 프로그램 번들</block>
  <block id="92c4cf66727cb67866ebf0c3ec416382" category="paragraph">의 최신 버전을 다운로드할 수 있습니다<block ref="e796e94083ba305bee55a53ec1dc755d" category="inline-link-rx"></block> 다운로드 섹션에서 압축을 풉니다.</block>
  <block id="31dfa917b0ab09bc8fa9aa62c5b68b9b" category="paragraph">예를 들어, 최신 버전이 21.07.1인 경우:</block>
  <block id="9b7632bed019c72ffa74193e1808fd78" category="section-title">3단계: Astra Trident 설치</block>
  <block id="326f6498f188018e71d4ea9c3a240042" category="paragraph">tridentctl install 명령을 실행하여 원하는 네임스페이스에 Astra Trident를 설치합니다.</block>
  <block id="ed1112be79a7a22fdbf9b294f3ed718b" category="paragraph">설치 프로그램이 완료되면 다음과 같이 표시됩니다. Kubernetes 클러스터의 노드 수에 따라 다음과 같은 Pod를 더 많이 관찰할 수 있습니다.</block>
  <block id="1c3da07a8a73bf0d4070c8c4b10d14c8" category="inline-link-macro">구축 후 작업</block>
  <block id="e3828f7a456f3c91d25ec19bbf457e6d" category="paragraph">위 예제와 유사한 출력이 표시되는 경우 이 단계를 완료했지만 Astra Trident가 아직 완전히 구성되지 않은 것입니다. 다음 단계를 계속 진행하십시오. 을 참조하십시오 <block ref="6bfdfe984198635473da869595980b46" category="inline-link-macro-rx"></block>.</block>
  <block id="a0015d3671af62700240db94388892fb" category="paragraph">그러나 설치 프로그램이 성공적으로 완료되지 않거나 * "trident-scsi-&lt;generated id&gt;"를 실행하는 * 가 표시되지 않으면 플랫폼이 설치되지 않은 것입니다.</block>
  <block id="e09245effc62059e51f926fad603e413" category="inline-link-macro">문제 해결</block>
  <block id="a03102a9f58cbddc7c8c4a6a8e198bc0" category="admonition">배포 중 문제 해결에 대한 자세한 내용은 을 참조하십시오 <block ref="d5a4e07afa9c1e3e2869e1c17ce11b3d" category="inline-link-macro-rx"></block> 섹션을 참조하십시오.</block>
  <block id="13c852fce58f7c6981fa0a952dcd76af" category="summary">Trident 연산자를 사용하면 ' Trident' 사양의 특성을 사용하여 Astra Trident가 설치되는 방식을 사용자 지정할 수 있습니다.</block>
  <block id="b9d69225e5cf4da0389ed6b1f6b66a10" category="doc">Trident 운영자 배포를 사용자 지정합니다</block>
  <block id="02e0835b3015839cde731027c217d70b" category="paragraph">속성 목록은 다음 표를 참조하십시오.</block>
  <block id="83f499a540b1323009c200d6f8cc9396" category="cell">매개 변수</block>
  <block id="7a1920d61156abc05a60135aefe8bc67" category="cell">기본값</block>
  <block id="f3f30d479f6e3b393d917a3b2f88c770" category="cell">'네임스페이스'</block>
  <block id="c9db68ea6cff44f42ac5acbbfccec399" category="cell">Astra Trident를 설치할 네임스페이스입니다</block>
  <block id="9aa82da0cffe247b84587c1cc8e32746" category="cell">"기본값"</block>
  <block id="a67cf6b087ff88dbfacec8375928995c" category="cell">"버그"</block>
  <block id="4f72bc786a1a01d5a1a8bc09d33334cc" category="cell">Astra Trident에 대한 디버깅을 활성화합니다</block>
  <block id="68934a3e9455fa72420237eb05902327" category="cell">거짓</block>
  <block id="3dd791c4864e77ae6cf11572e2d7b374" category="cell">IPv6를 통해 Astra Trident를 설치합니다</block>
  <block id="077e99fe42ced522b462656cffffe09c" category="cell">k8sTimeout</block>
  <block id="4448b73eac083e33b7142f0e5790fac5" category="cell">Kubernetes 작업 시간이 초과되었습니다</block>
  <block id="e4d71bf2abad047425f4463e27bb83b0" category="cell">30초</block>
  <block id="42cf123e93ecc5c0297652edbc547fc0" category="cell">이제 자동 지원입니다</block>
  <block id="4a213b7c3b997ffb0794b25909381d16" category="cell">AutoSupport 번들을 NetApp에 자동으로 보내지 않습니다</block>
  <block id="34d0f4a447cd1d7f59000d3be2c39320" category="cell">"enableNodePrep"입니다</block>
  <block id="2472256a6487b0917d32f6a044a4e0ac" category="cell">작업자 노드 종속성 자동 관리(* beta*)</block>
  <block id="2bccac20e55391730a985f9819e1cc41" category="cell">자동 지원 이미지</block>
  <block id="84448c234dfdfd2a7367341fd4b56a80" category="cell">AutoSupport 텔레메트리 컨테이너 이미지입니다</block>
  <block id="deb59c9b1f7c5aab7803950edd48fbdb" category="cell">"NetApp/트리덴트 - 자동 지원: 21.04.0"</block>
  <block id="f4a6821b04b9ce6b90148068341347b6" category="cell">자동 지원 프록시</block>
  <block id="7f54ca385f028308d19e228ce0534a47" category="cell">AutoSupport 텔레메트리 전송을 위한 프록시의 주소/포트입니다</block>
  <block id="256acfe307251e7444859851d87d5735" category="cell"><block ref="256acfe307251e7444859851d87d5735" category="inline-link-rx"></block></block>
  <block id="e9f06180af644cfa6e5d20bd67c03bc5" category="cell">"제거"를 선택합니다</block>
  <block id="076bc379a24183ce77834bac007ca852" category="cell">Astra Trident를 제거하는 데 사용되는 플래그입니다</block>
  <block id="cad060d2f14dbf08315c20014ed31daa" category="cell">로그포맷</block>
  <block id="acfc4a8e6d53bad27d4e2d393bfff61e" category="cell">사용할 Astra Trident 로깅 형식[text,json]</block>
  <block id="20cd815523e5806aec29a57282b0d49f" category="cell">"텍스트"</block>
  <block id="7610c5cc7910022402c4fbd450d889ce" category="cell">트리덴티이미지</block>
  <block id="20f408a3276af1f7f1bf02ba374786ca" category="cell">설치할 Astra Trident 이미지</block>
  <block id="896185b87765c519346253a5f54ecbe4" category="cell">"NetApp/트리덴트: 21.04"</block>
  <block id="8088435dc0e1c8b85217d850d3e7a602" category="cell">'imageRegistry'입니다</block>
  <block id="4f25f4cca5c1939f4a728d2678e719f7" category="cell">'&lt;registry FQDN&gt;[:port][/subpath]' 형식의 내부 레지스트리 경로입니다</block>
  <block id="1f147978ca8c4561ff70857129f3fa13" category="cell">"k8s.gcr.io/sig-storage(k8s 1.17+) 또는 quay.io/k8scsi"</block>
  <block id="e6b96cbb467923e86672bb25db5ecebb" category="cell">쿠벨레트디렉토리</block>
  <block id="31aad37dce0c28e12908582a0d63736a" category="cell">호스트의 kubelet 디렉토리에 대한 경로입니다</block>
  <block id="5b9febd4bd647dae5abfddaf99b9c540" category="cell">“/var/lib/kubelet”</block>
  <block id="b6e0e2c4168573f0ed61c842470342ba" category="cell">"위피"</block>
  <block id="4e33345575b5a443dec89767624a1ee8" category="cell">Astra Trident를 완전히 제거하기 위해 삭제할 리소스 목록입니다</block>
  <block id="2d30d1348c4d2533a165827a22516caa" category="cell">'imagePullSecrets'</block>
  <block id="f73bb4a0bc9913e7fc6db5f9e5f2afeb" category="cell">내부 레지스트리에서 이미지를 가져올 수 있는 비밀</block>
  <block id="d4d1a6713550b631ed2a47905a5ac4fa" category="admonition">pec.namespace` 는 어느 네임스페이스 Astra Trident가 설치되어 있는지 나타내기 위해 트리엔터레이터에 지정됩니다. Astra Trident가 설치된 후에는 이 매개 변수 * 를 업데이트할 수 없습니다. 이렇게 하면 트리엔오케스트레이터 상태가 실패로 바뀝니다. Astra Trident는 네임스페이스 간에 마이그레이션할 수 없습니다.</block>
  <block id="c1aa6523e4a912445f9d4b8b9fb560be" category="admonition">자동 작업자 노드 준비는 비생산 환경에서만 사용할 수 있는 * 베타 기능입니다.</block>
  <block id="0b3c55a2173aa8e730bca967a8dd7cf5" category="paragraph">'트리엔오케스트레이터'를 정의할 때 위에서 설명한 속성을 사용하여 설치를 사용자 정의할 수 있습니다. 예를 들면 다음과 같습니다.</block>
  <block id="27421a0c5ebcff7855c7c87dc579b371" category="paragraph">트리벤트오케스트레이터 인수를 통해 설치를 사용자 정의하려는 경우, 필요에 따라 수정할 수 있는 맞춤형 YAML 매니페스트를 생성하기 위해 'tridentctl'을 사용하는 것이 좋습니다.</block>
  <block id="237bc513b62b16e8ddd1661150fb7f94" category="summary">Trident 운영자와 함께 Astra Trident를 배포할 수 있습니다. Trident 연산자는 수동으로 또는 Hrom을 사용하여 배포할 수 있습니다.</block>
  <block id="cba9c445dab954e3483f9e5bef9f12c5" category="doc">Trident 연산자를 사용하여 구축</block>
  <block id="705db3afa1c1d4451f7b0f7f8552f1b5" category="list-text">Kubernetes 1.17 이상을 실행하는 지원되는 Kubernetes 클러스터에 대한 모든 권한이 있습니다.</block>
  <block id="f9589cad119238efbce2b063d5225fb4" category="section-title">Hrom을 사용하여 Trident 연산자를 배포합니다</block>
  <block id="8a414e5c564a0c9e7a0f799a3c8cf47c" category="paragraph">나열된 단계를 수행하여 Helm을 사용하여 Trident 연산자를 배포합니다.</block>
  <block id="dc2d0674739dcd145f5287a7d619ee05" category="paragraph">위에 나열된 필수 구성 요소 외에도 Hrom을 사용하여 Trident 연산자를 구축하려면 다음이 필요합니다.</block>
  <block id="8f5e62e2d03d87aeaafa8d4776fb7a79" category="list-text">Kubernetes 1.17 이상</block>
  <block id="2e1b3f44683eee188be985693c4af5e1" category="list-text">Helm 버전 3</block>
  <block id="bfd69e00e956b426c17001fc7ae7afbe" category="list-text">'helm install' 명령을 사용하여 배포 이름을 지정합니다. 다음 예를 참조하십시오.</block>
  <block id="e366a20246a41520da551be510c1d658" category="paragraph">설치 중에 구성 데이터를 전달하는 방법에는 두 가지가 있습니다.</block>
  <block id="a61e25800624ce452a1c4082ce082d9b" category="list-text">'--Values'(또는 '-f'): 재정의가 있는 YAML 파일을 지정합니다. 이 옵션은 여러 번 지정할 수 있으며 가장 오른쪽 파일이 우선 적용됩니다.</block>
  <block id="7dc8a47a7055ee868486daae4c256916" category="list-text">'--set': 명령행에서 overrides를 지정합니다.</block>
  <block id="f64fcf716c27478cdc36b1f36306d5eb" category="paragraph">예를 들어, 기본값인 debug를 변경하려면 다음 '--set' 명령을 실행합니다.</block>
  <block id="24da04b0777d00c6fe43de99895058bd" category="paragraph">제어 차트의 일부인 Values.YAML 파일은 키 목록과 기본값을 제공합니다.</block>
  <block id="1294c366742670bd28702f7cafffc981" category="paragraph">'Helm list'는 이름, 네임스페이스, 차트, 상태, 앱 버전, 개정 번호 등</block>
  <block id="3470548c691fb90c7ea544350c2c7052" category="section-title">Trident 연산자를 수동으로 배포합니다</block>
  <block id="8f3f1888bbf317edb14f0f439c7d142f" category="paragraph">나열된 단계를 수행하여 Trident 연산자를 수동으로 배포합니다.</block>
  <block id="619cde7335e798082dc3bfdbe30708a0" category="paragraph">가장 먼저 해야 할 일은 Linux 호스트에 로그인하여 해당 호스트가 관리 중인 _ 작업 _ 을(를) 관리하고 있는지 확인하는 것입니다. <block ref="ac355729d1ddc95a290738ca862fed08" category="inline-link-macro-rx"></block> 에 필요한 권한이 있어야 합니다.</block>
  <block id="e420b75ec3bc014e3f69c43b2383768b" category="admonition">OpenShift에서는 뒤에 나오는 모든 예시에서 kubtl 대신 OC를 사용하고, OC login-u system:admin 또는 OC login-u kubbe-admin을 실행하여 먼저 * system:admin * 으로 로그인합니다.</block>
  <block id="3b4c548466953befff1962ac2426cb8e" category="paragraph">Kubernetes 버전이 1.17 이후인지 확인하려면 다음 명령을 실행합니다.</block>
  <block id="b51ca564a2763a36e8eff661a1e45814" category="section-title">2단계: 운영자를 다운로드하고 설정합니다</block>
  <block id="2078c81a90072659fba28be2f6863a52" category="admonition">21.01부터 Trident 연산자는 클러스터 범위입니다. Trident 연산자를 사용하여 Trident를 설치하려면 "트리엔오케스트레이터" CRD(사용자 정의 리소스 정의)를 생성하고 다른 리소스를 정의해야 합니다. Astra Trident를 설치하기 전에 다음 단계를 수행하여 운영자를 설정해야 합니다.</block>
  <block id="76e266ddd09c36b072fda03f840a24df" category="list-text">의 최신 버전을 다운로드합니다<block ref="d4cf8040e05d7d00be7e40a7abf8ee09" category="inline-link-rx"></block> 다운로드 섹션에서 압축을 풉니다.</block>
  <block id="f3d3e6090d613a233f190256fd5f4fa3" category="list-text">적절한 CRD 매니페스트를 사용하여 '트리엔오케스트레이터' CRD를 생성합니다. 그런 다음 나중에 운영자가 설치를 인스턴스화하기 위해 '트리엔오케스트레이터' 사용자 정의 리소스를 만듭니다.</block>
  <block id="337d79852891a37d41285c9101c3fff4" category="paragraph">다음 명령을 실행합니다.</block>
  <block id="2fd9409a1ac929d355820ffd5accc531" category="list-text">'트리엔오케스트레이터' CRD가 생성된 후 운용자 배치에 필요한 다음과 같은 자원을 생성한다.</block>
  <block id="cb410399b5d1d9b73f065ed14123f45d" category="list-text">연산자를 위한 ServiceAccount입니다</block>
  <block id="8078c9a60d1b454fe7572e23c307625e" category="list-text">ServiceAccount에 대한 ClusterRole 및 ClusterRoleBinding</block>
  <block id="5e5472e17b92112eb99dbbae729e1a4b" category="list-text">전용 PodSecurityPolicy</block>
  <block id="dbbf8c6ec95775d28c3c6da1878bf8c3" category="list-text">작업자 자체</block>
  <block id="3eb35ab5560d306167480f5846c3f66a" category="paragraph">Trident 설치 프로그램에는 이러한 리소스를 정의하는 매니페스트가 포함되어 있습니다. 기본적으로 연산자는 '삼원' 네임스페이스에 배포됩니다. 트리덴트 네임스페이스가 없으면 다음 매니페스트를 사용하여 만듭니다.</block>
  <block id="9d010a8f9df48de6abe7351f048fe2f7" category="list-text">기본 '삼중류' 네임스페이스 이외의 이름 공간에 운용자를 배치하려면 '세르이스계정.YAML', '클러스터구속력.YAML', 'operator.YAML'을 업데이트하고 'bundle.YAML'을 작성해야 합니다.</block>
  <block id="16f1c44dd25afde65aacbc201617651f" category="paragraph">다음 명령을 실행하여 YAML 매니페스트를 업데이트하고 '고객.YAML'을 사용하여 'bundle.YAML'을 생성합니다.</block>
  <block id="05f465d1f3f89d87686947655659abc3" category="paragraph">다음 명령을 실행하여 리소스를 생성하고 연산자를 배포합니다.</block>
  <block id="a0fa1784e85c80577b8b123157bd45da" category="list-text">배치한 후 작업자의 상태를 확인하려면 다음을 수행합니다.</block>
  <block id="1c76f442bb494f18915f305a59518ed1" category="paragraph">운영자 배포는 클러스터의 작업자 노드 중 하나에서 실행되고 있는 포드를 성공적으로 생성합니다.</block>
  <block id="a770ca95121cc795b602f9af6af024fb" category="admonition">Kubernetes 클러스터에는 운영자의 인스턴스 * 하나가 있어야 합니다. Trident 연산자의 여러 배포를 생성하지 마십시오.</block>
  <block id="b22134de94bce671f8ac945536b7497c" category="section-title">3단계: Trident를 설치한 후 트리젠터레이터 생성</block>
  <block id="5693b155707eefef50a904b3b1523862" category="paragraph">이제 연산자를 사용하여 Astra Trident를 설치할 준비가 되었습니다! 이 작업을 수행하려면 '트리엔오케스트레이터'를 만들어야 합니다. Trident 설치 프로그램에는 'Trident Orchestrator'를 만들기 위한 예제 정의가 포함되어 있습니다. 이렇게 하면 '삼중덴트' 네임스페이스에서 설치가 시작됩니다.</block>
  <block id="eda3cb9b284c6edd303631dd83beca97" category="inline-link-macro">Trident 구축을 사용자 지정합니다</block>
  <block id="df1a9b2505f9a695dab238c459f4c11e" category="paragraph">Trident 연산자를 사용하면 ' Trident' 사양의 특성을 사용하여 Astra Trident가 설치되는 방식을 사용자 지정할 수 있습니다. 을 참조하십시오 <block ref="5d22c6b05e889509f3b16bf34345783f" category="inline-link-macro-rx"></block>.</block>
  <block id="f463fa7de78b2d3c00a2d47f9fc4ca50" category="paragraph">'트리엔오케스트레이터'의 상태는 설치가 성공적이었음을 나타내며 설치된 Trident의 버전을 표시합니다.</block>
  <block id="ec53a8c4f07baed5d8825072c89799be" category="cell">상태</block>
  <block id="2763f33c904a183bd0ef06f9c4fb4403" category="cell">설치 중</block>
  <block id="64162845794ff7262e665deec58a84f5" category="cell">운영자는 이 '트리엔오케스트레이터' CR을 사용하여 Astra Trident를 설치하고 있습니다.</block>
  <block id="98dd43dfae05b11befe1f140e0ec787a" category="cell">설치되어 있습니다</block>
  <block id="2fe2cc0adf9b69a871d33ba220695cd4" category="cell">Astra Trident가 성공적으로 설치되었습니다.</block>
  <block id="c2aaea4dacecce78b34302e41fcef75e" category="cell">제거 중</block>
  <block id="c27ff0e050a671f2eab32a372c9636bd" category="cell">이 경우, 'pec.uninstall=true'로 인해 운용자가 Astra Trident를 설치 제거 중입니다.</block>
  <block id="b78846123fdd78d5ab62451b855194e3" category="cell">제거되었습니다</block>
  <block id="f8a32612e33c768b5fa0dd033d91ce8d" category="cell">Astra Trident가 제거되었습니다.</block>
  <block id="d7c8c85bf79bbe1b7188497c32c3b0ca" category="cell">실패했습니다</block>
  <block id="273b9a9e933220f1963cbac7a7a46645" category="cell">운영자가 Astra Trident를 설치, 패치, 업데이트 또는 제거할 수 없습니다. 이 상태에서 자동으로 복구를 시도합니다. 이 상태가 지속되면 문제 해결이 필요합니다.</block>
  <block id="6909beea5b50605780e3411f879fe916" category="cell">업데이트 중</block>
  <block id="3201d58137fab497dea740d761a9733b" category="cell">운영자가 기존 설치를 업데이트하고 있습니다.</block>
  <block id="902b0d55fddef6f8d651fe1035b7d4bd" category="cell">오류</block>
  <block id="efaeca66375c8663b6d1d64f4886f267" category="cell">트리젠터레이터(트리젠터레이터)는 사용하지 않는다. 다른 파일이 이미 있습니다.</block>
  <block id="06a69b41e25711d4ae5a561ed9518f18" category="paragraph">설치 과정에서 트리엔오케스트레이터 상태가 설치 상태에서 설치 상태로 변경됩니다. 'Failed(실패)' 상태를 확인하고 운용자가 자체적으로 복구할 수 없는 경우 운용자의 로그를 확인해야 한다. 를 참조하십시오 <block ref="d5a4e07afa9c1e3e2869e1c17ce11b3d" category="inline-link-macro-rx"></block> 섹션을 참조하십시오.</block>
  <block id="a62e37b5d24190e57c50856ed67d1f30" category="paragraph">생성된 포드를 살펴보고 Astra Trident 설치가 완료되었는지 확인할 수 있습니다.</block>
  <block id="cb61ddc6afc630830f76a754c29c509e" category="paragraph">또한 'tridentctl'을 사용하여 설치된 Astra Trident의 버전을 확인할 수도 있습니다.</block>
  <block id="017115d0fb78b96eca56297dcaae750a" category="paragraph">이제 백엔드를 생성할 수 있습니다. 을 참조하십시오 <block ref="6bfdfe984198635473da869595980b46" category="inline-link-macro-rx"></block>.</block>
  <block id="b9966b5f76510c4c81d397b732dc0ced" category="summary">지원되는 프런트엔드, 백엔드 및 호스트 구성을 검토하여 시작하십시오.</block>
  <block id="5a2ebfb8baa378cfcfcba58bbb1380c2" category="doc">요구 사항</block>
  <block id="0582c93c9857a8b6d0380be79128eefc" category="admonition">Astra Trident가 사용하는 포트에 대한 자세한 내용은 를 참조하십시오 <block ref="c6b87a878d50568ac1e654ad3964af7b" category="inline-link-macro-rx"></block>.</block>
  <block id="c777be7f669397b0a376fe32ca5cd9c3" category="section-title">지원되는 프런트엔드(오케스트레이터)</block>
  <block id="74aefc05d193afd5c50a0df882997656" category="paragraph">Astra Trident는 다음을 비롯한 여러 컨테이너 엔진과 오케스트레이터가 지원됩니다.</block>
  <block id="37696641960d6c73a7dadab603c1877e" category="list-text">Mirantis Kubernetes 엔진 3.4</block>
  <block id="201eb37826a33e35adff9119f25946bd" category="paragraph">Trident 연산자는 다음 릴리즈에서 지원됩니다.</block>
  <block id="5596419ed8318cabbcb138ef27fd3035" category="inline-link">버그 수정 알림</block>
  <block id="3943a2e0490c50c43f31a486978ea80b" category="paragraph">또한 Astra Trident는 Google Cloud의 GKE(Google Kubernetes Engine), AWS의 EKS(Elastic Kubernetes Service), Azure의 AKS(Azure Kubernetes Service), Rancher 등의 완전히 관리되는 Kubernetes 오퍼링과도 연동됩니다.</block>
  <block id="f787cd4b6963b13f12fa53131f58ef6c" category="section-title">지원되는 백엔드(스토리지)</block>
  <block id="843e2f0c722d25903a6010b62ac4f13b" category="paragraph">Astra Trident를 사용하려면 다음 중 하나 이상의 지원되는 백엔드가 필요합니다.</block>
  <block id="4d82a1ec1af02725042c8c785564ee7a" category="list-text">NetApp ONTAP용 Amazon FSx</block>
  <block id="117bdbda976fe8b3212bc3b6327a0a1b" category="list-text">Cloud Volumes ONTAP</block>
  <block id="06021ba1ee96f1a3a57b50001fc7244c" category="list-text">AWS 환경을 위한 Cloud Volumes Service</block>
  <block id="a3c559e0541e9bb860178ce6fe414224" category="list-text">GCP용 Cloud Volumes Service</block>
  <block id="ff617c70912e62b6adb0266e42f9d4f5" category="list-text">FAS/AFF/9.3 이상을 선택합니다</block>
  <block id="1d3d126b8a5bad69c46ed03734beed47" category="list-text">NetApp All SAN 어레이(ASA)</block>
  <block id="c7c7a6a5641f33e348244f9c43010e16" category="section-title">피처 요구 사항</block>
  <block id="8c67111ad59dd108156a3e7c9a32b63c" category="paragraph">아래 표에는 Astra Trident의 이번 릴리즈와 함께 사용할 수 있는 기능과 지원하는 Kubernetes 버전이 요약되어 있습니다.</block>
  <block id="21021ea0e52be8e9c599f4dff41e5be0" category="cell">피처</block>
  <block id="80afba45eb055fc9bdc48c90d1debd06" category="cell">Kubernetes 버전</block>
  <block id="10f295a61d2a793ac8936a69cf458654" category="cell">기능 게이트가 필요합니까?</block>
  <block id="f336592ca417cff322b935bc0eeaff8f" category="cell">CSI Trident</block>
  <block id="51c52843a7958626357cfc8e1ef94e50" category="paragraph">1.17 이상</block>
  <block id="e830b7e4d1fb7f84600876af87cb4381" category="cell">볼륨 스냅샷</block>
  <block id="ea8ed249117e76cb53766e218fe2b7c7" category="cell">체적 스냅샷의 PVC</block>
  <block id="28dcded20f550dcad1bd9bb03a5bbe73" category="cell">iSCSI PV 크기 조정</block>
  <block id="1673543ed032e46f3572ba65bc070693" category="cell">ONTAP 양방향 CHAP</block>
  <block id="176e16df4faab1a1e06e9585c813d5fe" category="cell">동적 내보내기 정책</block>
  <block id="1f7219b07d5bce7feec002a9f4dc2201" category="cell">Trident 연산자</block>
  <block id="bf0d42cfb33347700a1060d7b0cf07c1" category="cell">Auto Worker Node Prep(베타)</block>
  <block id="443432948b68bb63d707ce7ecc4a021a" category="cell">CSI 토폴로지</block>
  <block id="4fa506be8cc1c8c936a3eff8a374fe26" category="list-text">RHEL 또는 CentOS 7.4 이상</block>
  <block id="2d736ed9cdbf58b500e9715daeb267e6" category="list-text">Ubuntu 18.04 이상</block>
  <block id="11ea58814ce429c3e3254a63f8cde7a4" category="paragraph">트리덴트틀(tridentctl) 유틸리티도 이 리눅스 배포판에서 실행됩니다.</block>
  <block id="13d80777c8fd43e555c1f5b1b72d7ef0" category="section-title">호스트 구성</block>
  <block id="62df396fbf0c4fd30e1e851335e8b26b" category="paragraph">사용 중인 백엔드에 따라 NFS 및/또는 iSCSI 유틸리티를 클러스터의 모든 작업자에 설치해야 합니다. 을 참조하십시오 <block ref="8e0b40cac942de59585b1131f9197d7b" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="2139fe384d5ae165545994dff01961d9" category="section-title">스토리지 시스템 구성</block>
  <block id="923680056b0f0258907f498670b4ead1" category="section-title">컨테이너 이미지 및 해당 Kubernetes 버전</block>
  <block id="aa92c4c233bc01609d957e469736b699" category="cell">컨테이너 이미지</block>
  <block id="3b29886980a3307188a882bdc7cad63b" category="cell">v1.17.0</block>
  <block id="ca2e728c8f17fef48811518aaed4de43" category="list-text">K8s.GCR.IO/SIG-storage/CSI-snapshotter:v3.0.3</block>
  <block id="b8f1a143b913482d06bc0abdd94e9fc7" category="cell">v1.18.0</block>
  <block id="79f59ba516b478a970a428a795414034" category="cell">v1.19.0</block>
  <block id="4b977ef7367155e20f954fe7b0a00c4f" category="cell">v1.20.0</block>
  <block id="6f0b081bef5e745ef2429ef74472d9bd" category="cell">v1.21.0</block>
  <block id="721d66fc3896f0caf2122a92b3f1c017" category="admonition">Kubernetes 버전 1.20 이상에서는 검증된 k8s.gcr.io/sig-storage/scsi-snapshotter:v4.x 이미지를 사용하십시오. v1 버전이 'volumesnapshots.snapshots.storage.k8s.io' CRD를 지원하는 경우에만 해당됩니다. v1beta1 버전이 v1 버전 없이 CRD를 지원하는 경우 검증된 k8s.gcr.io/sig-storage/scsi-snapshotter:v3.x 이미지를 사용하십시오.</block>
  <block id="a60c2f57df655a9ac5fcaa0750886195" category="summary">Kubernetes를 시작하는 경우 지침에 따라 Kubernetes를 설치하여 사용해 보십시오. 다음 지침은 Trident에서 시연을 위해 통합할 수 있는 베어본 단일 노드 클러스터를 제공합니다.</block>
  <block id="62bdbe048d174b559cb770f9ebaf0895" category="doc">시도해 보십시오</block>
  <block id="e8dadc588901af436e2c6036acf23973" category="inline-link-macro">NetApp 시험 구동</block>
  <block id="476652843c9581434ab31739d97c955a" category="paragraph">NetApp은 사용자가 요청할 수 있는 즉시 사용 가능한 연구소 이미지를 제공합니다 <block ref="eb9c34df0ed196dd801ef85207c8bf2c" category="inline-link-macro-rx"></block>. 테스트 드라이브는 3노드 Kubernetes 클러스터 및 Astra Trident가 설치 및 구성된 샌드박스 환경을 제공합니다. Astra Trident에 대해 알아보고 기능을 둘러보는 것도 좋습니다.</block>
  <block id="8685ac2061f9dca7ab48f41e0871f7af" category="inline-link-macro">kubeadm 설치 가이드</block>
  <block id="37bdb0f602c1d2a2a6f285533e4ce5c8" category="paragraph">또 다른 옵션은 을 보는 것입니다 <block ref="c7dbb75618a5e106a360075f923cb87f" category="inline-link-macro-rx"></block> Kubernetes에서 제공:</block>
  <block id="2cf0c4e99dd3c0b2e7e0f63af3531622" category="admonition">이러한 지침을 운영 환경에 사용하여 구축한 Kubernetes 클러스터를 사용해서는 안 됩니다. 배포 시 제공되는 운영 구축 가이드를 사용하여 즉시 프로덕션할 수 있는 클러스터를 생성할 수 있습니다.</block>
  <block id="e3ecede511471cf67c294e427e2f012e" category="paragraph">Kubernetes를 처음 사용하는 경우 개념 및 툴에 대해 자세히 알아보십시오 <block ref="22f850f308b2d2016502017a1dcd1044" category="inline-link-macro-rx"></block>.</block>
  <block id="55847a7d73d44b84804f47ee7863b80f" category="summary">Astra Trident를 구축한 후 백엔드 생성, 스토리지 클래스 생성, 볼륨 프로비저닝 및 POD에 볼륨 마운팅으로 진행할 수 있습니다.</block>
  <block id="3f297ef15cde0668e93b35f2752fd4fd" category="doc">다음 단계</block>
  <block id="0b0ca016c0d99a4845777aeeebb032ac" category="section-title">1단계: 백엔드를 생성합니다</block>
  <block id="4f374e8dd911d1e70f7b7a53fdac1f2a" category="paragraph">이제 Astra Trident에서 볼륨을 프로비저닝하는 데 사용할 백엔드를 만들 수 있습니다. 이렇게 하려면 필요한 매개 변수가 포함된 백엔드 .json 파일을 만듭니다. 서로 다른 백엔드 유형에 대한 샘플 구성 파일은 'ample-input' 디렉토리에서 찾을 수 있습니다.</block>
  <block id="8b389d7be97d6c697a4e775ff8338905" category="paragraph">을 참조하십시오 <block ref="49641f5ab61d7a6ce07b1b6ba31204f8" category="inline-link-macro-rx"></block> 백엔드 유형에 맞게 파일을 구성하는 방법에 대한 자세한 내용은 을 참조하십시오.</block>
  <block id="af445e1d9a0a481ba7f9b5f01df23a3d" category="paragraph">생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="00715976efdc0cc3b7c5a8512fb0e08d" category="inline-link-macro">문제 해결</block>
  <block id="936067ad00da88d877acb024c96f3129" category="paragraph">문제를 해결한 후 이 단계의 처음으로 돌아가서 다시 시도하십시오. 자세한 문제 해결 팁은 를 참조하십시오 <block ref="fa8c952f2dea85664a3e3e5dc210aa4c" category="inline-link-macro-rx"></block> 섹션을 참조하십시오.</block>
  <block id="0cf7ce61dd48f9396923c05ab8f5e302" category="section-title">2단계: 스토리지 클래스를 생성합니다</block>
  <block id="8c566ff50efde64c700b1188e862c328" category="inline-link">스토리지 클래스</block>
  <block id="c44e939795fbf61079e70122d3e77735" category="paragraph">Kubernetes 사용자는 가 지정된 영구 PVC(Volume Claim)를 사용하여 볼륨을 프로비저닝합니다<block ref="bc70014ff50467618a31ef39142ab151" category="inline-link-rx"></block> 이름별. 세부 정보는 사용자로부터 숨겨지지만 스토리지 클래스는 해당 클래스에 사용되는 공급자(이 경우 Trident)와 해당 클래스가 프로비저닝자로부터 의미하는 바를 식별합니다.</block>
  <block id="56cc6184a3bc4387f839993b204e4c5f" category="paragraph">Kubernetes 스토리지 클래스를 생성할 때 볼륨을 지정할 시기를 지정하십시오. 수업 구성에서는 이전 단계에서 생성한 백엔드를 모델링해야 하므로 Astra Trident가 이를 사용하여 새 볼륨을 프로비저닝합니다.</block>
  <block id="45a1f9131ca1bec07f47f45a194d9d58" category="paragraph">가장 간단한 스토리지 클래스는 설치 프로그램과 함께 제공되는 'ample-input/storage-class-csi.yAML.Templ' 파일을 기반으로 하는 것으로, 스토리지 드라이버 이름으로 __backend_type_'을(를) 대체합니다.</block>
  <block id="b4987be37083b7196f23d63ddd5d56df" category="paragraph">Kubernetes 오브젝트이므로 쿠버틀에서 생성되도록 kubtl을 사용하십시오.</block>
  <block id="a191af7083288f9d9556f3ebcd821a34" category="paragraph">이제 Kubernetes 및 Astra Trident에 * basic-CSI * 스토리지 클래스가 표시됩니다. Astra Trident는 백엔드에서 풀을 검색했습니다.</block>
  <block id="3bdc1ec6969d1615bb58d7f0443bf1c2" category="section-title">3단계: 첫 번째 볼륨을 프로비저닝합니다</block>
  <block id="a58b17a231318aa42ed47bfe0be43447" category="inline-link">영구적 볼륨 클레임</block>
  <block id="512b66e66e82ba09d70c3e9f784aa8af" category="paragraph">이제 첫 번째 볼륨을 동적으로 프로비저닝할 준비가 되었습니다. 이 작업은 Kubernetes를 생성하여 수행합니다<block ref="95c09f225fe48abca705fd090f5f4c89" category="inline-link-rx"></block> (PVC) 개체.</block>
  <block id="61e8eac65ddef26d4c4230d88cae8498" category="paragraph">방금 만든 저장소 클래스를 사용하는 볼륨에 대해 PVC를 생성합니다.</block>
  <block id="b357acbdc339437d16e4e967ecc6d0c2" category="paragraph">예를 들면 'Sample-input/PVC-basic-CSI.YAML'을 참조한다. 스토리지 클래스 이름이 생성한 이름과 일치하는지 확인합니다.</block>
  <block id="2fe8954464ccf22d2d06423b358f38a7" category="section-title">4단계: POD에 볼륨을 마운트합니다</block>
  <block id="366556d176e685870d134b7fc6e9ca3c" category="paragraph">이제 볼륨을 마운트하겠습니다. PV를 "/usr/share/nginx/html"에 장착하는 nginx 포드를 시작합니다.</block>
  <block id="6f5eca6ad9143d35bb33a1a17df3a848" category="paragraph">이때 POD(애플리케이션)는 더 이상 존재하지 않지만 볼륨은 여전히 존재합니다. 원하는 경우 다른 포드에서 사용할 수 있습니다.</block>
  <block id="3ba419ecccf23f33a6bae5d23f206fdd" category="paragraph">볼륨을 삭제하려면 클레임을 삭제합니다.</block>
  <block id="1a00c9156117d9ec9fa3e45d5a757d04" category="paragraph">이제 다음과 같은 추가 작업을 수행할 수 있습니다.</block>
  <block id="ce2c6a300f520205e891fc45009ec4c3" category="inline-link-macro">추가 백엔드를 구성합니다.</block>
  <block id="642bfa81920103d4177bb3fdf6f9186f" category="list-text"><block ref="642bfa81920103d4177bb3fdf6f9186f" category="inline-link-macro-rx"></block></block>
  <block id="93e8ba41e1ebcadc1338cc7f75109210" category="inline-link-macro">추가 스토리지 클래스를 생성합니다.</block>
  <block id="daa40449d28fbb16d2bcd8a8434d05e6" category="list-text"><block ref="daa40449d28fbb16d2bcd8a8434d05e6" category="inline-link-macro-rx"></block></block>
  <block id="3d522b99ca94333433532daa23e7ceab" category="summary">Astra Trident의 설치, 구성, 업그레이드 및 문제 해결에 대해 자주 묻는 질문에 대한 답변을 찾아보십시오.</block>
  <block id="af2a4d2810d86aa0169c117f82682f9a" category="doc">자주 묻는 질문</block>
  <block id="96ab491ef73d5db0cd15f55e1552cc22" category="section-title">일반적인 질문</block>
  <block id="b34c3d20de0f1b2c7a69bdc59002ad47" category="section-title">Astra Trident는 얼마나 자주 출시됩니까?</block>
  <block id="2f55088c7d055eb361252b15d5d7af10" category="paragraph">Astra Trident는 1월, 4월, 7월, 10월에 3개월마다 출시됩니다. Kubernetes 릴리스 한 달 후입니다.</block>
  <block id="15602d1e4b699ebca549a3d953672d8c" category="section-title">Astra Trident가 특정 버전의 Kubernetes에서 릴리스된 모든 기능을 지원합니까?</block>
  <block id="d860923e20119473e7f7d50683cb0559" category="paragraph">Astra Trident는 일반적으로 Kubernetes의 알파 기능을 지원하지 않습니다. Trident는 Kubernetes 베타 릴리즈를 따르는 두 Trident 릴리스 내에서 베타 기능을 지원할 수 있습니다.</block>
  <block id="52ffcf336df0055235949cf324a8624b" category="section-title">Astra Trident가 작동을 위해 다른 NetApp 제품에 종속되어 있습니까?</block>
  <block id="9a10bc69a2553cd055c7b66932fd3864" category="paragraph">Astra Trident는 다른 NetApp 소프트웨어 제품에 종속되어 있지 않으며 독립 실행형 애플리케이션으로 작동합니다. 그러나 NetApp 백엔드 스토리지 디바이스가 있어야 합니다.</block>
  <block id="bda04f64eaa9613cb4923cf43e24954c" category="section-title">Astra Trident 구성 세부 정보를 모두 얻으려면 어떻게 해야 합니까?</block>
  <block id="6d6d1fbb6191413b3262aed487048f1e" category="paragraph">"tridentctl get" 명령을 사용하여 Astra Trident 구성에 대한 자세한 정보를 얻을 수 있습니다.</block>
  <block id="d8634bcd1659c9cdf6f1a7a92ec00c30" category="section-title">Astra Trident에서 스토리지를 프로비저닝하는 방법에 대한 메트릭을 얻을 수 있습니까?</block>
  <block id="1435574cfec44734b2bfc2b94327b118" category="paragraph">예. Trident 20.01에는 관리되는 백엔드 수, 프로비저닝된 볼륨 수, 사용된 바이트 수 등 Astra Trident의 작업에 대한 정보를 수집하는 데 사용할 수 있는 Prometheus 엔드포인트가 도입되었습니다. Cloud Insights를 사용하여 모니터링 및 분석할 수도 있습니다.</block>
  <block id="3e9ebf4af3f0b9d1852396d46171ef99" category="section-title">CSI Provisioner로 Astra Trident를 사용할 때 사용자 환경이 달라집니까?</block>
  <block id="05f95d89af1ccd9b986014406a4b1fc8" category="paragraph">아니요 사용자 환경과 기능에 관한 한 변경 사항은 없습니다. 사용된 공급자 이름은 csi.trident.netapp.io` 입니다. 현재 및 향후 릴리즈에서 제공하는 모든 새로운 기능을 사용하려는 경우 이 Astra Trident 설치 방법을 사용하는 것이 좋습니다.</block>
  <block id="0a7e87df44869b8d60a83f35d1e2747b" category="section-title">Kubernetes 클러스터에 Astra Trident를 설치 및 사용합니다</block>
  <block id="ffb25b8f3453272318fba778e825268f" category="section-title">etcd의 지원되는 버전은 무엇입니까?</block>
  <block id="6a3ad0d68dcfe0164611dadb7f7656f9" category="paragraph">아스트라 트리덴트(Astra Trident)는 더 이상 '에트cd'를 필요로 하지 않습니다. CRD를 사용하여 상태를 유지합니다.</block>
  <block id="bde6cb03741f92107c63aeebe62d3278" category="section-title">Astra Trident가 개인 레지스트리에서 오프라인 설치를 지원합니까?</block>
  <block id="eeabb890ce57551c5685ffb613b78406" category="paragraph">예, Astra Trident는 오프라인으로 설치할 수 있습니다. 을 참조하십시오 <block ref="f0cd5c2694f3680f6758ce5ce7e21a5b" category="inline-link-macro-rx"></block>.</block>
  <block id="1c51806b370d428d5779dbcacd940174" category="section-title">Astra Trident를 원격으로 설치할 수 있습니까?</block>
  <block id="bf858450c271da75a3df3a15ca761330" category="paragraph">예. Astra Trident 18.10 이상은 클러스터에 대한 "kudctl" 액세스 권한이 있는 모든 시스템에서 원격 설치 기능을 지원합니다. "kubbtl" 액세스를 확인한 후(예: 원격 시스템에서 kubeck get nodes 명령을 시작하여 확인) 설치 지침을 따릅니다.</block>
  <block id="12694c2de4575e39a6f7e81d55e35de9" category="section-title">Astra Trident를 사용하여 고가용성을 구성할 수 있습니까?</block>
  <block id="f1cf2ca3af6ca7c374ad2104f570c790" category="paragraph">Astra Trident는 하나의 인스턴스로 Kubernetes 배포(ReplicaSet)로 설치되었으므로 HA가 내장되어 있습니다. 구축 시 복제본 수를 늘이지 않아야 합니다. Astra Trident가 설치된 노드가 손실되거나 POD에 액세스할 수 없는 경우 Kubernetes가 자동으로 Pod를 클러스터의 정상 노드에 다시 배포합니다. Astra Trident는 컨트롤 플레인만 지원하므로 Astra Trident를 다시 구축할 경우 현재 마운트된 Pod는 영향을 받지 않습니다.</block>
  <block id="1656e4b34abdb6d497b40cac65366767" category="section-title">Astra Trident에서 kube-system 네임스페이스에 액세스해야 합니까?</block>
  <block id="6f67e1edfd4aa5b0e695528a9c7d8898" category="paragraph">Astra Trident가 Kubernetes API Server에서 읽어 애플리케이션에서 새로운 PVC를 요청할 시기를 결정하므로 kubbe-system에 액세스해야 합니다.</block>
  <block id="16cdb35003b5bcf0f30556e0bc477511" category="section-title">Astra Trident에서 사용하는 역할 및 권한은 무엇입니까?</block>
  <block id="dd57666df1542a5c5c1c8ea446433dba" category="paragraph">Trident 설치 프로그램은 Kubernetes 클러스터의 PersistentVolume, PersistentVolumeClaim, StorageClass 및 Secret 리소스에 대한 특정 액세스 권한을 가진 Kubernetes ClusterRole을 생성합니다. 을 참조하십시오 <block ref="21005beb39aa5b473ddc4fbc9c302e0b" category="inline-link-macro-rx"></block>.</block>
  <block id="8ff39a39871cc30228035bc0580a6af4" category="section-title">설치에 Astra Trident가 사용하는 정확한 매니페스트 파일을 로컬로 생성할 수 있습니까?</block>
  <block id="34edccb29a11f4f0728f07bbefd9d0e6" category="paragraph">필요한 경우 설치에 Astra Trident가 사용하는 정확한 매니페스트 파일을 로컬에서 생성하고 수정할 수 있습니다. 을 참조하십시오 <block ref="21005beb39aa5b473ddc4fbc9c302e0b" category="inline-link-macro-rx"></block>.</block>
  <block id="e6af67b71bd46d7588b50f28e1414f9b" category="section-title">두 개의 개별 Kubernetes 클러스터를 위한 두 개의 개별 Astra Trident 인스턴스에 동일한 ONTAP 백엔드 SVM을 공유할 수 있습니까?</block>
  <block id="7bbf9b47e035f0f9bb7c46098e78fb4d" category="paragraph">권장되지 않지만 두 개의 Astra Trident 인스턴스에 동일한 백엔드 SVM을 사용할 수 있습니다. 설치 시 각 인스턴스의 고유한 볼륨 이름을 지정하거나 셋업/백엔드 .json 파일에 고유한 'toragePrefix' 매개변수를 지정하십시오. 이는 동일한 FlexVol가 두 인스턴스에 모두 사용되지 않도록 하기 위한 것입니다.</block>
  <block id="9840a5bb6278469ed550bcdcc92c29c5" category="section-title">ContainerLinux(이전의 CoreOS) 아래에 Astra Trident를 설치할 수 있습니까?</block>
  <block id="7a35680d9db247612b732ae47144f030" category="paragraph">Astra Trident는 Kubernetes Pod로, Kubernetes를 실행 중인 모든 위치에 설치할 수 있습니다.</block>
  <block id="5fc6de1b535ebb2a5380b6aa607e4cca" category="section-title">NetApp Cloud Volumes ONTAP에서 Astra Trident를 사용할 수 있습니까?</block>
  <block id="5d1cff73e26dc54ef52bdca5a29b319c" category="paragraph">예. Astra Trident는 AWS, Google Cloud 및 Azure에서 지원됩니다.</block>
  <block id="2ddee53d5c18f6e78f18dad82851303e" category="section-title">Astra Trident가 Cloud Volumes Services와 작동합니까?</block>
  <block id="404ebcdc21eb83145ddb36d33bd8c09e" category="paragraph">예, Astra Trident는 Azure의 Azure NetApp Files 서비스와 AWS 및 GCP의 Cloud Volumes Service를 지원합니다.</block>
  <block id="92d1656d06303733c5e1398fb273a17e" category="section-title">문제 해결 및 지원</block>
  <block id="9985a592486717ae388709b9267da4f9" category="section-title">NetApp은 Astra Trident를 지원합니까?</block>
  <block id="cc56e0da96ceaf708545923f1094815b" category="paragraph">Astra Trident는 오픈 소스이며 무료로 제공되지만, NetApp 백엔드가 지원되는 경우 NetApp은 이를 완벽하게 지원합니다.</block>
  <block id="a3d907947129a58ee6f9e23074840c8f" category="section-title">지원 케이스를 어떻게 제기합니까?</block>
  <block id="0265687df6c09d532b03477776c6d075" category="paragraph">지원 케이스를 제기하려면 다음 중 하나를 수행합니다.</block>
  <block id="5dab8cca21a0ff4e72d4e2a1ee5156ea" category="list-text">지원 어카운트 매니저에게 연락하여 티켓을 발급하는 데 도움을 받으십시오.</block>
  <block id="09ea0908fbfc4cde85bf416e35dc55c8" category="inline-link">NetApp 지원</block>
  <block id="a13956d424374973d31e5883b8bf8b6a" category="list-text">에 연락하여 지원 케이스를 제출하십시오<block ref="116f7ad90a3c7441981f82d8f8fba4d5" category="inline-link-rx"></block>.</block>
  <block id="3e77e87e5ee8fb4f6f910f4cf0594fc2" category="section-title">지원 로그 번들을 생성하려면 어떻게 해야 합니까?</block>
  <block id="7938aed248d09a5120eaf414e6c1d574" category="paragraph">tridentctl logs-a를 실행하여 지원 번들을 생성할 수 있습니다. 번들에 캡처된 로그 외에 kubelet 로그를 캡처하여 Kubernetes 측의 마운트 문제를 진단합니다. 쿠벨렛 로그를 얻는 지침은 Kubernetes 설치 방법에 따라 다릅니다.</block>
  <block id="2c3543f339dc749a508ed5e5e5aaae23" category="section-title">새 기능에 대한 요청을 제기해야 하는 경우 어떻게 해야 합니까?</block>
  <block id="42bfc6e3acd67192d42135138102a1de" category="inline-link">GitTrident 허브</block>
  <block id="c2146fea25aea76bae1b5853f60a2f87" category="paragraph">에서 문제를 만듭니다<block ref="47273b71915582ec6db59ad21099cfb9" category="inline-link-rx"></block> 제목에 * RFE * 를 기재하고 문제에 대한 설명을 기재하십시오.</block>
  <block id="0aa1d7a95d75c0faa8302a803356b7b7" category="section-title">결함은 어디에서 제기합니까?</block>
  <block id="4c1d312c39e7048d2c634824e243fdba" category="inline-link">Astra Trident GitHub를 참조하십시오</block>
  <block id="a814c59a6fef2fb64a2a32dedcf6f82e" category="paragraph">에서 문제를 만듭니다<block ref="e71a8230f1c77ee7d957187295b859e4" category="inline-link-rx"></block>. 문제와 관련된 모든 필수 정보와 로그를 포함해야 합니다.</block>
  <block id="fd0759571f12527967b660b5b327c65b" category="section-title">Astra Trident에 대한 간단한 질문을 하면 어떻게 됩니까? 커뮤니티나 포럼이 있습니까?</block>
  <block id="3561f3a3c5576e2ce0dc0d1e268bb9b2" category="inline-link">슬랙</block>
  <block id="f549c74b636d0ad80493d063fe6ecfc3" category="paragraph">질문, 문제 또는 요청이 있을 경우 NetApp을 통해 문의하십시오<block ref="2d9f7b5a7f56881c42c3b026a068eb36" category="inline-link-rx"></block> 팀 또는 GitHub를 선택합니다.</block>
  <block id="264c3819b5a8fdae87f1dc9af1988a90" category="section-title">스토리지 시스템의 암호가 변경되었고 Astra Trident가 더 이상 작동하지 않습니다. 어떻게 복구합니까?</block>
  <block id="061ec2ab4d383b8f20e15eda656db8f7" category="paragraph">'tridentctl update backend mybackend -f&lt;/path/to_new_backend.json&gt; -n triment'로 백엔드 암호를 업데이트합니다. 이 예에서 'mybackend'를 백엔드 이름으로, '/path/to_new_backend.json'을 올바른 백엔드 .json 파일 경로로 바꿉니다.</block>
  <block id="6100f37d544e87e462129f21e52bae7f" category="section-title">Astra Trident에서 내 Kubernetes 노드를 찾을 수 없습니다. 이 문제를 해결하려면 어떻게 합니까?</block>
  <block id="d5cf5c734786394c838bacc6597594c6" category="paragraph">Astra Trident가 Kubernetes 노드를 찾을 수 없는 두 가지 시나리오가 있을 수 있습니다. Kubernetes의 네트워킹 문제 또는 DNS 문제 때문일 수 있습니다. 각 Kubernetes 노드에서 실행되는 Trident 노드 데모는 Trident 컨트롤러와 통신하여 노드를 Trident에 등록할 수 있어야 합니다. Astra Trident를 설치한 후 네트워킹 변경이 발생하면 클러스터에 추가된 새 Kubernetes 노드에서만 이 문제가 발생합니다.</block>
  <block id="bcd549c9f0199c5b8d0b55f782bff9e8" category="section-title">Trident POD가 제거되면 데이터를 손실합니까?</block>
  <block id="136fed1edd42bf8ca22358da037d17fa" category="paragraph">Trident POD를 제거할 경우 데이터가 손실되지 않습니다. Trident의 메타데이터는 CRD 객체에 저장됩니다. Trident에서 프로비저닝한 모든 PVS가 정상적으로 작동합니다.</block>
  <block id="3de05f78e401869f4630ec8cabf339df" category="section-title">이전 버전에서 새 버전으로 직접 업그레이드할 수 있습니까(일부 버전을 건너뛰는 경우)?</block>
  <block id="ce44cbbc54839f39b351c091b0e3caa5" category="paragraph">NetApp은 하나의 주요 릴리즈에서 바로 다음 주요 릴리즈로 Astra Trident를 업그레이드할 수 있도록 지원합니다. 버전 18.xx에서 19.xx, 19.xx에서 20.xx로 업그레이드할 수 있습니다. 운영 구축 전에 연구소에서 업그레이드를 테스트해야 합니다.</block>
  <block id="0399b9e6348e554937a4d65efc97a1b8" category="section-title">Trident를 이전 릴리즈로 다운그레이드할 수 있습니까?</block>
  <block id="d307563c01953bd90a41ddd049f96d51" category="inline-link-macro">다운그레이드 섹션을 참조하십시오</block>
  <block id="0dedfa196a76d45ea496a2b3ebca850a" category="paragraph">다운그레이드를 원할 경우 다양한 요소를 평가해야 합니다. 을 참조하십시오 <block ref="4734dc58d0c9739f3584035ff28dc1f1" category="inline-link-macro-rx"></block>.</block>
  <block id="ba9c59aa9d07b25e124dcf6ca88d689a" category="section-title">백엔드 및 볼륨 관리</block>
  <block id="ffe72215dff9a93d62ee68905212025e" category="section-title">ONTAP 백엔드 정의 파일에서 관리 및 데이터 LIF를 모두 정의해야 합니까?</block>
  <block id="3a35d35cc18d96684d78b36a81422e0c" category="paragraph">백엔드 정의 파일에 둘 다 포함하는 것이 좋습니다. 그러나 관리 LIF는 필수 항목일 뿐입니다.</block>
  <block id="f3997f0b9446951754e665cfe7591cef" category="section-title">Astra Trident에서 ONTAP 백엔드에 대한 CHAP를 구성할 수 있습니까?</block>
  <block id="805f73dde029c6c119993b4496bbdc9e" category="paragraph">예. 20.04부터 Astra Trident는 ONTAP 백엔드에 대한 양방향 CHAP를 지원합니다. 이를 위해서는 백엔드 구성에서 'useCHAP=true'를 설정해야 합니다.</block>
  <block id="952cc22022a80bb8079f6dd7afb289d2" category="section-title">Astra Trident를 사용하여 엑스포트 정책을 관리하려면 어떻게 해야 합니까?</block>
  <block id="700815d44ae9a359311f64dbebbd8d42" category="paragraph">Astra Trident는 버전 20.04 이상에서 내보내기 정책을 동적으로 생성하고 관리할 수 있습니다. 따라서 스토리지 관리자는 백엔드 구성에서 하나 이상의 CIDR 블록을 제공할 수 있으며, 이러한 범위에 속하는 Trident 추가 노드 IP를 생성한 엑스포트 정책에 추가할 수 있습니다. 이러한 방식으로 Astra Trident는 주어진 CIDR 내에 IP가 있는 노드의 규칙 추가 및 삭제를 자동으로 관리합니다. 이 기능을 사용하려면 CSI Trident가 필요합니다.</block>
  <block id="ddd61a9bf73a6cb2a2375bcdfbecbe15" category="section-title">DataLIF에 포트를 지정할 수 있습니까?</block>
  <block id="c7449c080f216d9be59d8ff995985d39" category="paragraph">Astra Trident 19.01 이후 버전에서는 DataLIF에 포트를 지정할 수 있습니다. backend.json 파일에 ""management LIF":&lt;ip address&gt;:&lt;port&gt;""로 설정한다. 예를 들어, 관리 LIF의 IP 주소가 192.0.2.1이고 포트가 1000이면 """관리 LIF":"192.0.2.1:1000""을 구성합니다.</block>
  <block id="1d08384060bd88a7801faae4fe346d06" category="section-title">관리 및 데이터 LIF에 IPv6 주소를 사용할 수 있습니까?</block>
  <block id="955e051838e60a39384f98e20ef67d47" category="paragraph">예. Astra Trident 20.01은 ONTAP 백엔드에 대한 관리 LIF 및 데이터 LIF 매개 변수의 IPv6 주소 정의를 지원합니다. 주소가 IPv6 의미를 따르고 관리 LIF가 대괄호 안에 정의되어 있는지 확인해야 합니다(예: "[ec0d:6504:a9c1:a961:533d1:4bdf:ab32:e233]"). 또한 Astra Trident가 IPv6 기능을 위해 '--use-ipv6' 플래그를 사용하여 설치되어 있는지 확인해야 합니다.</block>
  <block id="4c0e813a0bfed033d75bbfd8b18f556c" category="section-title">백엔드에서 관리 LIF를 업데이트할 수 있습니까?</block>
  <block id="66d8fee83a94421ca416a2bdb33703b4" category="paragraph">예. 'tridentctl update backend' 명령을 사용하여 백엔드 관리 LIF를 업데이트할 수 있습니다.</block>
  <block id="c56cd7a01da4acc4fc86aa498cabfd99" category="section-title">백엔드에서 데이터 LIF를 업데이트할 수 있습니까?</block>
  <block id="9f811ba6d553275226edbacf07b2828b" category="paragraph">아니요. 백엔드에서 데이터 LIF를 업데이트할 수 없습니다.</block>
  <block id="1e0e6fcec605e6450ba12b95969c8959" category="section-title">Kubernetes용 Astra Trident에서 여러 개의 백엔드를 생성할 수 있습니까?</block>
  <block id="fb3cb30bfe23466a98407256c8b5164f" category="paragraph">Astra Trident는 동일한 드라이버나 다른 드라이버를 사용하여 동시에 많은 백엔드를 지원할 수 있습니다.</block>
  <block id="6454319cc2398418b67f5b2df5aa5cd3" category="section-title">Astra Trident는 백엔드 자격 증명을 어떻게 저장합니까?</block>
  <block id="1d406f7ac7268b602da0989a4675480e" category="paragraph">Astra Trident는 백엔드 자격 증명을 Kubernetes Secrets로 저장합니다.</block>
  <block id="64a610ffaa66abeebc73d8159b9f73ec" category="section-title">Astra Trident는 특정 백엔드를 어떻게 선택합니까?</block>
  <block id="c6e9fbb586ad55ddf4bbda9814c6adc9" category="paragraph">백엔드 속성을 사용하여 클래스에 맞는 풀을 자동으로 선택할 수 없는 경우 특정 풀 세트를 선택하는 데 'toragePools' 및 'additionalStoragePools' 매개 변수가 사용됩니다.</block>
  <block id="3beefa69a05dde01d93a438a943a5a7a" category="section-title">Astra Trident가 특정 백엔드에서 프로비저닝하지 않도록 하려면 어떻게 해야 합니까?</block>
  <block id="b5c265487a1fed6a3367664ccab664bb" category="paragraph">excludeStoragePools 매개 변수는 Astra Trident가 프로비저닝에 사용할 풀 세트를 필터링하고 일치하는 풀을 제거하는 데 사용됩니다.</block>
  <block id="e124ac30adf3eea60a13cd5f93980e7e" category="section-title">동일한 종류의 백엔드가 여러 개 있는 경우 Astra Trident는 어떤 백엔드를 사용할 것인지 어떻게 선택할 수 있습니까?</block>
  <block id="c02ba3e7f8a02e0d1e29e2190a86e352" category="paragraph">동일한 유형의 백엔드가 여러 개 구성되어 있는 경우 Astra Trident는 'torageClass' 및 'PersistentVolumeClaim'에 있는 매개 변수를 기반으로 적절한 백엔드를 선택합니다. 예를 들어, 여러 ONTAP-NAS 드라이버 백엔드가 있는 경우 Astra Trident는 'torageClass' 및 'PersistentVolumeClaim'의 매개 변수를 조합하여 'torageClass' 및 'PersistVolumeentClaim'에 나열된 요구 사항을 전달할 수 있는 백엔드와 일치시킵니다. 요청과 일치하는 백엔드가 여러 개 있는 경우, Astra Trident는 임의의 백엔드 중 하나를 선택합니다.</block>
  <block id="7a2fd62f4a63259a7f94543a0ae01e76" category="section-title">Astra Trident가 Element/SolidFire를 사용하는 양방향 CHAP를 지원합니까?</block>
  <block id="b127099c71415d532da3a26ed73eb041" category="paragraph">예.</block>
  <block id="7880810a250adc4ccf5108fe88325055" category="section-title">Astra Trident는 ONTAP 볼륨에 qtree를 어떻게 배포합니까? 단일 볼륨에 몇 개의 qtree를 구축할 수 있습니까?</block>
  <block id="657cbdac1a85665b0b38b37c9a306925" category="paragraph">'ONTAP-NAS-이코노미' 드라이버는 동일한 FlexVol에서 최대 200개의 qtree(50~300 구성 가능), 클러스터 노드당 100,000 qtree, 클러스터당 2.4M qtree를 지원합니다. 이코노미 드라이버가 서비스하는 새 "PersistentVolumeClaim"을 입력하면 운전자는 새 Qtree를 처리할 수 있는 FlexVol가 이미 있는지 확인합니다. Qtree를 처리할 수 있는 FlexVol가 없으면 새 FlexVol가 생성됩니다.</block>
  <block id="abbdd4298bb3e525fd172b2bbe5a451c" category="section-title">ONTAP NAS에 프로비저닝된 볼륨에 대해 Unix 권한을 설정하려면 어떻게 해야 합니까?</block>
  <block id="a535e502931280dfaa539ecd1cbdfc0c" category="paragraph">백엔드 정의 파일에 매개 변수를 설정하여 Astra Trident가 프로비저닝한 볼륨에 대해 Unix 권한을 설정할 수 있습니다.</block>
  <block id="094ef47e6456d60b656401b0f2bbfcbd" category="section-title">볼륨을 프로비저닝하는 동안 명시적 ONTAP NFS 마운트 옵션 세트를 구성하려면 어떻게 합니까?</block>
  <block id="84ae0d345d4b749efbbc8103b0770e68" category="paragraph">기본적으로 Astra Trident는 Kubernetes의 마운트 옵션을 아무 값으로도 설정하지 않습니다. Kubernetes 스토리지 클래스에서 마운트 옵션을 지정하려면 지정된 예제를 따르십시오<block ref="cd55c45fce745b7032050d3a7a9ec326" category="inline-link-rx"></block>.</block>
  <block id="ae6bc3659bb0be0a7d9f98a63775b7c2" category="section-title">프로비저닝된 볼륨을 특정 엑스포트 정책으로 설정하려면 어떻게 해야 합니까?</block>
  <block id="700a2008fea63d02c24b85f2f75d357e" category="paragraph">적절한 호스트가 볼륨에 액세스할 수 있도록 하려면 백엔드 정의 파일에 구성된 "exportPolicy" 매개 변수를 사용합니다.</block>
  <block id="9d5813dee71bcbf3d3a03c62354c3e55" category="section-title">ONTAP가 있는 Astra Trident를 통해 볼륨 암호화를 설정하려면 어떻게 해야 합니까?</block>
  <block id="5467ffdca7c34378117097446e6a4408" category="paragraph">백엔드 정의 파일의 암호화 매개 변수를 사용하여 Trident에서 프로비저닝한 볼륨에 대한 암호화를 설정할 수 있습니다.</block>
  <block id="ef1581716b653c4364dd5005dbe9e40a" category="section-title">Astra Trident를 통해 ONTAP에 대한 QoS를 구축하는 가장 좋은 방법은 무엇입니까?</block>
  <block id="f412d672b51ea3c57812ebf3be0ddccb" category="paragraph">ONTAP용 QoS를 구현하려면 'torageClaes'를 사용합니다.</block>
  <block id="1c771b761835123a135e64f70567d768" category="section-title">Astra Trident를 통해 씬 또는 일반 프로비저닝을 지정하려면 어떻게 해야 합니까?</block>
  <block id="0d97afe7a571dc39db1c810013844332" category="paragraph">ONTAP 드라이버는 씬 또는 일반 프로비저닝을 지원합니다. ONTAP 드라이버는 기본적으로 씬 프로비저닝입니다. 일반 프로비저닝이 필요한 경우 백엔드 정의 파일 또는 'torageClass'를 구성해야 합니다. 둘 다 구성된 경우 'torageClass'가 우선합니다. ONTAP에 대해 다음을 구성합니다.</block>
  <block id="2d0384de8b72e53c3476a478a5d4ec53" category="list-text">'torageClass'에서 'vorioningType' 속성을 굵게로 설정합니다.</block>
  <block id="3764067c4b14276efb241c511c8b0cc2" category="list-text">백엔드 정의 파일에서 'Backend spaceReserve Parameter'를 볼륨으로 설정하여 일반 볼륨을 활성화합니다.</block>
  <block id="d4391b26a81fead46afc74243c4029aa" category="section-title">실수로 PVC를 삭제한 경우에도 사용 중인 볼륨이 삭제되지 않도록 하려면 어떻게 해야 합니까?</block>
  <block id="e58a684cd1a44d4879defbb2ec06b9a4" category="paragraph">PVC 보호는 버전 1.10부터 Kubernetes에서 자동으로 활성화됩니다.</block>
  <block id="8d766c7d692523686b8954d72ee86ea4" category="section-title">Astra Trident에서 만든 NFS PVC를 늘릴 수 있습니까?</block>
  <block id="328e34871ba32779f27f3e8a8e78499a" category="paragraph">예. Astra Trident에서 만든 PVC를 확장할 수 있습니다. 볼륨 자동 증가 기능은 Trident에 적용되지 않는 ONTAP 기능입니다.</block>
  <block id="f2f324d5d940b44cd307b613c6990e0c" category="section-title">Astra Trident 외부에서 생성된 볼륨이 있는 경우 Astra Trident로 가져올 수 있습니까?</block>
  <block id="c894ce628e51d8d9d062a1e83cda37c8" category="paragraph">19.04부터는 볼륨 가져오기 기능을 사용하여 Kubernetes에 볼륨을 가져올 수 있습니다.</block>
  <block id="3319194e0ba07a6aa327aefa1ab1e41f" category="section-title">SnapMirror 데이터 보호(DP) 또는 오프라인 모드일 때 볼륨을 가져올 수 있습니까?</block>
  <block id="0b10afe39923054016a71caf423fdec6" category="paragraph">외부 볼륨이 DP 모드이거나 오프라인인 경우 볼륨 가져오기가 실패합니다. 다음과 같은 오류 메시지가 나타납니다.</block>
  <block id="9fd7d017b60cc366b6bc3b6e55213abe" category="section-title">Astra Trident에서 만든 iSCSI PVC를 확장할 수 있습니까?</block>
  <block id="29e2faaced65d1dd4c920c60e854e550" category="paragraph">Trident 19.10은 CSI Provisioner를 사용하여 iSCSI PVS를 확장할 수 있도록 지원합니다.</block>
  <block id="eed67b2d196c61d9c6cf4a50878ba446" category="section-title">리소스 할당량은 NetApp 클러스터로 어떻게 변환됩니까?</block>
  <block id="45f78013e46c8f3e884ed0f7becbd5ab" category="paragraph">NetApp 스토리지의 용량이 있는 경우 Kubernetes 스토리지 리소스 할당량이 작동합니다. 용량 부족으로 인해 NetApp 스토리지가 Kubernetes 할당량 설정을 적용할 수 없을 경우 Astra Trident가 프로비저닝하려고 하지만 오류를 해결합니다.</block>
  <block id="491a93842f7a65b8cbe82aca71db0d3f" category="section-title">Astra Trident를 사용하여 볼륨 스냅샷을 생성할 수 있습니까?</block>
  <block id="9792ac41ce6f91861f84548e1b4a2b1c" category="paragraph">예. Astra Trident는 스냅샷에서 필요 시 볼륨 스냅샷 및 영구 볼륨 생성을 지원합니다. 스냅샷에서 PVS를 생성하려면 'VolumeSnapshotDataSource' 기능 게이트가 활성화되어 있는지 확인합니다.</block>
  <block id="1eedb8a6574b0c07ea61689a7e3ec8d4" category="section-title">Astra Trident 볼륨 스냅샷을 지원하는 드라이버는 무엇입니까?</block>
  <block id="24c649a639a2c31810a4dfc6ed0190da" category="section-title">ONTAP를 사용하여 Astra Trident가 프로비저닝한 볼륨의 스냅샷 백업을 어떻게 생성합니까?</block>
  <block id="0bdcd128fab544a7df404bc496a4126e" category="paragraph">ONTAP-NAS, ONTAP-SAN, ONTAP-NAS-Flexgroup 드라이버에서 지원됩니다. FlexVol 레벨에서 ONTAP-SAN-이코노미 드라이버에 대한 스냅샷 정책을 지정할 수도 있습니다.</block>
  <block id="933b520ff6d70262ddb482995c684d57" category="paragraph">이는 'ONTAP-NAS-이코노미' 드라이버에서도 사용할 수 있지만 qtree 레벨의 세분화가 아니라 FlexVol 레벨의 세분화 수준에서 확인할 수 있습니다. Astra Trident에서 프로비저닝한 볼륨을 스냅샷하는 기능을 사용하려면 백엔드 매개 변수 옵션 '스냅샷 정책'을 ONTAP 백엔드에 정의된 대로 원하는 스냅샷 정책으로 설정하십시오. 스토리지 컨트롤러에서 생성한 스냅샷은 Astra Trident에서 알 수 없습니다.</block>
  <block id="594e8a352537de25938bdd663d6211b5" category="section-title">Astra Trident를 통해 프로비저닝된 볼륨에 대한 스냅샷 예약 비율을 설정할 수 있습니까?</block>
  <block id="8db5662205f3a6430af4bea6f08e7d45" category="paragraph">예. 백엔드 정의 파일에 '스냅샷 예약' 속성을 설정하여 Astra Trident를 통해 스냅샷 복사본을 저장할 디스크 공간의 특정 비율을 예약할 수 있습니다. 백엔드 정의 파일에 '스냅샷 정책'과 '스냅샷 예약'을 구성한 경우 백엔드 파일에 명시된 '스냅샷 예약 공간' 비율에 따라 스냅샷 예약 비율이 설정됩니다. '스냅샷 예약' 백분율 값이 언급되지 않은 경우 ONTAP는 기본적으로 스냅샷 예약 비율을 5로 설정합니다. '스냅샷 정책' 옵션이 없음으로 설정되어 있으면 스냅샷 예약 비율은 0으로 설정됩니다.</block>
  <block id="6b0d34d8a0749198a6b80eec69479c86" category="section-title">볼륨 스냅샷 디렉토리에 직접 액세스하고 파일을 복사할 수 있습니까?</block>
  <block id="eb3a2d1eb3c4022269f4c6837332311a" category="paragraph">예. 백엔드 정의 파일에서 '스냅샷 디렉토리' 매개 변수를 설정하여 Trident에서 프로비저닝한 볼륨의 스냅샷 디렉토리에 액세스할 수 있습니다.</block>
  <block id="81dbf5e91cc69bfcf6477128389d8a25" category="section-title">Astra Trident를 통해 볼륨에 대해 SnapMirror를 설정할 수 있습니까?</block>
  <block id="64dd4ea74b402889a9c341da491f4933" category="paragraph">현재 ONTAP CLI 또는 OnCommand System Manager를 사용하여 외부에서 SnapMirror를 설정해야 합니다.</block>
  <block id="e321bf6d54ded18df56a41ea51223a2a" category="section-title">영구 볼륨을 특정 ONTAP 스냅샷으로 복원하려면 어떻게 합니까?</block>
  <block id="5325f5d2cf63aaaa6610f09e8aa4dc35" category="paragraph">ONTAP 스냅숏에 볼륨을 복원하려면 다음 단계를 수행하십시오.</block>
  <block id="4e789db936072df2058e9f271a9b8db8" category="list-text">영구 볼륨을 사용하는 응용 프로그램 포드를 중지합니다.</block>
  <block id="b34baa75f4f799a23b19de9b94e86868" category="list-text">ONTAP CLI 또는 OnCommand System Manager를 통해 필요한 스냅샷으로 되돌립니다.</block>
  <block id="08754f2800804f1fe3673c858b4b56e0" category="list-text">응용 프로그램 포드를 다시 시작합니다.</block>
  <block id="0d3ef54a4cc337b5d907b6639e51c6d4" category="section-title">각 고객/테넌트에 대해 스토리지 클래스 사용을 어떻게 분리할 수 있습니까?</block>
  <block id="fda1b35892cb6f61447f0e49415937d9" category="paragraph">Kubernetes에서는 네임스페이스의 스토리지 클래스를 허용하지 않습니다. 그러나 Kubernetes를 사용하여 네임스페이스당 사용되는 스토리지 리소스 할당량을 사용하여 네임스페이스당 특정 스토리지 클래스의 사용을 제한할 수 있습니다. 특정 스토리지에 대한 특정 네임스페이스 액세스를 거부하려면 해당 스토리지 클래스에 대한 리소스 할당량을 0으로 설정합니다.</block>
  <block id="ea3d51fb2b16acb7cb260f25bc8965b1" category="summary">Astra Trident는 NetApp에서 관리하는 오픈 소스 스토리지 공급자 및 오케스트레이터입니다. Docker 및 Kubernetes에서 관리하는 컨테이너식 애플리케이션을 위한 스토리지 볼륨을 생성할 수 있습니다.</block>
  <block id="30d965eef5ba25c6b9998ae38270b43e" category="doc">법적 고지</block>
  <block id="c59ae8d7beeb519a23478ab048af482c" category="paragraph"><block ref="c59ae8d7beeb519a23478ab048af482c" category="inline-link-macro-rx"></block></block>
  <block id="e20acf6d4b1275a0b5d2eb01c845adff" category="summary">NetApp은 다양한 방법으로 Trident를 지원합니다. Slack 채널과 같은 다양한 무료 셀프 지원 옵션을 24x7 이용할 수 있습니다.</block>
  <block id="db5eb84117d06047c97c9a0191b5fffe" category="doc">지원</block>
  <block id="14340f3a4eb25a54f8446036d807d7c8" category="paragraph">Astra Trident는 공식적으로 지원되는 NetApp 프로젝트입니다. 표준 메커니즘을 사용하여 NetApp에 연락하면 필요한 엔터프라이즈급 지원을 받을 수 있습니다.</block>
  <block id="31521e7ff20a98e479b412febf1ac4b4" category="inline-link">NetApp의 Slack Work</block>
  <block id="b622c74429f1282e8ed1f79ee8d53260" category="paragraph">컨테이너 채널에는 컨테이너 사용자(Astra Trident 개발자 포함)의 활발한 공공 커뮤니티도 있습니다<block ref="e5c49b87a1fe6d362b72260d2620cf35" category="inline-link-rx"></block>. 프로젝트에 대한 일반적인 질문을 하고 비슷한 생각을 가진 동료와 관련 주제를 논의할 수 있는 좋은 장소입니다.</block>
  <block id="ef1161058705470bb877fbce688eea9e" category="summary">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="9a5f09cf66e692efdae493ce4c9aa64f" category="inline-link-macro">준비</block>
  <block id="6c728e8788471413351ba9fcd26ca76e" category="list-text"><block ref="6c728e8788471413351ba9fcd26ca76e" category="inline-link-macro-rx"></block></block>
  <block id="e5fc4f2bd89271cfb112e8b768f74dde" category="inline-link-macro">구성 및 예</block>
  <block id="874216718c1d50bbd2aa417449058e46" category="list-text"><block ref="874216718c1d50bbd2aa417449058e46" category="inline-link-macro-rx"></block></block>
  <block id="ce8828fc10a926c196951c9bdd0d534d" category="section-title">사용자 권한</block>
  <block id="96c17dbe45e7351fb2a4f71956c25e0c" category="paragraph">Astra Trident는 일반적으로 "admin" 클러스터 사용자 또는 "vsadmin" SVM 사용자를 사용하거나 동일한 역할을 가진 다른 이름을 가진 사용자를 사용하여 ONTAP 또는 SVM 관리자로 실행될 것으로 예상합니다. NetApp ONTAP 구축을 위한 Amazon FSx의 경우 Astra Trident는 클러스터 'fsxadmin' 사용자 또는 'vsadmin' SVM 사용자 또는 동일한 역할을 가진 다른 이름의 사용자를 사용하여 ONTAP 또는 SVM 관리자로 실행될 것으로 예상합니다. 'fsxadmin' 사용자는 클러스터 관리자 사용자에게 제한된 교체품입니다.</block>
  <block id="4937b52eb2cb058f225b69b2caafaf29" category="admonition">'limitAggregateUsage' 매개 변수를 사용하는 경우 클러스터 관리자 권한이 필요합니다. Astra Trident와 함께 NetApp ONTAP용 Amazon FSx를 사용하는 경우 "limitAggregateUsage" 매개 변수는 "vsadmin" 및 "fsxadmin" 사용자 계정과 작동하지 않습니다. 이 매개 변수를 지정하면 구성 작업이 실패합니다.</block>
  <block id="8f828c7344e7fe65d66237a25193068b" category="summary">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="b5c795328aa98beaf5bdc15b54a533c1" category="paragraph">ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오. 모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="5475028f502d04bc17cdfdf613d28cbf" category="paragraph">또한 둘 이상의 드라이버를 실행하고 둘 중 하나를 가리키는 스토리지 클래스를 생성할 수도 있습니다. 예를 들어, ONTAP-SAN 드라이버와 ONTAP-SAN-이코노미 클래스를 사용하는 '기본 클래스'를 사용하는 'san-dev' 클래스를 구성할 수 있습니다.</block>
  <block id="3b40a8d4978192509495ce411fe8db8c" category="paragraph">모든 Kubernetes 작업자 노드에 적절한 iSCSI 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="9ec363a49b52db56773849151c5853d4" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="c75f7811d70d17dbcd88e9d03752cbed" category="section-title">인증</block>
  <block id="51e35cec1e001fb8abfbe474a18dd282" category="paragraph">Astra Trident는 ONTAP 백엔드를 인증하는 두 가지 모드를 제공합니다.</block>
  <block id="00cbc0e7ed0014813b07fc8452f60df1" category="list-text">자격 증명 기반: 필요한 권한이 있는 ONTAP 사용자의 사용자 이름 및 암호입니다. ONTAP 버전과의 호환성을 최대한 보장하기 위해 admin 또는 vsadmin과 같은 미리 정의된 보안 로그인 역할을 사용하는 것이 좋습니다.</block>
  <block id="e2cd9c84c3ebf14f3c81be4692848e5b" category="list-text">인증서 기반: Astra Trident는 백엔드에 설치된 인증서를 사용하여 ONTAP 클러스터와 통신할 수도 있습니다. 이 경우 백엔드 정의에는 클라이언트 인증서, 키 및 사용할 경우 신뢰할 수 있는 CA 인증서의 Base64로 인코딩된 값이 있어야 합니다(권장).</block>
  <block id="f3a85dfc22761b09346aa0134d77d4f9" category="paragraph">사용자는 기존 백엔드를 업데이트할 수도 있으며 자격 증명 기반 에서 인증서 기반 으로, 그 반대로 전환할 수도 있습니다. 자격 증명과 인증서가 둘 다 제공된 경우 *, Astra Trident는 기본적으로 인증서를 사용하는 동시에 백엔드 정의에서 자격 증명을 제거하는 경고를 표시합니다.</block>
  <block id="a2f8f419bf420960ef8cca73e1999e09" category="section-title">자격 증명 기반 인증을 사용합니다</block>
  <block id="ceae351bc6b26100a9b1685a5d477c0a" category="paragraph">Astra Trident는 SVM 범위/클러스터 범위 관리자에게 ONTAP 백엔드와 통신하기 위한 자격 증명을 요구합니다. admin 또는 vsadmin과 같이 미리 정의된 표준 역할을 사용하는 것이 좋습니다. 이를 통해 향후 Astra Trident 릴리스에서 사용할 기능 API를 노출할 수 있는 향후 ONTAP 릴리스와 향후 호환성이 보장됩니다. 사용자 지정 보안 로그인 역할은 Astra Trident와 함께 생성 및 사용할 수 있지만 권장되지 않습니다.</block>
  <block id="2312b8f77f99c346269b67308afc3649" category="paragraph">백엔드 정의의 예는 다음과 같습니다.</block>
  <block id="2a2ef6dcf08a8789a55301af5f71304c" category="paragraph">백엔드 정의는 자격 증명이 일반 텍스트로 저장되는 유일한 위치라는 점에 유의하십시오. 백엔드가 생성된 후 사용자 이름/암호는 Base64로 인코딩되어 Kubernetes 암호로 저장됩니다. 백엔드의 생성/업딩은 자격 증명에 대한 지식이 필요한 유일한 단계입니다. 따라서 Kubernetes/스토리지 관리자가 수행할 수 있는 관리 전용 작업입니다.</block>
  <block id="052f76b486189a7b01340d5134eb7985" category="section-title">인증서 기반 인증을 사용합니다</block>
  <block id="0778b06c5ea9fded4fd7b586b248dd86" category="paragraph">신규 및 기존 백엔드는 인증서를 사용하여 ONTAP 백엔드와 통신할 수 있습니다. 백엔드 정의에는 세 가지 매개 변수가 필요합니다.</block>
  <block id="d5b9c9db262b1927d7914504f3587adb" category="list-text">clientCertificate: Base64로 인코딩된 클라이언트 인증서 값입니다.</block>
  <block id="8f2b750dd6a57864f0e36828c248ddfc" category="list-text">clientPrivateKey: Base64 - 연결된 개인 키의 인코딩된 값입니다.</block>
  <block id="200c2d2a44dec6455fa1c947f9c1f534" category="list-text">TrustedCACertificate: 신뢰할 수 있는 CA 인증서의 Base64 인코딩 값입니다. 신뢰할 수 있는 CA를 사용하는 경우 이 매개 변수를 제공해야 합니다. 신뢰할 수 있는 CA가 사용되지 않으면 이 작업을 무시할 수 있습니다.</block>
  <block id="6b634823c19ebc37c9e4fdbf08de1fff" category="paragraph">일반적인 워크플로에는 다음 단계가 포함됩니다.</block>
  <block id="c92e58d7dd251e6e6cdb16291a6dec90" category="list-text">클라이언트 인증서 및 키를 생성합니다. 생성 시 CN(일반 이름)을 ONTAP 사용자로 설정하여 인증하십시오.</block>
  <block id="69b521cddbc52a2d14539e349e2930f0" category="list-text">신뢰할 수 있는 CA 인증서를 ONTAP 클러스터에 추가합니다. 이는 스토리지 관리자가 이미 처리한 것일 수 있습니다. 트러스트된 CA가 사용되지 않으면 무시합니다.</block>
  <block id="2f3945695e5ca88abb46af80d87c6972" category="list-text">ONTAP 클러스터에 클라이언트 인증서 및 키(1단계)를 설치합니다.</block>
  <block id="e81810c4035ad015ad3f0d8c4f2c6454" category="list-text">ONTAP 보안 로그인 역할이 인증서 인증 방법을 지원하는지 확인합니다.</block>
  <block id="ea3bf76b270384627e7bcfb197ddb17b" category="list-text">생성된 인증서를 사용하여 인증을 테스트합니다. ONTAP 관리 LIF&gt; 및 &lt;SVM 이름&gt;을 관리 LIF IP 및 SVM 이름으로 바꿉니다.</block>
  <block id="83f2adf143dc8f5fbbb9d924f840c1ce" category="list-text">Base64로 인증서, 키 및 신뢰할 수 있는 CA 인증서를 인코딩합니다.</block>
  <block id="8d36e570f1edac5ae19e6733e3fbb4d5" category="list-text">이전 단계에서 얻은 값을 사용하여 백엔드를 생성합니다.</block>
  <block id="2ab8ad0fce083cd02635b9126cf4353c" category="section-title">인증 방법을 업데이트하거나 자격 증명을 회전합니다</block>
  <block id="85a73bd1a3fad449b226a7eecb546c6b" category="paragraph">기존 백엔드를 업데이트하여 다른 인증 방법을 사용하거나 해당 자격 증명을 회전할 수 있습니다. 이렇게 하면 사용자 이름/암호를 사용하는 백엔드를 인증서를 사용하도록 업데이트할 수 있고 인증서를 사용하는 백엔드는 사용자 이름/암호 기반으로 업데이트할 수 있습니다. 이를 위해서는 tridentctl backend update를 실행하는 데 필요한 parameter가 포함된 update 된 backend.json 파일을 사용한다.</block>
  <block id="5e36c3d66bd47ae551071244dc48df17" category="admonition">암호를 회전할 때 스토리지 관리자는 먼저 ONTAP에서 사용자의 암호를 업데이트해야 합니다. 그 다음에는 백엔드 업데이트가 있습니다. 인증서를 회전할 때 여러 인증서를 사용자에게 추가할 수 있습니다. 그런 다음 백엔드가 업데이트되어 새 인증서를 사용합니다. 그러면 ONTAP 클러스터에서 이전 인증서를 삭제할 수 있습니다.</block>
  <block id="6819218365fe3a3d66752f663feecddb" category="paragraph">백엔드를 업데이트해도 이미 생성된 볼륨에 대한 액세스가 중단되거나 이후에 생성된 볼륨 연결에 영향을 미치지 않습니다. 백엔드 업데이트가 성공적이면 Astra Trident가 ONTAP 백엔드와 통신하고 향후 볼륨 작업을 처리할 수 있음을 나타냅니다.</block>
  <block id="93a4f17ec735c794a2d38eb0d9dc736b" category="section-title">Igroup을 지정합니다</block>
  <block id="f66329c2f28d3aade033dade4fa02359" category="paragraph">Astra Trident에서 igroup을 사용하여 프로비저닝하는 볼륨(LUN)에 대한 액세스를 제어합니다. 관리자는 백엔드에 대한 igroup을 지정할 때 다음 두 가지 옵션을 사용할 수 있습니다.</block>
  <block id="caf7ba3262c90c77b09b7d53946b7be4" category="list-text">Astra Trident는 백엔드에 따라 igroup을 자동으로 생성하고 관리할 수 있습니다. 만약 'triviName'이 백엔드 정의에 포함되지 않으면, Astra Trident는 SVM에 'trident-&lt;backend-UUID&gt;'라는 igroup을 생성합니다. 그러면 각 백엔드에 전용 igroup이 있고 Kubernetes 노드 IQN의 자동 추가/삭제를 처리합니다.</block>
  <block id="b325b5680680ba28771d11978100bf3a" category="list-text">또는 미리 생성된 igroup을 백엔드 정의로 제공할 수도 있습니다. 이 작업은 'show'(이름) config 매개 변수를 사용하여 수행할 수 있습니다. Astra Trident가 기존 igroup에 Kubernetes 노드 IQN을 추가/삭제합니다.</block>
  <block id="ccdb9f53393401f058dcfc9c1de74547" category="paragraph">'인명이름'이 정의된 백엔드의 경우, '인명이름'을 '트리멘틀백엔드 업데이트'를 사용하여 삭제하고 Astra Trident에서 Igroup을 자동 처리할 수 있습니다. 이 경우 워크로드에 이미 연결된 볼륨에 대한 액세스가 중단되지 않습니다. 생성된 igroup Astra Trident를 사용하여 향후 연결을 처리할 것입니다.</block>
  <block id="8841675f2e0dbba5719034b41ac52435" category="admonition">Astra Trident의 각 고유 인스턴스에 대해 igroup을 할당하는 것은 Kubernetes 관리자 및 스토리지 관리자에게 유용한 모범 사례입니다. CSI Trident는 클러스터 노드 IQN을 igroup에 추가 및 제거하여 관리를 크게 단순화합니다. 전용 igroup을 사용하여 Kubernetes 환경(및 Astra Trident 설치)에서 동일한 SVM을 사용할 경우 한 Kubernetes 클러스터의 변경 사항이 다른 Kubernetes 클러스터와 관련된 igroup에 영향을 미치지 않도록 합니다. 또한 Kubernetes 클러스터의 각 노드에 고유한 IQN이 있는지 확인하는 것도 중요합니다. 위에 언급한 바와 같이, Astra Trident는 IQN의 추가 및 제거를 자동으로 처리합니다. 호스트 간에 IQN을 재사용하면 호스트가 서로 잘못 인식되어 LUN에 대한 액세스가 거부되는 바람직하지 않은 시나리오가 발생할 수 있습니다.</block>
  <block id="a3a4bece92a1c7bb017b9bc2681621f7" category="paragraph">Astra Trident가 CSI Provisioner로 작동하도록 구성된 경우 Kubernetes 노드 IQN이 igroup에 자동으로 추가/제거됩니다. Kubernetes 클러스터에 노드를 추가하면, "trident-CSI" DemonSet는 새로 추가된 노드에 pod("trident-CSI-xxxxx")를 배포하고 볼륨을 연결할 수 있는 새 노드를 등록합니다. 노드 IQN도 백엔드의 igroup에 추가됩니다. 이와 유사한 일련의 단계에서는 Kubernetes에서 노드에 코드로닝, 드레이닝 및 삭제가 발생하는 경우 IQN 제거를 처리합니다.</block>
  <block id="3882232e20d620974a87db190a124fe7" category="paragraph">Astra Trident가 CSI Provisioner로 실행되지 않을 경우, Kubernetes 클러스터의 모든 작업자 노드에서 iSCSI IQN을 포함하도록 igroup을 수동으로 업데이트해야 합니다. Kubernetes 클러스터에 참여하는 노드의 IQN을 igroup에 추가해야 합니다. 마찬가지로, Kubernetes 클러스터에서 제거된 노드의 IQN을 igroup에서 제거해야 합니다.</block>
  <block id="42f93278b0d15c8d0f6613813bf586d5" category="section-title">양방향 CHAP를 사용하여 연결을 인증합니다</block>
  <block id="5d34ca21e19aa85f2e3cbc5bc90702fb" category="paragraph">Astra Trident는 ONTAP-SAN과 ONTAP-SAN 절약 드라이버에 양방향 CHAP를 사용하여 iSCSI 세션을 인증할 수 있습니다. 이를 위해서는 백엔드 정의에서 'useCHAP' 옵션을 사용해야 합니다. "true"로 설정하면 Astra Trident가 SVM의 기본 이니시에이터 보안을 양방향 CHAP로 구성하고 백엔드 파일의 사용자 이름과 암호를 설정합니다. 양방향 CHAP를 사용하여 연결을 인증하는 것이 좋습니다. 다음 샘플 구성을 참조하십시오.</block>
  <block id="12dd7bfa072b5a1eecf975f6a5a6eaa7" category="admonition">useCHAP는 한 번만 설정할 수 있는 Boolean 옵션이다. 기본적으로 false로 설정되어 있습니다. true 로 설정한 후에는 false 로 설정할 수 없습니다.</block>
  <block id="bc601528678aeeb582101ed205a054bc" category="paragraph">useCHAP=true 외에, chapInitatorSecret, chapTargetInitialatorSecret, chapchTargetUsername, chapUsername 필드가 백엔드 정의에 포함되어야 합니다. tridentctl update를 실행하여 백엔드를 생성한 후 비밀을 변경할 수 있다.</block>
  <block id="9ffdb95250e26c7a6b468126ac7c75b0" category="section-title">작동 방식</block>
  <block id="adbaa30840aebfe537058f72e0989326" category="paragraph">스토리지 관리자는 useCHAP를 true로 설정하여 스토리지 백엔드에서 CHAP를 구성하도록 Astra Trident에 지시합니다. 여기에는 다음이 포함됩니다.</block>
  <block id="29b4db879e4cc96a6b71bc763367624b" category="list-text">SVM에서 CHAP 설정:</block>
  <block id="951e8b45bc49a5475337a1b55e3e3dc4" category="list-text">SVM의 기본 이니시에이터 보안 유형이 없음(기본값으로 설정) * 이고 * 볼륨에 이미 기존 LUN이 없는 경우 Astra Trident는 기본 보안 유형을 "CHAP"로 설정하고 CHAP 이니시에이터 및 대상 사용자 이름 및 암호 구성을 진행합니다.</block>
  <block id="313818ab0cd3579429d5bd6e5faab8ff" category="list-text">SVM에 LUN이 포함된 경우 Astra Trident는 SVM에서 CHAP를 활성화하지 않습니다. 따라서 SVM에 이미 있는 LUN에 대한 액세스가 제한되지 않습니다.</block>
  <block id="13e0c564d5e1fbd33279fb276166653d" category="list-text">CHAP 이니시에이터 및 타겟 사용자 이름과 암호를 구성합니다. 이러한 옵션은 백엔드 구성에 지정해야 합니다(위 참조).</block>
  <block id="9154c9db577ccbf466ca622a07931896" category="list-text">백엔드에 있는 'si. 이름'에 이니셜레이터 추가 관리 지정되지 않은 경우 기본적으로 트리덴트가 사용됩니다.</block>
  <block id="2c7856e86a0cd46cb4fb48fa0886745e" category="paragraph">백엔드가 생성된 후 Astra Trident는 해당 'tridentbackend' CRD를 생성하고 CHAP 비밀과 사용자 이름을 Kubernetes 비밀로 저장합니다. 이 백엔드에서 Astra Trident에 의해 생성된 모든 PVS는 CHAP를 통해 마운트되고 연결됩니다.</block>
  <block id="81f2df0265026a1a04bda5484798a10d" category="section-title">자격 증명을 회전하고 백엔드를 업데이트합니다</block>
  <block id="a7fe005c9f49619f4438aac8932fb361" category="paragraph">backend.json 파일에서 CHAP 파라미터를 업데이트하여 CHAP 자격 증명을 업데이트할 수 있다. 이렇게 하려면 CHAP 암호를 업데이트하고 "tridentctl update" 명령을 사용하여 이러한 변경 사항을 반영해야 합니다.</block>
  <block id="8959ac16a58b09dc5a158e86ab02cb53" category="admonition">백엔드의 CHAP 암호를 업데이트할 때 "tridentctl"을 사용하여 백엔드를 업데이트해야 합니다. Astra Trident에서 변경 사항을 선택할 수 없으므로 CLI/ONTAP UI를 통해 스토리지 클러스터의 자격 증명을 업데이트하지 마십시오.</block>
  <block id="1a59d0d7850406f157c314978eb3b821" category="paragraph">기존 연결은 영향을 받지 않습니다. SVM에서 Astra Trident가 자격 증명을 업데이트하면 활성 상태로 유지됩니다. 새 연결은 업데이트된 자격 증명을 사용하며 기존 연결은 계속 활성 상태로 유지됩니다. 기존 PVS를 연결 해제하고 다시 연결하면 업데이트된 자격 증명을 사용하게 됩니다.</block>
  <block id="4cc2b9916e7383e5fa29dc6188159e32" category="summary">백엔드는 Astra Trident와 스토리지 시스템 간의 관계를 정의합니다. Astra Trident가 스토리지 시스템과 통신하는 방법과 Astra Trident가 스토리지 시스템에서 볼륨을 프로비저닝하는 방법을 알려줍니다. Astra Trident를 설치한 후 다음 단계는 백엔드를 생성하는 것입니다. '트리펜엔드구성' 사용자 정의 리소스 정의(CRD)를 사용하면 Kubernetes 인터페이스를 통해 Trident 백엔드를 직접 생성하고 관리할 수 있습니다. 쿠베틀이나 이와 동등한 CLI 툴을 사용하여 Kubernetes를 배포할 수 있습니다.</block>
  <block id="a8e174c63ac21920b8405ffddc39214a" category="doc">kubectl로 백엔드를 만듭니다</block>
  <block id="913a4b06671d1e04e6582a85afe3abbe" category="section-title">트리엔백구성</block>
  <block id="d2031a5a319b9363cf98da6b1509598a" category="paragraph">트리젠벤디Config('tbc', 'tbconfig', 'tbackendconfig')는 쿠벡틀로 아스트라 트리덴트 백엔드를 관리할 수 있는 프론트이자 이름있는 CRD입니다. 이제 Kubernetes 및 스토리지 관리자는 전용 명령줄 유틸리티('tridentctl')를 사용하지 않고 Kubernetes CLI를 통해 직접 백엔드를 생성 및 관리할 수 있습니다.</block>
  <block id="b44c2fd5cefc815abed7e31c0fa8c8ac" category="paragraph">'트리펜엔드구성' 객체가 생성되면 다음과 같은 현상이 발생합니다.</block>
  <block id="858fafdff7fa27f202ae0eb981c6dff0" category="list-text">백엔드는 사용자가 제공하는 구성에 따라 Astra Trident에서 자동으로 생성합니다. 이는 내부적으로 트리덴백엔드(트리덴백엔드) CR로 표현된다.</block>
  <block id="40640dd98ca175d098c1c765b1e148d9" category="list-text">트리젠트백엔드구성은 아스트라 트리덴트(Astra Trident)가 만든 트리젠백엔드(트리젠백엔드)에 고유하게 바인딩됩니다.</block>
  <block id="1efc3a14ca6dc7c90db79e02f3abe7d5" category="paragraph">각각의 트리젠백엔드구성은 트리젠백엔드(트리젠백엔드)를 통해 일대일 매핑을 유지합니다. 전자는 백엔드를 설계 및 구성하기 위해 사용자에게 제공되는 인터페이스이며, 후자는 Trident가 실제 백엔드 객체를 나타내는 방법입니다.</block>
  <block id="c9038f47fe0df535b6bf5619c9ff629e" category="admonition">트리젠백엔드 CRS는 아스트라 트리덴트(Astra Trident)에 의해 자동으로 생성됩니다. 수정할 수 없습니다. 백엔드에 대한 업데이트를 하려면 '트리엔백구성' 개체를 수정하여 이 작업을 수행하십시오.</block>
  <block id="9c3385530cf6e460576e5f6e7cc1b912" category="paragraph">'트리엔백엔드구성' CR의 형식은 다음 예를 참조하십시오.</block>
  <block id="c84ef67352bb6783ff2881f9f2821c2a" category="inline-link">Trident - 장착 공구</block>
  <block id="f13a06ff6eab87969a9f96765f31ed9c" category="paragraph">의 예를 살펴볼 수도 있습니다<block ref="6511e50af21389f9e77db56e03f6dd72" category="inline-link-rx"></block> 원하는 스토리지 플랫폼/서비스의 샘플 구성을 위한 디렉토리입니다.</block>
  <block id="06df669f3ef6f929e9b58c9f47b65310" category="inline-link-macro">스토리지 드라이버에 대한 백엔드 구성 정보입니다</block>
  <block id="182839d8f6b2bdde60e1d972422cf3a2" category="paragraph">이 'pec'은 백엔드 구성 매개 변수를 사용합니다. 이 예에서는 백엔드에서 'ONTAP-SAN' 스토리지 드라이버를 사용하고 여기에 표로 제공된 구성 매개 변수를 사용합니다. 원하는 스토리지 드라이버에 대한 구성 옵션 목록은 를 참조하십시오 <block ref="5f2d139eefa7c36061f4d97161be02ea" category="inline-link-macro-rx"></block>.</block>
  <block id="92051c832f01d9070a7ed71d1ce523c5" category="paragraph">이번 시기에는 트리젠백엔드Config CR에 새로 도입된 자격 증명과 delitionPolicy 필드가 포함되어 있습니다.</block>
  <block id="5ab961de690e071f0dc1c0dabac7fd89" category="list-text">"credentials": 이 매개변수는 필수 필드이며 스토리지 시스템/서비스를 인증하는 데 사용되는 자격 증명을 포함합니다. 사용자 생성 Kubernetes Secret으로 설정됩니다. 자격 증명을 일반 텍스트로 전달할 수 없으며 오류가 발생합니다.</block>
  <block id="9f11e03722a7b912083c63fc68f4dd7b" category="list-text">"설명 정책": 이 필드는 트리젠BackendConfig가 삭제될 때 발생하는 동작을 정의합니다. 다음 두 가지 값 중 하나를 사용할 수 있습니다.</block>
  <block id="d09d50d3f84f9c585492818f491a2497" category="list-text">삭제(Delete): 이 경우 트리엔백엔드Config CR과 관련 백엔드가 모두 삭제됩니다. 이 값이 기본값입니다.</block>
  <block id="f0c89ce27bf4c43949ad8f26a4f586bb" category="list-text">[Tain]: 트리덴트Config CR이 삭제되면 백엔드 정의가 계속 존재하고 tridentctl로 관리될 수 있다. 삭제 정책을 "보존"으로 설정하면 사용자는 이전 릴리스(21.04 이전)로 다운그레이드하고 생성된 백엔드를 유지할 수 있습니다. 이 필드의 값은 '트리엔백엔드구성'이 생성된 후에 업데이트할 수 있습니다.</block>
  <block id="7f2208582df334d090d35357eb5d6901" category="admonition">백엔드 이름은 'pec.backendName'을 사용하여 설정됩니다. 지정하지 않으면 백엔드 이름이 '트리엔백엔드구성' 객체(metadata.name 지정합니다. 'pec.backendName'을 사용하여 백엔드 이름을 명시적으로 설정하는 것이 좋습니다.</block>
  <block id="317e77f416ffd109037a657fffa1e7f7" category="admonition">tridentctl로 만든 백엔드에는 관련된 트리젠BackendConfig 객체가 없습니다. 트리젠백엔드Config CR을 만들어 kubctl로 백엔드를 관리할 수 있습니다. 동일한 구성 매개 변수(예: 'pec.backendName', 'pec.storagePrefix', 'pec.storageDriverName' 등)를 지정할 때는 주의해야 합니다. Astra Trident는 새로 생성된 '트리젠백엔드구성'을 기존 백엔드와 자동으로 바인딩합니다.</block>
  <block id="625cc9b8ccc34496dc2b3fcffb7e384a" category="section-title">단계 개요</block>
  <block id="a867c4bbc8d632a517f22b7377b9b8ed" category="paragraph">kubbeck을 사용하여 새 백엔드를 생성하려면 다음을 수행해야 합니다.</block>
  <block id="4db4699aa0126dfb06878d7e07c0abdf" category="inline-link">쿠버네티스 비밀</block>
  <block id="7e5e1bb39eefe4eec7a88b845126d41d" category="list-text">을 생성합니다<block ref="fcce7b7bd05b6b012eabe3df8de04808" category="inline-link-rx"></block>. 비밀에는 Astra Trident가 스토리지 클러스터/서비스와 통신하는 데 필요한 자격 증명이 포함되어 있습니다.</block>
  <block id="c39d193a9cc4084cc6c7964e1bb5efd8" category="list-text">'트리멘백엔드구성' 객체를 만듭니다. 스토리지 클러스터/서비스에 대한 자세한 내용과 이전 단계에서 생성한 암호를 참조하십시오.</block>
  <block id="286b0035cf59742ffe54696b798f2368" category="paragraph">백엔드를 생성한 후 "kubbtl get tbc&lt;tbc-name&gt;-n&lt;trident-namespace&gt;"를 사용하여 해당 상태를 관찰하고 추가 세부 정보를 수집할 수 있습니다.</block>
  <block id="494cb787cd1c1f78123323c1006f2081" category="section-title">1단계: Kubernetes Secret 생성</block>
  <block id="a8c4d0cb53af2c6e334f5c58890021d6" category="paragraph">백엔드에 대한 액세스 자격 증명이 포함된 암호를 생성합니다. 이는 각 스토리지 서비스/플랫폼마다 다릅니다. 예를 들면 다음과 같습니다.</block>
  <block id="04402bf69acac56c72a55c0e4ac2165c" category="paragraph">이 표에는 각 스토리지 플랫폼의 비밀에 포함되어야 하는 필드가 요약되어 있습니다.</block>
  <block id="94cec86c6eef229009007e6d00d54ef1" category="cell">스토리지 플랫폼 암호 필드 설명입니다</block>
  <block id="1e6947ac7fb3a9529a9726eb692c8cc5" category="cell">비밀</block>
  <block id="c11257eff6563de2c05e353770c514ca" category="cell">필드 설명입니다</block>
  <block id="93c5bebdea9c94a0740fe6fd9bb250f0" category="paragraph">클라이언트 ID입니다</block>
  <block id="012e85295e2f1f744cfb8757f8dd4830" category="paragraph">앱 등록에서 클라이언트 ID</block>
  <block id="c9ff119073ea2567730fb42e3a4fe805" category="paragraph">ApiKey</block>
  <block id="defb11bd732dde7d185fcc4583818851" category="paragraph">CVS 계정 API 키입니다</block>
  <block id="ce656850400574e9f9cffb285ee8abc0" category="paragraph">secretKey를 선택합니다</block>
  <block id="5324944de62956f7d758fd5d2f6d8826" category="paragraph">CVS 계정 암호 키입니다</block>
  <block id="ee64ef6c307cfcfe5c0f085471cd61fa" category="paragraph">private_key_id</block>
  <block id="1e31c22f827d25c5973eee697baace79" category="paragraph">개인 키의 ID입니다. CVS 관리자 역할을 가진 GCP 서비스 계정에 대한 API 키의 일부</block>
  <block id="156a17333e77a3c504018cae5ada8c3b" category="paragraph">개인 키</block>
  <block id="8e0708b67ba6ce0f70a948152e7e7895" category="paragraph">개인 키. CVS 관리자 역할을 가진 GCP 서비스 계정에 대한 API 키의 일부</block>
  <block id="25de05ab7f10e99b499db62e0b89ad33" category="cell">요소(NetApp HCI/SolidFire)</block>
  <block id="2a6ba72e93aa7fa676d07973ed2716bb" category="paragraph">엔드포인트</block>
  <block id="41eba2d95ecaf35c8bd3a972c263ffe4" category="paragraph">테넌트 자격 증명이 있는 SolidFire 클러스터의 MVIP입니다</block>
  <block id="253b40ae359ba25b56231803430c4873" category="cell">ONTAP</block>
  <block id="14c4b06b824ec593239362517f538b29" category="paragraph">사용자 이름</block>
  <block id="6e1b40351708d93ce8c387f6f8ca7533" category="paragraph">클러스터/SVM에 연결할 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다</block>
  <block id="5f4dcc3b5aa765d61d8327deb882cf99" category="paragraph">암호</block>
  <block id="4d3fd9a7ab4c84b857fc26b2633237d0" category="paragraph">클러스터/SVM에 연결하는 암호 자격 증명 기반 인증에 사용됩니다</block>
  <block id="19dce7ac7f5290fc8fa218ad0c858df5" category="paragraph">clientPrivateKey를 선택합니다</block>
  <block id="8c5e8d4f9acf9295e1a96feef0c0b516" category="paragraph">Base64 - 클라이언트 개인 키의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="039e9d80fa53ba861c06b590ba3f9d34" category="paragraph">챕터 사용자 이름</block>
  <block id="a7128cd45d4a277fe5c6ed6f6c4238f7" category="paragraph">인바운드 사용자 이름입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="f9d0dc78b203f2c1106dc0c7d58a5397" category="paragraph">챕터시토시크릿</block>
  <block id="2f573af61fb37b4f1c5e2def2341b7c4" category="paragraph">CHAP 이니시에이터 암호입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="2ebe107bb3bc9551fbb0e5033046931c" category="paragraph">chapTargetUsername 을 선택합니다</block>
  <block id="e945f079b3e50bd5722f056b72282608" category="paragraph">대상 사용자 이름입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="4ab84a55744951d967033db9b64f6b27" category="paragraph">챕터타겟이니터시크릿</block>
  <block id="61b50fba255c10a4a2b5f7cf8276849a" category="paragraph">CHAP 타겟 이니시에이터 암호입니다. useCHAP = TRUE인 경우 필수입니다. ONTAP-SAN과 ONTAP-SAN 경제입니다</block>
  <block id="73d583a1445e1497ec3adaa011e2724c" category="paragraph">이 단계에서 만든 암호는 다음 단계에서 만든 트리젠백엔드Config 개체의 '증명서' 필드에 참조됩니다.</block>
  <block id="80a6c6a7044e3f06bb524f88ac2058f4" category="section-title">2단계: 트리엔백구성 CR을 작성합니다</block>
  <block id="3394622f88ed2c82c85e92e908879095" category="paragraph">이제 '트리엔백구성' CR을 만들 준비가 되었습니다. 이 예에서 'ONTAP-SAN' 드라이버를 사용하는 백엔드는 아래에 나와 있는 ' TridentBackendConfig ' 객체를 사용하여 생성합니다.</block>
  <block id="b5a13f13012993635ae9e627f314bbb9" category="section-title">3단계: 트리엔디Config CR의 상태를 확인합니다</block>
  <block id="967688089cfc07a6c8e893bce5186445" category="paragraph">이제 '트리펜엔드구성' CR을 생성했으므로 상태를 확인할 수 있습니다. 다음 예를 참조하십시오.</block>
  <block id="edc9d2e179d9bd8effd5277699967aff" category="paragraph">백엔드가 성공적으로 생성되어 '트리엔백엔드구성' CR에 바인딩되었습니다.</block>
  <block id="ecb5320e6f020f2c2dcad7a6268111ed" category="paragraph">위상은 다음 값 중 하나를 사용할 수 있습니다.</block>
  <block id="35ef366711dba4820492cd153e2bc30d" category="list-text">바운드: 트리젠백엔드Config CR은 백엔드와 연결되며 백엔드에는 트리젠백엔드Config CR의 uid로 설정된 configRef가 포함되어 있습니다.</block>
  <block id="f2edf590deb30828e48e7290aa78e788" category="list-text">'Unbound': ''로 표현됨. 트리젠백엔드Config 객체가 백엔드에 바인딩되지 않습니다. 새로 만든 트리젠백엔드Config CRS는 기본적으로 이 단계에 있습니다. 단계가 변경된 후에는 다시 바인딩되지 않은 상태로 되돌릴 수 없습니다.</block>
  <block id="895ba30a6f39f0691ad851fe26560431" category="list-text">"트리엔테구성" CR의 "설명 정책"이 삭제되도록 설정되었습니다. 트리젠백엔드Config CR이 삭제되면 삭제 상태로 전환됩니다.</block>
  <block id="0550ab6955adf5805cf2d00b7c592718" category="list-text">백엔드에 영구 볼륨 클레임(PVCs)이 없는 경우, 트리엔백엔드구성을 삭제하면 Astra Trident가 백엔드를 삭제하고 '트리엔백구성' CR을 삭제합니다.</block>
  <block id="ffd02eb489e62222a00391567d0bad81" category="list-text">백엔드에 PVC가 하나 이상 있는 경우 삭제 상태로 전환됩니다. 이후 트리젠백엔드Config CR도 삭제 단계로 진입한다. 모든 PVC가 삭제된 후에만 백엔드 및 트리젠백엔드구성이 삭제됩니다.</block>
  <block id="39d978e14d4d8c9f19589af0d4e72661" category="list-text">손실: 트리젠백엔드Config CR과 관련된 백엔드가 실수로 또는 고의적으로 삭제되었고, 트리젠백엔드Config CR에는 삭제된 백엔드에 대한 참조가 여전히 있습니다. 이 경우에도 '항목 정책' 값에 관계없이 '트리멘백엔드구성' CR은 삭제할 수 있습니다.</block>
  <block id="8375bdbfbc291bcedc60e7555e3dc43a" category="list-text">알 수 없음: Astra Trident가 ' Trident' CR과 연관된 백엔드의 상태 또는 존재를 확인할 수 없습니다. 예를 들어, API 서버가 응답하지 않거나 'tridentbackends.trident.netapp.io` CRD가 없는 경우 이 경우 사용자의 개입이 필요할 수 있습니다.</block>
  <block id="fdf3d4560a801cb64c255cc2790fe9cc" category="inline-link-macro">백엔드 업데이트 및 백엔드 삭제</block>
  <block id="57867491a75119ccf33f6ed8a434ff8e" category="paragraph">이 단계에서는 백엔드가 성공적으로 생성됩니다! 다음과 같은 몇 가지 작업을 추가로 처리할 수 있습니다 <block ref="9f5a7b55f1a44b55d5336cefd3bf688e" category="inline-link-macro-rx"></block>.</block>
  <block id="4dca0b80562cc590644c1acfada17219" category="section-title">(선택 사항) 4단계: 자세한 내용을 확인하십시오</block>
  <block id="22f66c61dd35abb0ae1840a7e38ae1b9" category="paragraph">다음 명령을 실행하여 백엔드에 대한 자세한 정보를 얻을 수 있습니다.</block>
  <block id="aab3a73056ee2962dff0130da0538454" category="paragraph">또한 '트리엔백구성'의 YAML/JSON 덤프를 얻을 수도 있습니다.</block>
  <block id="9fae9b8b2e8f0d5b91654165a5dacc1f" category="paragraph">'backendInfo'에는 '트리젠BackendConfig' CR에 대응하여 만든 백엔드의 'backendName'과 'backendUUID'가 포함되어 있습니다. 'lastOperationStatus' 필드는 사용자 트리거(예: 사용자가 'spec'에서 무언가를 변경한 경우) 또는 Astra Trident(예: Astra Trident 재시작 시)에 의해 트리거될 수 있는 '트리엔백엔드 Config' CR의 마지막 작업 상태를 나타냅니다. 성공 또는 실패일 수 있습니다. 단계 는 트리젠백엔드Config CR과 백엔드 간의 관계를 나타냅니다. 위의 예에서 'phase'는 값이 바인딩되어 있어 '트리젠백엔드구성' CR이 백엔드와 연결되어 있음을 의미합니다.</block>
  <block id="7b7587593fc7d381339d450faa35dfa9" category="paragraph">"kubbctl -n trident tbc &lt;tbc-cr-name&gt;" 명령을 실행하여 이벤트 로그의 세부 정보를 확인할 수 있습니다.</block>
  <block id="6dc07da7e54d697726bb349fb693fa8b" category="inline-link-macro">여기 를 참조하십시오</block>
  <block id="c732962a4a01ea5f406ec66e50e98903" category="admonition">tridentctl을 사용하여 연결된 'TrientBackendConfig' 객체가 포함된 백엔드는 업데이트하거나 삭제할 수 없습니다. tridentctl과 트리멘BackendConfig의 전환 단계를 이해하려면 <block ref="8d6bc70a41f48e3f72c3f5ea8752090b" category="inline-link-macro-rx"></block>.</block>
  <block id="bc960ce53bb0d62c44b5a3f212c279d3" category="summary">스토리지 클래스를 생성하고, 스토리지 클래스를 삭제하고, 기존 스토리지 클래스를 볼 수 있습니다.</block>
  <block id="e8b9c3a9859a62e9a58431c3b61f75d5" category="doc">스토리지 클래스를 관리합니다</block>
  <block id="5802c976ee5f858f76699af5294812e6" category="paragraph">스토리지 클래스 생성, 스토리지 클래스 삭제 및 기존 스토리지 클래스 보기에 대한 정보를 찾을 수 있습니다.</block>
  <block id="e123173acd76721f31496874fd778eca" category="section-title">스토리지 클래스를 설계합니다</block>
  <block id="a9a4b52c93b141ba28676afe58a5900d" category="paragraph">을 참조하십시오 <block ref="5a81d2db77288939223c6a591fc3991d" category="inline-link-macro-rx"></block> 스토리지 클래스의 정의 및 구성 방법에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="14f4c7abe09c4481722f1fa6563f2604" category="section-title">스토리지 클래스를 생성합니다</block>
  <block id="99b068c418b4a658f64806517e8567ac" category="paragraph">스토리지 클래스 파일이 있으면 다음 명령을 실행합니다.</block>
  <block id="fac03ff7d61c420a4caeeb44355cb2be" category="paragraph">'&lt;storage-class-file&gt;'을(를) 스토리지 클래스 파일 이름으로 바꿔야 합니다.</block>
  <block id="0fe0aa7b9b7529f66030afb1629507bb" category="section-title">스토리지 클래스를 삭제합니다</block>
  <block id="4bf50148821c75f616a96daca9255e6f" category="paragraph">Kubernetes에서 스토리지 클래스를 삭제하려면 다음 명령을 실행합니다.</block>
  <block id="65494a0b3404ce637afd88bcb7c82998" category="paragraph">'&lt;storage-class&gt;'은(는) 스토리지 클래스로 교체해야 합니다.</block>
  <block id="a5f526f5d63d827ce2c0146a20cd2ff7" category="paragraph">이 스토리지 클래스를 통해 생성된 영구 볼륨은 변경되지 않으며 Astra Trident는 계속 관리합니다.</block>
  <block id="1ffda19a93d453b434cfabeb86681d6d" category="admonition">Astra Trident는 생성한 볼륨에 대해 빈 "fsType"을 적용합니다. iSCSI 백엔드의 경우 StorageClass 에 parameters.fsType 을 적용하는 것이 좋습니다. esixing StorageClasses를 삭제하고 parameters.fsType을 지정하여 다시 생성해야 합니다.</block>
  <block id="e606165355271961ba07945766fbf83a" category="section-title">기존 스토리지 클래스를 봅니다</block>
  <block id="7c237bc6c124137d25df2dec1cb3e528" category="list-text">기존 Kubernetes 스토리지 클래스를 보려면 다음 명령을 실행합니다.</block>
  <block id="4aae22fbb9c0d354d0a9c15c6c126d89" category="list-text">Kubernetes 스토리지 클래스 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="bed443a9c5577e1043c277e8ebbb542f" category="list-text">Astra Trident의 동기화된 스토리지 클래스를 보려면 다음 명령을 실행합니다.</block>
  <block id="db66cf4d314ab7a719a76ed3af1b0173" category="list-text">Astra Trident의 동기화된 스토리지 클래스 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="ce32eb748bd7452bd6ee6d1d7ad6d3a7" category="section-title">기본 스토리지 클래스를 설정합니다</block>
  <block id="f30a1542c01c3c493f3c01c88dfe5fcd" category="paragraph">Kubernetes 1.6에는 기본 스토리지 클래스를 설정하는 기능이 추가되었습니다. 사용자가 영구 볼륨 클레임(PVC)에 영구 볼륨을 지정하지 않는 경우 영구 볼륨을 프로비저닝하는 데 사용되는 스토리지 클래스입니다.</block>
  <block id="7c435ae4763642458286cb691812ea55" category="list-text">스토리지 클래스 정의에서 주석 'torageclass.Kubernetes.io/is-default-class'를 true로 설정하여 기본 스토리지 클래스를 정의합니다. 사양에 따라 다른 값이나 주석 부재는 FALSE로 해석됩니다.</block>
  <block id="61fd76f55d29aaceb4a6ee09a318dc45" category="list-text">다음 명령을 사용하여 기존 스토리지 클래스를 기본 스토리지 클래스로 구성할 수 있습니다.</block>
  <block id="800477137444bec636483de85335cbb5" category="list-text">마찬가지로 다음 명령을 사용하여 기본 스토리지 클래스 주석을 제거할 수 있습니다.</block>
  <block id="2d2f31c3012657fd7b38b41312d1a0b8" category="paragraph">또한 Trident 설치 프로그램 번들에는 이 주석을 포함하는 예제도 있습니다.</block>
  <block id="94d8ac3a8d98f2232d3dc735878a5bc3" category="admonition">언제든지 클러스터에는 기본 스토리지 클래스가 하나만 있어야 합니다. Kubernetes에서 둘 이상의 작업을 수행하는 것을 기술적으로 금지하지는 않지만 기본 스토리지 클래스가 없는 것처럼 동작합니다.</block>
  <block id="6c36cb9c072dc4cb9e163c44568f6a91" category="section-title">스토리지 클래스에 대한 백엔드를 식별합니다</block>
  <block id="dc0742ede78913414129866d60898f67" category="paragraph">이 예는 Astra Trident 백엔드 객체에 대해 tridentctl이 출력하는 JSON으로 답할 수 있는 질문의 예입니다. 먼저 설치해야 할 JQ 유틸리티가 사용됩니다.</block>
  <block id="bee1e2306bc7054ee443dc651eae90de" category="summary">Astra Trident는 Astra Trident의 성능을 모니터링하는 데 사용할 수 있는 Prometheus 메트릭 엔드포인트 세트를 제공합니다.</block>
  <block id="44a004cad6eb7ea8839aaa8754ead178" category="doc">Astra Trident를 모니터링합니다</block>
  <block id="3f8e7343fbab71427901476dc4eb0cf3" category="paragraph">Astra Trident는 Astra Trident의 성능을 모니터링하는 데 사용할 수 있는 Prometheus 메트릭 엔드포인트 세트를 제공합니다.</block>
  <block id="c827f266cf12e05adc1fe95215415abf" category="paragraph">Astra Trident에서 제공하는 메트릭을 통해 다음을 수행할 수 있습니다.</block>
  <block id="6111d709595b0a106ff313a249eb9d92" category="list-text">Astra Trident의 상태 및 구성을 계속 확인하십시오. 성공적인 작업이 어떻게 이루어지는지, 예상대로 백엔드와 통신할 수 있는지 확인할 수 있습니다.</block>
  <block id="64dbac0ca36d9b1f6a8cf1e8a0123261" category="list-text">백엔드 사용 정보를 검토하고 백엔드에서 프로비저닝되는 볼륨 수와 사용된 공간 등을 파악합니다.</block>
  <block id="7f6516030964b624d9c71fd9ec7f83dd" category="list-text">사용 가능한 백엔드에 프로비저닝된 볼륨 양의 매핑을 유지합니다.</block>
  <block id="e436794bccbe602731bbde7766c1fa49" category="list-text">성과 추적. Astra Trident가 백엔드 및 작업을 수행하는 데 걸리는 시간을 확인할 수 있습니다.</block>
  <block id="efe0d75090a22534acabc936f8669994" category="admonition">기본적으로 Trident의 메트릭은 '/metrics' 끝점의 타겟 포트 8001에 표시됩니다. Trident가 설치된 경우 이러한 메트릭은 기본적으로 * 활성화됩니다.</block>
  <block id="a711863513c11f3a6d86294acc7be0ba" category="list-title">무엇을 &amp;#8217;필요로 할거야</block>
  <block id="1ed994b9754ad078cfc46aaf3dbf3a5d" category="list-text">Astra Trident가 설치된 Kubernetes 클러스터</block>
  <block id="eb8bfd69bb88378a6f4d987811890ce6" category="inline-link">컨테이너형 Prometheus 구축</block>
  <block id="42ae2e91a939ffa9bbda53c10bf5f89f" category="inline-link">네이티브 애플리케이션</block>
  <block id="050899631250104f17d24b27cc8a12e5" category="list-text">프로메테우스(Prometheus) 인스턴스. 이것은 일 수 있습니다<block ref="bd5b9e4bd7b88b90afb221fb760a777c" category="inline-link-rx"></block> 또는 Prometheus를 로 실행하도록 선택할 수 있습니다<block ref="3f1d5beaea78c0fd8cb397fbeb1c88bd" category="inline-link-rx"></block>.</block>
  <block id="68276ca40dfbfd36de911402152fa452" category="section-title">1단계: Prometheus 목표를 정의합니다</block>
  <block id="84c49e3c77b51ea186020145ae78103f" category="paragraph">메트릭을 수집하고 백엔드 Astra Trident가 관리하는, 생성하는 볼륨 등에 대한 정보를 얻으려면 Prometheus 타겟을 정의해야 합니다. 여기<block ref="dc7964965bf1b3af43b28caf6231e550" category="inline-link-rx"></block> Prometheus 및 Grafana를 Astra Trident와 함께 사용하여 메트릭을 검색하는 방법에 대해 설명합니다. 이 블로그에서는 Kubernetes 클러스터에서 운영자로 Prometheus를 실행하고 Astra Trident의 메트릭을 얻기 위해 ServiceMonitor를 생성하는 방법을 설명합니다.</block>
  <block id="c33638e0de87536b08eeb94264671d0f" category="section-title">2단계: Prometheus ServiceMonitor를 만듭니다</block>
  <block id="81a21a88b42cd5c83d149a080a627bad" category="paragraph">Trident 메트릭을 소비하려면 트리덴트 CSI 서비스를 감시하고 메티우스 포트에서 수신 대기하는 프로메테우스 서비스 모니터를 만들어야 합니다. 샘플 ServiceMonitor의 모양은 다음과 같습니다.</block>
  <block id="bfc1ad0fa725ea87ea056b2f2e8b6fe8" category="paragraph">이 ServiceMonitor 정의는 '삼중상 CSI' 서비스에서 반환된 지표를 검색하고 특히 서비스의 산부인과를 찾습니다. 따라서 이제 Prometheus가 Astra Trident의 메트릭을 이해하도록 구성되었습니다.</block>
  <block id="07338294bd70ea1e7710a574d7c8e2ce" category="paragraph">kubelet은 Astra Trident에서 직접 제공하는 측정 지표 외에도 자사의 측정 지표를 통해 많은 "kubelet_volume_ *" 측정 지표를 노출합니다. Kubelet는 연결된 볼륨, Pod 및 처리하는 기타 내부 작업에 대한 정보를 제공할 수 있습니다. 을 참조하십시오<block ref="3f1f0977d0df3e8b343e403140284021" category="inline-link-rx"></block>.</block>
  <block id="1db2022a8a8de5d612eda8e3be0e1065" category="section-title">3단계: PromQL을 사용하여 Trident 메트릭 쿼리</block>
  <block id="f5142e19a3b1edf809fce9d3b6aefc05" category="paragraph">PromQL은 시계열 또는 표 형식 데이터를 반환하는 식을 만드는 데 적합합니다.</block>
  <block id="8c6fb1be2521fd16337c11c626672678" category="paragraph">다음은 사용할 수 있는 몇 가지 PromQL 쿼리입니다.</block>
  <block id="b214fd0009b3929347f097bd843f0bfd" category="section-title">Trident 상태 정보를 가져옵니다</block>
  <block id="69fc54b5fac064131422d41948eb77ed" category="list-text">Astra Trident** 의 HTTP 2XX 응답률</block>
  <block id="f43362a8efc950ece8c14d4e5faddfa4" category="list-text">Astra Trident에서 상태 코드를 통해 얻은 REST 응답의 비율**</block>
  <block id="e69d9a06025140f38adabb6f709f6e5b" category="list-text">** Astra Trident **에 의해 수행된 작업의 평균 지속 시간(ms)</block>
  <block id="0505e17dec1e849391ad96f558fa613a" category="section-title">Astra Trident 사용 정보를 확인하십시오</block>
  <block id="f160a52d617adf6e6c5d379a9b8bca89" category="list-text">** 평균 볼륨 크기**</block>
  <block id="eb978bfe01ec0c72ad231f3953e304a2" category="list-text">** 각 백엔드에서 프로비저닝된 총 볼륨 공간**</block>
  <block id="5f735ae12eafbe476178928f4645475b" category="section-title">개별 볼륨 사용량을 가져옵니다</block>
  <block id="ee0898e9f0caa503f3eaa39c919f4c53" category="admonition">이 기능은 kubelet 메트릭도 수집한 경우에만 사용할 수 있습니다.</block>
  <block id="0bc301d2423b2ffaa38a5e275e4ec6f9" category="list-text">각 볼륨에 사용된 공간의** 비율**</block>
  <block id="8516d75df966e595bd1b5491acd01515" category="section-title">Astra Trident AutoSupport 텔레메트리 에 대해 자세히 알아보십시오</block>
  <block id="6f4ddec0f501988d2b0315a77c87eeaa" category="paragraph">기본적으로 Astra Trident는 Prometheus 메트릭 및 기본 백엔드 정보를 매일 NetApp에 보냅니다.</block>
  <block id="5276683815b670b0addfb8c8a45bbb41" category="list-text">Astra Trident가 Prometheus 메트릭 및 기본 백엔드 정보를 NetApp에 전송하지 않도록 하려면 Astra Trident 설치 중에 '--st침묵-autosupport' 플래그를 전달하십시오.</block>
  <block id="ca0f9a86ca33f1d6baa9051bd7f4ed21" category="inline-link">개인 정보 보호 정책</block>
  <block id="5b58783cbe6d85941bac008d83d3f5c8" category="list-text">Astra Trident는 또한 "tridentctl Send AutoSupport"를 통해 요청 시 NetApp 지원으로 컨테이너 로그를 보낼 수 있습니다. 로그를 업로드하려면 Astra Trident를 트리거해야 합니다. 로그를 제출하기 전에 NetApp의 내용에 동의해야 합니다<block ref="91b6c0438017ba5fa21c286a96d5acb4" category="inline-link-rx"></block>.</block>
  <block id="63b95d84cf55d169b2592f3ac621055f" category="list-text">지정되지 않은 경우 Astra Trident는 지난 24시간 동안 로그를 가져옵니다.</block>
  <block id="5224919a4ae5ccf610fb0ee74e4e7a94" category="inline-link">Trident AutoSupport를 누릅니다</block>
  <block id="18bc3bf6223e289af8243b039cd8d702" category="list-text">'--since' 플래그를 사용하여 로그 보존 기간을 지정할 수 있습니다. 예: 'tridentctl send AutoSupport --since=1h' 이 정보는 Astra Trident와 함께 설치되는 트리덴트 자동 지원 컨테이너를 통해 수집 및 전송됩니다. 에서 컨테이너 이미지를 얻을 수 있습니다<block ref="1b00454f0ab35dcec2ee1a0061efc6e5" category="inline-link-rx"></block>.</block>
  <block id="53084cad3d11df800502598c11e2d10b" category="inline-link">EULA</block>
  <block id="b9a52e8d1e9b14b8825c6ea01c0ce6d6" category="list-text">Trident AutoSupport는 개인 식별 정보(PII) 또는 개인 정보를 수집하거나 전송하지 않습니다. 이 제품은 와 함께 제공됩니다<block ref="173a360b412944768c2ab13e6c8fd1c7" category="inline-link-rx"></block> Trident 컨테이너 이미지 자체에는 적용되지 않습니다. 데이터 보안 및 신뢰에 대한 NetApp의 노력에 대해 자세히 알아볼 수 있습니다<block ref="8470ff535916bda3f4ea4723647a7135" category="inline-link-rx"></block>.</block>
  <block id="89f0f2832f60f480805faf638848c5b7" category="paragraph">Astra Trident에서 보낸 페이로드의 예는 다음과 같습니다.</block>
  <block id="d2ec86f126f845e79aff07e70bf89472" category="list-text">AutoSupport 메시지는 NetApp의 AutoSupport 엔드포인트로 전송됩니다. 개인 레지스트리를 사용하여 컨테이너 이미지를 저장하는 경우 '--image-registry' 플래그를 사용할 수 있습니다.</block>
  <block id="86c5a11fba83815412aec79f67f2d276" category="list-text">또한 설치 YAML 파일을 생성하여 프록시 URL을 구성할 수도 있습니다. 이는 트라이덴트ctl install --generate-custom-YAML을 이용해 YAML 파일을 생성하고 트리덴트 배포(trident-deployment)의 트리덴트 자동 지원 컨테이너에 대한 '--proxy-url' 주장을 추가하는 방식으로 가능하다.</block>
  <block id="46ab735110312d196d5265e534453cba" category="section-title">Astra Trident 메트릭을 비활성화합니다</block>
  <block id="8ec47dab227d183e0d3ad0cd529d289b" category="paragraph">** 메트릭을 보고하지 않으려면 ('--generate-custom-YAML' 플래그를 사용하여) 사용자 지정 YAML을 생성하고 이를 편집하여 삼중류-main' 컨테이너에 대해 호출되는 '--metrics' 플래그를 제거해야 합니다.</block>
  <block id="141da5e3f576179cbf2f6506b07ef538" category="summary">Astra Trident의 20.01 릴리즈부터 Kubernetes 계층에서 PVS(영구 볼륨)의 스냅샷을 생성할 수 있습니다. 이러한 스냅샷을 사용하여 Astra Trident에서 생성한 볼륨의 시점 복사본을 유지하고 추가 볼륨(클론) 생성을 예약할 수 있습니다.</block>
  <block id="e5879288a130fbd8d0b8682cfc375c4f" category="doc">스냅샷 작업</block>
  <block id="332138092a1597c4d5e69679199e490c" category="inline-link">릴리스 블로그</block>
  <block id="006b05a472974308122f7f05ef147e80" category="admonition">이 기능은 Kubernetes 1.17(베타)에서 사용할 수 있으며 1.20에서 GA됩니다. 베타 버전에서 GA로 전환하는 데 따른 변경 사항을 이해하려면 를 참조하십시오<block ref="02a1c904d0035e03c61e261dbe622345" category="inline-link-rx"></block>. GA로 졸업하면 v1 API 버전이 도입되고 v1beta1 스냅샷과 역호환됩니다.</block>
  <block id="e197a057bfe0ae792bb2b9ce9a78761e" category="list-text">볼륨 스냅숏을 생성하려면 외부 스냅샷 컨트롤러와 일부 사용자 지정 리소스 정의(CRD)를 생성해야 합니다. 사용 중인 Kubernetes Orchestrator는 이 책임이 있습니다(예: Kubeadm, GKE, OpenShift).</block>
  <block id="3923fe4170ab3f204b53d4caf958045f" category="paragraph">다음과 같이 외부 스냅샷 컨트롤러 및 스냅샷 CRD를 생성할 수 있습니다.</block>
  <block id="7737ff29322b0df9949b5d44ad3809a9" category="list-text">볼륨 스냅샷 CRD 생성:</block>
  <block id="7a993e4667899d0bca97d13e0bc37568" category="list-text">원하는 네임스페이스에 스냅샷 컨트롤러를 생성합니다. 아래 YAML 매니페스트를 편집하여 네임스페이스를 수정하십시오.</block>
  <block id="26c4fe55fc424c7b41b517701f54f074" category="inline-link">Webhook 확인 중</block>
  <block id="46b189b23dfbd5f3f622a1c04590b05e" category="admonition">CSI Snapshotter는 를 제공합니다<block ref="927ab0e919f8034deab1249bed53a289" category="inline-link-rx"></block> 사용자가 기존 v1beta1 스냅샷의 유효성을 검사하고 유효한 리소스 객체인지 확인할 수 있도록 합니다. Validating webhook는 잘못된 스냅샷 개체에 자동으로 레이블을 지정하며 나중에 유효하지 않은 객체가 생성되지 않도록 합니다. Validating webhook은 Kubernetes Orchestrator에 의해 구축됩니다. 유효성을 검사하는 Webhook을 수동으로 배포하는 방법은 지침을 참조하십시오<block ref="07cb3cdda0599ec9f2e82062ecd12e82" category="inline-link-rx"></block>. 유효하지 않은 스냅샷 매니페스트의 예를 찾습니다<block ref="bceda34f0850fc68d82f08741abbc69e" category="inline-link-rx"></block>.</block>
  <block id="f535be08d3997f1a801b132862d99a5c" category="paragraph">아래 예에서는 스냅샷 작업에 필요한 구조를 설명하고 스냅샷을 생성 및 사용하는 방법을 보여 줍니다.</block>
  <block id="551730f3a084f9dee63029647e815d3a" category="section-title">1단계: VolumeSnapshotClass 설정</block>
  <block id="d7ca7162c394dee752c35d07a92823da" category="inline-link-macro">'VolumeSnapshotClass</block>
  <block id="b91e58d7d80a51e4fa86b9ab27dca505" category="paragraph">볼륨 스냅샷을 생성하기 전에 를 설정합니다 <block ref="c740b46915208e935cb2017421ec0264" category="inline-link-macro-rx"></block>.</block>
  <block id="4744d2c82c1c470ab40280b2ebba0c08" category="paragraph">이 강물은 아스트라 트라이던트 CSI 드라이버를 가리킵니다. 정책이란 '삭제'나 '유지'가 될 수 있습니다. "유지"로 설정하면 "VolumeSnapshot" 객체가 삭제되더라도 스토리지 클러스터의 기본 물리적 스냅샷이 보존됩니다.</block>
  <block id="0ab6380edce0d0e7b8538ebf3215ebbd" category="section-title">2단계: 기존 PVC의 스냅샷을 생성합니다</block>
  <block id="ef55488b02c4b0173eb6f7bb867db086" category="paragraph">pvc1이라는 PVC에 대해 스냅샷이 생성되고 스냅샷 이름이 pvc1-snap으로 설정됩니다.</block>
  <block id="501470eb266ff6637de993e3f193ba40" category="paragraph">이로 인해 'VolumeSnapshot' 객체가 생성되었습니다. VolumeSnapshot은 PVC와 유사하며 실제 스냅샷을 나타내는 'VolumeSnapshotContent' 객체와 연결됩니다.</block>
  <block id="320e7c242b569ab5bbdaa490b3df817e" category="paragraph">pvc1-snap VolumeSnapshot에 대한 VolumeSnapshotContent 객체를 설명하여 식별할 수 있다.</block>
  <block id="b3841b02d7da01fde480332e3295a08e" category="paragraph">'스냅샷 컨텐츠 이름'은 이 스냅샷을 제공하는 VolumeSnapshotContent 객체를 식별합니다. Ready to Use 매개변수는 스냅샷이 새 PVC를 생성하는 데 사용될 수 있음을 나타냅니다.</block>
  <block id="7957320b126678e9b713ef146b3ac009" category="section-title">3단계: VolumeSnapshots에서 PVC를 생성합니다</block>
  <block id="4d780b57cad08f64bcd1ea7351a15588" category="paragraph">스냅샷을 사용하여 PVC를 생성하는 예는 다음 예를 참조하십시오.</block>
  <block id="2592284f87bba60e4c05337a134ef047" category="paragraph">"다소스"는 데이터 소스로 "pvc1-snap"이라는 VolumeSnapshot을 사용하여 PVC를 생성해야 함을 나타냅니다. 이렇게 하면 Astra Trident가 스냅샷에서 PVC를 생성하도록 지시합니다. PVC가 생성된 후 POD에 부착하여 다른 PVC와 마찬가지로 사용할 수 있습니다.</block>
  <block id="bda01e3aa44c411129a6fbf29445bfb4" category="admonition">연결된 스냅샷이 있는 영구 볼륨을 삭제하면 해당 Trident 볼륨이 "삭제 상태"로 업데이트됩니다. Astra Trident 볼륨을 삭제하려면 볼륨의 스냅샷을 제거해야 합니다.</block>
  <block id="fab3fcd54585164dbc9d7adf57f8e3d9" category="list-text"><block ref="fab3fcd54585164dbc9d7adf57f8e3d9" category="inline-link-macro-rx"></block></block>
  <block id="c740b46915208e935cb2017421ec0264" category="list-text"><block ref="c740b46915208e935cb2017421ec0264" category="inline-link-macro-rx"></block></block>
  <block id="72a5926b7fb086fe87e93771f6620556" category="summary">tridentctl을 사용하여 백엔드 관리 작업을 수행하는 방법에 대해 알아보십시오.</block>
  <block id="748a22b5f1312291ad55429ba4b809a0" category="doc">tridentctl을 사용하여 백엔드 관리를 수행합니다</block>
  <block id="aeeb03235358f0f4bf3be628bed08721" category="section-title">백엔드를 생성합니다</block>
  <block id="34746f7a1d24170eeebf5510a045d43d" category="inline-link-macro">백엔드 구성 파일</block>
  <block id="99b7232073a67a8c82304f979e3dc83f" category="paragraph">을 만든 후 <block ref="03c0b6ed8698193668e92f56e9be3efa" category="inline-link-macro-rx"></block>에서 다음 명령을 실행합니다.</block>
  <block id="1cabe44c722167581b1e219de6c58341" category="paragraph">백엔드 생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="b5f9999463782f0c36ecc89573a90a49" category="paragraph">구성 파일의 문제를 확인하고 수정한 후에는 간단히 'create' 명령을 다시 실행할 수 있습니다.</block>
  <block id="634b471e6af84767e06324552492b533" category="section-title">백엔드를 삭제합니다</block>
  <block id="412228c370a388e25ee06e8ad7a1da3f" category="paragraph">Astra Trident에서 백엔드를 삭제하려면 다음을 수행합니다.</block>
  <block id="f6816a6570e6b6097177f9adc1f4805b" category="list-text">백엔드 이름 검색:</block>
  <block id="11f4ccb46eb9afc4b1187c376b53123f" category="list-text">백엔드를 삭제합니다.</block>
  <block id="c87f53b53d179c2b5dcd5fad1efba831" category="admonition">Astra Trident가 백엔드에서 여전히 존재하는 볼륨 및 스냅샷을 프로비저닝한 경우 백엔드를 삭제하면 새 볼륨이 백엔드에서 프로비저닝되지 않습니다. 백엔드는 계속해서 "삭제" 상태에 있으며, Trident는 삭제될 때까지 해당 볼륨 및 스냅샷을 계속 관리합니다.</block>
  <block id="d694c8966214ec6d0068c0ab2951b65c" category="section-title">기존 백엔드를 봅니다</block>
  <block id="a6345aca446812b9124c47b385b33f43" category="paragraph">Trident가 알고 있는 백엔드를 보려면 다음을 실행합니다.</block>
  <block id="cb325bc4dded2aa4744b594966262a99" category="list-text">요약을 보려면 다음 명령을 실행합니다.</block>
  <block id="9f073deeee70a1418443c3b8379c5c02" category="list-text">모든 세부 정보를 보려면 다음 명령을 실행합니다.</block>
  <block id="93dbcf0189ff94d39230d2e3726969ab" category="section-title">백엔드를 업데이트합니다</block>
  <block id="27709162cf6b8ffced7bb1da6dd49df3" category="paragraph">새 백엔드 구성 파일을 생성한 후 다음 명령을 실행합니다.</block>
  <block id="4ca005817e9c882d0ef15d451a97dbf0" category="paragraph">백엔드 업데이트에 실패하면 백엔드 구성에 문제가 있거나 잘못된 업데이트를 시도했습니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="20b5ebaa2558437206eb6d1d47577805" category="paragraph">구성 파일의 문제를 확인하고 수정한 후에는 간단히 'update' 명령을 다시 실행할 수 있습니다.</block>
  <block id="d47f84a3cda326babf841866ad2326ab" category="section-title">백엔드를 사용하는 스토리지 클래스를 식별합니다</block>
  <block id="02fe9d429af25b46c16a1172d735124f" category="paragraph">이것은 JSON으로 백엔드 객체에 대해 tridentctl이 출력하는 질문의 예입니다. 이 유틸리티는 설치해야 하는 JQ 유틸리티를 사용합니다.</block>
  <block id="e00013adda7b5901ea3e44ae300fd73d" category="paragraph">이는 ' 재젠백엔드구성'을 사용하여 만든 백엔드에도 적용됩니다.</block>
  <block id="fe1db7f37fb893d9995534febe29a78b" category="summary">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 Cloud Volumes Service for AWS를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="6e399579bcb032270367d78455e1976f" category="doc">AWS용 CVS 백엔드를 구성합니다</block>
  <block id="f7dc2116b38f0f6097d64ca1dfdcd0b7" category="paragraph">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 AWS용 NetApp CVS(Cloud Volumes Service)를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="0eb1a8be2d6b9505f3b9940718c0c492" category="admonition">Cloud Volumes Service for AWS는 100GB 미만의 볼륨을 지원하지 않습니다. Trident는 더 작은 볼륨을 요청하는 경우 100GB 볼륨을 자동으로 생성합니다.</block>
  <block id="11873d2393ac3286e0e2949c7fb94c92" category="paragraph">를 구성하고 사용합니다<block ref="9185b014ee020a0dd27e376023f04353" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="162fd644b5a366df1c98de24d39a28e4" category="list-text">NetApp CVS로 구성된 AWS 계정</block>
  <block id="65e26b8fa373ad7924b14a196242b605" category="list-text">CVS 계정에 대한 API 영역, URL 및 키</block>
  <block id="15b7c7ffe264d7b8c61915ff2a6ef96c" category="section-title">백엔드 구성 옵션</block>
  <block id="9d370350f8d0178b5dfbec9def10d13a" category="paragraph">백엔드 구성 옵션은 다음 표를 참조하십시오.</block>
  <block id="7877022c956918624cc0373ff564cad4" category="cell">'내전'</block>
  <block id="40e27006e7b709772172391a3d17b331" category="cell">항상 1</block>
  <block id="868dff7060d78b6417dc8e065eca8374" category="cell">'torageDriverName'입니다</block>
  <block id="5aae2c40b50d296edbd4ba9cfb462b49" category="cell">스토리지 드라이버의 이름입니다</block>
  <block id="f8d960efa7386a75b65e6abbdb9e3c36" category="cell">"AWS-CV"</block>
  <block id="f5b55596d3f53b1857a4980dac9db979" category="cell">백엔드이름</block>
  <block id="5afd6479855e8d63f324b6ec2fa787b4" category="cell">사용자 지정 이름 또는 스토리지 백엔드</block>
  <block id="f476273c71e20fc5a845a5345a620117" category="cell">드라이버 이름 + "_" + API 키의 일부</block>
  <block id="2086191016950a784040f7d22ab27f60" category="cell">아피지역</block>
  <block id="a6a8368ae9ff89e7a4ca4c9e2b64ab56" category="cell">CVS 계정 지역. CVS 웹 포털의 계정 설정/API 액세스에서 값을 찾을 수 있습니다.</block>
  <block id="3639c86d22a854ef10a2cacfe9eed25d" category="cell">"apiURL"</block>
  <block id="9aea3113f9edf591b1b341775bd7d092" category="cell">CVS 계정 API URL입니다. CVS 웹 포털의 계정 설정/API 액세스에서 값을 찾을 수 있습니다.</block>
  <block id="a34d72a685d5e27eb6bc18f54a7bab1d" category="cell">아피키</block>
  <block id="3fc6085f3573a8e927eea401950de8d3" category="cell">CVS 계정 API 키입니다. CVS 웹 포털의 계정 설정/API 액세스에서 값을 찾을 수 있습니다.</block>
  <block id="9a5b66949f53f92871d3e1a8aae0cc19" category="cell">재키</block>
  <block id="e3891e2d275bb1f55f9de70059eed199" category="cell">CVS 계정 암호 키입니다. CVS 웹 포털의 계정 설정/API 액세스에서 값을 찾을 수 있습니다.</block>
  <block id="af18429250667f805769a7755a008c1f" category="cell">proxyURL</block>
  <block id="99d5bed813f066a1a1551b1bdab48e21" category="cell">프록시 서버가 CVS 계정에 연결해야 하는 경우 프록시 URL입니다. 프록시 서버는 HTTP 프록시 또는 HTTPS 프록시일 수 있습니다. HTTPS 프록시의 경우 프록시 서버에서 자체 서명된 인증서를 사용할 수 있도록 인증서 유효성 검사를 건너뜁니다. 인증이 활성화된 프록시 서버는 지원되지 않습니다.</block>
  <block id="2b45af5c768d7b2495ef631c991ecd78" category="cell">nfsMountOptions를 선택합니다</block>
  <block id="b9cc8276829a756e7a22476617204267" category="cell">NFS 마운트 옵션에 대한 세밀한 제어</block>
  <block id="2d1474e8b52ef42851337fb3fef4e1a1" category="cell">"nfsvers=3"</block>
  <block id="91590ee78f1b4751284f4f9ea80cfe86" category="cell">LimitVolumeSize</block>
  <block id="2288620b3dc019c6359bcc7f50b72ab3" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다</block>
  <block id="567c7f0eca746ed7513764be5ecf6d03" category="cell">""(기본적으로 적용되지 않음)</block>
  <block id="0322003a3502f221fdb74b059dfff46e" category="cell">'저급'</block>
  <block id="5a5b2759e0577a3e22002ed8430f2b4f" category="cell">새 볼륨에 대한 CVS 서비스 수준입니다. 값은 "표준", "프리미엄" 및 "익스트림"입니다.</block>
  <block id="e472abc54914c303a14c29f7e853a28a" category="cell">"표준"</block>
  <block id="f2f2c7c3c767da610bd95934104674f6" category="cell">debugTraceFlags를 선택합니다</block>
  <block id="e39a04a98487bb1fd113f63d47331565" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: "\{"api":false,"method":true}". 문제 해결 중이 아니며 자세한 로그 덤프가 필요한 경우가 아니면 이 방법을 사용하지 마십시오.</block>
  <block id="37a6259cc0c1dae299a7866489dff0bd" category="cell">null입니다</block>
  <block id="1394ee99ba1680da948a315df62a7b62" category="admonition">apiURL은 apiRegion마다 고유합니다. 예를 들어 서양대 2의 아픽지역(apiRegion)에는 이 있습니다<block ref="445c370e1a8fd8a5bb35e4bcf66dc8ff" category="inline-link-rx"></block> "apiURL". 이와 마찬가지로 우동1의 아피지역은 이 있다<block ref="89a36317c553c294eadd1c2b2e179f46" category="inline-link-rx"></block> "apiURL". 백엔드 구성의 CVS 대시보드에서 올바른 "apiRegion" 및 "apiURL" 매개 변수를 확인하십시오.</block>
  <block id="b4ba9ff8dbbcd251a1cb4e16ba80c36c" category="paragraph">각 백엔드는 단일 AWS 지역에 볼륨을 프로비저닝합니다. 다른 영역에 볼륨을 생성하려면 추가 백엔드를 정의할 수 있습니다.</block>
  <block id="5477b38834c7f5d99403326a17f0bf55" category="paragraph">구성 파일의 특수 섹션에서 다음 옵션을 지정하여 각 볼륨의 프로비저닝 방식을 기본적으로 제어할 수 있습니다. 아래의 구성 예를 참조하십시오.</block>
  <block id="9c64942fe493cb70c474ff447429d8a4" category="cell">엑포트 규칙</block>
  <block id="4e69ff68e3ee9207d53a76748485f3d8" category="cell">새 볼륨의 내보내기 규칙</block>
  <block id="1274e36c193ec0ce8b5c49d5e78ffd7b" category="cell">"0.0.0.0/0"</block>
  <block id="ce8f82152151ae2aadaec166eca744a9" category="cell">나프산디렉토리</block>
  <block id="781e781b44169c656fb79130bd8bd062" category="cell">'.snapshot' 디렉토리의 자성을 제어합니다</block>
  <block id="c07fbc0b2a1a865fe9e3a55c05b4f690" category="cell">"거짓"</block>
  <block id="7556d5a1b0c5f68b7cb5aedaa3156008" category="cell">안산예비역</block>
  <block id="31ed61cc3c85d0bb697cd12b77f37fd1" category="cell">스냅숏용으로 예약된 볼륨의 백분율입니다</block>
  <block id="e76dcf1d6497658a2994b5f1f65b7a83" category="cell">""(CVS 기본값 0 허용)</block>
  <block id="a48a8458539e489328f4d6d3fc0ee288" category="cell">'크기'입니다</block>
  <block id="dc78a90de250a0f2ca8ad52ee0c5d21b" category="cell">새 볼륨의 크기입니다</block>
  <block id="ef81b740be2293b7e3c41047afe98764" category="cell">"100G"</block>
  <block id="b2a2a92e6239fca01cafbcfd41760043" category="paragraph">exportRule 값은 IPv4 주소 또는 IPv4 서브넷을 CIDR 표기로 조합한 쉼표로 구분된 목록이어야 합니다.</block>
  <block id="635686d413c736dacb149d183959f020" category="admonition">CVS AWS 백엔드에서 생성된 모든 볼륨의 경우, Astra Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 스토리지 볼륨에 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="25f4894ddaab3c1182f12732d3bcf889" category="section-title">예 1: 최소 구성</block>
  <block id="9fe036cdf8651713d44464a40094dc62" category="paragraph">이는 절대적인 최소 백엔드 구성입니다.</block>
  <block id="2f51b29f400aa735b4f4bd32f0eeed4f" category="paragraph">이 구성은 CVS AWS를 시작하는 데 아주 적합하지만, 실제로 프로비저닝하는 볼륨에 대한 추가 범위를 제공하고 싶을 것입니다.</block>
  <block id="55c1dd55273b867b995333cc3abd250e" category="section-title">예 2: 단일 서비스 수준 구성</block>
  <block id="f8ee3192003a383290a06e5d20105030" category="paragraph">이 예에서는 AWS Us-east-1 영역에서 Astra Trident가 생성한 모든 스토리지에 동일한 측면을 적용하는 백엔드 파일을 보여 줍니다. 이 예제에서는 백엔드 파일의 proxyURL 사용도 보여 줍니다.</block>
  <block id="2b00c4aa6134b525e9355d880ecb0c8d" category="section-title">예 3: 가상 스토리지 풀 구성</block>
  <block id="fe8fbdb035f6bebecaf9a52e36d8a595" category="paragraph">이 예에서는 가상 스토리지 풀과 이를 다시 참조하는 StorageClasses와 함께 구성된 백엔드 정의 파일을 보여 줍니다.</block>
  <block id="a1306d5e7389ac9f3740a973a3175a2c" category="paragraph">아래 표시된 샘플 백엔드 정의 파일에서 모든 스토리지 풀에 대한 특정 기본값이 설정되어 있는데, 이 경우 '스냅샷 보존'이 5%로 설정되고 'exportRule'이 0.0.0.0/0으로 설정됩니다. 가상 스토리지 풀은 '스토리지' 섹션에 정의되어 있습니다. 이 예에서는 각 개별 스토리지 풀이 자체 'erviceLevel'을 설정하고 일부 풀이 기본값을 덮어씁니다.</block>
  <block id="7229192fbc3d9420b90f84958fee3b0d" category="paragraph">다음 StorageClass 정의는 위의 스토리지 풀을 참조합니다. "parameters.selector` 필드를 사용하여 각 StorageClass에 볼륨을 호스팅하는 데 사용되는 가상 풀을 지정할 수 있습니다. 볼륨은 선택한 풀에 정의된 측면을 갖습니다.</block>
  <block id="b60daecbb1685b08e94947d4137aa916" category="paragraph">첫 번째 StorageClass('cvs-extreme-extra-protection')는 첫 번째 가상 스토리지 풀에 매핑됩니다. 이 풀은 스냅샷 예약 공간이 10%인 최고 성능을 제공하는 유일한 풀입니다. 마지막 StorageClass('cvs-extra-protection')는 10%의 스냅샷 예비 공간을 제공하는 스토리지 풀을 호출합니다. Astra Trident는 선택된 가상 스토리지 풀을 결정하고 스냅샷 예약 요구 사항이 충족되는지 확인합니다.</block>
  <block id="3ad256eea0abb551eaab63c84aa3d1f9" category="paragraph">백엔드 구성 파일을 생성한 후 다음 명령을 실행합니다.</block>
  <block id="a61ed3c1ecae587dbee1f2c0ace81e3b" category="paragraph">백엔드 생성에 실패하면 백엔드 구성에 문제가 있는 것입니다. 다음 명령을 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="8427b84145b88f048d5caa532324cd11" category="paragraph">구성 파일의 문제를 확인하고 수정한 후 create 명령을 다시 실행할 수 있습니다.</block>
  <block id="e4f61797b38c111b04c612b285a06659" category="summary">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="9bc537b16cee9c42d1e2aa0048a2c426" category="paragraph">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오. 모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="00b8b321c68facfb94b31690cbd23e00" category="paragraph">모든 ONTAP 백엔드의 경우, Astra Trident는 SVM에 하나 이상의 Aggregate가 할당되어 있어야 합니다.</block>
  <block id="c6cd2f38be30f5256f7116692ab56edd" category="paragraph">또한 둘 이상의 드라이버를 실행하고 둘 중 하나를 가리키는 스토리지 클래스를 생성할 수도 있습니다. 예를 들어, 'ONTAP-NAS' 드라이버와 'ONTAP-NAS-이코노미'을 사용하는 Bronze 클래스를 사용하는 Gold 클래스를 구성할 수 있습니다.</block>
  <block id="fff0b214bfcab1734e0bec7b1d1f6079" category="paragraph">모든 Kubernetes 작업자 노드에 적절한 NFS 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="9ec363a49b52db56773849151c5853d4" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="07b434b23f63ca6490df33b213599320" category="section-title">NFS 엑스포트 정책을 관리합니다</block>
  <block id="9d66483f8378ffe30cde84e1b6dbf484" category="paragraph">Astra Trident는 NFS 엑스포트 정책을 사용하여 프로비저닝하는 볼륨에 대한 액세스를 제어합니다.</block>
  <block id="a297d9b7dbc393d5e8a5b3f98bcc9337" category="paragraph">Astra Trident는 엑스포트 정책을 사용할 때 다음 두 가지 옵션을 제공합니다.</block>
  <block id="0c87d42e666bbc299da2143379484281" category="list-text">Astra Trident는 엑스포트 정책 자체를 동적으로 관리할 수 있습니다. 이 운영 모드에서 스토리지 관리자는 허용할 수 있는 IP 주소를 나타내는 CIDR 블록 목록을 지정합니다. Astra Trident는 이러한 범위에 속하는 노드 IP를 엑스포트 정책에 자동으로 추가합니다. 또는 CIDR을 지정하지 않으면 노드에서 발견된 글로벌 범위의 유니캐스트 IP가 내보내기 정책에 추가됩니다.</block>
  <block id="e6add289c2b1cd5da45e00f3098b35de" category="list-text">스토리지 관리자는 엑스포트 정책을 생성하고 규칙을 수동으로 추가할 수 있습니다. Astra Trident는 구성에 다른 엑스포트 정책 이름을 지정하지 않는 한 기본 엑스포트 정책을 사용합니다.</block>
  <block id="4603f08ad837f4108ff2fe7665b0b1e3" category="section-title">엑스포트 정책을 동적으로 관리</block>
  <block id="801eb935808311c71ba522e642d12e3f" category="paragraph">CSI Trident의 20.04 릴리스는 ONTAP 백엔드에 대한 엑스포트 정책을 동적으로 관리할 수 있는 기능을 제공합니다. 따라서 스토리지 관리자는 명시적 규칙을 수동으로 정의하는 대신 작업자 노드 IP에 허용되는 주소 공간을 지정할 수 있습니다. 엑스포트 정책 관리를 크게 간소화하므로, 엑스포트 정책을 수정하면 더 이상 스토리지 클러스터에 대한 수동 작업이 필요하지 않습니다. 또한 스토리지 클러스터에 대한 액세스를 지정된 범위의 IP가 있는 작업자 노드에만 제한함으로써 세분화된 자동 관리를 지원합니다.</block>
  <block id="8b78bee43bfa1617b12c311f0ad26e81" category="admonition">CSI Trident에만 내보내기 정책의 동적 관리를 사용할 수 있습니다. 작업자 노드가 NATED가 아닌지 확인하는 것이 중요합니다.</block>
  <block id="44568b7468885ca198a66bb088b9e3b5" category="paragraph">두 가지 구성 옵션을 사용해야 합니다. 다음은 백엔드 정의의 예입니다.</block>
  <block id="2aaaab87910c3ed67eecb3ea8578619e" category="admonition">이 기능을 사용할 때는 SVM의 루트 교차점에 노드 CIDR 블록(예: 기본 엑스포트 정책)을 허용하는 엑스포트 규칙과 함께 사전 화된 엑스포트 정책이 있는지 확인해야 합니다. Astra Trident를 위한 SVM 전용 NetApp의 권장 모범 사례를 항상 따르십시오.</block>
  <block id="4975fc485ff51ca8f82c6ea96f927287" category="paragraph">다음은 위의 예를 사용하여 이 기능이 작동하는 방식에 대한 설명입니다.</block>
  <block id="acdca8a11423c4bc209db0a1a4909294" category="list-text">자동내보내기정책은 참으로 설정된다. 이는 Astra Trident가 'vm1' SVM에 대한 수출 정책을 만들고 'autoExportCIDR' 주소 블록을 사용하여 규칙 추가 및 삭제를 처리한다는 것을 의미합니다. 예를 들어 UUID 403b5326-8482-40dB-96d0-d83fb3f4daec 및 "true"로 설정된 autoExportPolicy가 있는 백엔드는 SVM에 trident-403b5326-8482-40db-96d0-d83fb3f4daec라는 이름의 엑스포트 정책을 생성합니다.</block>
  <block id="1bdcc9b4be16b7ad2f1b54c892491a43" category="list-text">autoExportCIDR에는 주소 블록 목록이 포함되어 있습니다. 이 필드는 선택 사항이며 기본적으로 ["0.0.0.0/0", ":/0"]입니다. 정의되지 않은 경우 Astra Trident는 작업자 노드에 있는 모든 전역 범위의 유니캐스트 주소를 추가합니다.</block>
  <block id="96d8905e0d42a0d3573c71fd4ecce0b8" category="paragraph">이 예에서는 192.168.0.0/24 주소 공간을 제공한다. 이 주소 범위에 속하는 Kubernetes 노드 IP가 Astra Trident가 생성하는 엑스포트 정책에 추가됨을 나타냅니다. Astra Trident가 실행 중인 노드를 등록하면 해당 노드의 IP 주소를 조회하여 autoExportCIDR에서 제공하는 주소 블록과 대조합니다. IP를 필터링한 후 Astra Trident는 검색된 클라이언트 IP에 대한 엑스포트 정책 규칙을 생성하며, 식별하는 각 노드에 대해 하나의 규칙을 사용합니다.</block>
  <block id="4646f167a1fb9819f41f28d5ab11c1fa" category="paragraph">백엔드를 생성한 후 백엔드에 대한 자동 내보내기 정책 및 자동 내보내기 CIDR을 업데이트할 수 있습니다. 기존 CIDR을 자동으로 관리하거나 삭제하는 백엔드에 새 CIDR을 추가할 수 있습니다. CIDR을 삭제할 때는 기존 연결이 끊어지지 않도록 주의해야 합니다. 백엔드에 대해 'autoExportPolicy'를 사용하지 않도록 설정하고 수동으로 생성된 내보내기 정책으로 돌아갈 수도 있습니다. 이렇게 하려면 백엔드 구성에서 'exportPolicy' 매개 변수를 설정해야 합니다.</block>
  <block id="18deff64a140a603bdb6070abed4eed4" category="paragraph">Astra Trident가 백엔드를 생성하거나 업데이트한 후 'tridentctl' 또는 해당 'tridentbackend' CRD:</block>
  <block id="83af513d9b9d50c1dc648bfea29797cb" category="paragraph">노드가 Kubernetes 클러스터에 추가되고 Astra Trident 컨트롤러에 등록되면 기존 백엔드의 내보내기 정책이 업데이트됩니다(백엔드의 "autoExportCIDR"에 지정된 주소 범위에 속하는 경우).</block>
  <block id="fd85ad7b0ce4e83937cbc1012086b9b3" category="paragraph">노드가 제거되면 Astra Trident는 온라인 상태인 모든 백엔드를 검사하여 노드에 대한 액세스 규칙을 제거합니다. Astra Trident는 관리되는 백엔드의 내보내기 정책에서 이 노드 IP를 제거하여 불량 마운트를 방지합니다. 단, 클러스터의 새 노드에서 이 IP를 다시 사용하지 않는 한 마찬가지입니다.</block>
  <block id="cda5977f42a72ef440d3b6233b9970bf" category="paragraph">기존 백엔드의 경우 백엔드를 "tridentctl update backend"로 업데이트하면 Astra Trident가 자동으로 내보내기 정책을 관리합니다. 그러면 백엔드의 UUID 뒤에 이름이 지정된 새 내보내기 정책이 생성되고 백엔드에 있는 볼륨은 새로 생성된 내보내기 정책을 다시 마운트할 때 사용합니다.</block>
  <block id="de1d1f6b64a5c5b6890c313888b290b7" category="admonition">자동 관리되는 내보내기 정책이 있는 백엔드를 삭제하면 동적으로 생성된 내보내기 정책이 삭제됩니다. 백엔드가 다시 생성되면 백엔드가 새 백엔드로 처리되어 새 엑스포트 정책이 생성됩니다.</block>
  <block id="920708f6d71767dcff22f9e43b4ec0c0" category="paragraph">라이브 노드의 IP 주소가 업데이트되면 노드에서 Astra Trident POD를 다시 시작해야 합니다. 그런 다음 Astra Trident가 이 IP 변경 사항을 반영하도록 관리하는 백엔드에 대한 엑스포트 정책을 업데이트합니다.</block>
  <block id="fe328cbae90d1a295c7e45733450d711" category="summary">Astra Trident는 Kubernetes 클러스터에 있는 노드에 필요한 NFS 및 iSCSI 툴을 자동으로 설치할 수 있습니다.</block>
  <block id="878a6c37d04e0b8f6746f8b1caf14789" category="doc">작업자 노드 자동 준비</block>
  <block id="360deb71f11973ab55dca824207c8594" category="paragraph">Astra Trident는 Kubernetes 클러스터에 있는 노드에 필요한 NFS 및 iSCSI 툴을 자동으로 설치할 수 있습니다. 이것은 * 베타 기능 * 이며 * 프로덕션 클러스터용으로 * 제공되지 않습니다. 현재 이 기능은 * CentOS, RHEL 및 Ubuntu * 를 실행하는 노드에 사용할 수 있습니다.</block>
  <block id="c105a7b612eafd056a1525c7dea9ddda" category="paragraph">이 기능을 위해 Astra Trident는 tridentctl을 사용하여 배포된 설치를 위한 '--enable-node-prep'라는 새로운 설치 플래그를 포함합니다. Trident 연산자가 있는 배포의 경우 부울 옵션 "enableNodePrep"을 사용합니다.</block>
  <block id="f6aec0bd36e5ab01303aa37ab52ec8d8" category="admonition">'--enable-node-prep' 설치 옵션은 Astra Trident가 볼륨을 작업자 노드에 마운트할 때 NFS 및 iSCSI 패키지 및/또는 서비스가 실행 중인지 설치 및 확인하도록 지시합니다. 이 기능은 개발/테스트 환경에서 사용할 수 있도록 고안된 * 베타 기능 * 으로, 운영용으로 * 검증되지 않았습니다.</block>
  <block id="f587ac26702eec76a28d335e634449b1" category="paragraph">tridentctl로 배포된 Astra Trident 설치에 '--enable-node-prep' 플래그가 포함된 경우 다음 작업이 수행됩니다.</block>
  <block id="7a63850885709e4125994faba4bd1667" category="list-text">설치의 일부로, Astra Trident가 실행되는 노드를 등록합니다.</block>
  <block id="c1ebfd51cbff72f2afbe7f30f827eda5" category="list-text">영구 볼륨 클레임(PVC) 요청이 이루어지면 Astra Trident는 관리하는 백엔드 중 하나에서 PV를 생성합니다.</block>
  <block id="5b70ed42b3c8f8528cef50ad01425fb3" category="list-text">POD에서 PVC를 사용하려면 POD가 실행되는 노드에 볼륨을 마운트하기 위해 Astra Trident가 필요합니다. Astra Trident는 필요한 NFS/iSCSI 클라이언트 유틸리티를 설치하고 필요한 서비스가 활성 상태인지 확인합니다. 볼륨이 마운트되기 전에 이 작업이 수행됩니다.</block>
  <block id="ac5aafb0e9591a4bede4be4f37f141cf" category="paragraph">작업자 노드의 준비는 볼륨을 마운트하려는 첫 번째 시도의 일부로 한 번만 수행됩니다. Astra Trident 외부의 변경 사항이 NFS와 iSCSI 유틸리티에 닿지 않는 한 이후의 모든 볼륨 마운트는 성공해야 합니다.</block>
  <block id="bf3c2b9140b25189d7032529446cfaf4" category="paragraph">이러한 방법으로 Astra Trident는 Kubernetes 클러스터의 모든 노드에 볼륨을 마운트 및 연결하는 데 필요한 유틸리티가 있는지 확인할 수 있습니다. NFS 볼륨의 경우 내보내기 정책에서도 볼륨을 마운트할 수 있어야 합니다. Trident는 백엔드별로 엑스포트 정책을 자동으로 관리할 수도 있고, 사용자는 대역 외 엑스포트 정책을 관리할 수도 있습니다.</block>
  <block id="ac8d6c792ab9df0b15a26713390895f1" category="summary">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 Google Cloud용 Cloud Volumes Service를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="fd1248bc6e4583a3f250f8e575cd59fe" category="doc">CVS for GCP 백엔드를 구성합니다</block>
  <block id="2562e7447cd588d1768109da5ba66ef1" category="paragraph">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 백엔드로 NetApp CVS(Cloud Volumes Service) for Google Cloud Platform(GCP)을 구성하는 방법에 대해 알아보십시오.</block>
  <block id="b85237ff884eb3aa5c20d9ffcdabbeac" category="admonition">NetApp Cloud Volumes Service for Google Cloud는 CVS를 지원하지 않습니다. 크기 100GiB 미만의 성능 볼륨 또는 크기 300GiB 미만의 CVS 볼륨을 지원합니다. Astra Trident는 요청된 볼륨이 최소 크기보다 작은 경우 최소 크기의 볼륨을 자동으로 생성합니다.</block>
  <block id="b0cee72642f5457a71ddd0b49efb6d93" category="inline-link">Google Cloud용 Cloud Volumes Service</block>
  <block id="da195e41c537042ae77405110c4512ff" category="paragraph">를 구성하고 사용합니다<block ref="5129d3f1116e9c5221bfcf965a1ede35" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="6801d56ba08d1acc2876c196223d531a" category="list-text">NetApp CVS로 구성된 Google Cloud 계정</block>
  <block id="2c00ff9c7700dc3529c57f0a5281bbe2" category="list-text">Google Cloud 계정의 프로젝트 번호입니다</block>
  <block id="43752d169c5729fffa3a6557a0978cb8" category="list-text">Google Cloud 서비스 계정에는 netcloudvolumes.admin 역할이 포함되어 있습니다</block>
  <block id="5d6ade9bdfebc79abf4c55e55a2c9941" category="list-text">CVS 서비스 계정에 대한 API 키 파일입니다</block>
  <block id="7d0ee86ffc673e47ce20265e1e21317f" category="inline-link">GCP의 CVS 서비스 유형입니다</block>
  <block id="1f57356f89e79e6730290eddcf7b84ee" category="paragraph">이제 Astra Trident에 더 작은 볼륨에 대한 지원이 기본 제공됩니다<block ref="fc2935a8a76e337f6e814f65964a47b6" category="inline-link-rx"></block>. 'torageClass=software'로 생성된 백엔드의 경우 볼륨은 이제 최소 프로비저닝 크기가 300GiB가 됩니다. CVS는 현재 제어된 가용성 하에서 이 기능을 제공하며 기술 지원을 제공하지 않습니다. 사용자는 1TiB 미만의 볼륨에 액세스하려면 등록해야 합니다<block ref="daab940ca038632df7b3bcdb2ce67b4b" category="inline-link-rx"></block>. NetApp은 고객이** 비운영** 워크로드에 1TiB 미만의 볼륨을 사용할 것을 권장합니다.</block>
  <block id="adf38902d2794fb5eb0ede6324a90db7" category="admonition">기본 CVS 서비스 유형('storageClass=software')을 사용하여 백엔드를 배포할 때 사용자는 해당 프로젝트 번호 및 프로젝트 ID에 대해 GCP에서 1TiB 미만의 볼륨 기능에 대한 액세스 권한을 얻어야 합니다. 이는 Astra Trident에서 1TiB 미만의 볼륨을 프로비저닝하는 데 필요합니다. 그렇지 않은 경우 600GiB 미만의 PVC에 대해 체적 생성에 실패합니다. 를 사용하여 1TiB 미만의 볼륨에 대한 액세스 권한을 얻습니다<block ref="d5347d47b24e3303f1c7b0ae61e08dc7" category="inline-link-rx"></block>.</block>
  <block id="3e6d0b5d82e6a07b21f37953b4f07f2b" category="paragraph">기본 CVS 서비스 레벨을 위해 Astra Trident에서 생성한 볼륨은 다음과 같이 프로비저닝됩니다.</block>
  <block id="b0f9c06798383f1aa62530b497a530f7" category="list-text">300GiB보다 작은 PVC로 인해 Astra Trident가 300GiB CVS 볼륨을 생성합니다.</block>
  <block id="f8d45755378c123e72db60a65c99c9eb" category="list-text">300GiB ~ 600GiB의 PVC로 인해 Astra Trident가 요청된 크기의 CVS 볼륨을 생성합니다.</block>
  <block id="60f847f16dcff8ca2ff2ce3434bcb4c9" category="list-text">600GiB와 1TiB 사이의 PVC로 인해 Astra Trident가 1TiB CVS 볼륨을 생성합니다.</block>
  <block id="96ca04bda01b9542611aa702d16b37ee" category="list-text">1TiB보다 큰 PVC로 인해 Astra Trident가 요청된 크기의 CVS 볼륨을 생성합니다.</block>
  <block id="07cc9934740ba3dd46a0d7d2c9502d39" category="cell">"GCP-CV"</block>
  <block id="6eb82a822b962404b9694b93f2967679" category="cell">'원어클래스'</block>
  <block id="f26f4f79d1de66f6ce1a2d9a1663dc5e" category="cell">스토리지 유형입니다. 하드웨어(성능 최적화) 또는 소프트웨어(CVS 서비스 유형)를 선택합니다.</block>
  <block id="c96383270cbab23de47b4f0961f64929" category="cell">'프로젝트 번호'</block>
  <block id="6a9b4c6a3586ab6a85d6c78e7dda0570" category="cell">Google Cloud 계정 프로젝트 번호입니다. 이 값은 Google Cloud 포털의 홈 페이지에서 확인할 수 있습니다.</block>
  <block id="c785bbb8190e6c0c816762918e34a0d7" category="cell">CVS 계정 지역. 백엔드에서 볼륨을 프로비저닝할 영역입니다.</block>
  <block id="3e4dad689bfe319e0980748c1c2175a7" category="cell">Google Cloud 서비스 계정의 API 키로, 'netappcloudvolumes.admin' 역할을 수행합니다. 여기에는 Google Cloud 서비스 계정의 개인 키 파일(백엔드 구성 파일에 verbatim 복사)의 JSON 형식 콘텐츠가 포함됩니다.</block>
  <block id="e96ca96c25a07de5f03e2535b0c2f7fc" category="paragraph">공유 VPC 네트워크를 사용하는 경우 projectNumber와 hostProjectNumber를 모두 지정해야 합니다. 이 경우 projectNumber는 서비스 프로젝트이고 hostProjectNumber는 호스트 프로젝트입니다.</block>
  <block id="91bffb05ce7b35189932ad387d14e41b" category="paragraph">아피지역(apiRegion)은 Astra Trident가 CVS 볼륨을 생성하는 GCP 지역을 나타냅니다. 지역 간 Kubernetes 클러스터를 생성할 때 "apiRegion"에서 생성된 CVS 볼륨을 여러 GCP 지역 노드에 예약된 워크로드에 사용할 수 있습니다. 지역 간 트래픽에는 추가 비용이 발생합니다.</block>
  <block id="31842a4ad923dd3481336d7d93dc2068" category="list-text">교차 지역 액세스를 활성화하려면 "allowedTopologies"에 대한 StorageClass 정의에 모든 영역이 포함되어야 합니다. 예를 들면 다음과 같습니다.</block>
  <block id="34c1edfb4ac8581528c3791be680aeb3" category="inline-link">CVS 서비스 유형입니다</block>
  <block id="457c2f1fead29343fe617ea61b06aaff" category="list-text">'torageClass'는 원하는 항목을 선택하는 데 사용할 수 있는 선택적 매개 변수입니다<block ref="46dc1bdb584c5005116d9d2a4d889e1d" category="inline-link-rx"></block>. 기본 CVS 서비스 유형('S torageClass=software') 또는 Trident에서 기본적으로 사용하는 CVS 성능 서비스 유형('torageClass=hardware')을 선택할 수 있습니다. 백엔드 정의에 각 CVS의 torageClass를 제공하는 apiRegion을 지정해야 합니다.</block>
  <block id="8ae8f69dea7cff0617560bc62f9c8c21" category="admonition">Astra Trident가 Google Cloud에 기본 CVS 서비스 유형과 통합된 베타 기능은**, 운영 워크로드용으로 제공되지 않습니다. Trident는** CVS에서 완벽하게 지원됨- 성능 서비스 유형으로 기본적으로 사용됩니다.</block>
  <block id="4dd7128ceae058946c44bbbb0985ec6f" category="paragraph">각 백엔드는 단일 Google Cloud 지역에 볼륨을 프로비저닝합니다. 다른 영역에 볼륨을 생성하려면 추가 백엔드를 정의할 수 있습니다.</block>
  <block id="51b2015e6da8653f4041b71312ad43fe" category="cell">'.snapshot' 디렉토리에 액세스합니다</block>
  <block id="33b57ed56f35d9bd9c44a151d47870c5" category="cell">"100Gi"</block>
  <block id="24ee58a4f143adf08af9c1d30049aab9" category="admonition">CVS Google Cloud 백엔드에서 생성된 모든 볼륨에 대해 Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 스토리지 볼륨에 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="db7f67d90a618d3698e7aab6ddef7169" category="section-title">예 2: 기본 CVS 서비스 유형 구성</block>
  <block id="22765d2acb079f52fa8f5b179e9a74fc" category="paragraph">이 예에서는 기본 CVS 서비스 유형을 사용하는 백엔드 정의를 보여 줍니다. 이는 범용 워크로드에 사용되며, 높은 조널 가용성과 함께 가벼운/중간 수준의 성능을 제공합니다.</block>
  <block id="32c780bbc74d6c4f4c9ff8d54332fef9" category="section-title">예 3: 단일 서비스 수준 구성</block>
  <block id="3862c5daf26e4fabfbac9261779b440a" category="paragraph">이 예에서는 Google Cloud Us-west2 지역에서 Astra Trident가 생성한 모든 스토리지에 동일한 측면을 적용하는 백엔드 파일을 보여 줍니다. 이 예제에서는 백엔드 구성 파일에서 proxyURL을 사용하는 방법도 보여 줍니다.</block>
  <block id="3a050f4cfb1985247f813dd3432ed5e6" category="section-title">예 4: 가상 스토리지 풀 구성</block>
  <block id="59e397d220ba994003ab3439526d48d1" category="paragraph">이 예에서는 가상 스토리지 풀을 사용하여 구성된 백엔드 정의 파일과 이를 다시 참조하는 'torageClasses'를 보여 줍니다.</block>
  <block id="cf13ba16f33b5f6772614929649be6c2" category="summary">tridentctl import를 사용하여 기존 스토리지 볼륨을 Kubernetes PV로 가져올 수 있습니다.</block>
  <block id="5f48c343984786005c9830d96c6fca87" category="doc">볼륨 가져오기</block>
  <block id="3cf3b5626cbcac07ab0c5304e90870e8" category="section-title">볼륨 가져오기를 지원하는 드라이버입니다</block>
  <block id="be8c8810fd80d5e84acf47d57d4e0dbc" category="paragraph">이 표에는 볼륨 가져오기를 지원하는 드라이버와 볼륨 가져오기가 도입된 릴리스가 나와 있습니다.</block>
  <block id="b8e7b465df7c5979dc731d06e84ce2cf" category="cell">놓습니다</block>
  <block id="b7a56ff81a861dd454ce0ee6725a66c2" category="paragraph">19.04</block>
  <block id="cb4e2f5c0cf3e43444774c2af2ada914" category="section-title">볼륨을 가져와야 하는 이유는 무엇입니까?</block>
  <block id="b347f0936a6b1f232605f50447a930de" category="paragraph">Trident로 볼륨을 가져오는 데는 다음과 같은 몇 가지 사용 사례가 있습니다.</block>
  <block id="cbccddedba4ba9a336f83d60dd1454f0" category="list-text">응용 프로그램을 Containerizing 하고 기존 데이터 집합을 다시 사용합니다</block>
  <block id="f0dd3bee13b8c14005d98bfbb9a48bf3" category="list-text">수명이 짧은 애플리케이션에 대한 데이터 세트 클론 사용</block>
  <block id="97161389816216aabbaffd954ef4a1f4" category="list-text">오류가 발생한 Kubernetes 클러스터를 리빌드합니다</block>
  <block id="fd045b8743b2b7018e0480bc9a2dd4c5" category="list-text">재해 복구 중에 애플리케이션 데이터 마이그레이션</block>
  <block id="92f0642c89b416c59d914adfb1e33828" category="section-title">가져오기는 어떻게 작동합니까?</block>
  <block id="902881a0ede032887467576928b25fe0" category="paragraph">영구 볼륨 클레임(PVC) 파일은 볼륨 가져오기 프로세스에서 PVC를 생성하는 데 사용됩니다. 최소한 PVC 파일에는 다음 예제와 같이 이름, 네임스페이스, accessModes 및 storageClassName 필드가 포함되어야 합니다.</block>
  <block id="be25b6ff84fa0d015f05f46bbbb6abd1" category="paragraph">tridentctl 클라이언트는 기존 스토리지 볼륨을 가져오는 데 사용됩니다. Trident는 볼륨 메타데이터를 유지하고 PVC 및 PV를 생성하여 볼륨을 가져옵니다.</block>
  <block id="bcf64a12adc519c7d409f80e5cccbe24" category="paragraph">스토리지 볼륨을 가져오려면 볼륨을 포함하는 Astra Trident 백엔드의 이름과 스토리지에서 볼륨을 고유하게 식별하는 이름을 지정합니다(예: ONTAP FlexVol, Element Volume, CVS 볼륨 경로). 스토리지 볼륨은 읽기/쓰기 액세스를 허용해야 하며 지정된 Astra Trident 백엔드에서 액세스할 수 있어야 합니다. '-f' 문자열 인수가 필요하며 YAML 또는 JSON PVC 파일의 경로를 지정합니다.</block>
  <block id="021814b63472d2b6dab37ce7d62c3ea2" category="paragraph">Astra Trident가 볼륨 가져오기 요청을 받으면 기존 볼륨 크기를 결정하고 PVC에 설정합니다. 스토리지 드라이버에서 볼륨을 가져온 후 PV는 PVC에 대한 ClaimRef를 사용하여 생성됩니다. 부가세 반환 청구액 정책은 당초 PV에서 '유지'로 설정되어 있습니다. Kubernetes에서 PVC 및 PV를 성공적으로 바인딩하면 스토리지 클래스의 부가세 반환 청구액 정책에 맞게 부가세 반환 청구액 정책이 업데이트됩니다. Storage Class의 Reclaim 정책이 'Delete'인 경우, PV 삭제 시 스토리지 볼륨이 삭제된다.</block>
  <block id="9d0bcc94449080a9fef1873acd638fb3" category="paragraph">'--no-manage' 인수를 사용하여 볼륨을 가져올 때 Trident는 개체의 수명 주기 동안 PVC 또는 PV에 대한 추가 작업을 수행하지 않습니다. Trident는 `--no-manage' 객체의 PV 및 PVC 이벤트를 무시하므로 PV가 삭제되어도 스토리지 볼륨은 삭제되지 않습니다. 볼륨 클론 및 볼륨 크기 조정과 같은 다른 작업도 무시됩니다. 이 옵션은 컨테이너화된 워크로드에 Kubernetes를 사용하고, 그렇지 않고 Kubernetes 외부 스토리지 볼륨의 라이프사이클을 관리하려는 경우에 유용합니다.</block>
  <block id="76057e180d7b3edcebaa935c7ccab687" category="paragraph">PVC 및 PV에 주석이 추가되어 용적을 가져온 후 PVC와 PV가 관리되었는지 여부를 나타내는 두 가지 목적으로 사용됩니다. 이 주석은 수정하거나 제거할 수 없습니다.</block>
  <block id="b20cebeefba038b396f3fe0494dad01b" category="paragraph">Trident 19.07 이상 버전에서는 PVS 연결을 처리하고 볼륨을 가져오는 과정에서 볼륨을 마운트합니다. 이전 버전의 Astra Trident를 사용하여 가져오는 경우 데이터 경로에 작업이 없으며 볼륨 가져오기에서 볼륨을 마운트할 수 있는지 여부를 확인하지 않습니다. 볼륨 가져오기에서 오류가 발생한 경우(예: StorageClass가 올바르지 않은 경우) PV에 대한 부가세 반환 청구액 정책을 '유지'로 변경하고 PVC 및 PV를 삭제한 후 볼륨 가져오기 명령을 다시 시도하면 복구할 수 있습니다.</block>
  <block id="420279975083139d76ba010ce1956b74" category="section-title">ONTAP-NAS 및 ONTAP-NAS-Flexgroup 가져오기</block>
  <block id="1b539ba5a07e124e582b2e4bfc489200" category="paragraph">ONTAP-NAS 드라이버로 생성된 각 볼륨은 ONTAP 클러스터의 FlexVol입니다. ONTAP-NAS 드라이버를 사용하여 FlexVol을 가져오는 작업은 동일합니다. ONTAP 클러스터에 이미 존재하는 FlexVol은 ONTAP-NAS PVC로 수입할 수 있다. 마찬가지로 FlexGroup vols는 ONTAP-NAS-Flexgroup PVC로 가져올 수 있습니다.</block>
  <block id="62a991a68d1e323e147c11deeaecdad2" category="admonition">ONTAP 볼륨을 Trident에서 가져오려면 RW 유형이어야 합니다. 볼륨이 DP 유형인 경우 SnapMirror 대상 볼륨이므로 볼륨을 Trident로 가져오기 전에 미러 관계를 끊어야 합니다.</block>
  <block id="b368a23170f18969c0c51a21bc3e2754" category="admonition">ONTAP-NAS 드라이버는 qtree를 가져오고 관리할 수 없습니다. ONTAP-NAS와 ONTAP-NAS-Flexgroup 드라이버는 중복 볼륨 이름을 허용하지 않습니다.</block>
  <block id="20a208be23a9e8a96ac28258acb9daa4" category="paragraph">예를 들어, 이름이 "ONTAP_NAS"인 백엔드에서 이름이 managed_volume"인 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="deba327c80a83b34abd4ba640b21e454" category="paragraph">Trident에서 관리하지 않을 'unmanaged_volume'('ONTAP_NAS 백엔드')이라는 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="9be12be7e9d5bb9faa5c9a952feafe07" category="paragraph">Trident는 '--no-manage' 인수를 사용할 때 볼륨의 이름을 바꾸거나 볼륨이 마운트되어 있는지 확인하지 않습니다. 볼륨이 수동으로 마운트되지 않은 경우 볼륨 가져오기 작업이 실패합니다.</block>
  <block id="4004cfbd69335a9d1ba9357ea0dfb079" category="admonition">사용자 지정 UnixPermissions를 사용하여 볼륨을 가져오는 기존 버그가 수정되었습니다. PVC 정의 또는 백엔드 구성에서 unixPermissions를 지정하고 Astra Trident에 볼륨을 가져오도록 지시할 수 있습니다.</block>
  <block id="d346ffc6ef3483fea67a321732823960" category="section-title">ONTAP-SAN 임포트</block>
  <block id="d995f4307341e76349912869caa5e2fb" category="paragraph">Astra Trident는 단일 LUN이 포함된 ONTAP SAN FlexVol도 가져올 수 있습니다. 이는 FlexVol 내 각 PVC와 LUN에 대해 FlexVol를 생성하는 ONTAP-SAN 드라이버와 일치합니다. 다른 경우와 마찬가지로 'tridentctl import' 명령을 사용할 수 있습니다.</block>
  <block id="1dd2cc952267be6c2cc8e5cff2b5aab1" category="list-text">ONTAP-SAN 백엔드 이름을 포함합니다.</block>
  <block id="e395471eab1d4c8fbc8452e98a95d0c5" category="list-text">가져올 FlexVol의 이름을 입력합니다. 이 FlexVol에는 가져와야 하는 LUN이 하나만 포함되어 있습니다.</block>
  <block id="9e6bd670c6fd6b2808fae744834b7675" category="list-text">'-f' 플래그와 함께 사용해야 하는 PVC 정의 경로를 제공합니다.</block>
  <block id="36b577af0f959f68e5e66336695e816c" category="list-text">PVC 관리 또는 비관리형 중에서 선택합니다. 기본적으로 Trident는 PVC를 관리하고 백엔드에서 FlexVol 및 LUN의 이름을 바꿉니다. 관리되지 않는 볼륨으로 가져오려면 '--no-manage' 플래그를 전달합니다.</block>
  <block id="f898748ff73fc5faf70687cbb0051311" category="admonition">관리되지 않는 'ONTAP-SAN' 볼륨을 가져올 때는 FlexVol의 LUN이 'LUN0'으로 명명되고 원하는 이니시에이터가 있는 igroup에 매핑되어 있는지 확인해야 합니다. Astra Trident에서 관리되는 가져오기를 위해 이 작업을 자동으로 처리합니다.</block>
  <block id="66f7455d3b73d0f9938704ee67b1f38a" category="paragraph">그러면 Astra Trident가 FlexVol를 가져와 PVC 정의와 연결합니다. Astra Trident는 FlexVol의 이름을 PVC-&lt;uuid&gt; 형식으로 바꾸고 FlexVol 내의 LUN은 LUN0으로 바꿉니다.</block>
  <block id="2d37ad5bcf7d115e10de14a38db72232" category="admonition">기존 활성 연결이 없는 볼륨을 가져오는 것이 좋습니다. 사용 중인 볼륨을 가져오려는 경우 먼저 볼륨을 클론한 다음 가져오기를 수행합니다.</block>
  <block id="72b3664e6e381ccc62031c13f7ad6df9" category="paragraph">ONTAP_SAN_DEFAULT 백엔드에 존재하는 ONTAP-SAN-MANDATED FlexVol를 가져오려면 tridentctl import 명령을 다음과 같이 실행합니다.</block>
  <block id="26d61ca2331eea0b3aca6c534f2dfcc7" category="admonition">Astra Trident에서 가져오려면 ONTAP 볼륨이 RW 유형이어야 합니다. 볼륨이 DP 유형인 경우 SnapMirror 대상 볼륨이므로 볼륨을 Astra Trident로 가져오기 전에 미러 관계를 끊어야 합니다.</block>
  <block id="4b8f39874197ebe1407531bd66624aa3" category="section-title">요소 불러오기</block>
  <block id="b00215e0583bb02c2474fa62f51462fa" category="paragraph">Trident를 사용하여 NetApp Element 소프트웨어/NetApp HCI 볼륨을 Kubernetes 클러스터로 가져올 수 있습니다. "tridentctl import" 명령의 인수로 Astra Trident 백엔드의 이름과 볼륨의 고유 이름 및 PVC 파일이 필요합니다.</block>
  <block id="c517a1b34541565def824e8e9aeb0524" category="admonition">Element 드라이버는 중복 볼륨 이름을 지원합니다. 중복된 볼륨 이름이 있는 경우 Trident의 볼륨 가져오기 프로세스에서 오류가 반환됩니다. 이 문제를 해결하려면 볼륨을 복제하여 고유한 볼륨 이름을 제공합니다. 그런 다음 복제된 볼륨을 가져옵니다.</block>
  <block id="441d2edc083114ed813856f0b61524d4" category="section-title">AWS-CV 가져오기</block>
  <block id="828c3f28cef558031e2f55632d27b6f4" category="admonition">AWS에서 NetApp Cloud Volumes Service가 지원하는 볼륨을 가져오려면 이름 대신 볼륨 경로를 기준으로 볼륨을 식별합니다.</block>
  <block id="91676978c9f14db1332e3c5b60f4d681" category="paragraph">adroit-jolly-swift 볼륨 경로를 사용하여 백엔드에서 awscvs_YEppr라는 AWS-CV 볼륨을 가져오려면 다음 명령을 사용합니다.</block>
  <block id="87e30ad820e5b10036bd18284c1f25ad" category="admonition">볼륨 경로는 / 이후의 볼륨 내보내기 경로 부분입니다. 예를 들어, 내보내기 경로가 10.0.0.1:/adroit-jolly-swift인 경우 볼륨 경로는 매우 교묘한 -jolly-swift입니다.</block>
  <block id="3be8989f2135d86f8b2d60f19eed3846" category="section-title">GCP-CV 가져오기</block>
  <block id="ea6ab4f91ea921bc82295089f42da373" category="paragraph">GCP-CV 볼륨 가져오기는 AWS-CV 볼륨 가져오기와 동일합니다.</block>
  <block id="9f25c8d8bca8641faa974c73a8d2f5da" category="section-title">Azure-NetApp - 파일 가져오기</block>
  <block id="e8945ce1398c6d24aa1d518bca08034c" category="paragraph">볼륨 경로 importvol1을 사용하여 백엔드에서 azurenetappfiles_40517이라는 Azure-NetApp-files 볼륨을 가져오려면 다음 명령을 실행합니다.</block>
  <block id="c3417eb755bee1658ae5b42ff2115193" category="admonition">ANF 볼륨의 볼륨 경로는 다음:/ 이후의 마운트 경로에 있습니다. 예를 들어, 마운트 경로가 10.0.0.2:/importvol1 인 경우 볼륨 경로는 importvol1 입니다.</block>
  <block id="2941c38dbb7c39c325787067c0540247" category="summary">kubbtl을 사용하여 백엔드 관리 작업을 수행하는 방법에 대해 알아보십시오.</block>
  <block id="bffb766af67c15f14cae35f03dd6f4a9" category="doc">kubeck을 사용하여 백엔드 관리 수행</block>
  <block id="20309eb77b701e6c49ca6b99a8f93f90" category="paragraph">'트리멘BackendConfig'를 삭제하면 Astra Trident가 백엔드 삭제/보존('정책' 기준)을 수행하도록 지시합니다. 백엔드를 삭제하려면 deletionPolicy가 delete로 설정되어 있는지 확인합니다. 트리젠백엔드구성만 삭제하려면, '정책'이 '유지'로 설정되어 있는지 확인하십시오. 이렇게 하면 백엔드가 계속 존재하고 'tridentctl'을 사용하여 관리할 수 있습니다.</block>
  <block id="3fa37f688874143cd423aabca8075ffb" category="paragraph">Astra Trident는 트리엔엔드구성에서 사용 중인 Kubernetes 비밀을 삭제하지 않습니다. Kubernetes 사용자는 기밀을 정해야 합니다. 비밀 정보를 삭제할 때는 주의해야 합니다. 암호는 백엔드에서 사용하지 않는 경우에만 삭제해야 합니다.</block>
  <block id="265ab4809f08d248e5045a8638ac7afa" category="paragraph">또한 'tridentctl get backend-n trident' 또는 'tridentctl get backend-o YAML-n trident'를 실행하여 존재하는 모든 백엔드 목록을 확인할 수 있습니다. 이 목록에는 tridentctl로 만든 백엔드 또한 포함됩니다.</block>
  <block id="93700a3ea9dc6d858638cd66cd2f2bfa" category="paragraph">백엔드를 업데이트해야 하는 이유는 여러 가지가 있을 수 있습니다.</block>
  <block id="56cdd71a65518838d73e00276ed6fab1" category="list-text">스토리지 시스템에 대한 자격 증명이 변경되었습니다. 자격 증명을 업데이트하려면 '트리펜엔드구성' 객체에 사용되는 Kubernetes Secret를 업데이트해야 합니다. Astra Trident가 자동으로 백엔드를 제공된 최신 자격 증명으로 업데이트합니다. 다음 명령을 실행하여 Kubernetes Secret를 업데이트하십시오.</block>
  <block id="6ef0ccb954a07e30d4ff894b5256ae30" category="list-text">매개 변수(예: 사용 중인 ONTAP SVM의 이름)를 업데이트해야 합니다. 이 경우 Kubernetes를 통해 '트리펜엔드구성' 객체를 직접 업데이트할 수 있습니다.</block>
  <block id="d4609cbe039ed7019e7151718c417bec" category="paragraph">또는 다음 명령을 실행하여 기존 '트리엔백엔드구성' CR을 변경합니다.</block>
  <block id="d38f034e9aa082af3ec19c23caff4b0f" category="paragraph">백엔드 업데이트에 실패하면 백엔드는 마지막으로 알려진 구성으로 계속 유지됩니다. 'kubtl get tbc&lt;tbc-name&gt;-o YAML-n trident' 또는 'kubtl t설명해 tbc&lt;tbc-name&gt;-n trident'를 실행하여 로그를 보고 원인을 확인할 수 있습니다.</block>
  <block id="5878b59fb3a8430928026b63b5ca336f" category="paragraph">구성 파일의 문제를 확인하고 수정한 후 update 명령을 다시 실행할 수 있습니다.</block>
  <block id="821b0ad941ad2559ef18eb8de56a470e" category="summary">Kubernetes 클러스터의 모든 작업자 노드는 Pod용으로 프로비저닝된 볼륨을 마운트할 수 있어야 합니다. 백엔드 중 하나에 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup 드라이버를 사용하는 경우 작업자 노드에 NFS 툴이 필요합니다. 그렇지 않으면 iSCSI 도구가 필요합니다.</block>
  <block id="89d83ec6e8ec0c087fbc4aedc555b362" category="doc">작업자 노드를 준비합니다</block>
  <block id="8b1d1603c11aec689eb0d88a5ebabb67" category="paragraph">Kubernetes 클러스터의 모든 작업자 노드는 Pod용으로 프로비저닝된 볼륨을 마운트할 수 있어야 합니다. 백엔드 중 하나에 ONTAP-NAS, ONTAP-NAS-이코노미 또는 ONTAP-NAS-Flexgroup 드라이버를 사용하는 경우 작업자 노드에 NFS 툴이 필요합니다. 그렇지 않으면 iSCSI 도구가 필요합니다.</block>
  <block id="9e4d9c5be865862a92caf88e2beae43f" category="paragraph">최신 버전의 RedHat CoreOS에는 기본적으로 NFS와 iSCSI가 모두 설치되어 있습니다.</block>
  <block id="f5c6a9fc65ae9fb698dc758b23c4ee97" category="admonition">NFS 또는 iSCSI 툴을 설치한 후에는 항상 작업자 노드를 재부팅해야 하며, 그렇지 않으면 컨테이너에 볼륨을 연결할 수 없습니다.</block>
  <block id="b7a66d04a41292979004906785008ca9" category="section-title">NFS 볼륨</block>
  <block id="696c660ff8d9323e55146a6dbd4e4088" category="cell">운영 체제</block>
  <block id="c441ee50c88f6e5e3a7c69fc69dad8b8" category="cell">명령</block>
  <block id="3fb1c9901f28248a22f47bd3917b5dc9" category="paragraph">RHEL/CentOS</block>
  <block id="e0b19bed1baf46134f4079471e193b01" category="paragraph">'SUDO yum install -y nfs-utils'</block>
  <block id="7eaf289636bc8d4f8b29b333a0f32dc2" category="paragraph">Ubuntu/Debian</block>
  <block id="1054b270f1635a3dd940e995cbc7ed78" category="paragraph">'UDO apt-get install-y nfs-common'을 선택합니다</block>
  <block id="31562df6c30f7b7efb939eaa0ee48415" category="admonition">부팅 중에 NFS 서비스가 시작되었는지 확인해야 합니다.</block>
  <block id="29ba980a9e9adedc9414ea868c74ebd5" category="section-title">iSCSI 볼륨</block>
  <block id="222194999a60d89dfcd0ff5867f49e88" category="paragraph">iSCSI 볼륨을 사용할 때는 다음 사항을 고려하십시오.</block>
  <block id="12fe03bf2457cc4e4e90af10a2f7092f" category="list-text">Kubernetes 클러스터의 각 노드에는 고유한 IQN이 있어야 합니다. * 이것은 필수 전제 조건입니다 *.</block>
  <block id="aaa200e86b57cd2a527761ec2bf4b9b0" category="list-text">RHCOS 버전 4.5 이상을 사용하거나 RHEL 또는 CentOS 버전 8.2 이상을 'olidfire-SAN' 드라이버로 사용하는 경우, CHAP 인증 알고리즘이 '/etc/iscsi/iscsid.conf'에서 MD5로 설정되어 있는지 확인하십시오.</block>
  <block id="0bad70dcf33f40dcc0d528d58b9eac76" category="inline-link">RedHat 설명서</block>
  <block id="dbb4705e17a1f8ba49af109d4f366609" category="list-text">iSCSI PVS에서 RHEL/RedHat CoreOS를 실행하는 작업자 노드를 사용하는 경우 StorageClass에서 discard 마운트 옵션을 지정하여 인라인 공간 재확보를 수행하십시오. 을 참조하십시오<block ref="166e862efdc516354d90f75a38532ddd" category="inline-link-rx"></block>.</block>
  <block id="8cd5b262d8d9950185128d052d55f7c8" category="list-text">다음 시스템 패키지를 설치합니다.</block>
  <block id="6bbf3284462dc8b9b90cb1adcd1c0ff4" category="paragraph">'SUDO yum install -y lsscsi iscsi -initiator-utils sg3_utils device-mapper-multipath'</block>
  <block id="1a5157a00ea5806f553766d5b3b114fd" category="list-text">iscsi-initiator-utils 버전이 6.2.0.874-2.el7 이상인지 확인합니다.</block>
  <block id="55c13faac514053f94cef55eb316c9a4" category="paragraph">rpm -q iscsi-initiator-utils</block>
  <block id="19955b3c2d2c1cfc1c82c2fe0347a065" category="list-text">스캔을 수동으로 설정합니다.</block>
  <block id="d2db641a196e6107eecf8c32f7cd7a4e" category="paragraph">'SUDO SED-I's/^\(node.session.scan\).*/\1 = manual/'/etc/iscsi/iscsid.conf'</block>
  <block id="d0b02d407fd5c75d0e7eac549a852191" category="list-text">다중 경로 설정:</block>
  <block id="8bec0eea71974a9138ccfa96983ddcfc" category="list-text">iscsid와 multipathd가 실행 중인지 확인합니다.</block>
  <block id="90a9d2e9b1b4ae58a957ff989f0732ba" category="paragraph">'SUDO systemctl enable -- now iscsid multipathd'</block>
  <block id="8018f5d6ddc4e67678d1659757828deb" category="list-text">"iSCSI" 활성화 및 시작:</block>
  <block id="0f905161e16c2cfa712f1fb7640afee4" category="paragraph">'SUDO systemctl enable -- now iscsi'</block>
  <block id="28ea88befb3a7f6a8e98e7ea7a4fd35f" category="paragraph">'SUDO apt-get install-y open-iscsi lsscsg3-utils multipath-tools scitools'</block>
  <block id="a53508e75911225e5de8b5febc82cf12" category="list-text">open-iscsi 버전이 2.0.874-5ubuntu2.10 이상(bionic) 또는 2.0.874-7.1uubuttu6.1 이상(focal)인지 확인합니다.</block>
  <block id="f6802be29c6bca93d8f44768b0347ac9" category="paragraph">d패키지-l open-iscsi</block>
  <block id="b163c84ad8a4e55a17b51aad8074093e" category="list-text">'open-iscsi'와 'multirpath-tools'가 활성화되어 실행되고 있는지 확인합니다.</block>
  <block id="8741473f7a80f4dd83071161b2c95301" category="paragraph">'SUDO systemctl status multipath -tools''SUDO systemctl enable -- now open-iscsi.service`'SUDO systemctl status open-iscsi'</block>
  <block id="1b757fe9c8a149de349a32b8d21feb54" category="admonition">Ubuntu 18.04의 경우 iSCSI 데몬이 시작되도록 "open-iscsi"를 시작하기 전에 iscsiadm"이 있는 타겟 포트를 검색해야 합니다. 또는 iSCSI 서비스를 수정하여 iscsid를 자동으로 시작할 수 있습니다.</block>
  <block id="fc1adc7c8cce02d3bd3dbc3e7ae52990" category="admonition">베타 기능인 작업자 노드 자동 준비에 대한 자세한 내용은 을 참조하십시오 <block ref="a57ab171c518329af81ea9d2536c4e10" category="inline-link-macro-rx"></block>.</block>
  <block id="3f82682ace484ae8a94f6b713a856a1f" category="summary">제공된 샘플 구성을 사용하여 Trident 설치를 위한 백엔드로 Azure NetApp Files를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="28b0abcecaf7a63edb46e4e137337018" category="doc">Azure NetApp Files 백엔드를 구성합니다</block>
  <block id="f972fcadaebc8b30143815ae86f44966" category="paragraph">제공된 샘플 구성을 사용하여 Astra Trident 설치의 백엔드로 Azure NetApp Files(ANF)를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="573fa5dc2f7f8efb65f65f94f56fb8ea" category="admonition">Azure NetApp Files 서비스는 100GB 미만의 볼륨을 지원하지 않습니다. Astra Trident는 더 작은 볼륨을 요청하는 경우 100GB 볼륨을 자동으로 생성합니다.</block>
  <block id="07e7004c50a67a3e4e366b4ca1c28e3d" category="paragraph">를 구성하고 사용합니다<block ref="24a785881ff1cdf191a2239811dc9597" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="66d640a9a050b05e6a914cbcd88a1e2e" category="list-text">Azure NetApp Files가 활성화된 Azure 구독의 'SubscriptionID'입니다.</block>
  <block id="b12fb354025b3dfa01277964eb72c060" category="inline-link">앱 등록</block>
  <block id="26e3a81fff63a114b3f66931fe9817bd" category="list-text">테난티디, 클라이언트ID, 그리고 고객비밀<block ref="8cf7d0e47908a64c9538530ae13f3b17" category="inline-link-rx"></block> Azure NetApp Files 서비스에 대한 충분한 권한이 있는 Azure Active Directory에서 앱 등록은 Azure에서 미리 정의한 소유자 또는 기고자 역할을 사용해야 합니다.</block>
  <block id="3cedfb797d3e1bc073ba2b0b4d2502cf" category="inline-link">Azure 문서</block>
  <block id="0d379fc2fdd52ac2845c4a58f8ab28b3" category="admonition">Azure 기본 제공 역할에 대한 자세한 내용은 를 참조하십시오<block ref="b2e35876b943de7ace62c0922ab24aca" category="inline-link-rx"></block>.</block>
  <block id="f494e4df0fff53e809d6563f8ec1782f" category="inline-link">위임된 서브넷</block>
  <block id="4a836a0efc98ecae9af9c3407923eefe" category="inline-link">빠른 시작 가이드</block>
  <block id="7b0fbaf9fee0388fe8032c97b8257fdc" category="list-text">Azure NetApp Files를 처음 사용하거나 새 위치에서 사용하는 경우 일부 초기 구성이 필요합니다. 를 참조하십시오<block ref="713c3fd99272dda043016179a5584f00" category="inline-link-rx"></block>.</block>
  <block id="4a56a2a81941c5206604b30f5115b1ba" category="paragraph">Trident는 백엔드 구성(서브넷, 가상 네트워크, 서비스 수준 및 위치)을 기반으로 요청된 위치에서 사용 가능한 용량 풀에 ANF 볼륨을 생성하고 요청된 서비스 수준 및 서브넷과 일치시킵니다.</block>
  <block id="3e566c45584d66d2ab94c2108f7c3488" category="cell">"Azure-NetApp-파일"</block>
  <block id="9dd18f393b35bf22098cf53e9c1c7fa6" category="cell">드라이버 이름 + "_" + 임의 문자</block>
  <block id="665120e71659a6a32f990a3181688d1b" category="cell">'스크립트 ID'입니다</block>
  <block id="b2ad290b003ccdce2a538f49a795f281" category="cell">Azure 구독의 구독 ID입니다</block>
  <block id="e07778d10cef90430253876cba7157e4" category="cell">텐antID</block>
  <block id="2975d48342e428a3b18123f85ed0ecb5" category="cell">앱 등록에서 테넌트 ID입니다</block>
  <block id="949ba1045db0d48bd189044e672d8097" category="cell">'클라이언트 ID'</block>
  <block id="2c07e9234f0df0d4c8887a04f7e641fe" category="cell">앱 등록의 클라이언트 ID입니다</block>
  <block id="56ef18e84ab36c2bdc4546e6a2756673" category="cell">'clientSecret</block>
  <block id="85f484f0892a96287b6224ddd3c5fbb2" category="cell">앱 등록에서 클라이언트 암호</block>
  <block id="fc7dd5b65d21ee7272a067c9404a8498" category="cell">위치</block>
  <block id="8fce436e09a08bd124727374d3e1d1d5" category="cell">새 볼륨을 생성할 Azure 위치의 이름입니다</block>
  <block id="1c65f12b4d30114593cc01384938cb5f" category="cell">'초표준', '프리미엄', '울트라' 중 하나</block>
  <block id="b21b08bb55acd409e40e9b45edd3bb34" category="cell">""(임의)</block>
  <block id="32ef1af5ccda7c2f6d85e55f5034f105" category="cell">가상네트워크</block>
  <block id="10afd0959cfa4a53bce9c8d395c40c48" category="cell">위임된 서브넷이 있는 가상 네트워크의 이름입니다</block>
  <block id="ec045173f4df65e5e8951c3ca9579945" category="cell">'우방'</block>
  <block id="0b8deda0ecc5080e8c0ed0b475e983ba" category="cell">Microsoft.Netapp/volumes` 에 위임된 서브넷의 이름입니다</block>
  <block id="9440dab4b1faaad2a053d658b9e70623" category="admonition">PVC를 생성하려고 할 때 "용량 풀을 찾을 수 없음" 오류가 발생하면 앱 등록에 필요한 권한과 리소스(서브넷, 가상 네트워크, 용량 풀)가 연결되지 않은 것일 수 있습니다. Astra Trident는 디버깅을 설정할 때 백엔드가 생성될 때 검색한 Azure 리소스를 기록합니다. 적절한 역할이 사용되고 있는지 확인하십시오.</block>
  <block id="a1fa27779242b4902f7ae3bdd5c6d508" category="cell">유형</block>
  <block id="e5ac299cc3b14e1fac29518569ca9bb1" category="cell">새 볼륨의 기본 크기입니다</block>
  <block id="ce46e8f3fc6eaddbe03115e0d62090ac" category="cell">유니크권한</block>
  <block id="dbb358dadb4da7e240eeaa0513a064e1" category="admonition">ANF 백엔드에서 생성된 모든 볼륨의 경우, Astra Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 스토리지 볼륨에 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="e43b3577dd4b74a4cfa994a56e8138b8" category="paragraph">이 구성은 ANF를 사용하여 지금 막 시작하는 데 이상적이지만, 실제로 용량 할당을 수행하는 볼륨에 대한 추가적인 범위 지정을 제공하려는 경우에 적합합니다.</block>
  <block id="725ae241ec74eed978f0b099030236b8" category="section-title">예 3: 고급 구성</block>
  <block id="a83f4a534ccef7ac1d209fb0015cd907" category="paragraph">이 백엔드 구성은 단일 서브넷에 대한 볼륨 배치 범위를 더욱 줄여주고 일부 볼륨 프로비저닝 기본값도 수정합니다.</block>
  <block id="198188b722e4e8ee2004b3bd2a9348ed" category="paragraph">이 백엔드 구성은 단일 파일에 여러 스토리지 풀을 정의합니다. 다양한 서비스 수준을 지원하는 여러 용량 풀이 있고 이를 나타내는 Kubernetes의 스토리지 클래스를 생성하려는 경우에 유용합니다.</block>
  <block id="db471f3119123601d175fe8d2ef2dd0a" category="paragraph">다음 'torageClass' 정의는 위의 스토리지 풀을 참조합니다. parameters.selector` 필드를 사용하면 볼륨을 호스팅하는 데 사용되는 각 'torageClass'에 대해 지정할 수 있습니다. 볼륨은 선택한 풀에 정의된 측면을 갖습니다.</block>
  <block id="08c4bc4ac4edd9b12963c0596478d746" category="summary">Astra Trident는 CSI 토폴로지 기능을 사용하여 Kubernetes 클러스터에 있는 노드를 선택적으로 생성하고 연결할 수 있습니다.</block>
  <block id="3d4635d3cf4f27b0e87f3fe86a84744d" category="doc">CSI 토폴로지를 사용합니다</block>
  <block id="4abea6bac3b0b48d11dd8dcd02a11bf9" category="inline-link">CSI 토폴로지 기능</block>
  <block id="592af423a2f6a51f57c639ec7f7b245e" category="admonition">CSI 토폴로지 기능에 대해 자세히 알아보십시오<block ref="ff042e7f24bd2adcec09d78466034177" category="inline-link-rx"></block>.</block>
  <block id="bbdcaf9b704dc7a7cf73e6000101b65a" category="paragraph">Kubernetes는 두 가지 고유한 볼륨 바인딩 모드를 제공합니다.</block>
  <block id="93590d63acbb4fa6864a4665157fbcea" category="list-text">'VolumeBindingMode'를 'Immediate'로 설정하면 Astra Trident는 토폴로지 인식 없이 볼륨을 생성합니다. 볼륨 바인딩 및 동적 프로비저닝은 PVC가 생성될 때 처리됩니다. 이는 기본 'VolumeBindingMode'이며 토폴로지 제약 조건을 적용하지 않는 클러스터에 적합합니다. 영구 볼륨은 요청 포드의 예약 요구 사항에 의존하지 않고 생성됩니다.</block>
  <block id="5fca24470d51aa51b0fb2d0f27c25c68" category="list-text">VolumeBindingMode를 WaitForFirstConsumer로 설정하면 PVC를 사용하는 POD가 예약 및 생성될 때까지 PVC에 대한 영구 볼륨의 생성 및 바인딩이 지연됩니다. 이렇게 하면 토폴로지 요구 사항에 따라 적용되는 일정 제한을 충족하기 위해 볼륨이 생성됩니다.</block>
  <block id="3bbc2da928dcf77a048cdd745fe7d208" category="admonition">WaitForFirstConsumer의 바인딩 모드에는 토폴로지 레이블이 필요하지 않습니다. 이 기능은 CSI 토폴로지 기능과 독립적으로 사용할 수 있습니다.</block>
  <block id="edff21c44983aaa85506a3dfe467c494" category="paragraph">CSI 토폴로지를 사용하려면 다음이 필요합니다.</block>
  <block id="6127fe8ac0294f905386b8e26b9a62a3" category="list-text">1.17 이상을 실행하는 Kubernetes 클러스터</block>
  <block id="f9213d77978aabdafac36d2b0a184e56" category="list-text">클러스터의 노드에는 토폴로지 인식( topology.Kubernetes.io/region' 및 topology.Kubernetes.io/zone')을 소개하는 레이블이 있어야 합니다. Astra Trident가 토폴로지 인식을 위해 설치되기 전에 클러스터의 노드에 이러한 레이블 * 이 있어야 합니다.</block>
  <block id="0bd58c9826639ac2db106c3b277a7e0f" category="section-title">1단계: 토폴로지 인식 백엔드 생성</block>
  <block id="c7d3751a47274aaa616d77a14f2e2722" category="paragraph">Astra Trident 스토리지 백엔드는 가용성 영역에 따라 볼륨을 선택적으로 프로비저닝하도록 설계할 수 있습니다. 각 백엔드는 지원해야 하는 영역과 영역의 목록을 나타내는 선택적 'SupportedTopologies' 블록을 전달할 수 있습니다. 이러한 백엔드를 사용하는 StorageClasses의 경우 지원되는 영역/영역에서 예약된 애플리케이션에서 요청하는 경우에만 볼륨이 생성됩니다.</block>
  <block id="168d311a918475a654f296f89a7da983" category="paragraph">다음은 백엔드 정의의 예입니다.</block>
  <block id="3e778236fe8f94ccc453f52d827e3719" category="admonition">'SupportedTopologies'는 백엔드 당 지역 및 영역 목록을 제공하는 데 사용됩니다. 이러한 영역 및 영역은 StorageClass 에서 제공할 수 있는 허용 가능한 값의 목록을 나타냅니다. 백엔드에서 제공되는 지역 및 영역의 하위 집합이 포함된 StorageClasses의 경우 Astra Trident는 백엔드에 볼륨을 생성합니다.</block>
  <block id="217d95247b26701da7fd823884d84723" category="paragraph">스토리지 풀별로 'SupportedTopologies'를 정의할 수도 있습니다. 다음 예를 참조하십시오.</block>
  <block id="c6c80256ac468b3d88d7b62d8753f192" category="paragraph">이 예에서는 "reGion" 및 "zone" 레이블이 스토리지 풀의 위치를 나타냅니다. "topology.Kubernetes.io/region" 및 "topology.Kubernetes.io/zone"은 스토리지 풀을 사용할 수 있는 위치를 지정합니다.</block>
  <block id="54e204e8e05b6eb24d965741eb977e69" category="section-title">2단계: 토폴로지를 인식하는 StorageClasses를 정의합니다</block>
  <block id="090f70d385b4a21aa6c8f2a0ca558616" category="paragraph">클러스터의 노드에 제공되는 토폴로지 레이블을 기반으로 StorageClasses를 정의하여 토폴로지 정보를 포함할 수 있습니다. 이렇게 하면 PVC 요청에 대한 후보 역할을 하는 스토리지 풀과 Trident에서 제공하는 볼륨을 사용할 수 있는 노드의 하위 세트가 결정됩니다.</block>
  <block id="ecb383148a1bc974cba3ac735a79f4c6" category="paragraph">다음 예를 참조하십시오.</block>
  <block id="ab0c7ec9411ede93aa545fbc095c0e75" category="paragraph">위에서 제공한 StorageClass 정의에서 volumeBindingMode는 WaitForFirstConsumer로 설정됩니다. 이 StorageClass에 요청된 PVC는 POD에서 참조될 때까지 작동하지 않습니다. 그리고, “allowedTopologies”는 사용할 지역과 지역을 제공한다. NetApp-SAN-us-east1 StorageClass는 위에 정의된 'AN-BACKEND-Us-east1' 백엔드에서 PVC를 생성합니다.</block>
  <block id="df340fb31051c975afb3518dfd32e07c" category="section-title">3단계: PVC 생성 및 사용</block>
  <block id="f98be29d352e7c38a6502e76bbfaf34c" category="paragraph">StorageClass가 생성되어 백엔드에 매핑되면 PVC를 생성할 수 있습니다.</block>
  <block id="c4b17c8733f9f36fdc682242d2b64ab2" category="paragraph">아래의 '샘플'을 참조하십시오.</block>
  <block id="427e01a8fca484c85a1e8e3a672b999a" category="paragraph">이 매니페스트를 사용하여 PVC를 만들면 다음과 같은 결과가 발생합니다.</block>
  <block id="e65f170821e3417d48579a28989a9260" category="paragraph">Trident에서 볼륨을 생성하여 PVC에 바인딩하려면 POD에서 PVC를 사용합니다. 다음 예를 참조하십시오.</block>
  <block id="9b8ff27bceb4601d1f866c4cf39fe449" category="paragraph">이 podSpec은 us-east1 지역에 존재하는 노드에서 pPod를 예약하고 us-east1-a 또는 us-east1-b 영역에 있는 노드 중에서 선택하도록 지시합니다.</block>
  <block id="c93345596f9f82deea04d17ef8c6ca89" category="paragraph">다음 출력을 참조하십시오.</block>
  <block id="0be3f6c5ce787eead27ad72578c2d31a" category="section-title">지원되는 토폴로지들을 포함하도록 백엔드를 업데이트합니다</block>
  <block id="476950aea923438779c9544953093cb9" category="paragraph">기존 백엔드는 'tridentctl backend update'를 사용하여 'upportedTopologies' 목록을 포함하도록 업데이트할 수 있습니다. 이는 이미 프로비저닝된 체적에 영향을 주지 않으며 후속 PVC에만 사용됩니다.</block>
  <block id="ded10f93b9e4453980b7009035c63418" category="inline-link">컨테이너에 대한 리소스를 관리합니다</block>
  <block id="47ea3356a13b3f6644e6c05450e9d5e1" category="list-text"><block ref="47ea3356a13b3f6644e6c05450e9d5e1" category="inline-link-rx"></block></block>
  <block id="6370f866cf64618c026027da41bd248e" category="inline-link">노드 선택기</block>
  <block id="2a4ad9fc807789134426a1b2babc5733" category="list-text"><block ref="2a4ad9fc807789134426a1b2babc5733" category="inline-link-rx"></block></block>
  <block id="873bf2b9b61a741ce5b7326a3a053489" category="inline-link">친화성 및 반친화성</block>
  <block id="ec5df0a2adb621359563958138462e34" category="list-text"><block ref="ec5df0a2adb621359563958138462e34" category="inline-link-rx"></block></block>
  <block id="e1e08e40036f927a0e660c22aa837f88" category="inline-link">오염과 내약입니다</block>
  <block id="66b1e0aa9cd6e46c0b85fdf56a15154a" category="list-text"><block ref="66b1e0aa9cd6e46c0b85fdf56a15154a" category="inline-link-rx"></block></block>
  <block id="0cc7642bbaf969ea355ea12764841c91" category="summary">Astra Trident 설치를 통해 ONTAP NAS 드라이버를 생성하고 사용하는 방법에 대해 알아보십시오. 이 섹션에서는 백엔드 구성 예제 및 백엔드를 StorageClasses에 매핑하는 방법에 대한 세부 정보를 제공합니다.</block>
  <block id="19ce3b2e7823907e5153f00fe04f64f7" category="doc">구성 옵션 및 예</block>
  <block id="a85f55a18073767a4945eac810e72cb2" category="cell">"ONTAP-NAS", "ONTAP-NAS-이코노미", "ONTAP-NAS-Flexgroup", "ONTAP-SAN", "ONTAP-SAN-이코노미"</block>
  <block id="237d7a1666794b0937adde704bb4795c" category="cell">드라이버 이름 + “_” + dataLIF</block>
  <block id="07c54fe26be1e43601e99cd9d4fbe262" category="cell">마나멘타LIF</block>
  <block id="bf926726f76b2da3a5585d6c7f464adc" category="cell">클러스터 또는 SVM 관리 LIF의 IP 주소입니다</block>
  <block id="c560b8d02093547d93a87c72d8b16eaf" category="cell">“10.0.0.1”, “[2001:1234:ABCD::fee]”</block>
  <block id="bd81db53971fda3e688447b28c747d1a" category="cell">다타LIF</block>
  <block id="d78aba84ea5a1453c8c9f4a603a84040" category="cell">프로토콜 LIF의 IP 주소입니다. IPv6의 경우 대괄호를 사용합니다. 설정한 후에는 업데이트할 수 없습니다</block>
  <block id="57b6222ff12a4dc5a5607f02194a83ce" category="cell">지정되지 않은 경우 SVM에서 파생됩니다</block>
  <block id="a0f3a965c12688befda99da850903dcb" category="cell">자동 내보내기 정책</block>
  <block id="4a5695a4c9eea28a296b0b2f210a15f8" category="cell">자동 엑스포트 정책 생성 및 업데이트 활성화 [부울]</block>
  <block id="b4ad0dff08149092bc3e4b16572af575" category="cell">자동 내보내기</block>
  <block id="af7117fef2444ab632b393ea31e722b8" category="cell">"autoExportPolicy"가 활성화된 경우 Kubernetes 노드 IP를 필터링하기 위한 CIDR 목록입니다</block>
  <block id="e537a193eb90bd46a645ce750bb5f3fc" category="cell">["0.0.0.0/0", "::/0"]"</block>
  <block id="eea443d4fcc24d4cd2cab08c2a6c062f" category="cell">'라벨'</block>
  <block id="b5cbbe3dadaab4a036fdb38af67ee936" category="cell">볼륨에 적용할 임의의 JSON 형식 레이블 세트입니다</block>
  <block id="1d76382e861d2df96647216b26d38948" category="cell">“”</block>
  <block id="cbdaf784161be9806a24fe78a8046c01" category="cell">'고객증명서'</block>
  <block id="a84cbedc106b973917ae925d04533f97" category="cell">Base64 - 클라이언트 인증서의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="8545e54eea74cf2579fbe1cb56b11862" category="cell">'clientPrivateKey'입니다</block>
  <block id="4a54228eb2be79492f8f76bb814ddf63" category="cell">Base64 - 클라이언트 개인 키의 인코딩된 값입니다. 인증서 기반 인증에 사용됩니다</block>
  <block id="b071cd8105f8f59b777098388b7a3322" category="cell">신탁인증서다</block>
  <block id="ffe4ce29fe1a6176d496c40332e9cb98" category="cell">Base64 - 신뢰할 수 있는 CA 인증서의 인코딩된 값입니다. 선택 사항. 인증서 기반 인증에 사용됩니다</block>
  <block id="6d77646a2fd9ab65f8e3344d7dce661a" category="cell">'사용자 이름'</block>
  <block id="83425e975af1b2d60355aa4162300198" category="cell">클러스터/SVM에 연결할 사용자 이름입니다. 자격 증명 기반 인증에 사용됩니다</block>
  <block id="6aa91a7fbb8c9edcf4aa5f9411aec19c" category="cell">"암호"</block>
  <block id="63d06d6cc41e485615f99a3aad0002b3" category="cell">클러스터/SVM에 연결하는 암호 자격 증명 기반 인증에 사용됩니다</block>
  <block id="afc423de2be5ca5ab3a6ae9548bbfcf3" category="cell">'VM'입니다</block>
  <block id="972abf48cbbadbcd573754140d35e19a" category="cell">사용할 스토리지 가상 머신입니다</block>
  <block id="ef65dd3301d78701f7cfcf8a01834f2f" category="cell">SVM 'managementLIF'가 지정된 경우에 파생됩니다</block>
  <block id="3b890f58db76bb3003ada171cd18c4db" category="cell">“인명이름”입니다</block>
  <block id="19563dd7f566b71700028a34e74a1107" category="cell">사용할 SAN 볼륨에 대한 igroup의 이름입니다</block>
  <block id="1c59f4b76e4f9bf529f88205cd0a8ac6" category="cell">“삼중 - &lt;backend-UUID&gt;”</block>
  <block id="c08068da3c5d19547544c4bd424a6b76" category="cell">'토르agePrefix'</block>
  <block id="e3f688f3aa653574b3253640aa98f47c" category="cell">SVM에서 새 볼륨을 프로비저닝할 때 사용되는 접두사 설정한 후에는 업데이트할 수 없습니다</block>
  <block id="a996d2f8e072c583d6cc26aa1e4aba87" category="cell">"삼중류"</block>
  <block id="12d2394af47293b12d6b5f411f99a6d1" category="cell">제한선태사용법</block>
  <block id="b6ea9c09f8ac215ea68be83cd0240aac" category="cell">사용량이 이 비율을 초과하면 프로비저닝이 실패합니다. ONTAP * 용 아마존 FSx에는 * 가 적용되지 않습니다</block>
  <block id="7962423206a6704e20fa94085d19b517" category="cell">“”(기본적으로 적용되지 않음)</block>
  <block id="c07510d6ca04643a0f81501d2407311b" category="cell">요청한 볼륨 크기가 이코노미 드라이버에 대한 이 값보다 큰 경우 용량 할당에 실패합니다.</block>
  <block id="9d96dfa28e7454a1119de523123a1e05" category="cell">“”(기본적으로 적용되지 않음)</block>
  <block id="c9a303edbc714d051896c3a678e59a8a" category="cell">'오만유연한'</block>
  <block id="79892588cbecd0b88729ea1a55b2a3a4" category="cell">FlexVol당 최대 LUN 수는 범위[50, 200]에 있어야 합니다.</block>
  <block id="2d782f413944b272c911c548418a18a3" category="cell">“100”</block>
  <block id="ae0784115c8f815d4a2ca170c59f3c99" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: {“api”:false, “method”:true}</block>
  <block id="08b29ae4ea305dd80d0c3a96da64e57e" category="cell">쉼표로 구분된 NFS 마운트 옵션 목록입니다</block>
  <block id="07f6b23cad3d6da54012935ff972affe" category="cell">"케트리스퍼플랙스볼륨"</block>
  <block id="a13306f726fdf72d2d992a7ebdc63b1b" category="cell">FlexVol당 최대 qtree, 범위 [50, 300]에 있어야 함</block>
  <block id="28326357ec2f8c06e01271c4ee2201f1" category="cell">“200”</block>
  <block id="f703d18584e163e18762e4dc13ad96a0" category="cell">'useREST'</block>
  <block id="1cd645595b39c5c8647c3c9a9c395322" category="cell">ONTAP REST API를 사용하는 부울 매개 변수입니다. * 기술 미리 보기 *</block>
  <block id="32a44f322750e15e2564c4648823248e" category="admonition">"useREST"는 프로덕션 워크로드가 아닌 테스트 환경에 권장되는** 기술 미리 보기로 제공됩니다. "true"로 설정하면 Astra Trident는 ONTAP REST API를 사용하여 백엔드와 통신합니다. 이 기능을 사용하려면 ONTAP 9.9 이상이 필요합니다. 또한 사용되는 ONTAP 로그인 역할은 ONTAP 애플리케이션에 대한 액세스 권한이 있어야 합니다. 이는 미리 정의된 vsadmin과 cluster-admin의 역할에서 충족됩니다.</block>
  <block id="57dc6ee0e65147014833f0586de90e46" category="paragraph">ONTAP 클러스터와 통신하려면 인증 매개 변수를 제공해야 합니다. 보안 로그인 또는 설치된 인증서의 사용자 이름/암호일 수 있습니다.</block>
  <block id="928832023634637f59ed58617f382728" category="admonition">NetApp ONTAP 백엔드에 Amazon FSx를 사용하는 경우 'limitAggregateUsage' 매개 변수를 지정하지 마십시오. NetApp ONTAP용 Amazon FSx에서 제공하는 "fsxadmin" 및 "vsadmin" 역할에는 애그리게이트 사용을 검색하고 Astra Trident를 통해 제한하는 데 필요한 액세스 권한이 없습니다.</block>
  <block id="88dce60232453383ab0d1c3c59cc931d" category="admonition">문제 해결 및 자세한 로그 덤프가 필요한 경우가 아니면 debugTraceFlags를 사용하지 마십시오.</block>
  <block id="c8725b273a5d1a37cc4d2ceafe222f96" category="admonition">백엔드를 생성할 때 생성 후에는 "다LIF"와 "toragePrefix"를 수정할 수 없습니다. 이러한 매개 변수를 업데이트하려면 새 백엔드를 생성해야 합니다.</block>
  <block id="118ec9e23f24f4ea0355c0a8fc7644f8" category="paragraph">'managementLIF' 옵션에 대해 FQDN(정규화된 도메인 이름)을 지정할 수 있습니다. 또한 dataLIF 옵션에 FQDN을 지정할 수 있으며, 이 경우 NFS 마운트 작업에 FQDN이 사용됩니다. 이렇게 하면 라운드 로빈 DNS를 생성하여 여러 데이터 LIF 간에 로드 밸런싱을 수행할 수 있습니다.</block>
  <block id="3de9530f105c3bf7d417c73170a03e5a" category="paragraph">모든 ONTAP 드라이버에 대한 manementLIF도 IPv6 주소로 설정할 수 있습니다. '--use-ipv6' 플래그를 사용하여 Astra Trident를 설치하십시오. 대괄호 안에 있는 'managementLIF' IPv6 주소를 정의할 때는 주의해야 합니다.</block>
  <block id="e896e54be988d9d7199d0e796b08b19b" category="admonition">IPv6 주소를 사용할 때는 [28e8:d9fb:a825:b7bf:69a8:d02f:9e7b:3555]와 같은 대괄호 안에 'managementLIF' 및 'dataLIF'(백엔드 정의에 포함된 경우)가 정의되어 있는지 확인하십시오. 다타LIF가 제공되지 않으면 Astra Trident가 SVM에서 IPv6 데이터 LIF를 가져옵니다.</block>
  <block id="06390865e9ec240a0e295db286d7bef7" category="paragraph">CSI Trident는 autoExportPolicy와 autoExportCIDR 옵션을 사용하여 내보내기 정책을 자동으로 관리할 수 있습니다. 이 기능은 모든 ONTAP-NAS- * 드라이버에 대해 지원됩니다.</block>
  <block id="e98c128dda80ebab208244e4f62e7372" category="paragraph">ONTAP-NAS-이코노미 드라이버의 경우 LimitVolumeSize 옵션도 qtree 및 LUN에 대해 관리하는 볼륨의 최대 크기를 제한하고, qtreesPerFlexvol 옵션을 사용하면 FlexVol당 최대 qtree 수를 사용자 지정할 수 있습니다.</block>
  <block id="92e660f52759e323dbc0ec71541a2e9e" category="paragraph">nfsMountOptions 매개 변수를 사용하여 마운트 옵션을 지정할 수 있습니다. Kubernetes 영구 볼륨의 마운트 옵션은 일반적으로 스토리지 클래스에서 지정되지만 스토리지 클래스에 마운트 옵션이 지정되지 않은 경우 Astra Trident는 스토리지 백엔드의 구성 파일에 지정된 마운트 옵션을 사용하여 로 돌아갑니다. 스토리지 클래스 또는 구성 파일에 마운트 옵션을 지정하지 않으면 Astra Trident가 연결된 영구 볼륨에 마운트 옵션을 설정하지 않습니다.</block>
  <block id="7587c806a60b3f88688668f32e0b766c" category="admonition">Astra Trident는 ONTAP-NAS와 ONTAP-NAS-Flexgroup을 사용하여 생성된 모든 볼륨의 “Comments” 필드에 제공 레이블을 설정합니다. 사용된 드라이버에 따라 FlexVol('ONTAP-NAS') 또는 FlexGroup('ONTAP-NAS-Flexgroup')에 주석이 설정됩니다. Astra Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 스토리지 볼륨에 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="193a49bcfb561fea878daa5efe72cad9" category="section-title">볼륨 프로비저닝을 위한 백엔드 구성 옵션</block>
  <block id="4b162a795c1916b18df8b6a76a8fef49" category="paragraph">구성의 특수 섹션에서 이러한 옵션을 사용하여 각 볼륨이 기본적으로 프로비저닝되는 방식을 제어할 수 있습니다. 예를 들어, 아래 구성 예제를 참조하십시오.</block>
  <block id="a0ee23c5b4cbd6a28a4143933891f927" category="cell">'팩시배부</block>
  <block id="26161d08a960162cd8633d0e23058aed" category="cell">LUN에 대한 공간 할당</block>
  <block id="3be488c6a2bc52ceb7e8685ca24927d7" category="cell">"참"</block>
  <block id="a6bddf19eed00dbe2199864dee8454ce" category="cell">'예비공간'</block>
  <block id="3bce5b103341500856287f5347e19f28" category="cell">공간 예약 모드, "없음"(씬) 또는 "볼륨"(일반)</block>
  <block id="e84c56670c389b09fcad5da7309a165b" category="cell">"없음"</block>
  <block id="0ec3875cf79264e4689a646be2f704b6" category="cell">냅샷정책</block>
  <block id="77f69e470b8766d2dc5df4b7f469ed72" category="cell">사용할 스냅샷 정책입니다</block>
  <block id="84d2c2c768bd1900489bad5fb46b4aac" category="cell">"qosPolicy"</block>
  <block id="54b94bba5d336f4e3d5fd7e88544fad1" category="cell">생성된 볼륨에 할당할 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다</block>
  <block id="952e3a12d35e717bf86a6000b0c08976" category="cell">적응성 QosPolicy</block>
  <block id="831924abd31e90baedabed887dbfc24c" category="cell">생성된 볼륨에 할당할 적응형 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다. ONTAP에서 지원되지 않음 - NAS - 이코노미</block>
  <block id="11f9fcd55c1d81cf352f86fe4cdfd444" category="cell">스냅샷 "0"에 예약된 볼륨의 백분율</block>
  <block id="af6626456fa359992271ea88de34094f" category="cell">"스냅샷 정책"이 "없음"이면 "없음"</block>
  <block id="4be01095ce6e500084fc427e5dec61ac" category="cell">'plitOnClone'을 선택합니다</block>
  <block id="6f5c0c94b1a17baffd2c33facaa10db6" category="cell">생성 시 상위 클론에서 클론을 분할합니다</block>
  <block id="19b4c847405d74614976bd1228f59c9f" category="cell">"거짓"</block>
  <block id="b091cbafedf94db98f17823d044434bd" category="cell">암호화</block>
  <block id="4ecb8b22870f9fb0645228cd38177c49" category="cell">NetApp 볼륨 암호화를 활성화합니다</block>
  <block id="a463baaf6666da7178b6fc6a3c8a3fee" category="cell">'생태성 스타일'을 참조하십시오</block>
  <block id="41da49bdd3fd88b2ddc6be7d6df1b335" category="cell">새로운 볼륨에 대한 보안 스타일</block>
  <block id="4cda9f87625c6278fae1a50fcbbf96d3" category="cell">“UNIX”</block>
  <block id="31aa018945eb62580d68d360cba8ba54" category="cell">'계층화 정책'</block>
  <block id="592a5879ac095ef6ca504cc43a9d7939" category="cell">"없음"을 사용하는 계층화 정책</block>
  <block id="ee6508d5290be6edafccc6e0f471f120" category="cell">ONTAP 9.5 이전 SVM-DR 구성의 경우 "스냅샷 전용</block>
  <block id="c005e78d4bd808038335c32dd84cf7da" category="cell">unixPermissions</block>
  <block id="3e9a232d025270ed6767c385b8291871" category="cell">모드를 선택합니다</block>
  <block id="2ad2c2d9206a1be7e744bb13b2b126dd" category="cell">“777”</block>
  <block id="7ad68fdac2eac069eb8ed0fc45b0fb74" category="cell">스냅샷 디렉토리</block>
  <block id="2907de5eba980e910513008165ea2c2b" category="cell">'.snapshot' 디렉토리의 가시성을 제어합니다</block>
  <block id="647ce4e5394e2e595e46b4fc50a628e9" category="cell">내보내기 정책</block>
  <block id="c1a0e97f953c948568aed6c134fc9711" category="cell">사용할 엑스포트 정책</block>
  <block id="6522432847a0e6902318a976e5533f62" category="cell">“기본값”</block>
  <block id="f7f695c763ad0e0ba03c2ff9cbcfcb3d" category="cell">보안 스타일</block>
  <block id="99c2306b30b8939278f0f817230f3573" category="admonition">Astra Trident와 함께 QoS 정책 그룹을 사용하려면 ONTAP 9.8 이상이 필요합니다. 비공유 QoS 정책 그룹을 사용하고 정책 그룹이 각 구성요소별로 적용되었는지 확인하는 것이 좋습니다. 공유 QoS 정책 그룹은 모든 워크로드의 총 처리량에 대해 상한을 적용합니다.</block>
  <block id="05c4365fe7e90a545f8b24060094a36a" category="paragraph">다음은 기본값이 정의된 예입니다.</block>
  <block id="06602e99c8d46d601029e6dd0b37e3f8" category="paragraph">ONTAP-NAS와 ONTAP-NAS-Flexgroups의 경우, Astra Trident는 이제 새로운 계산을 통해 스냅샷 예비 공간 비율 및 PVC로 FlexVol의 크기를 올바르게 조정했습니다. 사용자가 PVC를 요청하면 Astra Trident는 새 계산을 사용하여 더 많은 공간을 가진 원본 FlexVol를 생성합니다. 이 계산을 통해 사용자는 PVC에서 요청한 쓰기 가능 공간을 확보할 수 있으며 요청된 공간보다 적은 공간을 확보할 수 있습니다. v21.07 이전에는 사용자가 스냅샷 보존 공간을 50%로 하여 PVC(예: 5GiB)를 요청할 때 쓰기 가능한 공간은 2.5GiB에 불과합니다. 이는 사용자가 요청한 전체 볼륨과 스냅샷 보존 비율이 다르기 때문입니다. Trident 21.07을 사용하면 쓰기 가능한 공간이 요청되고 Astra Trident는 '스냅샷 보존' 번호를 전체 볼륨의 백분율로 정의합니다. 이는 ONTAP-NAS-이코노미(ONTAP-NAS-이코노미)에는 적용되지 않습니다. 이 작동 방식을 보려면 다음 예를 참조하십시오.</block>
  <block id="86ec808b80973d24eadfc617926f534e" category="paragraph">계산은 다음과 같습니다.</block>
  <block id="28ad7be76b350116bde3ae04e5f94a60" category="paragraph">snapshotReserve = 50%, PVC request = 5GiB의 경우, 총 볼륨 크기는 2/.5 = 10GiB이고 사용 가능한 크기는 5GiB입니다. 이는 사용자가 PVC 요청에서 요청한 것입니다. 'volume show' 명령은 다음 예와 유사한 결과를 표시합니다.</block>
  <block id="2f1534ee8d0c6ec998511ed37cfe0da9" category="image-alt">에는 volume show 명령의 출력이 나와 있습니다.</block>
  <block id="daabb7db82ac9f3f074671a1185c462e" category="paragraph">이전 설치에서 기존 백엔드는 Astra Trident를 업그레이드할 때 위에서 설명한 대로 볼륨을 프로비저닝합니다. 업그레이드하기 전에 생성한 볼륨의 경우 변경 사항을 관찰하기 위해 볼륨의 크기를 조정해야 합니다. 예를 들어, '스냅샷 보존 = 50'의 2GiB PVC는 쓰기 가능한 공간 1GiB를 제공하는 볼륨을 낳았습니다. 예를 들어, 볼륨을 3GiB로 조정하면 애플리케이션에 6GiB 볼륨의 쓰기 가능 공간이 3GiB로 표시됩니다.</block>
  <block id="2aae2b6accd04335b3eeceb2193b34d6" category="section-title">최소 구성의 예</block>
  <block id="bca36ce39f61ce2d375cbdb66eab5162" category="paragraph">다음 예에서는 대부분의 매개 변수를 기본값으로 두는 기본 구성을 보여 줍니다. 이는 백엔드를 정의하는 가장 쉬운 방법입니다.</block>
  <block id="f35c0fe4b6581c16866c964cef229bfa" category="admonition">Trident가 있는 NetApp ONTAP에서 Amazon FSx를 사용하는 경우 IP 주소 대신 LIF에 대한 DNS 이름을 지정하는 것이 좋습니다.</block>
  <block id="acf031eeb31936d30314a2d2a698e85b" category="section-title">ONTAP - 인증서 기반 인증을 갖춘 NAS 드라이버</block>
  <block id="78e5b29e139db71ceb7ca6bc99b5e228" category="paragraph">이는 최소 백엔드 구성의 예입니다. clientCertificate, clientPrivateKey, trustedCACertificate(신뢰할 수 있는 CA를 사용하는 경우 선택 사항)가 backend.json에 채워지고 클라이언트 인증서, 개인 키, 트러스트된 CA 인증서의 base64로 인코딩된 값을 각각 가져갑니다.</block>
  <block id="89e5db56c8bbbfc3f8f2325201c46450" category="section-title">자동 엑스포트 정책이 포함된 ONTAP-NAS 드라이버</block>
  <block id="8c35a9f7d631f51e05811b36617db641" category="paragraph">이 예에서는 Astra Trident가 동적 엑스포트 정책을 사용하여 엑스포트 정책을 자동으로 생성하고 관리하도록 지시하는 방법을 보여 줍니다. 이는 ONTAP-NAS-이코노미 및 ONTAP-NAS-Flexgroup 드라이버에도 동일하게 적용됩니다.</block>
  <block id="97cf2271125e9ece6c4bb85c7e38b6f6" category="section-title">ONTAP-NAS-flexgroup 드라이버</block>
  <block id="0178beee313066e023eef8c258ed5bfc" category="section-title">ONTAP - IPv6를 사용하는 NAS 드라이버</block>
  <block id="e3d163236efea4513c9df89a9c1be381" category="section-title">ONTAP - NAS - 경제적인 드라이버</block>
  <block id="6bef8424baf7897ad4b3ecd9446fc7c8" category="section-title">가상 스토리지 풀의 백엔드 예</block>
  <block id="54189b80c641ffe9ac5ea57dc48e465c" category="paragraph">아래 표시된 백엔드 정의 샘플 파일에서 'paceReserve'는 none, 'pacteAllocation'은 false, 암호화 같은 모든 스토리지 풀에 대해 특정 기본값이 설정됩니다. 가상 스토리지 풀은 스토리지 섹션에 정의됩니다.</block>
  <block id="6a24af0a579ec0e851db9d35e047d58e" category="paragraph">이 예에서는 일부 스토리지 풀이 자체 'spaceReserve', 'spaceAllocation' 및 'encryption' 값을 설정하고 일부 풀은 위에 설정된 기본값을 덮어씁니다.</block>
  <block id="412b252fa44d1a73e3e7bf22113f99a2" category="section-title">ONTAP - NAS 드라이버</block>
  <block id="f00b69018be0961b32ee24ec54fb56d1" category="section-title">백엔드를 StorageClasses에 매핑합니다</block>
  <block id="dc4edcc28563e022c1d21dec9d28dcca" category="paragraph">다음 StorageClass 정의는 위의 가상 스토리지 풀을 참조합니다. parameters.selector` 필드를 사용하여 각 StorageClass는 볼륨을 호스팅하는 데 사용할 수 있는 가상 풀을 호출합니다. 선택한 가상 풀에 볼륨이 정의되어 있습니다.</block>
  <block id="5303cd360e4a1dda505149e2497f5dd0" category="list-text">첫 번째 StorageClass('protection-gold')는 ONTAP-NAS-flexgroup 백엔드의 첫 번째 가상 스토리지 풀과 ONTAP-SAN 백엔드의 첫 번째 가상 스토리지 풀에 매핑됩니다. 골드 레벨 보호 기능을 제공하는 유일한 풀입니다.</block>
  <block id="b56bbc7832c420bea7e7ad925a5d3c31" category="list-text">두 번째 StorageClass('금전 보호')는 ONTAP-NAS-Flexgroup 백엔드의 세 번째 가상 스토리지 풀과 ONTAP-SAN 백엔드의 세 번째 가상 스토리지 풀에 매핑됩니다. 금 이외의 보호 수준을 제공하는 유일한 풀입니다.</block>
  <block id="93e138c887e529cb6657f632aa3a3867" category="list-text">세 번째 StorageClass('app-mysqldb')는 ONTAP-NAS 백엔드의 네 번째 가상 스토리지 풀과 ONTAP-SAN-이코노미 백엔드의 세 번째 가상 스토리지 풀에 매핑됩니다. mysqldb 유형 앱에 대한 스토리지 풀 구성을 제공하는 유일한 풀입니다.</block>
  <block id="a445ee76dc7da803a09c273595c3555c" category="list-text">네 번째 StorageClass('protection-silver-creditpoints-20k')는 ONTAP-NAS-flexgroup 백엔드의 세 번째 가상 스토리지 풀과 ONTAP-SAN 백엔드의 두 번째 가상 스토리지 풀에 매핑됩니다. 20000 크레딧 포인트에서 골드 레벨 보호 기능을 제공하는 유일한 풀입니다.</block>
  <block id="a2d5d3b55b3cff0e83e0c8feac3dfb45" category="list-text">다섯 번째 StorageClass('크레딧점-5k')는 ONTAP-NAS-이코노미 백엔드의 두 번째 가상 스토리지 풀과 ONTAP-SAN 백엔드의 세 번째 가상 스토리지 풀에 매핑됩니다. 5000 크레딧 포인트에 있는 유일한 풀 서비스입니다.</block>
  <block id="dc92c330959507a128db0801090f9e0d" category="paragraph">Astra Trident가 선택한 가상 스토리지 풀을 결정하고 스토리지 요구 사항을 충족해 줍니다.</block>
  <block id="3d79668ab3683a20086b2953dd541cfc" category="summary">백엔드는 Astra Trident와 스토리지 시스템 간의 관계를 정의합니다. Astra Trident가 스토리지 시스템과 통신하는 방법과 Astra Trident가 스토리지 시스템에서 볼륨을 프로비저닝하는 방법을 알려줍니다. Astra Trident는 스토리지 클래스에 정의된 요구 사항과 일치하는 백엔드에서 스토리지 풀을 자동으로 제공합니다. 사용 중인 스토리지 시스템 유형에 따라 백엔드를 구성하는 방법에 대해 자세히 알아보십시오.</block>
  <block id="87dc0337d3ded2211d9b01c32e22d90d" category="doc">백엔드 구성</block>
  <block id="2acbb5dd492d792d00383b0c76ade4ad" category="list-text"><block ref="2acbb5dd492d792d00383b0c76ade4ad" category="inline-link-macro-rx"></block></block>
  <block id="bf50e8af5395f90aa84ae77d9267a6d6" category="inline-link-macro">Cloud Volumes Service for AWS 백엔드를 구성합니다</block>
  <block id="cda28963ed4e2275760c1b26ef6c78e0" category="list-text"><block ref="cda28963ed4e2275760c1b26ef6c78e0" category="inline-link-macro-rx"></block></block>
  <block id="252e63ff646a0204671ca04a26b88e06" category="inline-link-macro">Google Cloud Platform 백엔드에 Cloud Volumes Service를 구성합니다</block>
  <block id="c00b6e370d4496e06d2135275a992af5" category="list-text"><block ref="c00b6e370d4496e06d2135275a992af5" category="inline-link-macro-rx"></block></block>
  <block id="f2733a323df72dea4b230205225bdc13" category="inline-link-macro">NetApp HCI 또는 SolidFire 백엔드를 구성합니다</block>
  <block id="b1064b6f7a5906eac23601dc24ba95a8" category="list-text"><block ref="b1064b6f7a5906eac23601dc24ba95a8" category="inline-link-macro-rx"></block></block>
  <block id="337de5d45c69b1e4dcf87a8e7ec9ff76" category="inline-link-macro">NetApp ONTAP용 Amazon FSx와 함께 Astra Trident를 사용하십시오</block>
  <block id="d7f015aa2f1d488e17e175dac6de3149" category="list-text"><block ref="d7f015aa2f1d488e17e175dac6de3149" category="inline-link-macro-rx"></block></block>
  <block id="24ca391029d6df294c5d5b8f1fe5b4eb" category="summary">ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="6f95a39ae3c518928ed5e4681a0fd49b" category="doc">ONTAP NAS 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="df3afb1ce4cf5592326d7f536313cbc9" category="list-text"><block ref="df3afb1ce4cf5592326d7f536313cbc9" category="inline-link-macro-rx"></block></block>
  <block id="6a60ddae29750feed1e12421a92ea824" category="list-text"><block ref="6a60ddae29750feed1e12421a92ea824" category="inline-link-macro-rx"></block></block>
  <block id="ff342df7522d6b527768cc6bfe5f9fae" category="summary">Astra Trident를 사용하면 Kubernetes 사용자가 볼륨을 생성한 후 확장할 수 있습니다. iSCSI 및 NFS 볼륨을 확장하는 데 필요한 구성에 대한 정보를 찾습니다.</block>
  <block id="15d79b565b148caa23e6f2b53813413d" category="section-title">iSCSI 볼륨을 확장합니다</block>
  <block id="0b981ab19df55a28a02578aa5f326db8" category="paragraph">CSI 프로비저닝을 사용하여 iSCSI PV(Persistent Volume)를 확장할 수 있습니다.</block>
  <block id="f8f338469c62eb8604f5304af08466ba" category="admonition">iSCSI 볼륨 확장은 ONTAP-SAN, ONTAP-SAN-이코노미, Solidfire-SAN 드라이버로 지원되며 Kubernetes 1.16 이상이 필요합니다.</block>
  <block id="13311fb741bdb3b9d877937311a2d64d" category="paragraph">iSCSI PV를 확장하면 다음 단계가 포함됩니다.</block>
  <block id="5141e3596f63bc5db3fd9ee32b736127" category="list-text">StorageClass 정의를 편집하여 allowVolumeExpansion 필드를 true로 설정합니다.</block>
  <block id="9e7362e47322994c4d272d377e83f31b" category="list-text">PVC 정의 편집 및 'pec.resources.requests.storage'를 업데이트하여 원래 크기보다 큰 새로 원하는 크기를 반영한다.</block>
  <block id="0860a1b7122f04033fb722b29d878468" category="list-text">크기를 조절하려면 PV를 포드에 부착해야 합니다. iSCSI PV의 크기를 조정할 때 두 가지 시나리오가 있습니다.</block>
  <block id="7ac758b4597806f6880d9618fa093e52" category="list-text">PV가 포드에 연결된 경우 Astra Trident는 스토리지 백엔드의 볼륨을 확장하고 디바이스를 다시 검사하며 파일 시스템의 크기를 조정합니다.</block>
  <block id="7efffb2478ff651b7e45343b4e9f6fa8" category="list-text">연결되지 않은 PV의 크기를 조정하려고 하면 Astra Trident가 스토리지 백엔드의 볼륨을 확장합니다. PVC가 POD에 바인딩되면 Trident가 디바이스를 다시 검사해 파일 시스템의 크기를 조정합니다. 그런 다음 확장 작업이 성공적으로 완료된 후 Kubernetes에서 PVC 크기를 업데이트합니다.</block>
  <block id="ec3e34c26eaf059dc3ac58d8efc9fa37" category="paragraph">아래 예에서는 iSCSI PVS의 확장 작동 방식을 보여 줍니다.</block>
  <block id="fe9ee1935ea7894fe4fd2f600993cd7d" category="section-title">1단계: 볼륨 확장을 지원하도록 StorageClass를 구성합니다</block>
  <block id="c83b8171dcc233263cf7eeaef8da6a4d" category="paragraph">이미 존재하는 StorageClass의 경우 allowVolumeExpansion 매개변수를 포함하도록 편집합니다.</block>
  <block id="59973fd7be015512b53fe121a13d5580" category="section-title">2단계: 생성한 StorageClass를 사용하여 PVC를 생성합니다</block>
  <block id="8592e7b08d26d1aa2ef3c44409c736fa" category="paragraph">Astra Trident가 PV(Persistent Volume)를 생성하여 이 PVC(Persistent Volume Claim)와 연결합니다.</block>
  <block id="8dacc1d7fdb5bfd3f8a4daedf3ccdd88" category="section-title">3단계: PVC를 부착하는 POD를 정의합니다</block>
  <block id="85f5dec267aa48cff82ccaf993019e6d" category="paragraph">이 예제에서는 'AN-PVC'를 사용하는 POD가 생성됩니다.</block>
  <block id="ebae1958b6002fb43077a474d845284c" category="section-title">4단계: PV를 확장합니다</block>
  <block id="63188b171689bcd93b1ca818b3a2ab9c" category="paragraph">1Gi 에서 2Gi 로 생성된 PV 의 크기를 조정하려면 PVC 정의를 편집하여 'pec.resources.requests.storage'를 2Gi 로 업데이트합니다.</block>
  <block id="eabf614ed44fe1c3e78cb2300949eb63" category="section-title">5단계: 확장 확인</block>
  <block id="28abbd693f528f04d0ff068b3013fcd6" category="paragraph">PVC, PV, Astra Trident 볼륨의 크기를 확인하여 확장이 제대로 작동하는지 확인할 수 있습니다.</block>
  <block id="75b8249751a8ea5869a0b5a8e465efc1" category="section-title">NFS 볼륨을 확장합니다</block>
  <block id="b5d3e13cbbf4f66f0d6b13357e86f974" category="paragraph">Astra Trident는 ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, AWS-CV, GCP-CV에 프로비저닝된 NFS PVS의 볼륨 확장을 지원합니다. 그리고 'Azure-NetApp-files' 백엔드가 있습니다.</block>
  <block id="578f10bb7cad2abad1cbbcb9a9a732f9" category="paragraph">NFS PV의 크기를 조정하려면 먼저 관리자가 "allowVolumeExpansion" 필드를 "true"로 설정하여 볼륨 확장을 허용하도록 스토리지 클래스를 구성해야 합니다.</block>
  <block id="27b4a9ed8609e35526601aa8d8be1ab9" category="paragraph">이 옵션 없이 스토리지 클래스를 이미 생성한 경우 'kubeck edit storageclass'를 사용하여 기존 스토리지 클래스를 편집하여 볼륨을 확장할 수 있습니다.</block>
  <block id="784f78e647973a0dcfa11b7a028c7eae" category="paragraph">Astra Trident는 이 PVC에 대해 20MiB NFS PV를 생성해야 합니다.</block>
  <block id="3b16cea25bd4a9aaf5a9c3dcc13ea7eb" category="section-title">3단계: PV를 확장합니다</block>
  <block id="e5c2c0bfcfbe01e6174199aaff9616a5" category="paragraph">새로 만든 20MiB PV의 크기를 1GiB로 조정하려면 PVC를 편집하여 pec.resources.requests.storage를 1GB로 설정합니다.</block>
  <block id="4a59ce1bc63fd7e6333968fb4bbd9d45" category="section-title">4단계: 확장을 확인합니다</block>
  <block id="c70f05fed7c73e0be4a0b24c8532a87c" category="paragraph">PVC, PV, Astra Trident 볼륨의 크기를 확인하여 크기가 올바르게 작동하는지 확인할 수 있습니다.</block>
  <block id="64984096fbf22f0a2b49f000ac843834" category="cell">NFS 마운트 옵션에 대한 세밀한 제어</block>
  <block id="18320b2a705a7bed37a6bc0af4aee093" category="cell">요청된 볼륨 크기가 이 값보다 큰 경우 용량 할당에 실패합니다</block>
  <block id="e59001176f4360988f5d774a8405b4b9" category="cell">엑포트정책</block>
  <block id="8b7b728c6a1e7accd6148646ba730e77" category="summary">Astra Trident에서 백엔드를 관리하는 다양한 방법에 대해 알아보십시오.</block>
  <block id="4342473e01edd2e1440b8b76076f4c9e" category="doc">백엔드 관리 옵션 간 이동</block>
  <block id="207aacc2f1990ce861bf20cfcd0ca067" category="paragraph">Astra Trident에서 백엔드를 관리하는 다양한 방법에 대해 알아보십시오. 트리젠백엔드구성이 도입됨에 따라 관리자는 이제 두 가지 방법으로 백엔드를 관리할 수 있게 되었습니다. 이 질문은 다음과 같습니다.</block>
  <block id="a7b407f571446f9f4a30f63e8160784a" category="list-text">tridentctl을 사용하여 만든 백엔드는 트리엔백엔드구성을 사용하여 관리할 수 있습니까?</block>
  <block id="3e1fc11d05c13404995af2b9fda64675" category="list-text">트리덴ctl을 사용하여 트리엔디Config를 사용하여 만든 백엔드를 관리할 수 있습니까?</block>
  <block id="41b338cd1cea5e2df168994a9bdedf75" category="section-title">TrientBackendConfig를 사용하여 tridentctl 백엔드를 관리합니다</block>
  <block id="d6da18e16f248df47ee8e5139ef0156a" category="paragraph">이 섹션에서는 'Tridentctl' 객체를 만들어 Kubernetes 인터페이스를 통해 직접 생성된 백엔드를 관리하는 데 필요한 단계에 대해 설명합니다.</block>
  <block id="bee2ae6068ad50344ddb325737434004" category="paragraph">이 내용은 다음 시나리오에 적용됩니다.</block>
  <block id="e9c4de6d076377511c2b6a8463898ef2" category="list-text">tridentctl로 만든 트리젠백엔드구성이 없는 기존 백엔드입니다.</block>
  <block id="8eed1f3ae09f008e2dbfb4280a0c137c" category="list-text">tridentctl로 만든 새 백엔드와 다른 트리젠BackendConfig 개체가 있습니다.</block>
  <block id="0507a4f0ac746171a414097e7f033dca" category="paragraph">두 시나리오 모두 Astra Trident가 볼륨을 예약하고 운영하면서 백엔드가 계속 존재할 것입니다. 관리자는 다음 두 가지 옵션 중 하나를 선택할 수 있습니다.</block>
  <block id="95328f21e7a6deb7bb94acb3866753a6" category="list-text">tridentctl을 사용하여 만든 백엔드를 관리하려면 계속 사용합니다.</block>
  <block id="82c1dd66573aab904c86b63e2d5486ad" category="list-text">tridentctl을 사용하여 만든 백엔드를 새 트리젠BackendConfig 개체에 바인딩합니다. 이를 통해 뒷골은 트리덴틀이 아니라 쿠벤틀로 관리된다는 뜻이다.</block>
  <block id="d12d5022b29f44c340ee55411970fe10" category="paragraph">kubbeck을 사용하여 기존 백엔드를 관리하려면 기존 백엔드에 바인딩되는 '트리젠백엔드구성'을 생성해야 합니다. 작동 방식에 대한 개요는 다음과 같습니다.</block>
  <block id="0637b40285532fa1b6c6a4548e63d2f4" category="list-text">Kubernetes 암호를 생성하십시오. 비밀에는 Astra Trident가 스토리지 클러스터/서비스와 통신하는 데 필요한 자격 증명이 포함되어 있습니다.</block>
  <block id="b863de09ccfaf2861ead350dd78a9933" category="list-text">'트리멘백엔드구성' 객체를 만듭니다. 스토리지 클러스터/서비스에 대한 자세한 내용과 이전 단계에서 생성한 암호를 참조하십시오. 동일한 구성 매개 변수(예: 'pec.backendName', 'pec.storagePrefix', 'pec.storageDriverName' 등)를 지정할 때는 주의해야 합니다. '현재 백엔드 이름'을 설정해야 합니다.</block>
  <block id="44411eb1f3a70196b442f0ed4bb62820" category="section-title">단계 0: 백엔드를 식별합니다</block>
  <block id="c400920d4e58cf882999474fbdf967d3" category="paragraph">기존 백엔드에 바인딩하는 '트리젠백엔드구성'을 생성하려면 백엔드의 구성을 확보해야 합니다. 이 예에서는 다음과 같은 JSON 정의를 사용하여 백엔드를 생성했다고 가정합니다.</block>
  <block id="2181a22b3daf7866094f9f0d79da87d0" category="paragraph">이 예에 표시된 것처럼 백엔드에 대한 자격 증명이 포함된 암호를 생성합니다.</block>
  <block id="c030a8fb45dd1e59dbe723d93fefa8b4" category="section-title">2단계: 트리엔벤디Config CR을 작성합니다</block>
  <block id="276e25c1cf06c603ba2d133ae2e39dde" category="paragraph">다음 단계는 기존 ONTAP-NAS-백엔드에 자동으로 바인딩되는 '트리젠백엔드구성' CR을 생성하는 것입니다(예:). 다음 요구 사항이 충족되는지 확인합니다.</block>
  <block id="0cbfd18f16db9afdef577eeddd6a8bee" category="list-text">같은 백엔드 이름은 'sepec.backendName'에 정의되어 있습니다.</block>
  <block id="f261e4f2fe82344f35f04f9b3813e425" category="list-text">구성 매개 변수는 원래 백엔드와 동일합니다.</block>
  <block id="12bf8ac3a10fbfae1244c8505d9aa91a" category="list-text">가상 스토리지 풀(있는 경우)은 원래 백엔드와 동일한 순서를 유지해야 합니다.</block>
  <block id="8f50f98a5b56105263e2f7ab18dc0686" category="list-text">자격 증명은 일반 텍스트가 아닌 Kubernetes Secret을 통해 제공됩니다.</block>
  <block id="05c8cd2e49ae2ecaee101c9bc5619d49" category="paragraph">이 경우 트리젠백엔드구성은 다음과 같습니다.</block>
  <block id="63d6f3ce15066b6232a788bb692bf721" category="paragraph">트리젠백엔드구성이 만들어지면 그 단계는 반드시 '바운드'되어야 한다. 또한 기존 백엔드의 백엔드 이름과 UUID도 동일하게 반영되어야 합니다.</block>
  <block id="d1a75f7c76623350486029378ab164c3" category="paragraph">이제 백엔드는 'tbc-ONTAP-nas-backend' 트리펜엔드구성 객체를 사용하여 완벽하게 관리됩니다.</block>
  <block id="fe1ffe29ba93d2779f921228fcba083e" category="section-title">tridentctl을 사용하여 TrientBackendConfig 백엔드를 관리합니다</block>
  <block id="fcea92f3e948217919ca8b4051c2c61e" category="paragraph">트리덴ctl은 트리엔백구성(TrientBackendConfig)을 사용하여 만든 백엔드를 나열하는 데 사용할 수 있습니다. 또한 관리자는 트리텐틀Config를 삭제하고 pec.deletionPolicy` 가 "Stain"으로 설정되어 있는지 확인하여 tridentctl을 통해 이러한 백엔드를 완벽하게 관리할 수도 있습니다.</block>
  <block id="ab0c73d8e0377b2df5b783d3a76f2249" category="paragraph">예를 들어, 다음 백엔드가 ``트리엔백구성”을 사용하여 생성되었다고 가정해 보겠습니다.</block>
  <block id="9874d325a018b14fb52adf25f612579e" category="paragraph">출력으로부터 '(트리젠백엔드구성) '이(가) 성공적으로 생성되었으며 백엔드에 바인딩되어 있습니다 [백엔드의 UUID 확인].</block>
  <block id="416d2581db02ba9bc1187cf17c86a1c4" category="section-title">단계 1: 삭제 확인 정책이 유지로 설정되었습니다</block>
  <block id="ea64db0654e81907c68ffc52d023c3c7" category="paragraph">정책이라는 가치를 한번 살펴보자. 이를 보철로 설정해야 합니다. 이렇게 하면 ' TrientBackendConfig ' CR을 삭제할 때 백엔드 정의가 계속 존재하고 'tridentctl'을 사용하여 관리할 수 있습니다.</block>
  <block id="1ad97e0f65ef91102831baaa31630c76" category="admonition">'정책'이 '유지'로 설정되어 있지 않으면 다음 단계로 진행하지 마십시오.</block>
  <block id="e66283ad5a3e477773a4c58ea53d800f" category="section-title">2단계: 트리펜엔드구성 CR을 삭제합니다</block>
  <block id="8313f77478cb0df464604ae4435acce2" category="paragraph">마지막 단계는 트리엔디Config CR을 삭제하는 것이다. '정책'이 '유지'로 설정되어 있는지 확인한 후 삭제를 계속 수행할 수 있습니다.</block>
  <block id="c1493b6d6e05639a816e5772bbb491af" category="paragraph">트리젠벤트Config 객체를 삭제하면 Astra Trident는 백엔드 자체를 삭제하지 않고 간단히 해당 객체를 제거합니다.</block>
  <block id="99c7791f20f0d41bd8f14c11e666a405" category="summary">NetApp ONTAP용 Amazon FSx와 Astra Trident를 사용하면 Amazon Elastic Kubernetes Service(EKS)에서 실행되는 Kubernetes 클러스터에서 ONTAP가 지원하는 블록 및 파일 영구 볼륨을 프로비저닝할 수 있습니다.</block>
  <block id="679e88f51c747ba6602cbc38cb32bff8" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block>는 NetApp의 ONTAP 스토리지 운영 체제가 제공하는 파일 시스템을 실행하고 실행할 수 있도록 완벽하게 관리되는 AWS 서비스입니다. NetApp ONTAP용 Amazon FSx를 사용하면 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에, AWS에 데이터를 저장하는 간편성, 민첩성, 보안, 확장성을 활용할 수 있습니다. FSX는 ONTAP의 다양한 파일 시스템 기능과 관리 API를 지원합니다.</block>
  <block id="7eb620c879218a348ba0e9afaedf6b01" category="paragraph">파일 시스템은 Amazon FSx의 주요 리소스이며, 이는 사내 ONTAP 클러스터와 유사합니다. 각 SVM 내에서 파일 시스템에 파일과 폴더를 저장하는 데이터 컨테이너인 하나 이상의 볼륨을 생성할 수 있습니다. NetApp ONTAP용 Amazon FSx를 사용하면 클라우드에서 Data ONTAP가 관리형 파일 시스템으로 제공됩니다. 새로운 파일 시스템 유형을 * NetApp ONTAP * 라고 합니다.</block>
  <block id="98cbc4f3bec852897b19deb4e76af117" category="paragraph">NetApp ONTAP용 Amazon FSx와 Astra Trident를 사용하면 Amazon Elastic Kubernetes Service(EKS)에서 실행되는 Kubernetes 클러스터가 ONTAP에서 지원하는 블록 및 파일 영구 볼륨을 프로비저닝할 수 있습니다.</block>
  <block id="ff27e75635c1ff1e88fbc656b16e56ce" category="section-title">Astra Trident에 대해 자세히 알아보십시오</block>
  <block id="ac7bd35f3efc1fd44a6368cea5fa9c21" category="paragraph">Astra Trident를 처음 사용하는 경우 아래에 제공된 링크를 사용하여 숙지하십시오.</block>
  <block id="483a5da192f46e3cfe8391d3ef234fc4" category="inline-link-macro">FAQ 를 참조하십시오</block>
  <block id="291df90d8802914b42223577bb41f627" category="list-text"><block ref="291df90d8802914b42223577bb41f627" category="inline-link-macro-rx"></block></block>
  <block id="d977410bdd2db39b51f9b9fbdbcc8061" category="inline-link-macro">Astra Trident를 사용하기 위한 요구사항</block>
  <block id="4d644a71fe6f2b6c8e2bcc86d5aaed77" category="list-text"><block ref="4d644a71fe6f2b6c8e2bcc86d5aaed77" category="inline-link-macro-rx"></block></block>
  <block id="486632f7d2196e772b742db4a4a0ad7c" category="inline-link-macro">Astra Trident 구축</block>
  <block id="70638242b92c90c812dfa8f50f272806" category="list-text"><block ref="70638242b92c90c812dfa8f50f272806" category="inline-link-macro-rx"></block></block>
  <block id="bec2d42d896d0905cf546e4b5ca33b97" category="inline-link-macro">NetApp ONTAP용 ONTAP, Cloud Volumes ONTAP 및 Amazon FSx를 구성하는 모범 사례</block>
  <block id="80a1961bd7058b357bb20148eaf24ec2" category="list-text"><block ref="80a1961bd7058b357bb20148eaf24ec2" category="inline-link-macro-rx"></block></block>
  <block id="80e431e9c3f38eb259dc9d255c8f4cf2" category="list-text"><block ref="80e431e9c3f38eb259dc9d255c8f4cf2" category="inline-link-macro-rx"></block></block>
  <block id="a479f33489c8d81410024a41c9544214" category="inline-link-macro">ONTAP SAN 백엔드 구성</block>
  <block id="9b405a9aada0c758f606770edf5e729c" category="list-text"><block ref="9b405a9aada0c758f606770edf5e729c" category="inline-link-macro-rx"></block></block>
  <block id="3db2a44c712d8cff702c0fe05daddb2c" category="inline-link-macro">ONTAP NAS 백엔드 구성</block>
  <block id="88cc0a1e56925a83682b7c1f999e281b" category="list-text"><block ref="88cc0a1e56925a83682b7c1f999e281b" category="inline-link-macro-rx"></block></block>
  <block id="0606b09e12901baae5719fde5a162beb" category="paragraph">드라이버 기능에 대해 자세히 알아보십시오 <block ref="36417a02a2b8551d9a22837b23ac7abd" category="inline-link-macro-rx"></block>.</block>
  <block id="55449fd175613962d882ab450cfc5f3c" category="inline-link">FabricPool</block>
  <block id="d07e2d99267e4fc3c508f6701be977b4" category="paragraph">NetApp ONTAP용 Amazon FSx에서 사용됩니다<block ref="d1584952da6bdedb0a24d5dbd43ce0bf" category="inline-link-rx"></block> 스토리지 계층을 관리합니다. 이 기능을 사용하면 데이터의 액세스 빈도 여부에 따라 데이터를 계층에 저장할 수 있습니다.</block>
  <block id="0066f4a006b2b4f192583757b5f7a3c2" category="paragraph">Astra Trident는 클러스터 'fsxadmin' 사용자 또는 'vsadmin' SVM 사용자 또는 동일한 역할을 가진 다른 이름을 가진 사용자를 사용하여 ONTAP 또는 SVM 관리자로 실행될 것으로 예상합니다. fsxadmin 사용자는 admin 클러스터 사용자를 제한적으로 대체합니다. Astra Trident는 일반적으로 Amazon이 아닌 FSx에서 ONTAP 배포에 "admin" 클러스터 사용자를 사용합니다.</block>
  <block id="8e64a609e66214066595e6300aaab281" category="section-title">드라이버</block>
  <block id="5979964b20770952072578428e9c11cb" category="paragraph">다음 드라이버를 사용하여 Astra Trident를 NetApp ONTAP용 Amazon FSx와 통합할 수 있습니다.</block>
  <block id="79a4618bb191cb293c330f8189531a13" category="list-text">'ONTAP-SAN': 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨용 자체 Amazon FSx 내에 있는 LUN입니다.</block>
  <block id="b8f98ceeb9b158e8af3527fce91e9e57" category="list-text">'ONTAP-SAN-이코노미': 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨에 대해 Amazon FSx당 구성 가능한 LUN 수를 가진 LUN입니다.</block>
  <block id="a5bc2c9e7628ac6c73838f9fea0e6ed6" category="list-text">ONTAP-NAS: 프로비저닝되는 각 PV는 NetApp ONTAP 볼륨용 전체 Amazon FSx입니다.</block>
  <block id="94a834f420b7c21f3a1053e6dc705a31" category="list-text">'ONTAP-NAS-E경제적인': 각 PV 프로비저닝은 qtree이며, NetApp ONTAP 볼륨에 대해 Amazon FSx당 qtree를 구성할 수 있습니다.</block>
  <block id="e42b07a9f050ef51ea1211004a50f223" category="list-text">'ONTAP-NAS-flexgroup': 프로비저닝되는 각 PV는 NetApp ONTAP FlexGroup 볼륨에 대한 전체 Amazon FSx입니다.</block>
  <block id="9dd7dc44e4a27c9a2c567d6b2a8b221a" category="paragraph">Astra Trident는 두 가지 인증 모드를 제공합니다.</block>
  <block id="5cefadbc856e5afd968e0dbf6f90ad85" category="list-text">자격 증명 기반: 파일 시스템에 대해 'fsxadmin' 사용자를 사용하거나 SVM용으로 구성된 'vsadmin' 사용자를 사용할 수 있습니다. 백엔드를 구성하려면 'vsadmin' 사용자를 사용하는 것이 좋습니다. Astra Trident는 이 사용자 이름과 암호를 사용하여 FSx 파일 시스템과 통신합니다.</block>
  <block id="ed2536bee60113131cf25b2de3ec8734" category="list-text">인증서 기반: Astra Trident는 SVM에 설치된 인증서를 사용하여 FSx 파일 시스템의 SVM과 통신합니다.</block>
  <block id="28e8b87c947c614dcb6e6f51703815e1" category="paragraph">인증에 대한 자세한 내용은 다음 링크를 참조하십시오.</block>
  <block id="619b69dca5d7c9f1f67ec55897733162" category="inline-link-macro">ONTAP NAS를 지원합니다</block>
  <block id="b773e97e2ae2aebea91c33b771a98316" category="list-text"><block ref="b773e97e2ae2aebea91c33b771a98316" category="inline-link-macro-rx"></block></block>
  <block id="548fedaf4074fe2826e3c53dfd92a19e" category="inline-link-macro">ONTAP SAN</block>
  <block id="58ec862225833e810e6a7f94667d42db" category="list-text"><block ref="58ec862225833e810e6a7f94667d42db" category="inline-link-macro-rx"></block></block>
  <block id="9f6c198d85b31b573b56186f8ecc4394" category="section-title">NetApp ONTAP용 Amazon FSx를 사용하여 EKS에서 Astra Trident를 구축하고 구성합니다</block>
  <block id="80d13d3dbe137e8fb646193f275eceeb" category="list-text">kubbtl이 설치된 기존 Amazon EKS 클러스터 또는 자체 관리 Kubernetes 클러스터</block>
  <block id="52d48fdd62aa109d7f163f0ef8a31b83" category="list-text">클러스터의 작업자 노드에서 연결할 수 있는 NetApp ONTAP 파일 시스템용 기존 Amazon FSx 및 SVM(스토리지 가상 시스템)입니다.</block>
  <block id="ae9a35d29039db87d65a796241a9043d" category="inline-link-macro">NFS 및/또는 iSCSI</block>
  <block id="26717a7ec67b264dcb09707406b962ef" category="list-text">에 대해 준비된 작업자 노드입니다 <block ref="b4b6a021fd40b8007c50db2baa5f32f0" category="inline-link-macro-rx"></block>.</block>
  <block id="fe914214000491758957f04647f8da36" category="inline-link">Amazon Machine Images(아마존 머신 이미지)</block>
  <block id="b048d74c93505355f9535fd30cba1a60" category="admonition">Amazon Linux 및 Ubuntu에 필요한 노드 준비 단계를 따라야 합니다<block ref="70013ee128d5437b3d9579d66ece4066" category="inline-link-rx"></block> (AMI) EKS AMI 유형에 따라 다릅니다.</block>
  <block id="7b94315b87c307aaeb6180ba3d298112" category="paragraph">다른 Astra Trident 요구 사항은 를 참조하십시오 <block ref="9754671a728b750cb0063ea36c5205bc" category="inline-link-macro-rx"></block>.</block>
  <block id="a63af3333b229a7d3d80f554369071d3" category="list-text">../triment-get-started/Kubernetes-deploy.html[배포 방법^] 중 하나를 사용하여 Astra Trident를 구축하십시오.</block>
  <block id="064bdeb131b9f896a140c3620503f952" category="list-text">다음과 같이 Astra Trident를 구성합니다.</block>
  <block id="0416f36f8f02433e530639fd76b0721d" category="list-text">SVM의 관리 LIF DNS 이름을 수집합니다. 예를 들어, AWS CLI를 사용하여 다음 명령을 실행한 후 "Endpoints" -&gt; "anagement"에서 DNSName 항목을 찾습니다.</block>
  <block id="d4eca488acc4ec18f87e7f00d23309cd" category="list-text">인증을 위한 인증서를 만들고 설치합니다. 'ONTAP-SAN' 백엔드를 사용하는 경우 을 참조하십시오 <block ref="db35e24c08f3bb29e6d31cbaa530e9d6" category="inline-link-macro-rx"></block>. 'ONTAP-NAS' 백엔드를 사용하는 경우 를 참조하십시오 <block ref="118a5731ca660935428e52a749b9e8a6" category="inline-link-macro-rx"></block>.</block>
  <block id="3e25473814d436a2ebac91120e147b0b" category="admonition">파일 시스템에 연결할 수 있는 모든 위치에서 SSH를 사용하여 파일 시스템(예: 인증서 설치)에 로그인할 수 있습니다. 파일 시스템 생성 시 구성한 fsxadmin 사용자, AWS FSX 기술파일 시스템"의 관리 DNS 이름을 사용합니다.</block>
  <block id="860958fe641e0edbd80fe522c36d0560" category="list-text">아래 예에 표시된 대로 인증서와 관리 LIF의 DNS 이름을 사용하여 백엔드 파일을 생성합니다.</block>
  <block id="1584837635038d443115ce4eeb3b33e4" category="paragraph">백엔드 만들기에 대한 자세한 내용은 다음 링크를 참조하십시오.</block>
  <block id="82744a46443ebff9011b85aa2468fdc2" category="list-text"><block ref="82744a46443ebff9011b85aa2468fdc2" category="inline-link-macro-rx"></block></block>
  <block id="31e8c05beab321d1465fc4c3f77e991a" category="inline-link-macro">ONTAP SAN 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="d1e8ff43d93982813a74a45f9b721655" category="list-text"><block ref="d1e8ff43d93982813a74a45f9b721655" category="inline-link-macro-rx"></block></block>
  <block id="408cf26cdce3db57f4b0cfb372f60739" category="admonition">Astra Trident에서 다중 경로를 사용할 수 있도록 ONTAP-SAN 및 ONTAP-SAN-이코노미 드라이버에 대해 "LIF"를 지정하지 마십시오.</block>
  <block id="d11f02b39cdb338286053b2f1315c6b4" category="inline-link-macro">스토리지 클래스, 볼륨 프로비저닝 및 POD에 볼륨 마운트</block>
  <block id="95a5f873da165cd068ef3ec7e17364f3" category="paragraph">배포 후 단계를 수행하여 을 생성합니다 <block ref="15bf5a6bf382a8a35f58cdae8ebe845c" category="inline-link-macro-rx"></block>.</block>
  <block id="cc788b7e72b2a734dd0985bd1e0e9fe3" category="inline-link">NetApp ONTAP용 Amazon FSx 문서</block>
  <block id="fd570b75466e2daca21a032e6fd5981c" category="list-text"><block ref="fd570b75466e2daca21a032e6fd5981c" category="inline-link-rx"></block></block>
  <block id="0ef79cb4bb284d3ca9c3e95489919301" category="inline-link">NetApp ONTAP용 Amazon FSx 블로그 게시물</block>
  <block id="3b94214fe5975bca8da92b72f8926be2" category="list-text"><block ref="3b94214fe5975bca8da92b72f8926be2" category="inline-link-rx"></block></block>
  <block id="5f3124ab7224f89a36fbb64fd2ebda15" category="summary">Astra Trident 설치를 통해 ONTAP SAN 드라이버를 생성하고 사용하는 방법에 대해 알아보십시오. 이 섹션에서는 백엔드 구성 예제 및 백엔드를 StorageClasses에 매핑하는 방법에 대한 세부 정보를 제공합니다.</block>
  <block id="ab4ce1634362493e6de248d103136787" category="cell">'useCHAP'입니다</block>
  <block id="3d6bb44641a25033325da197fbb8a670" category="cell">CHAP를 사용하여 ONTAP SAN 드라이버에 대한 iSCSI 인증 [부울]</block>
  <block id="7c6b65d42434282f1555f13b40e9fd25" category="cell">챕터시크릿</block>
  <block id="c8a7a6136447a56280ecf99e3ed87d65" category="cell">CHAP 이니시에이터 암호입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="948938ec6491061ccf17c7ae8eafbd26" category="cell">챕터타겟이니터시크릿</block>
  <block id="48db71efc42dda989b98744160575f4f" category="cell">CHAP 타겟 이니시에이터 암호입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="28687fafefb2992ff7856dcfd2c29e1f" category="cell">'chapUsername'입니다</block>
  <block id="e3f84c141fd3f4682dfb31e0d71c7f5f" category="cell">인바운드 사용자 이름입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="62fbbf4cfd0cc0a82f953199d14a61e3" category="cell">'chapTargetUsername'입니다</block>
  <block id="a379a576b788ab047d5e6405ff4f3511" category="cell">대상 사용자 이름입니다. useCHAP=true인 경우 필수입니다</block>
  <block id="dba7349d856fb1f0791cb0f6c700266f" category="paragraph">'ONTAP-SAN' 드라이버의 경우, 기본값은 SVM의 모든 데이터 LIF IP를 사용하고 iSCSI 다중 경로를 사용하는 것입니다. 'ONTAP-SAN' 드라이버에 데이터 LIF의 IP 주소를 지정하면 다중 경로를 비활성화하고 지정된 주소만 사용하게 됩니다.</block>
  <block id="9f86d18c38ffc3e7be07fb38b682a8be" category="admonition">백엔드를 생성할 때 생성 후에는 dataLIF와 toragePrefix를 수정할 수 없습니다. 이러한 매개 변수를 업데이트하려면 새 백엔드를 생성해야 합니다.</block>
  <block id="2fbf62d46404d999a0e6179621b359a3" category="paragraph">'ONTAP 이름'을 클러스터에 이미 생성된 igroup으로 설정할 수 있습니다. 지정하지 않으면 Astra Trident가 트리덴트 -&lt;backend-UUID&gt;라는 igroup을 자동으로 생성합니다. 미리 정의된 횟수 이름을 제공하는 경우, 환경 간에 SVM을 공유하려면 Kubernetes 클러스터 당 igroup을 사용하는 것이 좋습니다. 이는 Astra Trident가 IQN 추가/삭제를 자동으로 유지 관리하는 데 필요합니다.</block>
  <block id="22599fe16404024d4ce4c8111293b8c2" category="paragraph">백엔드는 또한 생성 후 igroup을 업데이트할 수 있습니다.</block>
  <block id="bc47775cbee2d365887513f379efaf66" category="list-text">ACA Trident 외부의 SVM에서 생성 및 관리되는 새로운 igroup을 가리키도록 특정 igroup 이름을 업데이트할 수 있습니다.</block>
  <block id="3e01e438ad7180641957b0d7d9716f65" category="list-text">고객 이름을 생략할 수 있습니다. 이 경우 Astra Trident가 트리덴트 - &lt;backend-UUID&gt; igroup을 자동으로 생성하고 관리합니다.</block>
  <block id="73e65f4bf1c67cf81e3531ab80adee7e" category="paragraph">두 경우 모두 볼륨 첨부 파일에 계속 액세스할 수 있습니다. 향후 볼륨 첨부 파일은 업데이트된 igroup을 사용합니다. 이 업데이트는 백엔드에 있는 볼륨에 대한 액세스를 방해하지 않습니다.</block>
  <block id="8a89357317a0c827764c86bc08ee62bd" category="paragraph">'managementLIF' 옵션에 대해 FQDN(정규화된 도메인 이름)을 지정할 수 있습니다.</block>
  <block id="88afceb4bf710fa1663fc5c08b2b1bda" category="paragraph">모든 ONTAP 드라이버에 대한 manementLIF도 IPv6 주소로 설정할 수 있습니다. '--use-ipv6' 플래그를 사용하여 Trident를 설치하십시오. 대괄호 안에 'managementLIF' IPv6 주소를 정의할 때는 주의해야 합니다.</block>
  <block id="18bfd4fb5bd53bc4e45e393e24c47255" category="paragraph">ONTAP-SAN 드라이버가 CHAP를 사용하도록 설정하려면 백엔드 정의에서 useCHAP 매개 변수를 true로 설정합니다. 그러면 Astra Trident가 백엔드에 제공된 SVM에 대한 기본 인증으로 양방향 CHAP를 구성하고 사용합니다. 을 참조하십시오 <block ref="8665da470a88e198066a0307a2be351b" category="inline-link-macro-rx"></block> 작동 방법에 대해 알아보십시오.</block>
  <block id="f9f7357cc7873819dbc075deb62cba4b" category="paragraph">ONTAP-SAN-이코노미 드라이버의 경우 LimitVolumeSize 옵션도 qtree 및 LUN에 대해 관리하는 볼륨의 최대 크기를 제한합니다.</block>
  <block id="29669b1b587897fc488d8e332600d528" category="admonition">Astra Trident는 "ONTAP-SAN" 드라이버를 사용하여 생성된 모든 볼륨의 "Comments" 필드에 제공 레이블을 설정합니다. 생성된 각 볼륨에 대해 FlexVol의 "Comments" 필드는 스토리지 풀에 있는 모든 레이블로 채워집니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="036c0eabd455d8a92d350429f2f5747e" category="cell">생성된 볼륨에 할당할 적응형 QoS 정책 그룹입니다. 스토리지 풀/백엔드에서 qosPolicy 또는 adapativeQosPolicy 중 하나를 선택합니다</block>
  <block id="fab51d2bc90465982b0994bc86e69db9" category="admonition">'ONTAP-SAN' 드라이버를 사용하여 생성된 모든 볼륨의 경우, Astra Trident가 FlexVol에 10%의 용량을 추가하여 LUN 메타데이터를 수용합니다. LUN은 사용자가 PVC에서 요청하는 정확한 크기로 프로비저닝됩니다. Astra Trident가 FlexVol에 10%를 더합니다(ONTAP에서 사용 가능한 크기로 표시). 이제 사용자가 요청한 가용 용량을 얻을 수 있습니다. 또한 이 변경으로 인해 사용 가능한 공간이 완전히 활용되지 않는 한 LUN이 읽기 전용이 되는 것을 방지할 수 있습니다. ONTAP-SAN-경제에는 적용되지 않습니다.</block>
  <block id="824d88f50ab9e39778b0ef5bc2516b2f" category="paragraph">'스냅샷 보존'을 정의하는 백엔드의 경우 Astra Trident는 다음과 같이 볼륨의 크기를 계산합니다.</block>
  <block id="4e762198289d9294de9c1cbb3f0b26b6" category="paragraph">1.1은 LUN 메타데이터를 수용하도록 FlexVol에 추가된 10%의 Astra Trident입니다. 나프산예비공간 = 5%, PVC 요청 = 5GiB의 경우 총 용적 크기는 5.79GiB이고 사용 가능한 크기는 5.5GiB입니다. 'volume show' 명령은 다음 예와 유사한 결과를 표시합니다.</block>
  <block id="e6e049b4753c744e95db32b0eeed8d5c" category="paragraph">현재 기존 볼륨에 대해 새 계산을 사용하는 유일한 방법은 크기 조정입니다.</block>
  <block id="19fd94d2657fdd90c44f1fcd72890482" category="admonition">Astra Trident가 있는 NetApp ONTAP에서 Amazon FSx를 사용하는 경우 IP 주소 대신 LIF에 대한 DNS 이름을 지정하는 것이 좋습니다.</block>
  <block id="f9e7424816477078eb0e49bf4eb4c87e" category="section-title">인증서 기반 인증을 갖춘 ONTAP-SAN 드라이버</block>
  <block id="9d6b2226030e3a797fc7ff6dbd810f66" category="section-title">양방향 CHAP가 있는 ONTAP-SAN 드라이버</block>
  <block id="b0a5c44c844418c2a5474a0d4c19182c" category="paragraph">이는 최소 백엔드 구성의 예입니다. 이 기본 구성은 useCHAP가 true로 설정된 ONTAP-SAN 백엔드를 생성합니다.</block>
  <block id="08f9dab0885378aea00f731ad9e52901" category="section-title">ONTAP-SAN - 경제적인 드라이버</block>
  <block id="22aec9ab9f9270747cb10c5bd593c1ab" category="paragraph">다음은 iSCSI의 예로, ONTAP-SAN-이코노미 드라이버를 들 수 있습니다.</block>
  <block id="c109878131f34375d85b7eff9721dcde" category="summary">Astra Trident 설치와 함께 Element 백엔드를 생성하고 사용하는 방법에 대해 알아보십시오.</block>
  <block id="d1d184cecc23825cff20fabf3cdfb862" category="list-text">Element 소프트웨어를 실행하는 지원되는 스토리지 시스템</block>
  <block id="4055116469942da7f6ed83abcf57d0a4" category="list-text">볼륨을 관리할 수 있는 NetApp HCI/SolidFire 클러스터 관리자 또는 테넌트 사용자에 대한 자격 증명</block>
  <block id="d5fa5f22855b065d96647dfb0c06d685" category="inline-link-macro">작업자 노드 준비 정보</block>
  <block id="fa81a6b0253aea3dd9eccc6f72c94371" category="list-text">모든 Kubernetes 작업자 노드에 적절한 iSCSI 툴이 설치되어 있어야 합니다. 을 참조하십시오 <block ref="33b3e91de73abed89a447676724b5cce" category="inline-link-macro-rx"></block>.</block>
  <block id="c443982ebc2d61b1fdf8348209939f8b" category="paragraph">'솔드파이어-SAN' 스토리지 드라이버는 파일 및 블록의 볼륨 모드를 모두 지원합니다. 파일 시스템 볼륨 코드의 경우 Astra Trident가 볼륨을 생성하고 파일 시스템을 생성합니다. 파일 시스템 유형은 StorageClass에 의해 지정됩니다.</block>
  <block id="02017e70674a0c740b2b95fbb0cc2aa1" category="paragraph">파일 시스템이 없습니다. 원시 블록 장치.</block>
  <block id="e1f3ce04f7f587f86c154146eace2807" category="admonition">Astra Trident는 향상된 CSI Provisioner로 작동할 때 CHAP를 사용합니다. CHAP(CSI의 기본값)를 사용하는 경우 추가 준비가 필요하지 않습니다. 비 CSI Trident와 CHAP를 사용하려면 명시적으로 UseCHAP 옵션을 설정하는 것이 좋습니다. 그렇지 않으면 를 참조하십시오 <block ref="195a24f2e3cd9264b9f38d5f581c56cd" category="inline-link-macro-rx"></block>.</block>
  <block id="156ef6dbbdc5c1984194012f4d3505a5" category="admonition">볼륨 액세스 그룹은 Astra Trident의 기존 비 CSI 프레임워크에서만 지원됩니다. CSI 모드에서 작동하도록 구성된 경우 Astra Trident는 CHAP를 사용합니다.</block>
  <block id="03362d64938adda17736eff8a3b091cc" category="paragraph">AccessGroups나 UseCHAP가 설정되지 않은 경우 다음 규칙 중 하나가 적용됩니다.</block>
  <block id="44b5e5595eea45ebf8e49f88409afdaa" category="list-text">기본 '트리덴트' 액세스 그룹이 감지되면 액세스 그룹이 사용됩니다.</block>
  <block id="f3bf91f3dbbbaec039ad830cc87a1013" category="list-text">액세스 그룹이 감지되지 않고 Kubernetes 버전이 1.7 이상인 경우 CHAP가 사용됩니다.</block>
  <block id="2353a0a3a06283f07550efc7bad8a90e" category="cell">항상 "solidfire-san"</block>
  <block id="f4210b28f3cf7c1f7e6e328bb42c6060" category="cell">“SolidFire_” + 스토리지(iSCSI) IP 주소입니다</block>
  <block id="06981b2729b4b522b21d903c7738a2ca" category="cell">끝점</block>
  <block id="955f5caa2495689258902533d1a6cd44" category="cell">'VIP'</block>
  <block id="b07ca7de83de58a699966c9bc9003020" category="cell">스토리지(iSCSI) IP 주소 및 포트</block>
  <block id="749df53d02481e75dd919dddf42fbbef" category="cell">볼륨에 적용할 임의의 JSON 형식 레이블 세트입니다.</block>
  <block id="4e25fe4a614b527d9b3d89ee6abe5d35" category="cell">테난트이름</block>
  <block id="251f1fc42c38ca55f30e5e9d11dac168" category="cell">사용할 테넌트 이름(찾을 수 없는 경우 생성됨)</block>
  <block id="f016e2c01f2bafa45e6b537d49f0f9da" category="cell">이니토IFace</block>
  <block id="4381b3c378885de93e2166f240096338" category="cell">iSCSI 트래픽을 특정 호스트 인터페이스로 제한합니다</block>
  <block id="5ff567e0863a47346f44f87ed793f508" category="cell">'UseCHAP'입니다</block>
  <block id="d390e6782f0a0af41ea0397e46b5368e" category="cell">CHAP를 사용하여 iSCSI를 인증합니다</block>
  <block id="32738663b16444872e4e5721c7c37660" category="cell">"액세스 그룹"</block>
  <block id="c4ca01925aae0c37398f0b30a4ce1273" category="cell">사용할 액세스 그룹 ID 목록입니다</block>
  <block id="e64099a24f6ef8bbbdb23c2a803cd065" category="cell">"트리덴트"라는 액세스 그룹의 ID를 찾습니다.</block>
  <block id="26194deaf50c44db6eb5983237bdaf25" category="cell">'유형'</block>
  <block id="ee1aea1de97320ad8e98436f68b01b4a" category="cell">QoS 사양</block>
  <block id="fcca02e29a08e37c6faf37a418b8d5c8" category="admonition">생성된 모든 볼륨에 대해 Astra Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 해당 스토리지 LUN에 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀에서 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성에서 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="a52b8d71eedc2812fe762b3ec88bfc2e" category="section-title">예 1: 세 가지 볼륨 유형을 사용하는 solidfire-SAN 드라이버에 대한 백엔드 구성</block>
  <block id="3185240fb49cba19667fbdf639f3271e" category="paragraph">이 예에서는 CHAP 인증을 사용하는 백엔드 파일을 보여 주고 특정 QoS 보장을 포함하는 세 가지 볼륨 유형을 모델링합니다. 그런 다음 "IOPS" 스토리지 클래스 매개 변수를 사용하여 각 스토리지 클래스를 사용할 스토리지 클래스를 정의할 가능성이 높습니다.</block>
  <block id="d030a0e9c177498f4267bf1a6a4eab28" category="section-title">예 2: 가상 스토리지 풀이 있는 solidfire-SAN 드라이버에 대한 백엔드 및 스토리지 클래스 구성</block>
  <block id="87af0508250ed6f900914914280a5eaf" category="paragraph">아래 표시된 샘플 백엔드 정의 파일에서 모든 스토리지 풀에 대해 특정 기본값이 설정되어 있으며, 이 경우 Silver에서 'type'을 설정합니다. 가상 스토리지 풀은 '스토리지' 섹션에 정의되어 있습니다. 이 예에서는 일부 스토리지 풀이 자체 유형을 설정하고 일부 풀은 위에 설정된 기본값을 덮어씁니다.</block>
  <block id="e4af8ad03936f6a7724e17f6e83c09c8" category="paragraph">첫 번째 StorageClass(스몰드파이어-골드-포)는 첫 번째 가상 스토리지 풀에 매핑됩니다. 골드의 Volume Type QoS로 골드 성능을 제공하는 유일한 풀입니다. 마지막 스토리지클래스(스몰드파이어-실버)는 실버 성능을 제공하는 스토리지 풀을 호출합니다. Astra Trident가 선택한 가상 스토리지 풀을 결정하고 스토리지 요구 사항을 충족해 줍니다.</block>
  <block id="4d0d37d727675761e4c0e324eb57ca2f" category="list-text"><block ref="4d0d37d727675761e4c0e324eb57ca2f" category="inline-link-macro-rx"></block></block>
  <block id="8682abd0ce083533bad141869c96ab2a" category="summary">Astra Trident는 볼륨을 관리하는 몇 가지 기능을 제공합니다. Astra Trident가 볼륨에 제공하는 기능에 대해 알아보십시오.</block>
  <block id="b42cbc6e68075c106b9faa27e4931091" category="doc">볼륨 작업을 수행합니다</block>
  <block id="eb487790322c4b8e9b4953d60be1acee" category="paragraph">볼륨 관리를 위한 Astra Trident의 기능에 대해 알아보십시오.</block>
  <block id="9e325272e7aed7c7bd6c28ff6fa4a90f" category="list-text"><block ref="9e325272e7aed7c7bd6c28ff6fa4a90f" category="inline-link-macro-rx"></block></block>
  <block id="c499fa59a1c9a0f6da195782a581f2e3" category="list-text"><block ref="c499fa59a1c9a0f6da195782a581f2e3" category="inline-link-macro-rx"></block></block>
  <block id="56661e701892ff873e44b62ffeec85e5" category="list-text"><block ref="56661e701892ff873e44b62ffeec85e5" category="inline-link-macro-rx"></block></block>
  <block id="c0417f5bbd54c5dc1c3704d6b566fcf3" category="list-text"><block ref="c0417f5bbd54c5dc1c3704d6b566fcf3" category="inline-link-macro-rx"></block></block>
  <block id="0f5dc79c8003190ab8f758b1748ba0d8" category="summary">NetApp은 제품과 서비스를 지속적으로 개선 및 개선하고 있습니다. 다음은 최신 버전의 Astra Trident에 포함된 최신 기능, 개선 사항 및 버그 수정 사항입니다.</block>
  <block id="5dd03e8d039863e563e049be198c3fd3" category="doc">릴리즈 노트</block>
  <block id="2e6ce374ac42de81aea6a3d682b92e33" category="paragraph">릴리즈 노트 최신 버전의 Astra Trident에 새로운 기능, 개선 사항 및 버그 수정 사항에 대한 정보를 제공합니다.</block>
  <block id="e4c4d344a524d21b898e4d04b6539aa7" category="admonition">설치 프로그램 zip 파일에 제공되는 Linux용 tridentctl 바이너리는 테스트되고 지원되는 버전입니다. zip 파일의 '/Extras' 부분에 제공된 'macos' 바이너리는 테스트되거나 지원되지 않습니다.</block>
  <block id="41cf959adc98386b54829d71a6ed5d37" category="section-title">수정</block>
  <block id="a6e7aa999ba654c6844672ae59f5137a" category="list-text">XFS 볼륨의 클론을 소스 볼륨과 동일한 노드에 마운트할 수 없는 문제(GitHub 문제 514)가 해결되었습니다.</block>
  <block id="4a921ae3eb8c2695dabd4044ff81141a" category="list-text">Astra Trident에서 종료 시 심각한 오류를 기록한 문제 해결(GitHub 문제 597)</block>
  <block id="852acc81ea6fa7363b73c5313002de83" category="list-text">Kubernetes 관련 수정 사항:</block>
  <block id="f94cc5159119c43751041256941deb2c" category="list-text">ONTAP-NAS와 ONTAP-NAS-Flexgroup 드라이버(GitHub 645호)를 사용하여 스냅샷을 생성할 때 볼륨의 사용된 공간을 최소 restoreSize로 반환합니다.</block>
  <block id="742ce2e3c9c8496323bd1176af2838a4" category="list-text">볼륨 크기 조정(GitHub 문제 560) 후 "파일 시스템 확장 실패" 오류가 기록된 문제 해결</block>
  <block id="9a445ecbad9af70a94bd7558ba95e059" category="list-text">포드가 종단 상태로 고착되는 문제 해결(GitHub 문제 572)</block>
  <block id="4f81c320a621b8c9d81c7334f2cffc71" category="list-text">ONTAP-SAN-E경제적인 FlexVol에 스냅샷 LUN이 포함될 수 있는 사례 해결(GitHub 문제 533)</block>
  <block id="169c3be63dd22b315ed7884e246338de" category="list-text">다른 이미지의 사용자 지정 YAML 설치 프로그램 문제 해결(GitHub 문제 613)</block>
  <block id="1077a1a91a96498c2f56bc630e632eee" category="list-text">스냅샷 크기 계산 수정(GitHub 문제 611)</block>
  <block id="fe705e5b02638736087c9fd97b2c4952" category="list-text">모든 Astra Trident 설치 관리자가 일반 Kubernetes를 OpenShift로 식별할 수 있는 문제 해결(GitHub 문제 639)</block>
  <block id="27b76ffa775f907a1fd51f21a669551b" category="list-text">Kubernetes API 서버에 연결할 수 없는 경우 조정을 중지하도록 Trident 연산자를 수정했습니다(GitHub 문제 599).</block>
  <block id="c1748037d10cffabb8e95e4ccf77c613" category="section-title">향상된 기능</block>
  <block id="1f9e922b6eff6cb06fca1ed9137eed38" category="list-text">GCP-CVS 성능 볼륨에 대한 "unixPermissions" 옵션에 대한 지원이 추가되었습니다.</block>
  <block id="294b850a76a040c20913e76c2fe6589a" category="list-text">600GiB~1TiB 범위의 GCP에서 확장성 최적화 CVS 볼륨 지원 추가</block>
  <block id="0333eb54465646b87754facff75fdb5f" category="list-text">Kubernetes 관련 개선사항:</block>
  <block id="c32aa411caa1ffd0e30a271f5be834d9" category="list-text">Kubernetes 1.22에 대한 지원이 추가되었습니다.</block>
  <block id="fa1fd8841173fa7ccde5059fb7c2f903" category="list-text">Trident 운영자 및 제어 차트를 Kubernetes 1.22(GitHub 문제 628)와 함께 사용할 수 있도록 했습니다.</block>
  <block id="dbaa551f190105e514f7816811f4b397" category="list-text">tridentctl 이미지 명령어(GitHub 문제 570)에 운용자 이미지 추가</block>
  <block id="be575f1ff204f2800114965a5c0d8575" category="section-title">실험적인 개선</block>
  <block id="29ddf941d9825cc9283521ee90468595" category="list-text">'ONTAP-SAN' 드라이버에 볼륨 복제 지원이 추가되었습니다.</block>
  <block id="e2f2b85987da5e2397c1e342a6fd9e28" category="list-text">ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-NAS-이코노미 드라이버에 대한 * 기술 미리보기 * REST 지원이 추가되었습니다.</block>
  <block id="95dc0391ce7b396d7dd5622284e8fc3e" category="section-title">알려진 문제</block>
  <block id="64a8f71bee95a6635e88bce00f1a2d3c" category="paragraph">알려진 문제점은 제품을 성공적으로 사용하지 못하게 만들 수 있는 문제를 식별합니다.</block>
  <block id="572b1d7e33a1c667884a1ffdff7a2d25" category="list-text">Astra Trident는 이제 StorageClass에 지정된 fsType 이 없는 볼륨에 대해 빈 fsType("fsType=""")을 적용합니다. Kubernetes 1.17 이상으로 작업할 때 Trident는 NFS 볼륨에 대한 빈 "fsType"을 제공할 수 있도록 지원합니다. iSCSI 볼륨의 경우 보안 컨텍스트를 사용하여 fsGroup을 적용할 때 StorageClass에 fsType을 설정해야 합니다.</block>
  <block id="91186d69835ccf9911e356f74938c539" category="list-text">여러 Astra Trident 인스턴스에서 백엔드를 사용할 경우 각 백엔드 구성 파일의 ONTAP 백엔드에 대해 서로 다른 'toragePrefix' 값을 사용하거나 SolidFire 백엔드에 다른 'TenantName'을 사용해야 합니다. Astra Trident는 Astra Trident의 다른 인스턴스가 생성한 볼륨을 감지할 수 없습니다. Astra Trident가 볼륨 생성을 idemptent 작업으로 처리하므로 ONTAP 또는 SolidFire 백엔드에서 기존 볼륨을 생성하려고 하면 성공합니다. 'toragePrefix' 또는 'TenantName'이 서로 다를 경우 같은 백엔드에서 생성된 볼륨의 이름 충돌이 있을 수 있습니다.</block>
  <block id="9bf4c601179068ff3574d2cf87536564" category="list-text">Astra Trident('tridentctl' 또는 Trident Operator 사용)를 설치하고 tridentctl을 사용하여 Astra Trident를 관리하는 경우 'KUBEBEECONFIG' 환경 변수를 설정해야 합니다. 이는 Kubernetes 클러스터가 트리덴트틀과 연동되어야 한다는 것을 나타내기 위해 필요합니다. 여러 Kubernetes 환경에서 작업할 경우 'KUBECONFIG' 파일을 정확하게 소싱해야 합니다.</block>
  <block id="6d791d3b45515fd8619e489b938f39e8" category="inline-link">마운트 옵션</block>
  <block id="d4b9b9554fd820f43eae492d33e41167" category="inline-link">'원어클래스'</block>
  <block id="a5c785ee36f0f2d14349653f744c8e3b" category="list-text">iSCSI PVS에 대해 온라인 공간 재확보를 수행하려면 작업자 노드의 기본 OS에 볼륨에 마운트 옵션을 전달해야 할 수 있습니다. 이는 디카드(disscard)가 필요한 RHEL/RedHat CoreOS 인스턴스에 적용됩니다<block ref="2ee633fb26bfccf07d490458d29f92a2" category="inline-link-rx"></block>에 mountmounted 폐기 옵션이 포함되어 있는지 확인합니다<block ref="b44436f062a8f5a535d8cafcffeb70b2" category="inline-link-rx"></block> 온라인 블록 삭제를 지원합니다.</block>
  <block id="c2ebda3702872aaa7ad44122f2343d7e" category="list-text">Kubernetes 클러스터당 Astra Trident 인스턴스가 두 개 이상 있는 경우, Astra Trident가 다른 인스턴스와 통신할 수 없고 자신이 생성한 다른 볼륨을 검색할 수 없기 때문에 클러스터 내에서 둘 이상의 인스턴스가 실행될 경우 예기치 않거나 잘못된 동작이 발생합니다. Kubernetes 클러스터당 하나의 Astra Trident 인스턴스만 있어야 합니다.</block>
  <block id="294f8c33b7ccdbcbf422998b64c9c931" category="list-text">Astra Trident가 오프라인인 상태에서 Astra Trident 기반의 'torageClass' 객체를 Kubernetes에서 삭제하면, Astra Trident는 온라인 상태가 되었을 때 데이터베이스에서 해당 스토리지 클래스를 제거하지 않습니다. tridentctl이나 REST API를 사용하여 이러한 스토리지 클래스를 삭제해야 합니다.</block>
  <block id="ddab3f1d971a7608afb4c30c688a32ac" category="list-text">사용자가 해당 PVC를 삭제하기 전에 Astra Trident가 프로비저닝한 PV를 삭제하는 경우 Astra Trident는 백업 볼륨을 자동으로 삭제하지 않습니다. 'tridentctl' 또는 REST API를 통해 볼륨을 제거해야 합니다.</block>
  <block id="0821431aba133adbfa7fa0ca1781eedd" category="list-text">FlexGroup은 애그리게이트 세트가 각 프로비저닝 요청에서 고유하지 않으면 한 번에 둘 이상의 ONTAP를 동시에 프로비저닝할 수 없습니다.</block>
  <block id="38699c45ccc629a8b46bd780d7aef2f6" category="list-text">IPv6를 통해 Astra Trident를 사용할 때는 대괄호 안의 백엔드 정의에 "managementLIF"와 "dataLIF"를 지정해야 합니다. 예: ``FD20:8b1e:b258:2000:f816:3eff:feec:0]'.</block>
  <block id="d83c67344719a209c50396895dd2fbe1" category="list-text">OpenShift 4.5와 함께 'olidfire-san' 드라이버를 사용하는 경우 기본 작업자 노드에서 md5를 CHAP 인증 알고리즘으로 사용해야 합니다.</block>
  <block id="e9a7080bd6d1b50ff15cef6f14fa1d64" category="inline-link">Astra Trident GitHub를 참조하십시오</block>
  <block id="b94e036fb032554ca486dd8fc2e3fafe" category="list-text"><block ref="b94e036fb032554ca486dd8fc2e3fafe" category="inline-link-rx"></block></block>
  <block id="3334dfda9735f9b3ed55a34ef316b599" category="inline-link">Astra Trident 블로그</block>
  <block id="d090b5d97388b77aa02e5d1203c037a0" category="list-text"><block ref="d090b5d97388b77aa02e5d1203c037a0" category="inline-link-rx"></block></block>
  <block id="7d4fab76513c90b603a722620cde60fe" category="doc">명령줄 옵션</block>
  <block id="8db7df66ab1d7ab5f1dc947acdb5fae4" category="section-title">로깅</block>
  <block id="7e2a14542a2613424ad88206fd2dd9aa" category="list-text">'-debug': 디버깅 출력을 활성화합니다.</block>
  <block id="55e727716c7f623987be58e50732c01e" category="list-text">'-LogLevel &lt;level&gt;': 로깅 수준(debug, info, warn, error, fatal)을 설정한다. 기본적으로 info(정보) 가 사용됩니다.</block>
  <block id="30136395f01879792198317c11831ea4" category="section-title">쿠버네티스</block>
  <block id="5700f5ae190580b01f6ed6c031668336" category="list-text">'-k8s_pod': 이 옵션 또는 '-k8s_api_server'를 사용하여 Kubernetes를 지원합니다. 이 설정을 사용하면 Trident에서 포함된 POD의 Kubernetes 서비스 계정 자격 증명을 사용하여 API 서버에 연락합니다. Trident가 서비스 계정이 활성화된 Kubernetes 클러스터에서 POD로 실행되는 경우에만 작동합니다.</block>
  <block id="24095e7ef85031e99914e2c5298a7ded" category="list-text">"-k8s_api_server &lt;insecure-address:insecure-port&gt;": Kubernetes 지원을 활성화하려면 이 옵션 또는 "-k8s_pod"를 사용하십시오. Trident가 지정된 경우 제공된 비보안 주소 및 포트를 사용하여 Kubernetes API 서버에 연결합니다. 따라서 Trident를 POD 외부에 배포할 수 있지만 API 서버에 대한 비보안 연결만 지원합니다. 안전하게 연결하려면 '-k8s_POD' 옵션을 사용하여 포드에 Trident를 배포합니다.</block>
  <block id="9d77217a2dfe50f2575ced46f5e661d8" category="list-text">"-k8s_config_path &lt;file&gt;": 필수. KubeConfig 파일에 대한 경로를 지정해야 합니다.</block>
  <block id="c5fd214cdd0d2b3b4272e73b022ba5c2" category="section-title">Docker 를 참조하십시오</block>
  <block id="1e071a3d810132af1c9f8f6a03ca5609" category="list-text">'-volume_driver&lt;name&gt;': Docker 플러그인을 등록할 때 사용되는 드라이버 이름입니다. 기본값은 'NetApp'입니다.</block>
  <block id="dfbbfd6bbf6bc798d1cbe8895d1cff22" category="list-text">'-driver_port&lt;port-number&gt;': UNIX 도메인 소켓이 아닌 이 포트에서 수신 대기하십시오.</block>
  <block id="3874d7b8c9196001f8bfe4c49f43b323" category="list-text">'-config &lt;file&gt;': 필수. 백엔드 구성 파일에 대한 이 경로를 지정해야 합니다.</block>
  <block id="50780f47f6839d47d60bc4555ee00c3f" category="section-title">휴식</block>
  <block id="bfffd3cb0560af555e57dd6bad52a9be" category="list-text">"-address &lt;ip-or-host&gt;": Trident의 REST 서버가 수신할 주소를 지정합니다. 기본값은 localhost입니다. localhost에서 듣거나 Kubernetes Pod에서 실행 중인 경우, REST 인터페이스는 Pod 외부에서 직접 액세스할 수 없습니다. POD IP 주소를 통해 REST 인터페이스에 액세스할 수 있도록 하려면 "-address""를 사용합니다.</block>
  <block id="433f174b6e54b889696b2efd4ef40dc6" category="admonition">Trident REST 인터페이스는 127.0.0.1(IPv4의 경우) 또는 [::1](IPv6의 경우)에서만 수신 및 서비스하도록 구성할 수 있습니다.</block>
  <block id="049ad2e7bef322af60013bbdd35ebbe7" category="list-text">'-port&lt;port-number&gt;': Trident의 REST 서버가 수신할 포트를 지정합니다. 기본값은 8000입니다.</block>
  <block id="188cb756fe8659cb2caf27ca6d1446b4" category="list-text">REST는 REST 인터페이스를 활성화한다. 기본값은 true 입니다.</block>
  <block id="8447c4879970f03c99a2bec36a05c141" category="summary">Astra Trident의 REST API와 상호 작용하려는 경우 REST 엔드포인트를 직접 사용할 수 있습니다.</block>
  <block id="a0ebcf8495639418ba9d4b85dbb67b8b" category="doc">Astra Trident REST API</block>
  <block id="319c1a7b5479ffa2a028b658ad5b7033" category="inline-link-macro">tridentctl 명령 및 옵션</block>
  <block id="d7c9226cc31c5b12ee3114bc7014c075" category="paragraph">이 기능은 Kubernetes가 아닌 구축 환경에서 Astra Trident를 독립 실행형 바이너리로 사용하는 고급 설치에 유용합니다.</block>
  <block id="ff307287df4629ad827fba73568b9a58" category="paragraph">보안을 강화하기 위해 POD 내부에서 실행할 때 Astra Trident의 'ReST API'는 기본적으로 localhost로 제한됩니다. 이 동작을 변경하려면 POD 구성에서 Astra Trident의 '-address' 인수를 설정해야 합니다.</block>
  <block id="8b3c7aa88e751573c842f17535525f19" category="paragraph">API는 다음과 같이 작동합니다.</block>
  <block id="7528035a93ee69cedb1dbddb2f0bfcc8" category="section-title">가져오기</block>
  <block id="2fab7aa97b6a2cfae6563e72aac5161e" category="list-text">'&lt;triment-address&gt;/triment/v1/&lt;object-type&gt;': 해당 형식의 모든 개체를 나열합니다.</block>
  <block id="c34156b367bae1b376f09b89d3be7992" category="list-text">'&lt;trident-address&gt;/trident/v1/&lt;object-type&gt;/&lt;object-name&gt;': 명명된 개체의 세부 정보를 가져옵니다.</block>
  <block id="a02439ec229d8be0e74b0c1602392310" category="section-title">게시</block>
  <block id="6692e2cd6834e6b9b2151799cac2a9f8" category="paragraph">'&lt;triment-address&gt;/triment/v1/&lt;object-type&gt;': 지정된 형식의 개체를 만듭니다.</block>
  <block id="ce87eb03803d5633c163541464e9e7f2" category="inline-link-macro">트리덴ctl의 명령과 옵션</block>
  <block id="3d2bacacf0178e742d5abb2abc32d431" category="list-text">생성할 개체의 JSON 구성이 필요합니다. 각 개체 유형의 사양은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="5b2f45c3d098b61927afda859c9144f8" category="list-text">개체가 이미 있는 경우 동작이 달라집니다. backends는 기존 개체를 업데이트하지만 다른 모든 개체 형식은 작업에 실패합니다.</block>
  <block id="32f68a60cef40faedbc6af20298c1a1e" category="section-title">삭제</block>
  <block id="ecfc51243c8c28fc234ff87f1f9ddb88" category="paragraph">삭제 &lt;triment-address&gt;/triment/v1/&lt;object-type&gt;/&lt;object-name&gt;': 명명된 리소스를 삭제합니다.</block>
  <block id="80e4e3d3203325fb6aeb139614fd09f3" category="admonition">백엔드 또는 스토리지 클래스와 연결된 볼륨은 계속 존재하므로 별도로 삭제해야 합니다. 자세한 내용은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="ce94b1f7df7a6a05a559b66f96eff1cc" category="paragraph">이러한 API의 호출 방법에 대한 예제를 보려면 debug("-d") 플래그를 전달하십시오. 자세한 내용은 을 참조하십시오 <block ref="e87a326653960de9774fcc58ee9fa490" category="inline-link-macro-rx"></block>.</block>
  <block id="04333ff788951193122a833ecd614950" category="summary">Kubernetes 및 Trident, Trident 및 스토리지와 Kubernetes 및 스토리지 간의 관계를 결정하는 몇 가지 리소스 개체가 있습니다. 이러한 오브젝트 중 일부는 Kubernetes를 통해 관리되며 나머지는 Trident를 통해 관리됩니다.</block>
  <block id="da1e63dd673a1932cebb48b6a81bbbb1" category="doc">Kubernetes 및 Trident 오브젝트</block>
  <block id="d107eefb0ce66911b186b03b9e9c337e" category="paragraph">REST API를 사용하여 리소스 객체를 읽고 쓰면서 Kubernetes 및 Trident와 상호 작용할 수 있습니다. Kubernetes 및 Trident, Trident 및 스토리지와 Kubernetes 및 스토리지 간의 관계를 결정하는 몇 가지 리소스 개체가 있습니다. 이러한 오브젝트 중 일부는 Kubernetes를 통해 관리되며 나머지는 Trident를 통해 관리됩니다.</block>
  <block id="62499e0de79c4d07c7915a36f9faa0d8" category="section-title">개체가 서로 어떻게 상호 작용합니까?</block>
  <block id="b9ea565816618011ca591fc191fe5e63" category="paragraph">오브젝트, 목표 및 상호 작용 방식을 이해하는 가장 쉬운 방법은 Kubernetes 사용자의 스토리지에 대한 단일 요청을 따르는 것입니다.</block>
  <block id="ec7d6500a82a56ee8f5fff02eafa7af7" category="list-text">사용자가 이전에 관리자가 구성한 Kubernetes의 torageClass에서 특정 크기의 새 PersistentVolume을 요청하는 PersistentVolumeClaim을 만듭니다.</block>
  <block id="6b25cc026b6f29464d3fce0f6ec67805" category="list-text">Kubernetes의 torageClass는 Trident를 프로비저닝자로 식별하고 Trident에 요청된 클래스에 대한 볼륨 프로비저닝 방법을 알려주는 매개 변수를 포함합니다.</block>
  <block id="5b078d6b19593ee6c55f428e2c85faa7" category="list-text">Trident는 클래스에 대한 볼륨을 프로비저닝하는 데 사용할 수 있는 일치하는 'backends'와 'toragePools'를 식별하는 이름과 동일한 이름의 자체 'torageClass'를 찾습니다.</block>
  <block id="ff099186f912c7abb21bcf68690c98d7" category="list-text">Trident는 일치하는 백엔드에 스토리지를 프로비저닝하고 Kubernetes의 "PersistentVolume"과 "PersistentVolume"과 실제 스토리지 간의 관계를 유지하는 Trident의 볼륨을 찾고, 마운트하고, 처리하는 방법을 Kubernetes의 "PersistentVolume"과 두 개의 객체를 만듭니다.</block>
  <block id="6d2ae40bc02e88464563ae42ae22d54c" category="list-text">Kubernetes는 PersistentVolumeClaim을 새로운 PersistentVolume에 바인딩합니다. PersistentVolumeClaim이 실행되는 모든 호스트에서 PersistentVolume이 마운트되는 "PersistentVolumeClaim"이 포함된 POD</block>
  <block id="490c1b0e3a604c81abb3db1b778ec07b" category="list-text">사용자가 Trident를 가리키는 VolumeSnapshotClass를 사용하여 기존 PVC의 VolumeSnapshot을 생성합니다.</block>
  <block id="9f4e11d34d158ebd365226367c8b15d9" category="list-text">Trident는 PVC와 연결된 볼륨을 식별하고 백엔드에 볼륨의 스냅샷을 생성합니다. 또한 스냅샷을 식별하는 방법을 Kubernetes에 지시하는 'VolumeSnapshotContent'도 생성합니다.</block>
  <block id="c6a606bdd6882cd42de13f2ba3614285" category="list-text">사용자는 'VolumeSnapshot'을 소스로 사용하여 'PersistentVolumeClaim'을 생성할 수 있습니다.</block>
  <block id="8ecb92f33c033b00fcf3c18e59c4b177" category="list-text">Trident는 필요한 스냅샷을 식별하고 "PersistentVolume"과 "Volume"을 생성하는 것과 동일한 단계를 수행합니다.</block>
  <block id="428895404a5e57e01a138a5df672d0fc" category="inline-link">영구 볼륨</block>
  <block id="173423532ed9a565a05f32db2c8f8172" category="admonition">Kubernetes 객체에 대한 자세한 내용은 를 읽는 것이 좋습니다<block ref="92dc8ed82beb7484ab6097a3e91b0deb" category="inline-link-rx"></block> 섹션을 참조하십시오.</block>
  <block id="e21ffd3da11b6c6deee412bfb8695e30" category="section-title">Kubernetes PersistentVolumeClaim 객체</block>
  <block id="794a32773794ee6c545794c065d1a88b" category="paragraph">Kubernetes "PersistentVolumeClaim" 개체는 Kubernetes 클러스터 사용자가 만든 스토리지 요청입니다.</block>
  <block id="43cf8e1465c61efc8b1b9bf71aa9931c" category="paragraph">Trident는 표준 사양 외에도 사용자가 백엔드 구성에서 설정한 기본값을 무효화하려는 경우 다음 볼륨별 주석을 지정할 수 있도록 합니다.</block>
  <block id="55f6611cb342565cf0f5002400f53a95" category="cell">주석</block>
  <block id="1527fede1d561a899313c8cb3eb1e7bf" category="cell">볼륨 옵션</block>
  <block id="db8a0bbeae97b94338c1b7a61e2a1ec3" category="cell">지원되는 드라이버</block>
  <block id="f3780100617165ed98557e3a6d2be72d" category="cell">trident.netapp.io/fileSystem</block>
  <block id="44d4d4eb1f08d8eb29766160086f61dd" category="cell">파일 시스템</block>
  <block id="59c54cb66816513690f886c6cbd45d7e" category="cell">ONTAP-SAN, solidfire-san, eseries-iscsi, ONTAP-san-이코노미</block>
  <block id="979f70bf9da982ee97ac075df4f048c3" category="cell">trident.netapp.io/cloneFromPVC</block>
  <block id="b4ead50a5ca4f307f7d61da7763ad204" category="cell">CloneSourceVolume</block>
  <block id="a056535de687a7e3ba370fa531941d0e" category="cell">ONTAP-NAS, ONTAP-SAN, solidfire-san, AWS-CV, Azure-NetApp-파일, GCP-CV, ONTAP-SAN-이코노미</block>
  <block id="46ec89aa5290ead7b514dd5182caa0a7" category="cell">trident.netapp.io/splitOnClone</block>
  <block id="58c1c86186ef8de4f6e12d8f3aed8b64" category="cell">SplitOnClone 을 참조하십시오</block>
  <block id="80f05e749a4f524e8c8a05fa19d5df0e" category="cell">ONTAP-NAS, ONTAP-SAN</block>
  <block id="d6f010e4b4bf9748dcaa34feb70188ce" category="cell">trident.netapp.io/protocol</block>
  <block id="81788ba0d7d02d81c063dbca621ba11b" category="cell">프로토콜</block>
  <block id="100b8cad7cf2a56f6df78f171f97a1ec" category="cell">모두</block>
  <block id="e9898504ff0569325d48acaee7e9ced9" category="cell">trident.netapp.io/exportPolicy</block>
  <block id="61396290e72fa7d707996351c8815bd6" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup</block>
  <block id="2902d12b1fe6d9ef5bd1a3474f2356e9" category="cell">trident.netapp.io/snapshotPolicy</block>
  <block id="0a236e7685e50a59df980d0a30929d6c" category="cell">스냅샷 정책</block>
  <block id="7f3bf2672240703dc69740ce11443cf2" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN</block>
  <block id="6224177007fc13e9e0d3789985ed165a" category="cell">trident.netapp.io/snapshotReserve</block>
  <block id="bb0d75280f9b683f2f1f0767fd0aff9b" category="cell">snapshotReserve</block>
  <block id="3419db347ff8e06397e8a611be353848" category="cell">ONTAP-NAS, ONTAP-NAS-flexgroup, ONTAP-SAN, AWS-CV, GCP-CV</block>
  <block id="1cb43054bed661d8c8457ddbb43e1b1b" category="cell">trident.netapp.io/snapshotDirectory</block>
  <block id="1ae33c448502ac3d326593aee304c21f" category="cell">스냅샷 디렉토리</block>
  <block id="ec1739ebad429a70f25efc292c347f8e" category="cell">trident.netapp.io/unixPermissions</block>
  <block id="69d900d222446aab8591b45a7363c9e7" category="cell">trident.netapp.io/blockSize</block>
  <block id="480d1b61a0432d1319f7504a3d7318dd" category="cell">블록 크기</block>
  <block id="c0d2a793e71b152662b3e8cd2da00620" category="cell">solidfire-SAN</block>
  <block id="fc5f8320f80474f09bdd1e3c3849123e" category="paragraph">생성된 PV에 'Delete' Reclaim 정책이 있는 경우, Trident는 PV가 해제될 때(즉, 사용자가 PVC를 삭제할 때) PV와 보조 볼륨을 모두 삭제합니다. 삭제 작업이 실패할 경우 Trident는 PV를 해당 상태로 표시하고 성공할 때까지 또는 PV를 수동으로 삭제할 때까지 주기적으로 작업을 다시 시도합니다. PV에서 '+Retain+' 정책을 사용할 경우 Trident는 이를 무시하고 관리자가 Kubernetes 및 백엔드에서 이를 정리하여 제거하기 전에 볼륨을 백업 또는 검사할 수 있다고 가정합니다. PV를 삭제해도 Trident에서 백업 볼륨을 삭제하지 않습니다. REST API('tridentctl')를 사용하여 제거해야 합니다.</block>
  <block id="5dad99bb31feaed11fecbe29cf682e51" category="paragraph">Trident는 CSI 사양을 사용하여 볼륨 스냅샷 생성을 지원합니다. 볼륨 스냅샷을 생성하고 이를 데이터 소스로 사용하여 기존 PVC를 복제할 수 있습니다. 이렇게 하면 PVS의 시점 복제본을 스냅샷 형태로 Kubernetes에 표시할 수 있습니다. 그런 다음 스냅샷을 사용하여 새 PVS를 생성할 수 있습니다. 이 기능이 어떻게 동작하는지 알아보려면 "+주문형 볼륨 스냅샷+"를 살펴보십시오.</block>
  <block id="2553df6c9f03b727070656d38019ad3e" category="paragraph">또한 Trident는 클론 생성을 위한 "cloneFromPVC" 및 "plitOnClone" 주석을 제공합니다. 이러한 주석을 사용하여 Kubernetes 1.13 이하 버전에서 CSI 구현을 사용하지 않고 PVC를 복제하거나 Kubernetes 릴리스가 베타 볼륨 스냅샷(Kubernetes 1.16 이하)을 지원하지 않을 경우 사용할 수 있습니다. Trident 19.10은 PVC를 통한 클론 생성을 위한 CSI 워크플로우를 지원합니다.</block>
  <block id="91adc865e5be78d779fd6aa38481ca58" category="admonition">CSI Trident와 기존 비 CSI 프런트엔드 및 CLoneFromPVC와 'PlitOnClone' 주석을 사용할 수 있습니다.</block>
  <block id="96e0288ecc3c91f97de46420e70a4f8f" category="paragraph">예를 들어 이미 mysql이라는 PVC가 있는 사용자는 trident.netapp.io/cloneFromPVC: mysql 같은 주석을 사용해 mysqlclone이라는 새로운 PVC를 만들 수 있습니다. 이 주석을 설정하면 Trident가 볼륨을 처음부터 프로비저닝하는 대신 MySQL PVC에 해당하는 볼륨을 클론합니다.</block>
  <block id="ff0fa770e22db25a156c5e2d7f017283" category="paragraph">다음 사항을 고려하십시오.</block>
  <block id="5faae6e509c8aecf9f8815a4ceef02b3" category="list-text">유휴 볼륨의 클론을 생성하는 것이 좋습니다.</block>
  <block id="f89d76e06e88814705882a1faad838fb" category="list-text">PVC와 그 클론은 동일한 Kubernetes 네임스페이스에서 동일한 스토리지 클래스를 가져야 합니다.</block>
  <block id="f769a6b54b1d1476b6628ebd1c4b98c4" category="list-text">ONTAP-NAS와 ONTAP-SAN 드라이버를 함께 사용하면 trident.netapp.io/splitOnClone` 과 함께 PVC 주석 trident.netapp.io/cloneFromPVC` 을 설정하는 것이 바람직할 수 있습니다. Trident는 trident.netapp.io/splitOnClone` 를 true로 설정하면 상위 볼륨에서 복제된 볼륨을 분할하여 복제된 볼륨의 수명 주기를 부모 볼륨에서 완전히 분리하여 스토리지 효율성을 잃게 됩니다. trident.netapp.io/splitOnClone` 를 설정하지 않거나 "false"로 설정하지 않으면 상위 볼륨과 클론 볼륨 간의 종속성을 생성하여 클론이 먼저 삭제되지 않으면 상위 볼륨을 삭제할 수 없게 되어 백엔드에서 공간 소비가 줄어듭니다. 클론을 분할하는 것이 올바른 시나리오는 빈 데이터베이스 볼륨을 복제하여 볼륨과 해당 클론이 크게 달라질 것으로 예상되며 ONTAP에서 제공하는 스토리지 효율성의 이점을 얻지 못하는 경우입니다.</block>
  <block id="83a9930ebb180c904bf2e71e27928287" category="paragraph">'ample-input' 디렉토리에는 Trident와 함께 사용할 PVC 정의의 예가 포함되어 있습니다. Trident 볼륨과 관련된 매개 변수 및 설정에 대한 자세한 설명은 Trident Volume 개체를 참조하십시오.</block>
  <block id="a02475a5207a446cd0b3607b0b24c079" category="section-title">Kubernetes PersistentVolume 오브젝트</block>
  <block id="6cb5412cc2fe8210c4d14d6d6b08ab79" category="paragraph">Kubernetes "PersistentVolume" 개체는 Kubernetes 클러스터에서 사용할 수 있는 스토리지 부분을 나타냅니다. 사용 포드와 독립적인 라이프 사이클이 있습니다.</block>
  <block id="292289b7334983e53d9fb9bd00d30820" category="admonition">Trident는 "PersistentVolume" 개체를 만들고 프로비저닝하는 볼륨을 기준으로 Kubernetes 클러스터에 자동으로 등록합니다. 스스로 관리할 수 없습니다.</block>
  <block id="443f09ca4d0d1cc13b5baa064b90c0b7" category="paragraph">Trident 기반의 'torageClass'를 참조하는 PVC를 생성하면 Trident는 해당 스토리지 클래스를 사용하여 새 볼륨을 프로비저닝하고 해당 볼륨에 대한 새 PV를 등록합니다. 프로비저닝 볼륨과 해당 PV를 구성할 때 Trident는 다음 규칙을 따릅니다.</block>
  <block id="b27c91fe87605abbb0d5240430518a1c" category="list-text">Trident는 Kubernetes의 PV 이름과 스토리지 프로비저닝에 사용되는 내부 이름을 생성합니다. 두 경우 모두 이름은 해당 범위에서 고유합니다.</block>
  <block id="9c2f88a5c4297bd88ead0cd6314fe886" category="list-text">볼륨의 크기는 플랫폼에 따라 가장 가까운 할당 가능한 수량으로 반올림될 수 있지만 PVC에서 요청된 크기와 최대한 가깝게 일치합니다.</block>
  <block id="dcbd1c3ef9cd1dce444a22a9db5994d6" category="section-title">Kubernetes StorageClass 객체입니다</block>
  <block id="0d35625a483152791f4e2d0b751a09cc" category="paragraph">Kubernetes의 torageClass 객체는 속성 세트를 사용하여 스토리지를 프로비저닝하기 위해 PersistentVolumeClaims의 이름으로 지정됩니다. 스토리지 클래스 자체는 사용할 구축 소유자를 식별하고 프로비저닝이 이해할 수 있는 조건으로 해당 자산 세트를 정의합니다.</block>
  <block id="f7738d717849274e5992d460fd2c0a75" category="paragraph">관리자가 만들고 관리해야 하는 두 가지 기본 개체 중 하나입니다. 다른 하나는 Trident 백엔드 객체입니다.</block>
  <block id="e51377a773f4713e536b061eaa2d4b04" category="paragraph">Trident를 사용하는 Kubernetes의 torageClass 개체는 다음과 같습니다.</block>
  <block id="39edc8618b50008d4cb2050414d6921f" category="paragraph">이러한 매개 변수는 Trident에만 해당되며 Trident에 클래스에 볼륨을 프로비저닝하는 방법을 알려줍니다.</block>
  <block id="b16da8ed7f6c8cce3011dc2b6c7bd1a4" category="paragraph">스토리지 클래스 매개 변수는 다음과 같습니다.</block>
  <block id="f2bbdf9f72c085adc4d0404e370f0f4c" category="cell">속성</block>
  <block id="b651efdb98a5d6bd2b3935d0c3f4a5e2" category="cell">필수 요소입니다</block>
  <block id="736b91750e516139acc13c5eb6564f92" category="cell">속성</block>
  <block id="59a1e7292a0114529fb1b3401b37bc28" category="cell">[string] 문자열을 매핑합니다</block>
  <block id="7fa3b767c460b54a2be4d49030b349c7" category="cell">아니요</block>
  <block id="1b40216e6fe613bd013bf8710182e650" category="cell">아래의 특성 섹션을 참조하십시오</block>
  <block id="c614017642b6cfd9e6a25c7df122d917" category="cell">스토리지 풀</block>
  <block id="b8f32852327d2ffce86ae3ead4fdfb52" category="cell">Map [string] StringList 입니다</block>
  <block id="bdd0ddb870ed9de6f6e7d3a75200e9f7" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="145d1b89a9f9ed8bdc16d1f7a814cace" category="cell">추가 StoragePools</block>
  <block id="6907a73ad9068ddf5f99d022102220bb" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="7df974d787ead594df017a11672f2f0e" category="cell">excludeStoragePools를 참조하십시오</block>
  <block id="99ba77776c83983f5ecbd2b51f2b43ef" category="cell">내의 스토리지 풀 목록에 백엔드 이름 매핑</block>
  <block id="f74d4b2b456fb453c0980710290f66eb" category="paragraph">스토리지 속성 및 가능한 값은 스토리지 풀 선택 특성 및 Kubernetes 속성으로 분류할 수 있습니다.</block>
  <block id="2fdf10f3f64b631cd3a137740de02f8b" category="section-title">스토리지 풀 선택 특성입니다</block>
  <block id="1f5912cd581dba393d5eecc43059adf4" category="paragraph">이러한 매개 변수는 지정된 유형의 볼륨을 프로비저닝하는 데 사용해야 하는 Trident 관리 스토리지 풀을 결정합니다.</block>
  <block id="c82a6100dace2b41087ba6cf99a5976a" category="cell">값</block>
  <block id="6bb24468956384c482a8b5a901fb6383" category="cell">제공합니다</block>
  <block id="15c2d85f1fae22a3c3a0594510a1f611" category="cell">요청하십시오</block>
  <block id="7aa57840938d59b415c1e10dcd1f7173" category="cell">에 의해 지원됩니다</block>
  <block id="0e72be2e13bf8a2ff8078d3435e5aa7c" category="cell">미디어 ^1^</block>
  <block id="b45cffe084dd3d20d928bee85e7b0f21" category="cell">문자열</block>
  <block id="9ccd7f94313a98beb95801927907a0ab" category="cell">HDD, 하이브리드, SSD</block>
  <block id="9bf3032f6854fb376cd8e3e92e11b077" category="cell">풀에는 이 유형의 미디어가 포함되어 있으며, 하이브리드는 둘 모두를 의미합니다</block>
  <block id="5c79c761bae4c27e96c04e54d1da1e91" category="cell">지정된 미디어 유형입니다</block>
  <block id="c9cb5e737e2746339fd0b462332c8740" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, solidfire-SAN</block>
  <block id="b713baf75bcf13859037b5274d27d4b8" category="cell">프로비저닝 유형</block>
  <block id="6026fbd9abd05590949de220154e3262" category="cell">얇고 두껍습니다</block>
  <block id="3064025fe3541bec9942e14fcaedfab7" category="cell">풀은 이 프로비저닝 방법을 지원합니다</block>
  <block id="cf65591e3da90317fc132ea7464105d8" category="cell">프로비저닝 방법이 지정되었습니다</block>
  <block id="ef2577df8468ab39e993a1938ba7f38d" category="cell">일반: 모든 ONTAP 및 eseries - iSCSI; 씬: All ONTAP &amp; solidfire - SAN</block>
  <block id="55b56fb238360663afa6230ad82e74a0" category="cell">백엔드 유형</block>
  <block id="9d7b1f44c2f9de09e74ed8f6104c3f16" category="paragraph">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, solidfire-SAN, eSeries-iSCSI, AWS-CV, GCP-CV, Azure-NetApp-파일, ONTAP-SAN-이코노미</block>
  <block id="0e1201d4d96df2d9d03c9c66b90874a1" category="cell">풀이 이 백엔드 유형에 속합니다</block>
  <block id="c4efe19137f43450149d48fddbab6c28" category="cell">백엔드가 지정되었습니다</block>
  <block id="a04622349b3ede0d4176ca2c2e161763" category="cell">모든 드라이버</block>
  <block id="695633290d050f31cec0c9d4bd4a57fe" category="cell">스냅샷 수</block>
  <block id="c506ff134babdd6e68ab3e6350e95305" category="cell">불입니다</block>
  <block id="ac1ffb15effdc77a86029972670d022f" category="cell">참, 거짓</block>
  <block id="4ac43bef181074fbd4a1f3620b46f77f" category="cell">풀은 스냅샷이 있는 볼륨을 지원합니다</block>
  <block id="13410bff9f7871113a6af273e2a1b97f" category="cell">스냅샷이 활성화된 볼륨</block>
  <block id="b43a2204ed324763abdbca5be0c35b02" category="cell">ONTAP-NAS, ONTAP-SAN, solidfire-SAN, AWS-CV, GCP-CV</block>
  <block id="bc3832c405ec6cb9c831849328240f3b" category="cell">복제</block>
  <block id="609d32aa243917905f282544b543752a" category="cell">풀은 볼륨 클론을 지원합니다</block>
  <block id="bcb81802de31cf9c717de3c1d6c2f610" category="cell">클론이 활성화된 볼륨</block>
  <block id="5bdf74912a51c34815f11e9a3d20b609" category="cell">암호화</block>
  <block id="5f2f2cc138a8bc7067c7f61ab4db0f4d" category="cell">풀은 암호화된 볼륨을 지원합니다</block>
  <block id="0bda31a93b84fd2b45a90df39c4c8049" category="cell">암호화가 활성화된 볼륨입니다</block>
  <block id="dcc09b4a72e31323b652676ce4677771" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroups, ONTAP-SAN</block>
  <block id="79073619fba8242703524f16870ff858" category="cell">IOPS</block>
  <block id="fa7153f7ed1cb6c0fcf2ffb2fac21748" category="cell">내부</block>
  <block id="86e5d65893929e5d38b4bdcb9fb48ecd" category="cell">양의 정수입니다</block>
  <block id="bf57d1db8292b2855fa998a86562cfa7" category="cell">풀은 이 범위에서 IOPS를 보장할 수 있습니다</block>
  <block id="342a7ce5bb7debc6ba84dc2a3bced587" category="cell">볼륨은 이러한 IOPS를 보장합니다</block>
  <block id="895f3d78c77292d9761bdabdc3cf0c99" category="paragraph">^1^: ONTAP Select 시스템에서 지원되지 않습니다</block>
  <block id="5b3c68bde0b3658758a8ebf47ec6abf1" category="paragraph">대부분의 경우 요청된 값이 프로비저닝에 직접적인 영향을 미치며, 예를 들어 일반 프로비저닝을 요청하면 볼륨이 걸쭉하게 프로비저닝됩니다. 하지만 Element 스토리지 풀은 제공된 IOPS 최소 및 최대값을 사용하여 요청된 값이 아닌 QoS 값을 설정합니다. 이 경우 요청된 값은 스토리지 풀을 선택하는 데만 사용됩니다.</block>
  <block id="311fa7e17587a62a6fdcb110253feed7" category="paragraph">이상적으로는 '속성'을 단독으로 사용하여 특정 클래스의 요구 사항을 충족하는 데 필요한 스토리지의 품질을 모델링할 수 있습니다. Trident는 사용자가 지정한 '속성'의 _ALL_과 일치하는 스토리지 풀을 자동으로 검색하여 선택합니다.</block>
  <block id="d0c865b74e0c4b4b387506e9e95d22b2" category="paragraph">클래스에 맞는 풀을 자동으로 선택하기 위해 속성(attributes)을 사용할 수 없는 경우, 'toragePools' 및 'additionalStoragePools' 매개 변수를 사용하여 풀을 더 세분화하거나 특정 풀 세트를 선택할 수도 있습니다.</block>
  <block id="06a87a25fa98442cf561762851213f7e" category="paragraph">'toragePools' 매개 변수를 사용하면 지정된 'attributes'와 일치하는 풀 세트를 추가로 제한할 수 있습니다. 즉, Trident는 프로비저닝에서 'attributes'와 'toragePools' 매개 변수로 식별되는 풀의 교집합을 사용합니다. 매개 변수만 사용하거나 둘 다 함께 사용할 수 있습니다.</block>
  <block id="0c66a737e57eb6ac0885d2ba6d87cc12" category="paragraph">"additionalStoragePools" 매개 변수를 사용하면 "attributes" 및 "toragePools" 매개 변수로 선택한 풀에 관계없이 Trident에서 프로비저닝에 사용하는 풀 집합을 확장할 수 있습니다.</block>
  <block id="2ed95c63c6e58641d710e098e7e23154" category="paragraph">'excludeStoragePools' 매개 변수를 사용하여 Trident에서 프로비저닝을 위해 사용하는 풀 집합을 필터링할 수 있습니다. 이 매개 변수를 사용하면 일치하는 풀이 모두 제거됩니다.</block>
  <block id="9f8bfd75f7eb5b95503bb0abedf83b40" category="paragraph">'toragePools' 및 'additionalStoragePools' 매개 변수에서 각 항목은 '&lt;backend&gt;:&lt;storagePoolList&gt;' 형식을 사용합니다. 여기서 '&lt;storagePoolList&gt;'는 지정된 백엔드에 대한 쉼표로 구분된 스토리지 풀 목록입니다. 예를 들어, additionalStoragePools 값은 ontapnas_192.168.1.100:aggr1,aggr2;solidfire_192.168.1.101:bronze처럼 보일 수 있습니다. 이러한 목록에는 백엔드 및 목록 값 모두에 대한 regex 값이 적용됩니다. tridentctl 백엔드 가져오기 를 사용하여 백엔드와 해당 풀의 목록을 가져올 수 있습니다.</block>
  <block id="c087dddd46fcf0fbbf390abeff2216c3" category="section-title">Kubernetes 특성</block>
  <block id="d05956159ee82aafaaacfe08d33d3be6" category="paragraph">이러한 특성은 동적 프로비저닝 중 Trident가 스토리지 풀/백엔드를 선택하는 데 아무런 영향을 주지 않습니다. 대신 이러한 특성은 Kubernetes 영구 볼륨에서 지원하는 매개 변수만 제공합니다. 작업자 노드는 파일 시스템 생성 작업을 담당하며 xfsprogs와 같은 파일 시스템 유틸리티가 필요할 수 있습니다.</block>
  <block id="0e6ac0d7fca9c59e6545312a071555b6" category="cell">관련 드라이버</block>
  <block id="ae6b2a160dd2fafdee385c348edee0c1" category="cell">Kubernetes 버전</block>
  <block id="7cfbb6f07899c8071ff38e69dca190e2" category="cell">fsType입니다</block>
  <block id="64b6d80cc167d5c657b60054dbe396ee" category="cell">ext4, ext3, xfs 등</block>
  <block id="7928a56d4874d982a06a59e3f30f6935" category="cell">블록 볼륨의 파일 시스템 유형입니다</block>
  <block id="b1c94ca2fbc3e78fc30069c8d0f01680" category="cell">모두</block>
  <block id="2435c5eb0d842c13f635d4b1d6667a52" category="paragraph">Trident 설치 프로그램 번들에는 'Sample-input/storage-class- *.YAML'의 Trident와 함께 사용할 수 있는 여러 가지 스토리지 클래스 정의가 포함되어 있습니다. Kubernetes 스토리지 클래스를 삭제하면 해당 Trident 스토리지 클래지도 삭제됩니다.</block>
  <block id="6b218cef3794c1b32702bd37753ce9ef" category="section-title">Kubernetes VolumeSnapshotClass 객체</block>
  <block id="65d18b5db5d5f35e4ddc5c696687d1bd" category="paragraph">쿠버네티스 VolumeSnapshotClass 객체는 'torageClaes'와 유사합니다. 이 기능을 사용하면 여러 스토리지 클래스를 정의할 수 있으며, 스냅샷을 필요한 스냅샷 클래스와 연결하기 위해 볼륨 스냅숏에서 참조할 수 있습니다. 각 볼륨 스냅샷은 단일 볼륨 스냅샷 클래스와 연결됩니다.</block>
  <block id="031e09713b698739db52cb150ef97605" category="paragraph">스냅샷을 생성하려면 관리자가 VolumeSnapshotClass를 정의해야 합니다. 볼륨 스냅샷 클래스는 다음과 같은 정의로 생성됩니다.</block>
  <block id="879cd061c6bf448cd6fc39dd56947611" category="paragraph">driver는 CSI-snapclass 클래스의 볼륨 스냅샷을 요청하는 Kubernetes를 Trident에서 처리하도록 지정합니다. "eletionPolicy"는 스냅샷을 삭제할 때 수행할 작업을 지정합니다. "eletionPolicy"를 "Delete"로 설정하면 스냅샷이 삭제될 때 스토리지 클러스터의 기본 스냅샷과 볼륨 스냅샷 객체가 제거됩니다. 또는 '유지'로 설정하면 VolumeSnapshotContent와 물리적 스냅샷이 보존됩니다.</block>
  <block id="4fa3f62cc9d9b7064a0d4b93d16a3636" category="section-title">Kubernetes VolumeSnapshot 오브젝트</block>
  <block id="7ba558df52a052235cf288011e5d667c" category="paragraph">Kubernetes 'VolumeSnapshot' 개체는 볼륨의 스냅샷을 생성하는 요청입니다. PVC는 사용자가 볼륨에 대해 요청하는 것처럼 볼륨 스냅샷은 사용자가 기존 PVC의 스냅샷을 생성하도록 요청하는 것입니다.</block>
  <block id="f67af493d1fd83b472d5f27307b2f3d9" category="paragraph">볼륨 스냅샷 요청이 들어오면 Trident는 백엔드의 볼륨에 대한 스냅샷 생성을 자동으로 관리하고 고유한 'VolumeSnapshotContent' 객체를 생성하여 스냅샷을 표시합니다. 기존 PVC에서 스냅샷을 생성하고 새 PVC를 생성할 때 스냅샷을 DataSource로 사용할 수 있습니다.</block>
  <block id="53847015682974d066a919b1b45a44a5" category="admonition">VolumeSnapshot의 생수는 소스 PVC와는 독립적입니다. 소스 PVC가 삭제된 후에도 스냅샷이 지속됩니다. 연관된 스냅샷이 있는 PVC를 삭제할 때 Trident는 이 PVC에 대한 백업 볼륨을 * Deleting * 상태로 표시하지만 완전히 제거하지는 않습니다. 연결된 모든 스냅샷이 삭제되면 볼륨이 제거됩니다.</block>
  <block id="c1c597a8c6353c0a951a61e538d2f143" category="section-title">Kubernetes VolumeSnapshotContent 객체</block>
  <block id="e562bdcf97dce6973a736651f45eb054" category="paragraph">Kubernetes의 'VolumeSnapshotContent' 객체는 이미 프로비저닝된 볼륨에서 생성된 스냅샷을 나타냅니다. 이 스냅샷은 "PersistentVolume"과 유사하며 스토리지 클러스터에서 프로비저닝된 스냅샷을 나타냅니다. 스냅샷이 생성될 때 PersistentVolumeClaim 및 PersistentVolume 개체와 마찬가지로 VolumeSnapshotContent 개체는 스냅샷 생성을 요청한 VolumeSnapshot 객체에 대한 일대일 매핑을 유지합니다.</block>
  <block id="ca8035550d447392debfcaeb62855bd3" category="admonition">Trident는 'VolumeSnapshotContent' 객체를 생성한 후 프로비저닝하는 볼륨을 기준으로 Kubernetes 클러스터에 자동으로 등록합니다. 스스로 관리할 수 없습니다.</block>
  <block id="af741aec1c66e51c00d35a38f92471de" category="paragraph">VolumeSnapshotContent 객체에는 스냅샷 스냅샷(스냅샷 핸들 등)을 고유하게 식별하는 세부 정보가 포함되어 있습니다. 이 나프산Handle은 PV의 이름과 VolumeSnapshotContent 객체의 이름을 조합한 독특한 것이다.</block>
  <block id="b22c73e808eef321ee9941ec2e58b64f" category="paragraph">스냅샷 요청이 들어오면 Trident가 백엔드에 스냅샷을 생성합니다. 스냅샷이 생성된 후 Trident는 'VolumeSnapshotContent' 객체를 구성하여 해당 스냅샷을 Kubernetes API에 노출합니다.</block>
  <block id="ca106d43cc3f2b8c6ae43c99a3c529d7" category="section-title">Kubernetes CustomResourceDefinition 개체입니다</block>
  <block id="7c43d52062b795d2d8e7f33b9dbbf671" category="paragraph">Kubernetes 사용자 지정 리소스는 관리자가 정의하며 비슷한 객체를 그룹화하는 데 사용되는 Kubernetes API의 엔드포인트입니다. Kubernetes에서는 오브젝트 컬렉션을 저장하기 위한 사용자 지정 리소스의 생성을 지원합니다. kubeck Get CRD를 실행하여 이러한 리소스 정의를 얻을 수 있습니다.</block>
  <block id="09d4c17e4e0e002375326eee41d0f77f" category="paragraph">사용자 정의 리소스 정의(CRD) 및 관련 오브젝트 메타데이터는 Kubernetes에서 메타데이터 저장소에 저장됩니다. 따라서 Trident를 위한 별도의 저장소가 필요하지 않습니다.</block>
  <block id="798d49964270b9d2f638171af7258d00" category="paragraph">19.07 릴리스부터 Trident는 다양한 "CustomResourceDefinition" 개체를 사용하여 Trident 백 엔드, Trident 스토리지 클래스 및 Trident 볼륨과 같은 Trident 개체의 ID를 보존합니다. 이러한 오브젝트는 Trident에서 관리합니다. 또한 CSI 볼륨 스냅샷 프레임워크는 볼륨 스냅샷을 정의하는 데 필요한 일부 CRD를 소개합니다.</block>
  <block id="9f59afd5e4687b9960361128f049dae4" category="paragraph">CRD는 Kubernetes를 구성하는 것입니다. 위에 정의된 리소스의 객체는 Trident에 의해 생성됩니다. 간단히 예로, 'tridentctl'을 사용하여 백엔드를 생성할 때 해당하는 'tridentbackends' CRD 객체는 Kubernetes에서 사용할 수 있도록 생성됩니다.</block>
  <block id="7cdfd680fe492e028cde251c38475469" category="paragraph">다음은 Trident의 CRD에 대해 고려해야 할 몇 가지 사항입니다.</block>
  <block id="adecfe476427253e9c680a7c5150a9cc" category="list-text">Trident가 설치되면 일련의 CRD가 생성되어 다른 리소스 유형과 마찬가지로 사용할 수 있습니다.</block>
  <block id="b54c0b51e5e24cea2035a3e3624c5719" category="list-text">Trident의 이전 버전('etcd'를 사용하여 상태를 유지 관리)에서 업그레이드할 경우 Trident 설치 프로그램이 'etcd' 키 값 데이터 저장소에서 데이터를 마이그레이션하고 해당 CRD 개체를 만듭니다.</block>
  <block id="c4b35352cbf7a52a9444a610687067f8" category="inline-link-macro">Trident를 제거합니다</block>
  <block id="14beb70da78e5a36efe980226d286a53" category="list-text">tridentctl uninstall 명령을 사용하여 Trident를 제거할 때 Trident Pod는 삭제되지만 생성된 CRD는 정리되지 않습니다. 을 참조하십시오 <block ref="91f30c1df5df3b507b6d93916b3fade3" category="inline-link-macro-rx"></block> Trident를 완전히 제거하고 처음부터 다시 구성할 수 있는 방법을 이해합니다.</block>
  <block id="514e780152cf1b5087027f7c70643070" category="section-title">Trident StorageClass 개체입니다</block>
  <block id="193c267230acf55be171a6a179560847" category="paragraph">Trident는 Kubernetes의 torageClass 오브젝트에 대해 공급자 필드에 csi.trident.netapp.io`/`netapp.io/trident` 를 지정하는 일치하는 스토리지 클래스를 만듭니다. 스토리지 클래스 이름은 이 이름이 나타내는 Kubernetes의 torageClass 개체와 일치합니다.</block>
  <block id="64cf33bfeab6c6bd8aa626b86fda9cbd" category="admonition">Kubernetes를 사용하면 Trident를 프로비저닝한 Kubernetes의 torageClass가 등록되면 이러한 객체가 자동으로 생성됩니다.</block>
  <block id="51fa0a833f47d8f00ee2677c6fa7b075" category="paragraph">스토리지 클래스는 볼륨에 대한 일련의 요구 사항으로 구성됩니다. Trident는 이러한 요구 사항을 각 스토리지 풀에 있는 속성과 일치시킵니다. 일치하는 경우 해당 스토리지 풀이 해당 스토리지 클래스를 사용하여 볼륨을 프로비저닝할 수 있는 유효한 타겟입니다.</block>
  <block id="04d84bba5a5e103ae9c192c03a7ad2f3" category="paragraph">REST API를 사용하여 스토리지 클래스를 직접 정의하는 스토리지 클래스 구성을 생성할 수 있습니다. 그러나 Kubernetes 구축의 경우 새로운 Kubernetes의 torageClass 오브젝트를 등록할 때 이러한 객체가 생성되기를 기대합니다.</block>
  <block id="21283df20640a21f468122a427ef1bfc" category="section-title">Trident 백엔드 객체</block>
  <block id="3c244b984a2188556c1115a5a27dbe1b" category="paragraph">백엔드는 Trident가 볼륨을 프로비저닝하는 스토리지 공급자를 나타냅니다. 단일 Trident 인스턴스가 원하는 수의 백엔드를 관리할 수 있습니다.</block>
  <block id="d71c5fad4769c19422c07158e24510ba" category="admonition">이것은 직접 만들고 관리하는 두 가지 개체 유형 중 하나입니다. 다른 하나는 Kubernetes의 torageClass 오브젝트입니다.</block>
  <block id="6e8c08b737e50e4dc89c4bd33b8ea726" category="paragraph">이러한 객체를 구성하는 방법에 대한 자세한 내용은 백엔드 구성 을 참조하십시오.</block>
  <block id="af5e532a14b6a8c1f094b8532420e8d1" category="section-title">Trident StoragePool 객체</block>
  <block id="54fd1dc39c3eecd913b4c9140522996c" category="paragraph">스토리지 풀은 각 백엔드에서 용량 할당에 사용할 수 있는 고유한 위치를 나타냅니다. ONTAP의 경우 SVM에 있는 애그리게이트와 대응합니다. NetApp HCI/SolidFire의 경우 관리자 지정 QoS 밴드에 해당합니다. Cloud Volumes Service의 경우 클라우드 공급자 지역에 해당합니다. 각 스토리지 풀에는 고유한 스토리지 특성 세트가 있으며, 이 특성 집합은 성능 특성과 데이터 보호 특성을 정의합니다.</block>
  <block id="4ab1440e71a70a97c4966bcc0095f02b" category="paragraph">다른 오브젝트와 달리 스토리지 풀 후보 는 항상 자동으로 검색되고 관리됩니다.</block>
  <block id="d2a63f6dfdfef268198f3e6e304ab9ba" category="section-title">Trident 볼륨 개체</block>
  <block id="894765102686902c6acc3024e5bdb9bd" category="paragraph">볼륨은 NFS 공유 및 iSCSI LUN과 같은 백엔드 엔드포인트로 구성된 기본 프로비저닝 단위입니다. Kubernetes에서는 이러한 항목이 "PersistentVolumes"에 직접 해당합니다. 볼륨을 생성할 때 볼륨의 용량을 할당할 수 있는 위치와 크기를 결정하는 스토리지 클래스가 있는지 확인합니다.</block>
  <block id="2e53db54827c8c05b7bfe9cb31f299d9" category="admonition">Kubernetes에서 이러한 오브젝트는 자동으로 관리됩니다. 프로비저닝 Trident를 보려면 해당 Trident를 확인하십시오.</block>
  <block id="22fcc98910d0241e9835f502b7cb2398" category="admonition">연결된 스냅샷이 있는 PV를 삭제하면 해당 Trident 볼륨이 * Deleting * 상태로 업데이트됩니다. Trident 볼륨을 삭제하려면 볼륨의 스냅샷을 제거해야 합니다.</block>
  <block id="05353bc86910df31b2da9c8d3d26aad1" category="paragraph">볼륨 구성은 프로비저닝된 볼륨에 있어야 하는 속성을 정의합니다.</block>
  <block id="2af72f100c356273d46284f6fd1dfc08" category="cell">버전</block>
  <block id="ce9af1e3f0493eb7d5ffdf584ed763ba" category="cell">Trident API 버전("1")</block>
  <block id="b068931cc450442b63f5b3d276ea4297" category="cell">이름</block>
  <block id="a6105c0a611b41b08f1209506350279e" category="cell">예</block>
  <block id="017dbd2b0a2195c3e8052cdff67bad39" category="cell">생성할 볼륨의 이름입니다</block>
  <block id="78ec9b60245b46a4f05158076962ace9" category="cell">storageClass 를 선택합니다</block>
  <block id="fa00f346deccdbebef2b3cc0702d41de" category="cell">볼륨을 프로비저닝할 때 사용할 스토리지 클래스입니다</block>
  <block id="f7bd60b75b29d79b660a2859395c1a24" category="cell">크기</block>
  <block id="264c52ca068dfed30f5826bb054839f4" category="cell">용량 할당할 볼륨의 크기(바이트)입니다</block>
  <block id="4f18882934f0472b4bfa32928bf92f14" category="cell">사용할 프로토콜 유형;"파일" 또는 "블록"</block>
  <block id="252c6d364cc1a0437939a4f01b0717ae" category="cell">내부 이름</block>
  <block id="2857a43e58983276d059c0e6e2fcb0e9" category="cell">스토리지 시스템에 있는 객체의 이름으로, Trident에서 생성</block>
  <block id="ff4630d4b2307b42398211e68c0c3996" category="cell">ONTAP(NAS, SAN) 및 SolidFire - * 및 AWS-CV *: 복제할 볼륨의 이름입니다</block>
  <block id="e94d46d7c89bcb7e6ac2e2df4d21bafb" category="cell">ONTAP(NAS, SAN): 상위 클론에서 클론을 분할합니다</block>
  <block id="819549a86d14e849e1d0042c9156d781" category="cell">ONTAP - *: 사용할 스냅샷 정책</block>
  <block id="e38882545bfedafc7e8ec5973b2e6dd8" category="cell">ONTAP - *: 스냅숏용으로 예약된 볼륨의 비율입니다</block>
  <block id="fc86db1233bfa77d5143dcaae9842cb1" category="cell">ONTAP-NAS *: 사용할 엑스포트 정책</block>
  <block id="48e1d8180a61943f438c259b2b6715f8" category="cell">ONTAP-NAS *: 스냅샷 디렉토리가 표시되는지 여부를 나타냅니다</block>
  <block id="3f7c94eec4bbf43962e1667f5a334469" category="cell">ONTAP-NAS *: 초기 UNIX 권한</block>
  <block id="4b2d5d83aef608a3fb59ec6eda8bea26" category="cell">SolidFire - *: 블록/섹터 크기</block>
  <block id="62fe71ae4f6a04a6937feb48ba5dc4f4" category="cell">파일 시스템 유형입니다</block>
  <block id="44be9d1a43b6ec865a2264e42c53de2d" category="paragraph">Trident는 볼륨을 생성할 때 'internalName'을 생성합니다. 이 단계는 두 단계로 구성됩니다. 먼저, 저장소 접두사(기본 "트리덴트" 또는 백엔드 구성의 접두사)를 볼륨 이름에 추가하여 "&lt;prefix&gt;-&lt;volume-name&gt;" 형식의 이름을 만듭니다. 그런 다음 백엔드에서 허용되지 않는 문자를 대체하여 이름을 삭제하는 작업을 진행합니다. ONTAP 백엔드의 경우 하이픈을 밑줄로 바꿉니다. 따라서 내부 이름은 "&lt;prefix&gt;_&lt;volume-name&gt;"이 됩니다. 요소 백엔드의 경우 밑줄을 하이픈으로 바꿉니다. 모든 오브젝트 이름에 30자 제한이 적용되는 E-Series의 경우, Trident는 각 볼륨의 내부 이름에 대해 랜덤 문자열을 생성합니다. CVS(AWS)의 경우, 고유한 볼륨 생성 토큰에 16~36자 제한이 적용되는 Trident는 각 볼륨의 내부 이름에 대한 랜덤 문자열을 생성합니다.</block>
  <block id="49539689cebb34166a417b3b666818e5" category="paragraph">볼륨 구성을 사용하여 REST API를 사용하여 볼륨을 직접 프로비저닝할 수 있지만 Kubernetes 배포에서는 대부분의 사용자가 표준 Kubernetes "PersistentVolumeClaim" 방법을 사용할 것으로 예상됩니다. Trident는 프로비저닝 프로세스의 일부로 이 볼륨 개체를 자동으로 만듭니다.</block>
  <block id="cbd341b63adaa47fcb248e55d33f6eae" category="section-title">Trident 스냅샷 개체</block>
  <block id="a1b3787bbd275b7ed5812d022dd36932" category="paragraph">스냅샷은 볼륨의 시점 복제본으로, 새 볼륨을 용량 할당하거나 복구 상태를 복구하는 데 사용할 수 있습니다. Kubernetes에서는 이러한 객체가 'VolumeSnapshotContent' 객체와 직접 일치합니다. 각 스냅샷은 스냅샷에 대한 데이터의 소스인 볼륨에 연결됩니다.</block>
  <block id="cdf5c8d3dd31e49b82a5b3e2c4a65280" category="paragraph">각 '스냅샷' 개체에는 아래 나열된 속성이 포함됩니다.</block>
  <block id="27118326006d3829667a400ad23d5d98" category="cell">문자열</block>
  <block id="de73fbae2864dd61c921cf0648a9717a" category="cell">Trident 스냅샷 개체의 이름입니다</block>
  <block id="8e744456fb3d02d69442038d3e771460" category="cell">스토리지 시스템의 Trident 스냅샷 개체의 이름입니다</block>
  <block id="617a43eb0446f84414df73cce2997fa1" category="cell">볼륨 이름</block>
  <block id="b58c8ff1e837af6dafa971bf3d320646" category="cell">스냅샷이 생성된 영구 볼륨의 이름입니다</block>
  <block id="2c2aed4b417a0f9c189d7ad6414ae28c" category="cell">볼륨 국제 이름</block>
  <block id="db1a117103c348ebaec41f9e249554c3" category="cell">스토리지 시스템에서 연결된 Trident 볼륨 개체의 이름입니다</block>
  <block id="73f3d5934fdd36989f24cbae94ab423b" category="paragraph">Kubernetes 'VolumeSnapshot' 객체 요청이 생성되면 Trident는 백업 스토리지 시스템에 스냅샷 객체를 생성하여 작동합니다. 이 스냅샷 개체의 인터날Name은 볼륨 스냅샷 개체의 UID(예: 스냅샷-e8d8a0ca-9826-11e9-9807-525400f3f660)와 접두사 스냅샷-UID를 결합하여 생성됩니다. 볼륨 이름 과 볼륨 InternalName 은 백업 볼륨의 세부 정보를 가져오는 방식으로 채워집니다.</block>
  <block id="e977c869b42c54e3c7d8fb9c071aab2b" category="summary">Astra Trident가 통신하는 포트에 대해 자세히 알아보십시오.</block>
  <block id="b229055f6bd047c28dfc84c9bee4c252" category="doc">Astra Trident 포트</block>
  <block id="219abf04d1bb79760c15ca6966b68fb3" category="paragraph">Astra Trident는 다음 포트를 통해 통신합니다.</block>
  <block id="60aaf44d4b562252c04db7f98497e9aa" category="cell">포트</block>
  <block id="261addf78c7b2c961032b3dd08ba0b1f" category="cell">목적</block>
  <block id="7e6b20d014d1c659e4eaf20dc2dcd7eb" category="cell">8443</block>
  <block id="69bbf3571db03f0487c04a8254d15c75" category="cell">백채널 HTTPS</block>
  <block id="bc3c4a6331a8a9950945a1aa8c95ab8a" category="cell">8001입니다</block>
  <block id="e5a4c481cc6f5935efb2c9d381f2e342" category="cell">Prometheus 메트릭 엔드포인트</block>
  <block id="67ff32d40fb51f1a2fd2c4f1b1019785" category="cell">8000</block>
  <block id="10f5b805a46ea829cc3b9d8560a224ae" category="cell">Trident REST 서버</block>
  <block id="35cf0f704286108deb76366a16415140" category="cell">17546</block>
  <block id="fb1396f82d0096741ea1b06f8cee2340" category="cell">Trident 디포드에 사용되는 활성/준비 프로브 포트</block>
  <block id="b9c469bd571fac8818d4000055d327df" category="admonition">'--probe-port' 플래그를 사용하여 설치 시간 동안 활성/준비 프로브 포트를 변경할 수 있습니다. 이 포트가 작업자 노드의 다른 프로세스에서 사용되지 않도록 하는 것이 중요합니다.</block>
  <block id="afe272beb780ad53d441c342bf1c8c77" category="summary">Trident에 대한 간단한 액세스를 제공하는 명령줄 유틸리티인 tridentctl 에 대해 자세히 알아보십시오.</block>
  <block id="4e49f66de2e2dc43c25555fe50639334" category="paragraph">를 클릭합니다<block ref="5a856e83aada9750fe5389f8da94335b" category="inline-link-rx"></block> Astra Trident에 대한 간단한 액세스를 제공하는 명령줄 유틸리티인 tridentctl이 포함되어 있습니다. 충분한 권한을 가진 Kubernetes 사용자는 이를 사용하여 Astra Trident를 설치할 뿐 아니라 직접 상호 작용하여 Astra Trident Pod가 포함된 네임스페이스를 관리할 수 있습니다.</block>
  <block id="8ca34267f11cb69ea424bc0320f0e295" category="paragraph">사용법은 tridentctl - -help를 실행한다.</block>
  <block id="2dd878ee55d738aa02e6b0b162d45708" category="paragraph">사용 가능한 명령:</block>
  <block id="4386bd8da14af923cbb7ac011ffc048e" category="list-text">'create': Astra Trident에 리소스를 추가합니다.</block>
  <block id="f40f9a4cf242d0355aaf8d9e06617436" category="list-text">삭제: Astra Trident에서 하나 이상의 리소스를 제거합니다.</block>
  <block id="94b75e236d78fe800d1d32acc3882789" category="list-text">'Get': Astra Trident에서 하나 이상의 리소스를 받아보세요.</block>
  <block id="bc9ef80dceea04796c6218fe96e05b30" category="list-text">도움말 : 명령에 대한 도움말입니다.</block>
  <block id="f5421bf790b945f508fa1b9f223318e5" category="list-text">"이미지": Astra Trident가 필요로 하는 컨테이너 이미지 테이블을 인쇄합니다.</block>
  <block id="40e65170f778aaa7f4ab7f645b3bb3df" category="list-text">가져오기: 기존 자원을 Astra Trident로 가져옵니다.</block>
  <block id="a824e587817131e2052a450803b2d97c" category="list-text">설치: Astra Trident 설치</block>
  <block id="c90c365a06ede3139cad79d4e55673ee" category="list-text">로그: 아스트라 트리덴트(Astra Trident)의 로그를 인쇄합니다.</block>
  <block id="e5c5ad2be68f58e910aa42a9fcc98141" category="list-text">'종료': Astra Trident에서 리소스를 보냅니다.</block>
  <block id="3166458a066b2d14394e408f1f8fed84" category="list-text">"설치 제거": Astra Trident를 제거합니다.</block>
  <block id="8c8fcf9d4df8bd54d26dc748cc4bac55" category="list-text">업데이트: Astra Trident에서 자원을 수정합니다.</block>
  <block id="042aeda3cc45bf1f53a0e74660dbd924" category="list-text">업그레이드: Astra Trident에서 리소스를 업그레이드합니다.</block>
  <block id="d014c15bf0496b645d02caf1704932f7" category="list-text">'러션': 아스트라 트리덴트(Astra Trident)의 버전을 인쇄해 보세요.</block>
  <block id="1c90ba5cf3791b6148c7887a696911ec" category="paragraph">플래그:</block>
  <block id="568cd496b6bde641a886745edfa59ae7" category="list-text">''-d,--debug': 출력 디버그</block>
  <block id="fe27ec35afa597521f9616f18c32e556" category="list-text">''-h,- 도움말: tridentctl 도움말.</block>
  <block id="874377d6c0baee9e8e842c8abf13d28c" category="list-text">''-n,-namespace string': Astra Trident 배포의 네임스페이스.</block>
  <block id="463b413ea9e7764a789f3e987cb06fc8" category="list-text">''-o, - 출력 문자열: 출력 형식. json|YAML|name|wide|ps(기본값) 중 하나.</block>
  <block id="85c5338e138fc6d122a579f7a07040bf" category="list-text">``s’, -- 서버 문자열: Astra Trident REST 인터페이스의 주소/포트.</block>
  <block id="76ea0bebb3c22822b4f0dd9c9fd021c5" category="section-title">생성</block>
  <block id="b8d486e9285b25b72d6efad05e41de4d" category="paragraph">'create' 명령을 실행하여 Astra Trident에 리소스를 추가할 수 있습니다.</block>
  <block id="6d5c7e6905e460d1fba1f2dd1c0d2a8a" category="paragraph">사용 가능한 옵션: "backend": Astra Trident에 백엔드를 추가합니다.</block>
  <block id="099af53f601532dbd31e0ea99ffdeb64" category="section-title">삭제</block>
  <block id="0d847e459450017616b8ab50b372ad2e" category="paragraph">"Delete" 명령을 실행하여 Astra Trident에서 하나 이상의 리소스를 제거할 수 있습니다.</block>
  <block id="16713f316b7cce82385c040efc32ac83" category="paragraph">사용 가능한 옵션:</block>
  <block id="417f8bf14ed5852917d189612c7d163c" category="list-text">백엔드: Astra Trident에서 하나 이상의 스토리지 백엔드를 삭제합니다.</block>
  <block id="cafc31fff08c0637f779500b7840fe1e" category="list-text">노드: Astra Trident에서 하나 이상의 CSI 노드를 삭제합니다.</block>
  <block id="4896fd245b78ab9b7d044375c1fce85e" category="list-text">'스냅샷': Astra Trident에서 하나 이상의 볼륨 스냅샷을 삭제합니다.</block>
  <block id="cef6b6bb7932e7450e35eafc3d986f18" category="list-text">'스토라게': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스토리지 클래스를 삭제합니다.</block>
  <block id="14eeaf8d1da512153855b759185ee129" category="list-text">'볼륨': Astra Trident에서 하나 이상의 스토리지 볼륨을 삭제합니다.</block>
  <block id="b5eda0a74558a342cf659187f06f746f" category="section-title">가져오기</block>
  <block id="c7a7a677647f05a4032891d4aef5bed5" category="paragraph">"get" 명령을 실행하여 Astra Trident에서 하나 이상의 리소스를 가져올 수 있습니다.</block>
  <block id="2dd609bd837a41363817262fd314b0be" category="list-text">"백엔드": Astra Trident에서 하나 이상의 스토리지 백엔드를 가져옵니다.</block>
  <block id="ad4ba4a1b0612fa67f4386330ac00e9d" category="list-text">스냅샷: 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스냅샷을 얻을 수 있습니다.</block>
  <block id="5385ccfb9fd8a07e53dc1a6ac58a101d" category="list-text">'스라거글라스': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 스토리지 클래스를 받으세요.</block>
  <block id="060da5b15e6fb7129c04e18b3d96c702" category="list-text">'볼륨': 아스트라 트리덴트(Astra Trident)에서 하나 이상의 볼륨을 가져옵니다.</block>
  <block id="59b514174bffe4ae402b3d63aad79fe0" category="section-title">이미지</block>
  <block id="16ca0a361439e1f936eaa5c919443b10" category="paragraph">"images" 플래그를 실행하여 Astra Trident에 필요한 컨테이너 이미지 테이블을 인쇄할 수 있습니다.</block>
  <block id="1008ac4609cab9210ae758ff8fee8127" category="paragraph">플래그: * ``h, - 도움말’: 이미지 도움말. * ``v, - -k8s-version string': Kubernetes 클러스터의 의미 있는 버전</block>
  <block id="f6c534966bc7687e0c87134d025f8837" category="section-title">볼륨 가져오기</block>
  <block id="df5ec83145dcd824f8daf85d89e5dd8a" category="paragraph">'볼륨 가져오기' 명령을 실행하여 기존 볼륨을 Astra Trident로 가져올 수 있습니다.</block>
  <block id="ccf1bb29ef5562c033962d35014005e9" category="paragraph">별칭: 볼륨, v</block>
  <block id="48c7ae9a5466415a6b9666ad86746640" category="list-text">''-f, --파일 이름 문자열': YAML 또는 JSON PVC 파일 경로.</block>
  <block id="1bb2af29a08ab6ea9414a8656234b8c6" category="list-text">''-h, - 도움말: 볼륨 도움말.</block>
  <block id="0ad393d5c23749c23f3855220b55375a" category="list-text">'--관리 안 함: PV/PVC만 생성 볼륨 라이프사이클 관리를 가정하지 마십시오.</block>
  <block id="19ad89bc3e3c9d7ef68b89523eff1987" category="section-title">설치합니다</block>
  <block id="42ddf993417d9568ca6a057fe55f9c63" category="paragraph">설치 플래그를 실행하여 Astra Trident를 설치할 수 있습니다.</block>
  <block id="d14ef114d140fec912921e8447a4dd25" category="list-text">"--autosupport-image string": AutoSupport Telemetry의 컨테이너 이미지(기본값: "NetApp/트리덴트 자동 지원: 20.07.0")</block>
  <block id="fbd7cc4267716ab9206612c6dcaa206e" category="list-text">`--autosupport-proxy string': AutoSupport 텔레메트리 전송을 위한 프록시의 주소/포트입니다.</block>
  <block id="8bb3d6751910d39b8c964e90434b79db" category="list-text">"--CSI": CSI Trident 설치(Kubernetes 1.13의 경우에만 재정의, 기능 게이트 필요)</block>
  <block id="778cbd0cbbd73953bc965ad29269803c" category="list-text">''--enable-node-prep': 노드에 필요한 패키지 설치 시도</block>
  <block id="23945a1dd08f0fb29fc1b73a02a2f48d" category="list-text">''--generate-custom-YAML': 아무것도 설치하지 않고 YAML 파일을 생성합니다.</block>
  <block id="351ac43ddb05bc31fb7aa4d76c9098ed" category="list-text">''-h, - 도움말: 설치 도움말.</block>
  <block id="1968a7e86875b6b6ca9d5222172f8d16" category="list-text">`--http-request-timeout': Trident 컨트롤러의 REST API에 대한 HTTP 요청 시간 초과를 재정의합니다(기본값 1m30s).</block>
  <block id="3b825e283b9b4452c1ef223373ad950d" category="list-text">''--image-registry string': 내부 이미지 레지스트리의 주소/포트입니다.</block>
  <block id="ba7224837b2ded4b5b295c1012fcc2c0" category="list-text">''--k8s-timeout duration': 모든 Kubernetes 운영(기본값 3m0s)의 시간 초과.</block>
  <block id="6018142252ad7b87dc139b3235ff4fd3" category="list-text">''--kubelet-dir string': kubelet의 내부 상태(기본값 "/var/lib/kubelet")의 호스트 위치입니다.</block>
  <block id="e36f8ff54239eb329caf981624e29cb9" category="list-text">''--log-format string': Astra Trident 로깅 형식(text, json)(기본 "text").</block>
  <block id="75f452bd493d8727bcf31563cc9106b4" category="list-text">`--pv string ': Astra Trident가 사용한 레거시 PV의 이름이며, 이 이름이 존재하지 않는지 확인합니다(기본 "삼중류").</block>
  <block id="ba2a8d0773dc83972c406043a789e4dd" category="list-text">''--PVC string': Astra Trident에서 사용하는 기존 PVC의 이름인 경우 이 항목이 존재하지 않는지 확인합니다(기본 "삼중류").</block>
  <block id="6c99958eae5167b3baa561e4f7ee33f1" category="list-text">``침묵 AutoSupport’’는 AutoSupport 번들을 NetApp에 자동으로 보내지 않습니다(기본값: TRUE).</block>
  <block id="77c96d54825d934e8abaadbc0049935d" category="list-text">'--silent': 설치 중 대부분의 출력을 비활성화합니다.</block>
  <block id="daeedc3203fdc6c1fb8dfe70e2381ed3" category="list-text">'--trident-image string': 설치할 Astra Trident 이미지.</block>
  <block id="9a7a8500c6fa970d6879b522c3e33437" category="list-text">''--use-custom-YAML': 설정 디렉토리에 존재하는 기존 YAML 파일을 사용합니다.</block>
  <block id="bbf23448d408765a1240d287ed41ceff" category="list-text">''--use-ipv6: Astra Trident의 통신에는 IPv6를 사용합니다.</block>
  <block id="2165e4fa5bddb65a31f6a0c495c2fa37" category="section-title">로그</block>
  <block id="501416d02a886c81e8849b2f400e28a3" category="paragraph">"logs" 플래그를 실행하여 Astra Trident의 로그를 인쇄할 수 있습니다.</block>
  <block id="be8607b2dc354b7010b1464ac140fc1b" category="list-text">``A, - 아카이브' : 달리 명시하지 않는 한 모든 로그를 포함하는 지원 아카이브를 만듭니다.</block>
  <block id="d8d07479f4d5c7f0ef2b0f51407f070c" category="list-text">''-h, - 도움말: 로그 도움말.</block>
  <block id="f925a9593a051a85d10acec74988d84f" category="list-text">''-l,-log string': Astra Trident log를 표시합니다. 트리덴트|auto|트리덴트-operator|all 중 하나(기본 "자동").</block>
  <block id="d8a224d86fa21c6c564987d0848bf681" category="list-text">''--node string: 노드 POD 로그를 수집할 Kubernetes 노드 이름입니다.</block>
  <block id="a335d03b82ae4916c848dd419432f477" category="list-text">''-p, -- previous': 이전 컨테이너 인스턴스에 대한 로그가 있으면 가져옵니다.</block>
  <block id="d7d7c214e32f71943c71783fa9d5fb55" category="list-text">'--사이드카': 사이드카 컨테이너의 통나무를 가져오십시오.</block>
  <block id="2541d938b0a58946090d7abdde0d3890" category="section-title">전송</block>
  <block id="3121026e841bd19d147c54ac43e423c0" category="paragraph">'send' 명령을 실행하여 Astra Trident에서 리소스를 보낼 수 있습니다.</block>
  <block id="9ce1e94be8ccb1612967a7e2cbe69a6f" category="paragraph">사용 가능한 옵션: 'AutoSupport': AutoSupport 아카이브를 NetApp에 보냅니다.</block>
  <block id="fe98497efedbe156ecc4b953aea77e07" category="section-title">설치 제거</block>
  <block id="e980a564a92aa568234d9757a591756b" category="paragraph">"uninstall" 플래그를 실행하여 Astra Trident를 제거할 수 있습니다.</block>
  <block id="dcb0c76edbe301ede057149da76bf89b" category="paragraph">플래그: * ``h, - 도움말': 제거 도움말. '--silent': 제거 중 대부분의 출력을 비활성화합니다.</block>
  <block id="3ac340832f29c11538fbe2d6f75e8bcc" category="section-title">업데이트</block>
  <block id="328865de703bbe034177e6eb51dc3d28" category="paragraph">'update' 명령어를 실행하여 Astra Trident에서 자원을 수정할 수 있다.</block>
  <block id="8680f448b33371bcb4778563a93f4702" category="paragraph">사용 가능한 옵션: "backend": Astra Trident에서 백엔드를 업데이트합니다.</block>
  <block id="ae26b3d8e556703291282149e3ae894f" category="section-title">업그레이드</block>
  <block id="87911de7a0bc3ff821f75ab303a0edc0" category="paragraph">"업그레이드" 명령을 실행하여 Astra Trident에서 리소스를 업그레이드할 수 있습니다.</block>
  <block id="70cc5172db10ac60dd0b32e57285e85c" category="paragraph">사용 가능한 옵션: 볼륨: NFS/iSCSI에서 CSI로 하나 이상의 영구 볼륨을 업그레이드합니다.</block>
  <block id="9867997bba4e250bad7411d19fce3905" category="paragraph">'tridentctl' 및 실행 중인 Trident 서비스의 버전을 인쇄하려면 'rsion' 플래그를 실행할 수 있습니다.</block>
  <block id="800f73959f4b721c78f4651c6b4b2052" category="paragraph">플래그: * `--client': 클라이언트 버전만 해당(서버 필요 없음). '-h, - 도움말': 버전 도움말.</block>
  <block id="a1582c89f8e85f372306a05848eafb68" category="summary">NetApp 스토리지 제품 포트폴리오는 Kubernetes 클러스터의 다양한 측면과 통합되어 고급 데이터 관리 기능을 제공하며, Kubernetes 구축의 기능, 기능, 성능 및 가용성을 향상합니다.</block>
  <block id="9944b094c4079f770fabc4ae629feb0f" category="doc">Kubernetes와 통합된 NetApp 제품</block>
  <block id="3cce5f3eaf76e098ba8e28f7bbba3f92" category="section-title">아스트라</block>
  <block id="293b14f82e58fc3efc27bf18185a38c8" category="paragraph"><block ref="35a6b548833df39b8bbc748563b1938b" category="inline-link-rx"></block> 퍼블릭 클라우드와 온프레미스 모두에서 Kubernetes에서 실행되는 데이터 리치 컨테이너 워크로드를 손쉽게 관리, 보호 및 이동할 수 있습니다. Astra는 퍼블릭 클라우드 및 온프레미스에 있는 NetApp의 검증되고 광범위한 스토리지 포트폴리오의 Trident를 사용하여 영구 컨테이너 스토리지를 프로비저닝하고 제공합니다. 또한, 스냅샷, 백업 및 복원, 활동 로그, 데이터 보호, 재해/데이터 복구, 데이터 감사, Kubernetes 워크로드의 마이그레이션 사용 사례를 위한 액티브 클론 복제와 같은 풍부한 고급 애플리케이션 인식 데이터 관리 기능을 제공합니다.</block>
  <block id="51fd2fc669e51c6870f1148623240f69" category="paragraph">ONTAP는 모든 애플리케이션에 고급 데이터 관리 기능을 제공하는 NetApp의 다중 프로토콜 통합 스토리지 운영 체제입니다. ONTAP 시스템은 All-Flash, 하이브리드 또는 All-HDD 구성을 제공하며 엔지니어링 하드웨어(FAS 및 AFF), 화이트박스(ONTAP Select), 클라우드 전용(Cloud Volumes ONTAP) 등 다양한 구축 모델을 제공합니다.</block>
  <block id="cbb7697b4f6f189240d043ff70ca133c" category="admonition">Trident는 위에 언급된 모든 ONTAP 배포 모델을 지원합니다.</block>
  <block id="5c04ffbd0c110bf7b37d6b95eb756b75" category="paragraph"><block ref="700b45b9fca207b66f675c8d5dfb073b" category="inline-link-rx"></block> 는 클라우드에서 ONTAP 데이터 관리 소프트웨어를 실행하는 소프트웨어 전용 스토리지 어플라이언스입니다. Cloud Volumes ONTAP를 운영 워크로드, 재해 복구, DevOps, 파일 공유 및 데이터베이스 관리에 사용할 수 있습니다. 스토리지 효율성, 고가용성, 데이터 복제, 데이터 계층화, 애플리케이션 정합성을 보장함으로써 엔터프라이즈 스토리지를 클라우드로 확장합니다.</block>
  <block id="04452ff4732608f62e53d20e4b8f4c92" category="paragraph"><block ref="6a2736fcbb5755dd03d114a5153506eb" category="inline-link-rx"></block> 은 완벽하게 관리되는 AWS 서비스로, 고객이 NetApp의 ONTAP 스토리지 운영 체제에서 제공하는 파일 시스템을 시작하고 실행할 수 있도록 지원합니다. ONTAP용 FSX를 사용하면 고객이 익숙한 NetApp 기능, 성능 및 관리 기능을 활용하는 동시에 AWS에 데이터를 저장할 때 간편성, 민첩성, 보안, 확장성을 활용할 수 있습니다. ONTAP용 FSX는 ONTAP의 다양한 파일 시스템 기능과 관리 API를 지원합니다.</block>
  <block id="27bb76bfb1e4f9966c31f5042348cd1e" category="section-title">Element 소프트웨어</block>
  <block id="231afe47f3f37d3808096b36c28b4ded" category="inline-link">요소</block>
  <block id="1fdf61a8f946268990d8e15dd9069a6d" category="paragraph"><block ref="eca39b018af81e7b5c8e71b5b4aa3790" category="inline-link-rx"></block> 스토리지 관리자가 성능을 보장하고 단순화된 스토리지 설치 공간을 활용하여 워크로드를 통합할 수 있도록 지원합니다. Element는 스토리지 관리의 모든 측면을 자동화하는 API와 결합되어 스토리지 관리자가 더 적은 노력으로 더 많은 작업을 수행할 수 있게 합니다.</block>
  <block id="08edd2123939d5309dced149763a50ee" category="section-title">NetApp HCI</block>
  <block id="25f221cc63a7e1fa55b05c29420a72a2" category="paragraph"><block ref="2841e7defe3939e68d83d007d1ad666b" category="inline-link-rx"></block> 일상적인 작업을 자동화하고 인프라 관리자가 보다 중요한 기능에 집중할 수 있도록 하여 데이터 센터의 관리 및 확장을 단순화합니다.</block>
  <block id="be17f8b9c728a6cb61cad5a2609b3888" category="paragraph">NetApp HCI는 Trident에서 완전히 지원합니다. Trident는 컨테이너화된 애플리케이션에 대한 스토리지 장치를 기본 NetApp HCI 스토리지 플랫폼에 직접 프로비저닝 및 관리할 수 있습니다.</block>
  <block id="b146010b35b21e2354c084cf6d1d2a5d" category="section-title">SANtricity</block>
  <block id="6161e6c043d51e8eea03494bff7fc57b" category="paragraph">NetApp의 E-Series 및 EF-Series 스토리지 플랫폼은 를 사용합니다<block ref="01c1197ee4ca6d1b24476d1f7b6bc83e" category="inline-link-rx"></block> 어떠한 규모의 애플리케이션에도 스토리지 서비스를 제공할 수 있는, 뛰어난 가용성과 성능을 갖춘 강력한 스토리지를 제공하는 운영 체제입니다.</block>
  <block id="9589e472cb7c5e0d01ca15ecca72de0d" category="paragraph">Trident는 제품 포트폴리오에서 SANtricity 볼륨을 생성하고 관리할 수 있습니다.</block>
  <block id="29e7ab00082418141d470583a19c28d3" category="paragraph"><block ref="2384314bcd106c8062815b2ed789c4ad" category="inline-link-rx"></block> NetApp에서 제공하는 엔터프라이즈급 Azure 파일 공유 서비스입니다. Azure에서 기본적으로 가장 까다로운 파일 기반 워크로드를 실행하고 NetApp에서 기대하는 성능 및 강력한 데이터 관리를 제공할 수 있습니다.</block>
  <block id="962483cc436ac01febcdca57fff4735f" category="inline-link">AWS 환경을 위한 NetApp Cloud Volumes Service</block>
  <block id="9cd398e3307ca354d12d0f47aca4f913" category="paragraph"><block ref="a105e3d261515148b2a94b7605496120" category="inline-link-rx"></block> 는 NFS 및 SMB를 통해 NAS 볼륨을 All-Flash 성능으로 제공하는 클라우드 네이티브 파일 서비스입니다. 이 서비스를 사용하면 기존 애플리케이션을 포함한 모든 워크로드를 AWS 클라우드에서 실행할 수 있습니다. ECS(Elastic Container Service) 인스턴스에 대해 일관된 고성능, 즉각적인 클론 생성, 데이터 보호 및 보안 액세스를 제공하는 완전 관리형 서비스를 제공합니다.</block>
  <block id="a3b5183ae6f5c3f1d6644448f795b5cb" category="inline-link">Google Cloud용 NetApp Cloud Volumes Service</block>
  <block id="a1515efe69d0ac9d979af2bdfc068934" category="paragraph"><block ref="68704f3321dd8ca7029c03c29da7736a" category="inline-link-rx"></block> 는 NFS 및 SMB를 통해 NAS 볼륨을 All-Flash 성능으로 제공하는 클라우드 네이티브 파일 서비스입니다. 이 서비스를 사용하면 기존 애플리케이션을 포함한 모든 워크로드를 GCP 클라우드에서 실행할 수 있습니다. GCE(Google Compute Engine) 인스턴스에 대한 일관된 고성능, 즉각적인 복제, 데이터 보호 및 보안 액세스를 제공하는 완전 관리형 서비스를 제공합니다.</block>
  <block id="5ee08ab883e000ce6b739dbb0b6ff376" category="summary">Kubernetes 시스템 일부에 대해 자세히 알아보십시오.</block>
  <block id="607ae6360b32f1bd6e559e915d414fab" category="doc">Kubernetes 개념</block>
  <block id="d60f0fff1c23a02458849862f593357e" category="inline-link">Kubernetes 시스템</block>
  <block id="a7018a5fd7b610274c7786aa5402e64d" category="paragraph">의 각 부분에 대해 자세히 알아보십시오<block ref="f01a74527fa0343e793eb393c9d4809a" category="inline-link-rx"></block>.</block>
  <block id="fc96768681dcf6770119445ffe2537cd" category="summary">볼륨을 생성하려면 필요한 경우 지정된 Astra Trident 드라이버 이름과 함께 표준 docker 볼륨 명령을 사용합니다.</block>
  <block id="feabbbf9b5afb31194daf0d8e3ff75dc" category="doc">볼륨 작업</block>
  <block id="00e5ed77f92b42f144be7dfb7106bf10" category="paragraph">필요한 경우 지정된 Astra Trident 드라이버 이름을 사용하여 표준 docker 볼륨 명령을 사용하여 볼륨을 쉽게 생성, 클론 생성 및 제거할 수 있습니다.</block>
  <block id="dc88dce8ec264777b2f90ec0af744f43" category="section-title">볼륨을 생성합니다</block>
  <block id="a32b09b1335e0afbb640a9412690680d" category="list-text">기본 이름을 사용하여 드라이버로 볼륨을 생성합니다.</block>
  <block id="8b5708fe1297b9ca8b3be5b99bf29407" category="list-text">특정 Astra Trident 인스턴스를 사용하여 볼륨 생성:</block>
  <block id="93da65a9fd0004d9477aeac024e08e15" category="inline-link-macro">옵션</block>
  <block id="593e5c95e1adc19e8d81719c16b57bc1" category="admonition">지정하지 않은 경우 <block ref="3a0a40f90bfa29e0eb23418c553e5ef5" category="inline-link-macro-rx"></block>, 드라이버 기본값이 사용됩니다.</block>
  <block id="1e1e2461d5dfd51f1ebd0eadcba142f4" category="list-text">기본 볼륨 크기를 재정의합니다. 다음 예를 참조하여 드라이버로 20GiB 볼륨을 생성합니다.</block>
  <block id="5149eec9d959a54cf392efaa710541d1" category="admonition">볼륨 크기는 옵션 단위(예: 10G, 20GB, 3TiB)가 포함된 정수 값이 포함된 문자열로 표시됩니다. 단위를 지정하지 않으면 기본값은 G입니다 크기 단위는 2(B, KiB, MiB, GiB, TiB) 또는 10(B, KB, MB, GB, TB)의 거듭제곱으로 표현될 수 있습니다. 단축 단위는 2의 거듭제곱을 사용합니다(G=GiB, T=TiB,…).</block>
  <block id="9bc129eac7adf7ea5d8ed1c021fab2dc" category="section-title">볼륨을 제거합니다</block>
  <block id="281a0f40363a276c6ec125244c784112" category="list-text">다른 Docker 볼륨과 마찬가지로 볼륨을 제거합니다.</block>
  <block id="7959e3701f7a7fba7713c7530d496324" category="admonition">'솔드파이어-SAN' 드라이버를 사용할 때 위의 예에서는 볼륨을 삭제하고 삭제합니다.</block>
  <block id="5a1345d94751fc14bedf8f6f5e77a0ff" category="paragraph">Docker를 위한 Astra Trident를 업그레이드하려면 다음 단계를 수행하십시오.</block>
  <block id="d50044469c0bf9ab38eff9cf7243fb25" category="section-title">볼륨의 클론을 생성합니다</block>
  <block id="d9bab73e26d2aaa2f602f32954ab9cd7" category="paragraph">ONTAP-NAS, ONTAP-SAN, 졸idfire-SAN, AWS-CV, GCP-CV 스토리지 드라이버를 사용할 때 Astra Trident는 볼륨을 복제할 수 있습니다. ONTAP-NAS-Flexgroup 또는 ONTAP-NAS-이코노미 드라이버를 사용할 때는 복제가 지원되지 않습니다. 기존 볼륨에서 새 볼륨을 생성하면 새 스냅샷이 생성됩니다.</block>
  <block id="9374b766b9dd78063440afd69afabf38" category="list-text">볼륨을 검사하여 스냅샷을 열거합니다.</block>
  <block id="2747096689037792fa87de7a0e8440e2" category="list-text">기존 볼륨에서 새 볼륨을 생성합니다. 이렇게 하면 새 스냅샷이 생성됩니다.</block>
  <block id="31d9b5ed201aa44dbeae6d17d38c0c6f" category="list-text">볼륨의 기존 스냅샷에서 새 볼륨을 생성합니다. 새 스냅샷은 생성하지 않습니다.</block>
  <block id="516b30a46da41c6969cb7249d6567905" category="section-title">외부에서 생성된 볼륨에 액세스합니다</block>
  <block id="d8c20bb137be94fec8295c3fc5175b54" category="paragraph">Trident*만 * 을 사용하여 컨테이너별로 외부에서 생성된 블록 장치(또는 해당 클론)에 액세스할 수 있습니다. * 파티션이 없고 파일 시스템이 Astra Trident에서 지원하는 경우(예: "ext4"-formatted"/dev/sdc1"은 Astra Trident를 통해 액세스할 수 없습니다.</block>
  <block id="c2bccf4258de19dd1e03e25f66d80f98" category="summary">Docker와 함께 Astra Trident를 사용할 때 알려진 문제에 대한 정보를 확인하십시오.</block>
  <block id="3a3b7ac2e39541ea05707ccd6eb054d4" category="doc">알려진 문제 및 제한 사항</block>
  <block id="ba6bb78ba304725781af9e773f1957e2" category="paragraph">Docker에서 Astra Trident를 사용할 때 알려진 문제 및 제한 사항에 대한 정보를 확인하십시오.</block>
  <block id="8bb35988eac5a841d2af092365f1aa42" category="section-title">이전 버전에서 Trident Docker 볼륨 플러그인을 20.10 이상으로 업그레이드하면 해당 파일 또는 디렉터리 오류가 없는 업그레이드 오류가 발생합니다.</block>
  <block id="7aebfa1e2291377e040de92d7f7f335f" category="list-title">해결 방법</block>
  <block id="f49f11bc5398ac13e500d16eac424e77" category="list-text">플러그인을 비활성화합니다.</block>
  <block id="cc3dae6dd6670606c41c62b10273605e" category="list-text">플러그인을 제거합니다.</block>
  <block id="6010901b5c4bb6ad671e6f07fcc038d8" category="list-text">추가 'config' 매개 변수를 제공하여 플러그인을 다시 설치합니다.</block>
  <block id="e527ab8c1c51767e38a3603d51d2d6e5" category="section-title">볼륨 이름은 최소 2자 이상이어야 합니다.</block>
  <block id="45c9df594d13c8a5e5472503d5f14b01" category="inline-link">버그 25773을 참조하십시오</block>
  <block id="c167efd138e06a8ee59885983c5ddf69" category="admonition">이는 Docker 클라이언트의 제한 사항입니다. 클라이언트는 단일 문자 이름을 Windows 경로로 해석합니다.<block ref="f082f49b923960d888c1d98a1e9f4fcb" category="inline-link-rx"></block>.</block>
  <block id="3c4f022a33d4aace82350c9966fa238b" category="section-title">Docker Swarm에는 Astra Trident가 모든 스토리지 및 드라이버 조합에서 이를 지원하지 않는 특정 동작이 있습니다.</block>
  <block id="a7c3ff464b1ef4364de4df03d66bee5e" category="list-text">현재 Docker Swarm은 볼륨 ID 대신 볼륨 이름을 고유한 볼륨 식별자로 사용합니다.</block>
  <block id="61ab6f5cff8de89cba95d9e3bbc4ff71" category="list-text">볼륨 요청은 Swarm 클러스터의 각 노드로 동시에 전송됩니다.</block>
  <block id="521e51548c3f7c96e72d432edf4af42d" category="list-text">볼륨 플러그인(Astra Trident 포함)은 Swarm 클러스터의 각 노드에서 독립적으로 실행해야 합니다. ONTAP의 작동 방식과 'ONTAP-NAS' 및 'ONTAP-SAN' 드라이버의 작동 방식 때문에 이러한 제한 내에서 작동할 수 있는 유일한 드라이버가 됩니다.</block>
  <block id="69418caf7b92279073f695612c68de99" category="paragraph">나머지 드라이버에는 명확한 "승자" 없이 단일 요청에 대해 대량의 볼륨을 생성할 수 있는 경합 상태와 같은 문제가 있습니다. 예를 들어, Element에는 볼륨의 이름이 같지만 ID가 다를 수 있는 기능이 있습니다.</block>
  <block id="48cbf13b390ff021b130d5f372147af5" category="paragraph">NetApp은 Docker 팀에 피드백을 제공했지만, 향후 소구에 대한 표시는 제공하지 않습니다.</block>
  <block id="29cff148f43bc689eb14447b333f6f83" category="section-title">FlexGroup를 프로비저닝하고 있는 경우, 두 번째 FlexGroup에 프로비저닝되는 FlexGroup와 공통되는 하나 이상의 애그리게이트가 있는 경우 ONTAP는 두 번째 FlexGroup를 프로비저닝하지 않습니다.</block>
  <block id="0e9e734e557a02db30a20e5ac259cfb9" category="summary">각 스토리지 드라이버에는 다양한 옵션이 있으며, 볼륨 생성 시 이를 지정하여 결과를 사용자 지정할 수 있습니다. 구성된 스토리지 시스템에 적용되는 옵션은 아래를 참조하십시오.</block>
  <block id="11e1b165c1d718d825f4bb9aaf0b884e" category="doc">드라이버별 볼륨 옵션</block>
  <block id="bca0712c590c8d3c228bf1044aed730b" category="paragraph">볼륨 생성 작업 중에 이러한 옵션을 사용하는 것은 간단합니다. CLI 동작 중에 '-o' 연산자를 사용하여 옵션과 값을 제공한다. 이러한 값은 JSON 구성 파일의 모든 등가 값을 재정의합니다.</block>
  <block id="6021d91bdededf94b8ae37c30e820118" category="section-title">ONTAP 볼륨 옵션</block>
  <block id="16dc9caa069072a49db7ea7c81a7cf66" category="paragraph">NFS 및 iSCSI에 대한 볼륨 생성 옵션은 다음과 같습니다.</block>
  <block id="054b4f3ea543c990f6b125f41af6ebf7" category="cell">옵션을 선택합니다</block>
  <block id="d3a07c97b6050b305c7dda0aea1657be" category="paragraph">볼륨의 크기는 기본적으로 1GiB로 설정됩니다.</block>
  <block id="69e8c7b4f73d39cea9948875813f7ddd" category="paragraph">볼륨을 씬 또는 일반 프로비저닝합니다. 기본값은 Thin 입니다. 유효한 값은 '없음'(씬 프로비저닝) 및 '볼륨'(일반 프로비저닝)입니다.</block>
  <block id="91853d7e2338a1395280185fc93d4650" category="paragraph">그러면 스냅샷 정책이 원하는 값으로 설정됩니다. 기본값은 '없음'입니다. 즉, 볼륨에 대해 스냅샷이 자동으로 생성되지 않습니다. 스토리지 관리자가 수정하지 않는 한, "default"라는 정책이 모든 ONTAP 시스템에 존재하며, 이 정책은 6시간, 2일, 2주 스냅샷을 생성하고 유지합니다. 스냅숏에 보존되어 있는 데이터는 볼륨의 모든 디렉터리에서 '.snapshot' 디렉토리를 찾아 복구할 수 있습니다.</block>
  <block id="b8a0fde33bd7662b7b9cb4158f04ef52" category="paragraph">이렇게 하면 스냅숏 예비 공간이 원하는 비율로 설정됩니다. 기본값은 값이 없습니다. 즉, snapshotPolicy를 선택한 경우 ONTAP가 snapshotReserve(일반적으로 5%)를 선택하거나 snapshotPolicy가 none인 경우 0%를 선택합니다. 모든 ONTAP 백엔드에 대한 구성 파일에서 기본 snapshotReserve 값을 설정할 수 있으며 ONTAP-NAS-이코노미 를 제외한 모든 ONTAP 백엔드에 대한 볼륨 생성 옵션으로 사용할 수 있습니다.</block>
  <block id="0625856b9dc58db03a6e2c49b1f029e3" category="paragraph">볼륨을 클론 생성할 때 ONTAP가 상위 클론에서 즉시 클론을 분할합니다. 기본값은 false 입니다. 볼륨을 클론 복제하는 사용 사례에는 스토리지 효율성을 높일 기회가 없을 것 같기 때문에 생성 즉시 클론을 상위 볼륨에서 분리하는 것이 가장 좋습니다. 예를 들어 빈 데이터베이스를 복제하면 많은 시간을 절약할 수 있지만 스토리지 절감 효과는 거의 없으므로 즉시 클론을 분리하는 것이 좋습니다.</block>
  <block id="be94792f601f829d9b2be22553c6bf31" category="paragraph">이렇게 하면 새 볼륨에 NVE(NetApp Volume Encryption)가 기본적으로 'false'로 설정됩니다. 이 옵션을 사용하려면 NVE 라이센스가 클러스터에서 활성화되어 있어야 합니다.</block>
  <block id="cdaf246fba737b75127faa65456baa30" category="paragraph">볼륨에 사용할 계층화 정책을 설정합니다. 비활성(콜드) 상태일 때 데이터를 클라우드 계층으로 이동할지 결정합니다.</block>
  <block id="1c46d85ab16f6b373409ad15260b1b0a" category="paragraph">다음 추가 옵션은 NFS * 에만 적용됩니다 *.</block>
  <block id="b145a4acc7a577d843f538580013776b" category="paragraph">볼륨 자체에 대한 권한 집합을 제어합니다. 기본적으로 사용 권한은 '---rwxr-XR-x' 또는 숫자 표기 0755로 설정되며 root는 소유자가 됩니다. 텍스트 또는 숫자 형식이 작동합니다.</block>
  <block id="76a4004d727b54162f2e0542094a89a3" category="paragraph">이것을 "참"으로 설정하면 볼륨에 액세스하는 클라이언트에 '.snapshot' 디렉토리가 표시됩니다. 기본값은 false로, 이는 '.snapshot' 디렉토리의 가시성이 기본적으로 해제되어 있음을 의미합니다. 공식 MySQL 이미지 등 일부 이미지는 '.snapshot' 디렉토리가 표시될 때 예상대로 작동하지 않습니다.</block>
  <block id="700d608597316c75fc869190f51cff49" category="paragraph">볼륨에 사용할 엑스포트 정책을 설정합니다. 기본값은 '기본값'입니다.</block>
  <block id="6b068a846d408b1d9ccd2c7220326b9d" category="paragraph">볼륨에 액세스하는 데 사용할 보안 스타일을 설정합니다. 기본값은 UNIX입니다. 유효한 값은 UNIX와 Mixed입니다.</block>
  <block id="842aac52866a44b40a5733ce352cf6df" category="paragraph">다음 추가 옵션은 iSCSI * 에만 적용됩니다 *.</block>
  <block id="3184b1a9846944fabb00496c4b6b613a" category="cell">파일 시스템 유형</block>
  <block id="56efcdcb9168adcb146b4d86bf55e99d" category="cell">iSCSI 볼륨을 포맷하는 데 사용되는 파일 시스템을 설정합니다. 기본값은 ext4 입니다. 유효한 값은 ext3, ext4, xfs입니다.</block>
  <block id="79686ba706c992e7385f0c5b28be8294" category="cell">이를 "false"로 설정하면 LUN의 공간 할당 기능이 해제됩니다. 기본값은 "true"입니다. 즉, 볼륨에 공간이 부족하고 볼륨의 LUN에서 쓰기를 허용할 수 없을 때 ONTAP에서 호스트에 알립니다. 또한 이 옵션을 사용하면 호스트가 데이터를 삭제할 때 ONTAP에서 자동으로 공간을 재확보할 수 있습니다.</block>
  <block id="ff7c0fcd6a31e735a61c001f75426961" category="section-title">예</block>
  <block id="9e6d454a094b92b0132e48d2369debf5" category="paragraph">아래 예를 참조하십시오.</block>
  <block id="be1e1c94a5fc3bb66c2ae9425eeefbdb" category="list-text">10GiB 볼륨 생성:</block>
  <block id="a6490f19f59ecd8e4ed8634990ea366c" category="list-text">스냅샷을 사용하여 100GiB 볼륨 생성:</block>
  <block id="297d0d2fcc555e5037c8d251daf5a620" category="list-text">setuid 비트가 설정된 볼륨을 생성합니다.</block>
  <block id="6e31a0481f4f7e423abcde0bf31025c8" category="paragraph">최소 볼륨 크기는 20MiB입니다.</block>
  <block id="a65684b0a191599ad968126dd65f2e9d" category="paragraph">스냅숏 예비 공간이 지정되지 않고 스냅샷 정책이 "없음"인 경우 Trident는 0%의 스냅숏 예비 공간을 사용합니다.</block>
  <block id="8c05fd71822bf85c290cef86db959f68" category="list-text">스냅숏 정책이 없고 스냅숏 예비 공간이 없는 볼륨을 생성합니다.</block>
  <block id="d15d662af6e4417b0b7c134a84ed577c" category="list-text">스냅샷 정책이 없는 볼륨 및 10%의 사용자 지정 스냅숏 예비 공간을 생성합니다.</block>
  <block id="52a56a468f11c3298931c8e32c938e15" category="list-text">스냅샷 정책 및 10%의 사용자 지정 스냅숏 예비 공간이 있는 볼륨을 생성합니다.</block>
  <block id="0a77fdb1c16069c98ebe6510137af9d2" category="list-text">스냅샷 정책을 사용하여 볼륨을 생성하고 ONTAP의 기본 스냅샷 예약 공간(일반적으로 5%)을 적용합니다.</block>
  <block id="f6f813eaaff2b296a27b6bf051485d2b" category="section-title">Element 소프트웨어 볼륨 옵션</block>
  <block id="a514753df071ac540af065b659d1c65c" category="paragraph">Element 소프트웨어 옵션은 볼륨과 연관된 서비스 품질(QoS) 정책의 크기 및 크기를 표시합니다. 볼륨을 생성할 때 해당 볼륨과 연관된 QoS 정책은 '-o type=service_level' 명명법을 사용하여 지정합니다.</block>
  <block id="f201e088f13d93e3d12b3c0ef78dece3" category="paragraph">Element 드라이버로 QoS 서비스 수준을 정의하는 첫 번째 단계는 하나 이상의 유형을 생성하고 구성 파일의 이름과 연결된 최소, 최대 및 버스트 IOPS를 지정하는 것입니다.</block>
  <block id="5cb7e4a4b6a51af0b5b09cb230b83422" category="paragraph">기타 Element 소프트웨어 볼륨 생성 옵션에는 다음이 포함됩니다.</block>
  <block id="8730c4572b866ffc01a4aefebc896555" category="paragraph">볼륨 크기, 기본값 1GiB 또는 구성 항목... "기본값":{"크기":"5G"}.</block>
  <block id="d52146098b8ecd83b888289a86e26d19" category="cell">블록사이즈</block>
  <block id="348ef18ccca06aa29547bd9ad87beebe" category="paragraph">512 또는 4096 중 하나를 사용합니다. 기본값은 512 또는 구성 항목 DefaultBlockSize 입니다.</block>
  <block id="1daf1c12549d6d3ae75c4d8d5f59d532" category="paragraph">QoS 정의가 포함된 다음 샘플 구성 파일을 참조하십시오.</block>
  <block id="7afe0c73e341cee7c90b4d4dda4600d9" category="paragraph">위 구성에서는 Bronze, Silver, Gold의 세 가지 정책 정의가 있습니다. 이러한 이름은 임의로 지정됩니다.</block>
  <block id="cb5b68dacb07bd02a5152bf4ad1de8c6" category="list-text">10GiB 골드 볼륨 생성:</block>
  <block id="89014c611c13195dc852587ef9d2bb16" category="list-text">100GiB Bronze 볼륨 생성:</block>
  <block id="7f65aa9497b5352a28e3eed539643ea7" category="section-title">AWS 볼륨 옵션 기반 CVS(Cloud Volumes Service</block>
  <block id="97f74fbb7a82eb99b7ea43017c0bfbe2" category="paragraph">AWS 드라이버에서 CVS에 대한 볼륨 생성 옵션은 다음과 같습니다.</block>
  <block id="742a301c15fea3569e5059520217090e" category="paragraph">볼륨 크기는 기본적으로 100GB입니다.</block>
  <block id="326ea14a491277cac4032c7b6413a545" category="paragraph">볼륨의 CVS 서비스 수준은 기본적으로 표준입니다. 유효한 값은 표준, 프리미엄 및 극단입니다.</block>
  <block id="a6b420fe5da257523d2105e9aae9fbc1" category="paragraph">그러면 스냅숏 예비 공간이 원하는 비율로 설정됩니다. 기본값은 no 값이며, 이는 CVS에서 스냅숏 예비 공간(일반적으로 0%)을 선택한다는 의미입니다.</block>
  <block id="fe0bb617c9579d2f1d51ca5a627839fb" category="list-text">200GiB 볼륨 생성:</block>
  <block id="6f5c2d108fc1cf862350561160c4ecac" category="list-text">500GiB 프리미엄 볼륨 생성:</block>
  <block id="84e002f675928fb7347e346a6214eefc" category="paragraph">최소 볼륨 크기는 100GB입니다.</block>
  <block id="c3fa12e6fe179aa6330774fb658371a5" category="section-title">GCP 볼륨 옵션에 대한 CV</block>
  <block id="c112845976cf3ccb7ec927bea467b805" category="paragraph">GCP 드라이버에서 CVS에 대한 볼륨 생성 옵션은 다음과 같습니다.</block>
  <block id="3d9999cfb7d197cd40ffb0d665cf46a6" category="paragraph">볼륨 크기는 CVS - 성능 볼륨의 경우 기본적으로 100GiB, CVS 볼륨의 경우 300GiB입니다.</block>
  <block id="256a798c267200d8cfa583eecaa2cc31" category="paragraph">이렇게 하면 스냅숏 예비 공간이 원하는 비율로 설정됩니다. 기본값은 no 값이며, 이는 CVS에서 스냅숏 예비 공간(일반적으로 0%)을 선택한다는 의미입니다.</block>
  <block id="4e984a8dd0f1e9f166c162b4c01da5d2" category="list-text">2TiB 볼륨 생성:</block>
  <block id="39407360e3929c32bb19c04cf3549d2e" category="list-text">5TiB 프리미엄 볼륨 생성:</block>
  <block id="077eacce80395f222c5785ca68ffe958" category="paragraph">CVS 성능 볼륨의 경우 최소 볼륨 크기는 100GiB, CVS 볼륨의 경우 300GiB입니다.</block>
  <block id="05891dbb3b7306197f5cd0da8f1768ef" category="section-title">Azure NetApp Files 볼륨 옵션</block>
  <block id="bda1cf59d924de8c8c73a8b619aace9c" category="paragraph">Azure NetApp Files 드라이버에 대한 볼륨 생성 옵션은 다음과 같습니다.</block>
  <block id="23c9c608b55b9071002aeddfd6c5563c" category="summary">Astra Trident를 구축하기 전에 호스트에 필수 프로토콜 사전 요구 사항을 설치하고 구성해야 합니다.</block>
  <block id="782bd8949cb40c80fd3f3126eccab35a" category="doc">배포를 위한 사전 요구 사항</block>
  <block id="b4851e92b19af0c5c82447fc0937709d" category="inline-link-macro">요구 사항</block>
  <block id="33446a91021b76dfabfca4afe312824a" category="list-text">배포가 모든 를 충족하는지 확인합니다 <block ref="bc54c30334f793aa90542f3d86da0da6" category="inline-link-macro-rx"></block>.</block>
  <block id="d46ecc35447a8c17ef014ff6daf07bba" category="inline-link">설치 또는 업데이트합니다</block>
  <block id="1035fa0ac2c3ed19f6ba56cafe7e121f" category="list-text">지원되는 버전의 Docker가 설치되어 있는지 확인합니다. Docker 버전이 오래되었으면<block ref="0b011811ae105895ca4da9769d7e6f99" category="inline-link-rx"></block>.</block>
  <block id="7760c52227ccba10f5bc395571ca7a60" category="list-text">프로토콜 사전 요구 사항이 호스트에 설치 및 구성되어 있는지 확인합니다.</block>
  <block id="7f50d5e5825124658e17cc8cfaa7f823" category="list-text">다중 경로 데몬을 시작합니다.</block>
  <block id="87772a853423d643181e2b56bcb4b17f" category="paragraph">'SUDO mpathconf - -enable - -with_multipathd y'</block>
  <block id="43ce2a55c085b27f271203155d2745e1" category="list-text">'iscsid'와 'multipathd'가 활성화되어 실행되고 있는지 확인합니다.</block>
  <block id="04c298ec3fc67bce1115cddcc2b3b829" category="paragraph">'SUDO systemctl enable iscsid multipathd''SUDO systemctl start iscsid multipathd'</block>
  <block id="2cfaa468af4e9de7ba9933d9e0081572" category="list-text">iSCSI 타겟 검색:</block>
  <block id="f0c700b766cfcc86bc21496513c58391" category="paragraph">'sudo iscsiadm -m discoverydb -t st -p &lt;data_LIF_ip&gt;--discover'</block>
  <block id="18124bf28831e04dabc4dc81d1d4e69f" category="list-text">검색된 iSCSI 대상에 로그인합니다.</block>
  <block id="ba64ec4efdc69990967a75a918b83635" category="paragraph">'SUDO iscsiadm -m node -p &lt;data_LIF_ip&gt;--login'</block>
  <block id="8bd830b1ea0595874b57cfd34c877123" category="paragraph">'SUDO systemctl enable iscsi''SUDO systemctl start iscsi'를 활성화합니다</block>
  <block id="e6693412ed2252a87ece3f264fb334ed" category="paragraph">'SUDO tee /etc/multipath.conf&lt;-'EOF' 기본값 {user_friendly_names yes find_multipath yes}EOF sudo service multipath-tools restart'입니다</block>
  <block id="0d29eaa34aa7badaae0d49b35a2a0d12" category="paragraph">'SUDO service open-iscsi start sudo service multipath-tools start'를 참조하십시오</block>
  <block id="e84181a29f4e43a18b27e7d82797adef" category="summary">Docker를 위한 Astra Trident는 NetApp의 스토리지 플랫폼과 AWS의 Cloud Volumes Service를 위한 Docker 에코시스템과 직접 통합됩니다. 또한 향후 추가 플랫폼을 추가할 수 있도록 스토리지 플랫폼에서 Docker 호스트에 이르는 스토리지 리소스의 프로비저닝 및 관리를 지원합니다.</block>
  <block id="d2eb05d1990246a079aeb2f56e3a4237" category="paragraph">Astra Trident의 여러 인스턴스를 동일한 호스트에서 동시에 실행할 수 있습니다. 이를 통해 여러 스토리지 시스템 및 스토리지 유형에 동시에 연결할 수 있으며, Docker 볼륨에 사용되는 스토리지를 사용자 지정할 수 있습니다.</block>
  <block id="89bcbd8e4ba49b7310e9fa748e878c4b" category="inline-link-macro">배포를 위한 사전 요구 사항</block>
  <block id="d1e7215d070e62d3e82e915d703ceaa9" category="paragraph">를 참조하십시오 <block ref="a51fda4654690ac4414966ed4956599c" category="inline-link-macro-rx"></block>. 필수 구성 요소가 충족되었는지 확인한 후 Astra Trident를 배포할 준비가 되었습니다.</block>
  <block id="88f0ab229fa9d759d74fcf6ab7cc17b1" category="section-title">Docker 관리형 플러그인 방법(버전 1.13/17.03 이상)</block>
  <block id="135b308ed83c53f1516b7c754566d1c4" category="admonition-title">시작하기 전에</block>
  <block id="070ecb002d71e4e7618a4b46a5ba690f" category="admonition">기존 데몬 방법으로 Astra Trident pRE Docker 1.13/17.03을 사용한 경우, 관리 플러그인 방법을 사용하기 전에 Astra Trident 프로세스를 중지하고 Docker 데몬을 다시 시작해야 합니다.</block>
  <block id="7bf1ee8f4e093050c1cdf1842931af7d" category="list-text">실행 중인 모든 인스턴스 중지:</block>
  <block id="47b9ec5c8c4439980c63f4188bad5324" category="list-text">Docker를 다시 시작합니다.</block>
  <block id="5311ac4d72d5c91dcaa39b896d3b8027" category="list-text">Docker Engine 17.03(새로운 1.13) 이상이 설치되어 있는지 확인합니다.</block>
  <block id="07d6db5e99a0aa19fe76f15efed30ecf" category="inline-link">설치를 설치하거나 업데이트합니다</block>
  <block id="2c3bc9d0632e0cccc05fdd3c42467df9" category="paragraph">버전이 최신 버전이 아니면<block ref="ddebe10ca17c0276898872fa2632e8fb" category="inline-link-rx"></block>.</block>
  <block id="48afbcf494fc19ee409f5aff48ae32c3" category="list-text">구성 파일을 생성하고 다음과 같이 옵션을 지정합니다.</block>
  <block id="9314e9bcd24c80b255fc3e9e697a2ada" category="list-text">config 기본 파일 이름은 config.json 이지만 원하는 이름은 파일 이름으로 config 옵션을 지정하여 사용할 수 있습니다. 구성 파일은 호스트 시스템의 '/etc/netapdvp' 디렉토리에 있어야 합니다.</block>
  <block id="8798dc2a3b5e61873054923c9f170ac7" category="list-text">로그 수준: 로깅 수준(debug, info, warn, error, fatal)을 지정합니다. 기본값은 '정보'입니다.</block>
  <block id="45ed67026a1141006588fcc698646141" category="list-text">debug: 디버그 로깅을 사용할 수 있는지 여부를 지정합니다. 기본값은 false 입니다. TRUE인 경우 로그 수준을 재정의합니다.</block>
  <block id="3bed6f89999b483af7f55024d9e7c02a" category="list-text">구성 파일의 위치를 생성합니다.</block>
  <block id="28156615c51d4bad2ee47d0a9f43f404" category="list-text">구성 파일을 생성합니다.</block>
  <block id="4e2deef4eda7b7593f1e94279c96a31d" category="list-text">관리 플러그인 시스템을 사용하여 Astra Trident를 시작합니다.</block>
  <block id="a4574d19d34a14aa0accde782f35318b" category="list-text">Astra Trident를 사용하여 구성된 시스템의 스토리지를 소모합니다.</block>
  <block id="a9c521f25a3bacb94ad1dd4705b3585f" category="list-text">"firstVolume"이라는 이름의 볼륨을 생성합니다.</block>
  <block id="4fbca4f67cbe96bc7d7a16691d2912c2" category="list-text">컨테이너가 시작될 때 기본 볼륨을 생성합니다.</block>
  <block id="b8e88709dbc4f2f80a96f53f83862704" category="list-text">"firstVolume" 볼륨을 제거합니다.</block>
  <block id="0e68ac1d84bfedf203365a9fb37db9ed" category="section-title">기존 방법(버전 1.12 이하)</block>
  <block id="2c1107bda4c1ae7904ab1835c35973b7" category="list-text">Docker 버전 1.10 이상이 설치되어 있는지 확인합니다.</block>
  <block id="b6fdfa2eab3e357687eba5ddec2bea0c" category="paragraph">버전이 최신 버전이 아니면 설치를 업데이트하십시오.</block>
  <block id="45c61654258cfd16ceec15df7df02138" category="inline-link">배포 지침을 따릅니다</block>
  <block id="07dff22faeb910f375341cfcbd4899fd" category="paragraph">또는,<block ref="9ce989a7f7f995616a47f5dd291ed229" category="inline-link-rx"></block>.</block>
  <block id="588d2fe1c60271cde75dbeba32e0b25b" category="list-text">시스템에 NFS 및/또는 iSCSI가 구성되어 있는지 확인합니다.</block>
  <block id="03fe5b0d58270efa87041677cac72ad7" category="list-text">NetApp Docker Volume Plugin 설치 및 구성:</block>
  <block id="f45f5a64dae951d3e37c9bd382201b06" category="list-text">응용 프로그램 다운로드 및 압축 풀기:</block>
  <block id="b255d9e06a4ca8e9f5bc31c9198426ad" category="list-text">용지함 경로의 위치로 이동:</block>
  <block id="ca8a5486f4257b2aef35a8e769fc51d9" category="list-text">바이너리를 배치하고 구성 파일을 생성한 후 원하는 구성 파일을 사용하여 Trident 데몬을 시작합니다.</block>
  <block id="d3fa61f14ead6cf1cf1d584cf0b6c4e1" category="admonition">지정하지 않는 한 볼륨 드라이버의 기본 이름은 "NetApp"입니다.</block>
  <block id="9ad37c975c341297c49c69353516a727" category="paragraph">데몬이 시작된 후에는 Docker CLI 인터페이스를 사용하여 볼륨을 생성하고 관리할 수 있습니다</block>
  <block id="e3dec3f86b9a3b1be209ab63855ce432" category="list-text">볼륨 생성:</block>
  <block id="5ff2e3e853922fdb84ef21b85ffdac2e" category="list-text">컨테이너를 시작할 때 Docker 볼륨 프로비저닝:</block>
  <block id="8f6a91f5f21d0478e3fd89095fc28ab9" category="list-text">Docker 볼륨 제거:</block>
  <block id="e63e2a2b9c9184e703ff8d93bb92508b" category="section-title">시스템 시작 시 Astra Trident를 시작합니다</block>
  <block id="34f4e076aba0519cebd8bb63617b2f7e" category="paragraph">systemd 기반 시스템의 샘플 단위 파일은 git repo의 'eemb/trident.service.example` 에서 찾을 수 있습니다. CentOS/RHEL에서 파일을 사용하려면 다음을 수행하십시오.</block>
  <block id="5b51496da86e5a2073e0c618390c3d2a" category="list-text">파일을 올바른 위치에 복사합니다.</block>
  <block id="44103de0a164f687d305ad91e919d8ee" category="paragraph">실행 중인 인스턴스가 두 개 이상인 경우 단위 파일에 고유한 이름을 사용해야 합니다.</block>
  <block id="3223aadc84a3ccb4a3473ba01c895184" category="list-text">파일을 편집하고 설명(행 2)을 드라이버 이름과 구성 파일 경로(줄 9)에 맞게 변경하여 환경을 반영합니다.</block>
  <block id="1edae3931401a32d7dd7dd6e0a2ad563" category="list-text">IT 부서에서 변경 사항을 수집하도록 시스템 다시 로드:</block>
  <block id="db38a93e27eba57d507611d002ad612f" category="list-text">서비스를 활성화합니다.</block>
  <block id="c7e0a4deeebe264aa7d5f7f3ca3ef77f" category="paragraph">이 이름은 '/usr/lib/systemd/system' 디렉토리에 있는 파일의 이름에 따라 달라집니다.</block>
  <block id="baa04490a79e9e8de7fa4cd44e2c6fbb" category="list-text">서비스를 시작합니다.</block>
  <block id="93c7574cf83c1f01b04891cf2d826cea" category="list-text">상태를 봅니다.</block>
  <block id="f4f15418284ae7a01b27fccc1af0463a" category="admonition">단위 파일을 수정할 때마다 'stemctl daemon -reload' 명령을 실행하여 변경 사항을 확인합니다.</block>
  <block id="27dce2b92c5c5b89e353888e6cb24dea" category="summary">사용 중인 볼륨에 영향을 주지 않고 Docker용 Astra Trident를 안전하게 업그레이드할 수 있습니다. 업그레이드 프로세스 중에는 플러그인에서 지시하는 docker volume 명령이 성공하지 못하는 짧은 기간이 있으며 플러그인이 다시 실행될 때까지 응용 프로그램에서 볼륨을 마운트할 수 없습니다. 대부분의 경우 몇 초 이내에 완료됩니다.</block>
  <block id="0350c5473efd300324aaaadeecc676d2" category="doc">Astra Trident를 업그레이드하거나 제거합니다</block>
  <block id="f683581d3e75f05f9d9215f9b4696cef" category="section-title">업그레이드</block>
  <block id="ed279061e829314cb0dc7a1708ca5e5b" category="list-text">기존 볼륨 나열:</block>
  <block id="7c256ad076320e18e087b238e9063f3f" category="list-text">플러그인 비활성화:</block>
  <block id="f4ea3e4191f5bda0b91e08059bf9842a" category="list-text">플러그인 업그레이드:</block>
  <block id="b2449107a206e37587b47513f76a7b27" category="admonition">Astra Trident의 18.01 릴리스는 nDVP를 대체합니다. 'NetApp/ndvp-plugin' 이미지에서 'NetApp/트리덴트 - 플러그인' 이미지로 직접 업그레이드해야 합니다.</block>
  <block id="824ba648551a27da6c43705bcd663830" category="list-text">플러그인 활성화:</block>
  <block id="e4c48899ce42f4eb019f54a1a8e66560" category="list-text">플러그인이 활성화되어 있는지 확인합니다.</block>
  <block id="c4d884c606b57bb6cb43864e3499d5a2" category="list-text">볼륨이 표시되는지 확인합니다.</block>
  <block id="103e515a078c6f2419abc4c84554d67c" category="admonition">Astra Trident(20.10 이전)의 이전 버전에서 Astra Trident 20.10 이상으로 업그레이드하는 경우 오류가 발생할 수 있습니다. 자세한 내용은 을 참조하십시오 <block ref="6d21ff1c2708107ac3f4ed1a6e27b449" category="inline-link-macro-rx"></block>. 오류가 발생하면 먼저 플러그인을 비활성화하고 플러그인을 제거한 다음 추가 구성 매개 변수 "docker plugin install NetApp/trident-plugin:20.10 -- alias NetApp --grant-all-permissions config=config.json"을 전달하여 필요한 Astra Trident 버전을 설치해야 합니다</block>
  <block id="a27dfe771799a09fd55fea73286eb6ab" category="section-title">설치 제거</block>
  <block id="7578be09dc225364649898a30619a336" category="paragraph">Docker용 Astra Trident를 제거하려면 다음 단계를 수행하십시오.</block>
  <block id="867d93c3d1de0e8e75fa408cfadcbba5" category="list-text">플러그인이 생성한 모든 볼륨을 제거합니다.</block>
  <block id="4a28a108f39c07ac09218644ca6e9bb0" category="list-text">플러그인 제거:</block>
  <block id="4cfa22b281cbd36e1a275d61ec23a9b4" category="summary">문제 해결에 도움이 되는 로그를 수집할 수 있습니다. 로그를 수집하는 방법은 Docker 플러그인을 실행하는 방법에 따라 다릅니다.</block>
  <block id="fe1786b49549e8e06a89b9c57d7fc514" category="doc">로그를 수집합니다</block>
  <block id="83f4d02d2dd31f09291e098bf4ae502b" category="list-text">권장 관리 플러그인 방법(예: docker plugin 명령 사용)을 사용하여 Astra Trident를 실행 중인 경우 다음과 같이 봅니다.</block>
  <block id="17c40798131b12188d43b1a90dabfc69" category="paragraph">표준 로깅 수준에서는 대부분의 문제를 진단할 수 있어야 합니다. 충분하지 않은 경우 디버그 로깅을 활성화할 수 있습니다.</block>
  <block id="c28722abec5c1daefa02916119bbff91" category="list-text">디버그 로깅을 사용하려면 디버그 로깅을 사용하도록 설정한 플러그인을 설치합니다.</block>
  <block id="b142025dd533fb27bf7df1a93c55e311" category="paragraph">또는 플러그인이 이미 설치된 경우 디버그 로깅을 활성화합니다.</block>
  <block id="98e6888e14bd8bcd734870a8331ca6ea" category="list-text">호스트에서 바이너리 자체를 실행하는 경우 호스트의 '/var/log/netapp dvp' 디렉토리에서 로그를 사용할 수 있습니다. 디버그 로깅을 사용하려면 플러그인을 실행할 때 '-debug'를 지정합니다.</block>
  <block id="2aa0797ce5da04d1c6f027c9b3276483" category="section-title">일반적인 문제 해결 팁</block>
  <block id="94d799ff06bdb0aedb7b64151dac73d7" category="list-text">새 사용자가 실행하는 가장 일반적인 문제는 플러그 인을 초기화할 수 없도록 잘못 구성된 것입니다. 이 경우 플러그인을 설치하거나 활성화하려고 할 때 다음과 같은 메시지가 표시될 수 있습니다.</block>
  <block id="fe6b4529e706ebc0f7e3668d3230d029" category="paragraph">"데몬으로부터 오류 응답: UNIX/run/docker/plugins/&lt;id&gt;/NetApp.sock:connect:해당 파일 또는 디렉토리 없음</block>
  <block id="3d924bd43304301ed127cbbd303a4fa6" category="paragraph">즉, 플러그인을 시작하지 못했습니다. 다행히 플러그인은 사용자가 겪을 수 있는 대부분의 문제를 진단하는 데 도움이 되는 포괄적인 로깅 기능을 갖추고 있습니다.</block>
  <block id="79c820c2d64495c47651e58e73f97294" category="list-text">PV를 컨테이너에 마운트하는 데 문제가 있는 경우 rpcbind가 설치되어 실행되고 있는지 확인합니다. 호스트 OS에 필요한 패키지 관리자를 사용하고 rpcbind가 실행 중인지 확인합니다. 'stemctl status rpcbind' 또는 이와 동등한 기능을 실행하여 rpcbind 서비스의 상태를 확인할 수 있습니다.</block>
  <block id="2358ca3eef46b0e25466e80dbea7ea4b" category="summary">Astra Trident 구성에 사용할 수 있는 구성 옵션을 확인하십시오.</block>
  <block id="34e1f7eb303c0a150cd440611b3b5e24" category="doc">스토리지 구성 옵션</block>
  <block id="51f834b47bcd78a0f4f40fd8ca40446f" category="section-title">글로벌 구성 옵션</block>
  <block id="b22d82aea9557ba6aa7b915d40309d9b" category="paragraph">이러한 구성 옵션은 사용 중인 스토리지 플랫폼에 관계없이 모든 Astra Trident 구성에 적용됩니다.</block>
  <block id="63b276a6c28274ed5e553d4ce3fe7eb1" category="paragraph">구성 파일 버전 번호입니다</block>
  <block id="c4ca4238a0b923820dcc509a6f75849b" category="paragraph">1</block>
  <block id="ac5eb8fcbd1ed9c85a98d91e10e26a38" category="paragraph">스토리지 드라이버 이름입니다</block>
  <block id="86561da64fcea64abfe5587158ea1c15" category="paragraph">ONTAP-NAS, ONTAP-SAN, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, 졸idfire-san, Azure-NetApp-files, AWS-CV, GCP-CV</block>
  <block id="3f2b20ce3aa5e39b0dbfe20326747a7b" category="paragraph">볼륨 이름에 대한 선택적 접두사입니다. 기본값: “netapdvp_”.</block>
  <block id="46fa46eed970046d03e2dedc95cdc83b" category="paragraph">스테이징 _</block>
  <block id="fcf783284187f1e80e772eacd9266ee1" category="paragraph">볼륨 크기에 대한 선택적 제한. 기본값: ""(강제 적용 안 됨)</block>
  <block id="75da9d6de91e782eca4fa00341367135" category="paragraph">10G</block>
  <block id="3eed2a7dac1f2329f3a9574a68e5e1c4" category="admonition">요소 백엔드에 'toragePrefix'(기본값 포함)를 사용하지 마십시오. 기본적으로 '졸idfire-san' 드라이버는 이 설정을 무시하고 접두어를 사용하지 않습니다. Docker 볼륨 매핑에 특정 tenantID를 사용하거나 이름 문지가 사용된 경우 Docker의 Docker 버전, 드라이버 정보 및 원시 이름으로 채워진 특성 데이터를 사용하는 것이 좋습니다.</block>
  <block id="0863f9e97e159e3ea1ce46bdb49b1254" category="paragraph">생성하는 모든 볼륨에서 기본 옵션을 지정하지 않아도 됩니다. '크기' 옵션은 모든 컨트롤러 유형에 사용할 수 있습니다. 기본 볼륨 크기를 설정하는 방법은 ONTAP 구성 섹션을 참조하십시오.</block>
  <block id="41ad23e0468b5a035cae097ac8b28bb9" category="paragraph">새 볼륨의 선택적 기본 크기입니다. 기본값: “1G”</block>
  <block id="08aa1584c9a5791fb64b0f7f1453f9eb" category="paragraph">10G</block>
  <block id="0353522b39b87d54d40d3f09ec668851" category="section-title">ONTAP 구성</block>
  <block id="cd536bce1bed61366e8d17a85fe6678a" category="paragraph">위의 글로벌 구성 값 외에도 ONTAP를 사용할 경우 다음과 같은 최상위 옵션을 사용할 수 있습니다.</block>
  <block id="464779f3491153dd1e79ddbd8a81e3f0" category="paragraph">ONTAP 관리 LIF의 IP 주소입니다. FQDN(정규화된 도메인 이름)을 지정할 수 있습니다.</block>
  <block id="190dafab69706a67221c1226360de7dc" category="paragraph">10.0.0.1</block>
  <block id="bfdeb0e1ca992a3dcb6853265e453e21" category="paragraph">프로토콜 LIF의 IP 주소이며 지정하지 않을 경우 파생됩니다. "ONTAP-NAS" 드라이버 * 에만 * FQDN을 지정할 수 있으며, 이 경우 FQDN이 NFS 마운트 작업에 사용됩니다. 'ONTAP-SAN' 드라이버의 경우, 기본값은 SVM의 모든 데이터 LIF IP를 사용하고 iSCSI 다중 경로를 사용하는 것입니다. ONTAP-SAN 드라이버에 대한 다LIF의 IP 주소를 지정하면 드라이버가 다중 경로를 비활성화하고 지정된 주소만 사용하게 됩니다.</block>
  <block id="98a2cd7efa1ba950d42e42af495c4248" category="paragraph">10.0.0.2</block>
  <block id="11053eb2b6ac6e8802c67c054cf55ad9" category="paragraph">사용할 스토리지 가상 머신(관리 LIF가 클러스터 LIF인 경우 필요)</block>
  <block id="b26399fddd6473c150b4e7528fb04fdc" category="paragraph">SVM_NFS 를 클릭합니다</block>
  <block id="723a179bbb9fc3c4f12cf296a8841b27" category="paragraph">스토리지 디바이스에 접속할 사용자 이름입니다</block>
  <block id="6173aa5206484b5224450952747c7148" category="paragraph">vsadmin을 선택합니다</block>
  <block id="8cf10281cf3b9290d5988c57a7d19693" category="paragraph">스토리지 디바이스에 연결하는 암호입니다</block>
  <block id="5ebe2294ecd0e0f08eab7690d2a6ee69" category="paragraph">비밀</block>
  <block id="7e6d207f2b120c6cc9caa98510aa51c6" category="cell">골재</block>
  <block id="ac53191a99c328660eafa4696375dbfb" category="paragraph">프로비저닝을 위한 애그리게이트(선택 사항, SVM에 셋팅해야 하는 경우) ONTAP-NAS-Flexgroup 드라이버의 경우 이 옵션이 무시됩니다. SVM에 할당된 모든 애그리게이트는 FlexGroup 볼륨을 프로비저닝하는 데 사용됩니다.</block>
  <block id="70d2c7701d2837552c0a38c02a326592" category="paragraph">aggr1</block>
  <block id="925060a0c0a15f99ef1bee43f1660ea4" category="paragraph">선택 사항으로, 사용량이 이 백분율보다 높을 경우 용량 할당에 실패합니다</block>
  <block id="f819de81247be4a5428dc0e169de28b8" category="paragraph">75%</block>
  <block id="876885770cf58d20ef5672cc5594e85d" category="inline-link">NFS 호스트 구성 정보는 여기 를 참조하십시오</block>
  <block id="0a19ca3d1db7e5bc24b58f73b91c3f49" category="paragraph">NFS 마운트 옵션을 세밀하게 제어합니다. 기본값은 "-o nfsvers=3"입니다. * ONTAP-NAS 및 ONTAP-NAS-이코노미 드라이버에만 사용 가능 *.<block ref="71f7a3f48cfd3876cffba401813b7db0" category="inline-link-rx"></block>.</block>
  <block id="301c869c551e12d862ab0291837102a0" category="paragraph">o nfsvers = 4</block>
  <block id="00d72747af4eb1f0bab120935efe88fe" category="paragraph">플러그인에서 사용되는 igroup. 기본값은 “netapdvp”입니다. * ONTAP-SAN driver * 에서만 사용 가능.</block>
  <block id="79e762988462f6f8da9becfbfd789755" category="paragraph">myigroup</block>
  <block id="5c5adadf8175fd69d4af9bfdb608c42c" category="paragraph">최대 요청 가능 볼륨 크기 및 qtree 상위 볼륨 크기. * 이 옵션은 'ONTAP-NAS-이코노미' 드라이버의 경우 FlexVol의 크기를 추가로 제한합니다 *.</block>
  <block id="f07e606cfe25ac6fb07d9c4af941d9a2" category="paragraph">300g</block>
  <block id="981ba910eb0ffc42f42059de056624b4" category="paragraph">FlexVol당 최대 qtree는 범위 [50, 300]에 있어야 하며 기본값은 200입니다. * 'ONTAP-NAS-이코노미' 드라이버의 경우 이 옵션을 사용하여 FlexVol*당 최대 qtree 수를 사용자 지정할 수 있습니다.</block>
  <block id="94f6d7e04a4d452035300f18b984988c" category="paragraph">300</block>
  <block id="3890063556e337d458019437f027030b" category="paragraph">생성하는 모든 볼륨에 기본 옵션을 지정하지 않아도 됩니다.</block>
  <block id="887ba6a0090fff5ace8889efb3b766af" category="paragraph">공간 예약 모드, "없음"(씬 프로비저닝) 또는 "볼륨"(일반)</block>
  <block id="334c4a4c42fdb79d7ebc3e73b517e6f8" category="paragraph">없음</block>
  <block id="b614ecafc9c9bbcd0206b519e5481f8d" category="paragraph">사용할 스냅샷 정책, 기본값은 "없음"입니다.</block>
  <block id="e35ead0e9e7038a6c58695bfa4741686" category="paragraph">Snapshot reserve percentage, 기본값은 ""이며 ONTAP의 기본값을 사용합니다</block>
  <block id="d3d9446802a44259755d38e6d163e820" category="paragraph">10</block>
  <block id="eb28cb6308c229ba4561cf02d78b9a07" category="paragraph">생성 시 복제본을 상위 복제본에서 분할합니다. 기본값은 "false"입니다.</block>
  <block id="988726bbf32c455be56acbfb0da3aad0" category="paragraph">NetApp 볼륨 암호화 활성화, 기본값 "false"</block>
  <block id="b326b5062b2f0e69046810717534cb09" category="paragraph">참</block>
  <block id="a3b703e23c8d0caf2b2fb4f46057013b" category="paragraph">프로비저닝된 NFS 볼륨에 대한 NAS 옵션, 기본값: “777”</block>
  <block id="f1c1592588411002af340cbaedd6fc33" category="paragraph">777</block>
  <block id="525eba0ced0a1c122a9112c4d10fbdc2" category="paragraph">".snapshot" 디렉토리에 액세스하기 위한 NAS 옵션은 기본적으로 "false"로 설정됩니다.</block>
  <block id="b60dd25e9d373b87424c30a74da2703f" category="paragraph">사용할 NFS 엑스포트 정책의 NAS 옵션, 기본값: "기본값"</block>
  <block id="c21f969b5f03d33d43e04f8f136e7682" category="paragraph">기본값</block>
  <block id="af6bd5b29a0589f7c6a47f47fae230c7" category="paragraph">프로비저닝된 NFS 볼륨에 액세스하기 위한 NAS 옵션, 기본값은 "UNIX"입니다.</block>
  <block id="1d770934d44de09b0d24f04fd01708ba" category="paragraph">혼합</block>
  <block id="79c6531f572824f3178c8b1fb0f35d26" category="paragraph">파일 시스템 유형을 선택하는 SAN 옵션, 기본값은 "ext4"로 설정됩니다.</block>
  <block id="310201b6353c5f38bc039e0e51b079d3" category="paragraph">XFS</block>
  <block id="3cec6d01b4f10a61939982ecfb47fc7f" category="paragraph">사용할 계층화 정책, 기본값은 "없음", ONTAP 9.5 이전 SVM-DR 구성의 경우 "스냅샷 전용"입니다</block>
  <block id="90adf331b7868c7af46ad6e035e93844" category="section-title">축척 옵션</block>
  <block id="493a6606c4789fad3c7317b99cb563d0" category="paragraph">ONTAP-NAS와 ONTAP-SAN 드라이버는 각 Docker 볼륨에 대해 ONTAP FlexVol를 생성합니다. ONTAP는 최대 12,000개의 FlexVol 클러스터를 사용하여 클러스터 노드당 최대 1,000개의 FlexVol을 지원합니다. Docker 볼륨 요구 사항이 이러한 제한 범위 내에 있을 경우 Docker 볼륨 세부 스냅샷 및 클론 복제와 같은 FlexVol에서 제공되는 추가 기능 때문에 'ONTAP-NAS' 드라이버가 선호되는 NAS 솔루션입니다.</block>
  <block id="b8f30e4086b754ccaf7bd5d01d8df137" category="paragraph">FlexVol에 허용 가능한 것보다 더 많은 Docker 볼륨이 필요한 경우 ONTAP-NAS-이코노미 또는 ONTAP-SAN-이코노미 드라이버를 선택합니다.</block>
  <block id="50710f3a4715e3f874848944b6b54e28" category="paragraph">'ONTAP-NAS-이코노미' 드라이버는 자동으로 관리되는 FlexVol 풀 내에 ONTAP qtree로 Docker 볼륨을 생성합니다. qtree는 일부 기능을 희생하여 클러스터 노드당 최대 100,000 및 클러스터당 2,400,000까지 훨씬 더 뛰어난 확장을 제공합니다. 'ONTAP-NAS-G경제적인' 드라이버는 Docker 볼륨의 세분화된 스냅샷 또는 클론 복제를 지원하지 않습니다.</block>
  <block id="0c8b91c6c2ba9c892f3eea2cd9c86cd1" category="admonition">Swarm은 여러 노드에서 볼륨 생성을 조율하지 않으므로 현재 Docker Swarm에서 ONTAP-NAS-이코노미 드라이버가 지원되지 않습니다.</block>
  <block id="5849dbe631db5b1e1b365f9f2f84ff60" category="paragraph">ONTAP-SAN-이코노미 드라이버는 자동으로 관리되는 FlexVol의 공유 풀 내에 Docker 볼륨을 ONTAP LUN으로 생성합니다. 이렇게 하면 각 FlexVol가 하나의 LUN에만 제한되지 않으며 SAN 워크로드에 더 나은 확장성을 제공합니다. 스토리지 시스템에 따라 ONTAP는 클러스터당 최대 16384개의 LUN을 지원합니다. 볼륨이 그 아래에 LUN이 있으므로 이 드라이버는 Docker 볼륨 세부 스냅샷 및 클론 복제를 지원합니다.</block>
  <block id="65e92c8f7fa9750b795cc1046328cf06" category="paragraph">수십 억 개의 파일로 구성된 페타바이트 용량으로 확장할 수 있는 단일 볼륨의 병렬 처리를 늘리려면 ONTAP-NAS-Flexgroup 드라이버를 선택하십시오. FlexGroups의 이상적인 사용 사례로는 AI/ML/DL, 빅데이터 및 분석, 소프트웨어 빌드, 스트리밍, 파일 저장소 등이 있습니다. Trident는 FlexGroup 볼륨을 프로비저닝할 때 SVM에 할당된 모든 애그리게이트를 사용합니다. Trident의 FlexGroup 지원에도 다음과 같은 고려 사항이 있습니다.</block>
  <block id="9d83b6d2e2b099e63bf8e2fc8c870893" category="list-text">ONTAP 버전 9.2 이상이 필요합니다.</block>
  <block id="e7c74973b26ad51b9db42a9c347a8cd4" category="list-text">이번 작부터 FlexGroups는 NFS v3만 지원합니다.</block>
  <block id="02a100b04add3b90fddef64499e825a2" category="list-text">SVM에 대해 64비트 NFSv3 식별자를 사용하는 것이 좋습니다.</block>
  <block id="496f8625569b787269edab0f3de973da" category="list-text">최소 권장 FlexGroup 크기는 100GB입니다.</block>
  <block id="db78b2a7acf43fa03cd95fb3a77c82f9" category="list-text">FlexGroup 볼륨에 대해서는 클론 생성이 지원되지 않습니다.</block>
  <block id="f5ac1e3c252855373c7f660dbd89699d" category="inline-link">NetApp FlexGroup 볼륨 모범 사례 및 구현 가이드 를 참조하십시오</block>
  <block id="df1a7e79743809601db1d20d6a33ae52" category="paragraph">FlexGroups에 적합한 FlexGroups 및 워크로드에 대한 자세한 내용은 를 참조하십시오<block ref="b8a99695d7979127a1cab07b42e22743" category="inline-link-rx"></block>.</block>
  <block id="b30b6b60171d85877ea91897bdd6faed" category="paragraph">같은 환경에서 고급 기능과 대규모 확장을 위해 ONTAP-NAS를 사용하는 Docker Volume Plugin과 ONTAP-NAS-E경제적인 인스턴스를 여러 개 실행할 수 있습니다.</block>
  <block id="0c0f6724044ed44fb85d2ce3193cb7c3" category="section-title">ONTAP 구성 파일의 예</block>
  <block id="9420b5e8ed08a163eeafb1d5026f74be" category="paragraph">* 'ONTAP-NAS' 드라이버용 NFS 예 *</block>
  <block id="c26e7b2e60e156979940cd72ed83d0b9" category="paragraph">* 'ONTAP-NAS-Flexgroup' 드라이버의 NFS 예 *</block>
  <block id="3a57e82fd5f9855754a03019c433aff7" category="paragraph">* 'ONTAP-NAS-이코노미' 드라이버용 NFS 예 *</block>
  <block id="2bfad97b56e71c619e45f6d4c2e4c2e2" category="paragraph">* 'ONTAP-SAN' 드라이버용 iSCSI 예 *</block>
  <block id="98f803effb81ad687bcd941b70439aaa" category="paragraph">* 'ONTAP-SAN-이코노미' 드라이버용 NFS 예시 *</block>
  <block id="ffe54c343031d16e77db73e2d950e277" category="section-title">Element 소프트웨어 구성</block>
  <block id="3afcd136a7bffa20fc39ba6581412cd2" category="paragraph">Element 소프트웨어(NetApp HCI/SolidFire)를 사용하는 경우 글로벌 구성 값 외에도 이러한 옵션을 사용할 수 있습니다.</block>
  <block id="6f8cfcd7221d73b0e27985966dfd6e1f" category="paragraph"><block ref="608956a9224818c204ba64e5dd4b5f0c" category="inline-link-rx"></block></block>
  <block id="501aa777bd36217575e7547e7fed62cb" category="paragraph"><block ref="501aa777bd36217575e7547e7fed62cb" category="inline-link-rx"></block></block>
  <block id="c61f15977fe4efa0866eea87fb740cda" category="paragraph">iSCSI IP 주소 및 포트</block>
  <block id="6a6b63874c664c103982f6d422c6384e" category="paragraph">10.0.0.7:3260</block>
  <block id="72deb2676231ab8e068ef60dd89edd4c" category="paragraph">사용할 SolidFireF 테넌트(찾을 수 없는 경우 생성됨)</block>
  <block id="5eda5112bf8affeb1d2cd8eea6302076" category="paragraph">“Docker”</block>
  <block id="d2672389886b173aef703433f7e4b89b" category="paragraph">iSCSI 트래픽을 기본 인터페이스가 아닌 인터페이스로 제한할 때 인터페이스를 지정합니다</block>
  <block id="5935dcd024929bc7086bb230802bf576" category="paragraph">아래 예를 참조하십시오</block>
  <block id="5e9bf55f849ccc5a31a50d1fa784d28c" category="cell">레가시NamePrefix</block>
  <block id="db7adc3775b0b56c59ce4263fbd79fbf" category="paragraph">업그레이드된 Trident 설치의 접두사 1.3.2 이전 버전의 Trident를 사용하고 기존 볼륨을 업그레이드하는 경우 이 값을 설정하여 볼륨 이름 방법을 통해 매핑된 이전 볼륨에 액세스해야 합니다.</block>
  <block id="8d3aa50a0f9c3c059677927a3fbbfcda" category="paragraph">“netapdvp-”</block>
  <block id="36f9c7b615268efec7f4c56c387a55bb" category="paragraph">졸idfire-san 드라이버는 Docker Swarm을 지원하지 않습니다.</block>
  <block id="1059bb8540c48e6b455e802384bad65d" category="section-title">Element 소프트웨어 구성 파일의 예</block>
  <block id="8898f8d83fe6ae40ee889ae1b53dd2a1" category="section-title">AWS 구성에서 CVS(Cloud Volumes Service</block>
  <block id="51a61fe7c333c9b247fa4a36f100af60" category="paragraph">글로벌 구성 값 외에도 AWS에서 CVS를 사용할 경우 이러한 옵션을 사용할 수 있습니다. 필요한 값은 모두 CVS 웹 사용자 인터페이스에서 사용할 수 있습니다.</block>
  <block id="87cb49c3ba3ad2b7881daec6cbe2c058" category="paragraph">CVS 계정 지역(필수) CVS 웹 포털의 계정 설정 &gt; API 액세스에서 찾을 수 있습니다.</block>
  <block id="ab62ad1f18caedc5173216159619af30" category="paragraph">"미국 - 동부 - 1"</block>
  <block id="72bb1da9c467950d42f276dd60372f9d" category="paragraph">CVS 계정 API URL(필수) CVS 웹 포털의 계정 설정 &gt; API 액세스에서 찾을 수 있습니다.</block>
  <block id="90ecc3761b44b9c5f99193048d67b991" category="paragraph">“https://cds-aws-bundles.netapp.com:8080/v1” 참조하십시오</block>
  <block id="14d4df12da21ca887a11026db7d26c5a" category="paragraph">CVS 계정 API 키(필수) CVS 웹 포털의 계정 설정 &gt; API 액세스에서 찾을 수 있습니다.</block>
  <block id="49df949d63ad2fe5a679bea21beb739f" category="paragraph">CVS 계정 비밀 키(필수). CVS 웹 포털의 계정 설정 &gt; API 액세스에서 찾을 수 있습니다.</block>
  <block id="eccfbdf9565fdb1f0b53121d07c0ca4d" category="paragraph">프록시 서버가 CVS 계정에 연결해야 하는 경우 프록시 URL입니다. 프록시 서버는 HTTP 프록시 또는 HTTPS 프록시일 수 있습니다. HTTPS 프록시의 경우 프록시 서버에서 자체 서명된 인증서를 사용할 수 있도록 인증서 유효성 검사를 건너뜁니다. * 인증이 활성화된 프록시 서버는 지원되지 않습니다 *.</block>
  <block id="58b40a255bdd79778c81b51b0189d3bc" category="paragraph">“http://proxy-server-hostname/” 참조하십시오</block>
  <block id="1fc4f89077ac8f740a8209cb13dad780" category="paragraph">NFS 마운트 옵션, 기본값: "-o nfsvers=3"</block>
  <block id="c0c057b1fbdbb4b3fbff5af024800013" category="paragraph">“nfsvers=3, proto=tcp, timeo=600”</block>
  <block id="989640232ebd1cee1600241dcaf3092b" category="paragraph">성능 수준(표준, 프리미엄, 익스트림), 기본값: "표준"</block>
  <block id="6dc6830d3f5eeef9925e20cb2872face" category="paragraph">“프리미엄”</block>
  <block id="4c4783b692750885787114cffe439cc4" category="admonition">NetApp Cloud Volumes Service for AWS는 100GB 미만의 볼륨을 지원하지 않습니다. 보다 쉽게 애플리케이션을 배포할 수 있도록 작은 볼륨이 요청되는 경우 Trident가 자동으로 100GB 볼륨을 생성합니다.</block>
  <block id="2141207c4b192cfda3ca9862d3051c75" category="paragraph">AWS에서 CVS를 사용하는 경우 이러한 기본 볼륨 옵션 설정을 사용할 수 있습니다.</block>
  <block id="0b4473f186b60c3a658cb10df719e6e7" category="paragraph">NFS 액세스 목록(주소 및/또는 CIDR 서브넷)의 기본값은 "0.0.0.0/0"입니다.</block>
  <block id="4fd06576654815d69b61384ef4f9e084" category="paragraph">“10.0.1.0 / 24,10.0.2.100”</block>
  <block id="6cac9fafaf62c70b75f827e614328121" category="paragraph">스냅숏 예비 공간 비율, 기본값은 " "로, CVS 기본값을 0으로 적용합니다</block>
  <block id="c669350437225628cf4fcc3d0ec9d8f6" category="paragraph">“10”</block>
  <block id="24e52229704d0addd6cb9915c2e78093" category="paragraph">볼륨 크기, 기본값: "100GB"</block>
  <block id="36a1049642c95770e66c6905f890a00a" category="paragraph">“500G”</block>
  <block id="f0fe7c79add8387e161dd776e6af2313" category="section-title">AWS 구성 파일의 CVS 예</block>
  <block id="4c4a4e3967b80166b1c89a42bb702c5c" category="section-title">GCP 구성의 Cloud Volumes Service(CVS</block>
  <block id="c731f72e1d22a7c5e01a7cb789a8885e" category="inline-link">GCP</block>
  <block id="16aba044aae8d4a1f104875fadfa8b7a" category="paragraph">Trident는 이제 기본 CVS 서비스 유형을 사용하여 더 작은 볼륨에 대한 지원을 제공합니다<block ref="ba449b67e05ccd893d094c64611dfdac" category="inline-link-rx"></block>. 'torageClass=software'로 생성된 백엔드의 경우 볼륨은 이제 최소 프로비저닝 크기가 300GiB가 됩니다. * NetApp은 고객이 비운영 워크로드에 1TiB 미만의 볼륨을 사용할 것을 권장합니다 *. CVS는 현재 제어된 가용성 하에서 이 기능을 제공하며 기술 지원을 제공하지 않습니다.</block>
  <block id="6d43083e1ac79c6ae1d612b064c50415" category="admonition">1TiB 미만의 볼륨에 액세스하려면 등록하십시오<block ref="daab940ca038632df7b3bcdb2ce67b4b" category="inline-link-rx"></block>.</block>
  <block id="13c75fbfea8d654533aa97741ee726eb" category="admonition">기본 CVS 서비스 유형의 'torageClass=software'를 사용하여 백엔드를 배포할 때는 해당 프로젝트 번호 및 프로젝트 ID에 대해 GCP의 1TiB 미만의 볼륨 기능에 대한 액세스 권한을 얻어야 합니다. Trident에서 1TiB 미만의 볼륨을 프로비저닝하는 데 이 작업이 필요합니다. 그렇지 않은 경우, 600GiB 미만의 PVC에 대해 체적 생성 * 이 실패합니다. 를 사용하여 1TiB 미만의 볼륨에 대한 액세스 권한을 얻습니다<block ref="d5347d47b24e3303f1c7b0ae61e08dc7" category="inline-link-rx"></block>.</block>
  <block id="8a5a1d824b8678ed57f0b091512af961" category="paragraph">Trident에서 기본 CVS 서비스 수준을 위해 생성한 볼륨은 다음과 같이 프로비저닝됩니다.</block>
  <block id="17e388f76e4ab809d67d7da3f508f16e" category="list-text">300GiB보다 작은 PVC로 인해 Trident가 300GiB CVS 볼륨을 생성합니다.</block>
  <block id="c12c279867b9062aac25467988994298" category="list-text">300GiB에서 600GiB 사이인 PVC로 인해 Trident가 요청된 크기의 CVS 볼륨을 생성합니다.</block>
  <block id="4ff78214fe676a45289036b058361170" category="list-text">PVCs가 600GiB에서 1TiB 사이인 경우 Trident가 1TiB CVS 볼륨을 생성합니다.</block>
  <block id="de59c7ff95f1d72edb04ee0b3b70de27" category="list-text">1TiB보다 큰 PVC로 인해 Trident가 요청된 크기의 CVS 볼륨을 생성합니다.</block>
  <block id="49821db5dac692677dc0f49801db61dd" category="paragraph">글로벌 구성 값 외에도 GCP에서 CVS를 사용할 경우 이러한 옵션을 사용할 수 있습니다.</block>
  <block id="2ecba853d55bf844defef38593bfeddd" category="paragraph">CVS 계정 지역(필수) 이 백엔드에서 볼륨을 프로비저닝할 GCP 영역입니다.</block>
  <block id="91730af327707bec713a5f18f6d8df6a" category="paragraph">"미국 2"</block>
  <block id="44242a2deef719f96982e82f0be8fc65" category="paragraph">GCP 프로젝트 번호(필수). GCP 웹 포털의 홈 화면에서 찾을 수 있습니다.</block>
  <block id="d4445a55440abc4ee9235c02b46555b3" category="paragraph">“123456789012”</block>
  <block id="1a269fb3ec0496720ca75e984d8de40e" category="cell">hostProjectNumber입니다</block>
  <block id="e34e53c32d906addf366532becb0dcd1" category="paragraph">GCP 공유 VPC 호스트 프로젝트 번호(공유 VPC를 사용하는 경우 필요)</block>
  <block id="efd711f7b98e2f0003cbf70aa18a14c0" category="paragraph">“098765432109”</block>
  <block id="2c3fb314d5e72bbcae6b7a25d5b8edaa" category="paragraph">CVS 관리자 역할을 가진 GCP 서비스 계정의 API 키입니다(필수). 은 GCP 서비스 계정의 개인 키 파일(백엔드 구성 파일에 verbatim 복사)의 JSON 형식 컨텐츠입니다. 서비스 계정에 netappcloudvolumes.admin 역할이 있어야 합니다.</block>
  <block id="6a17ea7b1fdab79ffd3eddf255aaf46d" category="paragraph">(개인 키 파일의 내용)</block>
  <block id="1631dca111b8c1a922c7f29d48eb7121" category="cell">네트워크</block>
  <block id="bbf068b3542ca7b12963602ea10acbfa" category="paragraph">CVS 볼륨에 사용되는 GCP 네트워크, 기본값: “기본값”</block>
  <block id="69cd8c867e8af214f6e9c04138d56ff5" category="admonition">공유 VPC 네트워크를 사용하는 경우 projectNumber와 hostProjectNumber를 모두 지정해야 합니다. 이 경우 projectNumber는 서비스 프로젝트이고 hostProjectNumber는 호스트 프로젝트입니다.</block>
  <block id="ac4650c60f6238dc7461aa20cf40d081" category="admonition">NetApp Cloud Volumes Service for GCP는 크기 100GiB 미만의 CVS - 성능 볼륨 또는 크기 300GiB 미만의 CVS 볼륨을 지원하지 않습니다. Trident는 애플리케이션 구축을 더 쉽게 할 수 있도록 너무 작은 볼륨을 요청하는 경우 최소 크기의 볼륨을 자동으로 생성합니다.</block>
  <block id="0075471554ab0900a2a82a3481e9d1a2" category="paragraph">GCP에서 CVS를 사용하는 경우 이러한 기본 볼륨 옵션 설정을 사용할 수 있습니다.</block>
  <block id="7946d615645dcc579e9f7d0ea1ab5dce" category="paragraph">볼륨 크기, 기본값: "100GiB"</block>
  <block id="6dd08dbe0437571ae84c751c0d9e7db2" category="paragraph">“10T”</block>
  <block id="14d7cea065a37d05840128a2193e5d0b" category="section-title">GCP 구성 파일의 예 CVS</block>
  <block id="e303017ec184887efb9bebcc178d78c5" category="section-title">Azure NetApp Files 구성</block>
  <block id="83e44b4ce45c0f8e6a65a21d4dd12587" category="paragraph">를 구성하고 사용합니다<block ref="24a785881ff1cdf191a2239811dc9597" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="3f72ed4087b557a1841662fa1eec0927" category="list-text">Azure NetApp Files가 활성화된 Azure 구독의 'SubscriptionID'입니다</block>
  <block id="8f2cfe6996e4a915299313c85a777630" category="list-text">테난티디, 클라이언트ID, 그리고 고객비밀<block ref="8cf7d0e47908a64c9538530ae13f3b17" category="inline-link-rx"></block> Azure NetApp Files 서비스에 대한 충분한 권한이 있는 Azure Active Directory에서</block>
  <block id="761f4d4786b8e1a6c65bf01f90ff17cd" category="list-text">하나 이상의 Azure 위치가 있습니다<block ref="c5f14b2142014dc234282a513132bad4" category="inline-link-rx"></block></block>
  <block id="dc2194d6594556ab2ec2b961b22b55a9" category="admonition">Azure NetApp Files를 처음 사용하거나 새 위치에서 사용하는 경우, 일부 초기 구성이 필요합니다<block ref="03c0e2c26eabaafc3ff886c9295f214c" category="inline-link-rx"></block> 안내합니다.</block>
  <block id="0b0b881d3a43e5782867f1e6ea7ae219" category="admonition">Astra Trident 21.04.0 이전 버전에서는 수동 QoS 용량 풀을 지원하지 않습니다.</block>
  <block id="9fc00ac6b0164174fe95b39347777acf" category="paragraph">“Azure-NetApp-파일”</block>
  <block id="150fed11d160cf3a20a84935a6da6b2f" category="paragraph">스토리지 백엔드의 사용자 지정 이름입니다</block>
  <block id="8c6cd78048829f0726a268945284d717" category="paragraph">드라이버 이름 + “_” + 임의 문자</block>
  <block id="f68b03078b004c148f3382adb3803512" category="paragraph">"표준", "프리미엄" 또는 "Ultra" 중 하나</block>
  <block id="48483edc045345a516ed748c1964e3bf" category="paragraph">“”(임의)</block>
  <block id="544e534f1aa0d97c48ccedd92fe2ba3d" category="paragraph">Azure 위치의 이름 에 새 볼륨이 생성됩니다</block>
  <block id="c9266840071171609b858a86983e5cbc" category="paragraph">"-o nfsvers=3"</block>
  <block id="bb7d88b29e22a86389e711d24d78d8b0" category="admonition">Azure NetApp Files 서비스는 100GB 미만의 볼륨을 지원하지 않습니다. 보다 쉽게 애플리케이션을 배포할 수 있도록 작은 볼륨이 요청되는 경우 Trident가 자동으로 100GB 볼륨을 생성합니다.</block>
  <block id="c73b8a061778625d86923a1ee3b2b65a" category="paragraph">구성의 특수 섹션에서 이러한 옵션을 사용하여 각 볼륨이 기본적으로 프로비저닝되는 방식을 제어할 수 있습니다.</block>
  <block id="9aef9232b6d23ad9af140b946025a2e9" category="paragraph">새 볼륨의 내보내기 규칙. CIDR 표기법을 사용하여 IPv4 주소 또는 IPv4 서브넷의 조합을 쉼표로 구분해야 합니다.</block>
  <block id="5b080068f6b7a62124d4bbe75e0ccebe" category="paragraph">“0.0.0.0/0”</block>
  <block id="cf4ad5c346075cb763a78a1eeb590f67" category="paragraph">“100G”</block>
  <block id="c26659d1a1cc7dd886f591fd462c9b91" category="section-title">Azure NetApp Files 구성의 예</block>
  <block id="b735d2db48e665b21117295550615ff3" category="paragraph">* 예 1: Azure-NetApp-파일 * 에 대한 최소 백엔드 구성</block>
  <block id="c9ed1200ddf4fe7e1e4120cb35885310" category="paragraph">이는 절대적인 최소 백엔드 구성입니다. 이 구성을 통해 Trident는 전 세계 모든 위치에서 ANF에 위임된 모든 NetApp 계정, 용량 풀 및 서브넷을 검색하고 이 중 하나에 무작위로 새 볼륨을 배치합니다.</block>
  <block id="c31e8cd6c5230f025186373673347b9c" category="paragraph">이 구성은 ANF를 처음 사용해 보고 그러나 실제로, 용량 할당 볼륨에 대한 추가 범위를 제공하여 사용자가 원하는 특성을 갖고 있는지 확인하고 사용 중인 컴퓨팅에 가까운 네트워크에서 끝내고자 합니다. 자세한 내용은 다음 예제를 참조하십시오.</block>
  <block id="189a6649956b03bce537a5eb6247fc83" category="paragraph">* 예 2: Azure-NetApp-파일 * 에 대한 단일 위치 및 특정 서비스 수준</block>
  <block id="0f10d4c5e31fffa777f19dd757816f93" category="paragraph">이 백엔드 구성은 Azure의 "eastus" 위치에 볼륨을 "프리미엄" 용량 풀에 배치합니다. Trident는 해당 위치에서 ANF에 위임된 모든 서브넷을 자동으로 검색하여 그 중 하나에 무작위로 새 볼륨을 배치합니다.</block>
  <block id="418698e54dde6b45a123af5be774679e" category="paragraph">* 예 3: Azure-NetApp-파일 * 에 대한 고급 구성</block>
  <block id="75f9eb2b518c3ec9d39a7c1f8b4b94a9" category="paragraph">* 예 4: Azure-NetApp-파일 * 이 포함된 가상 스토리지 풀</block>
  <block id="e0b432486549d4404054c64e947ef84e" category="inline-link-macro">스토리지 풀</block>
  <block id="b0e0c2dae5878f7a113284ddd0f3c6c2" category="paragraph">이 백엔드 구성은 여러 개를 정의합니다 <block ref="a2da53ffe8493aa084053197c8de9b91" category="inline-link-macro-rx"></block> 단일 파일. 다양한 서비스 수준을 지원하는 여러 용량 풀이 있고 이를 나타내는 Kubernetes의 스토리지 클래스를 생성하려는 경우에 유용합니다.</block>
  <block id="8b4e612e7ec021b91bdf46a69c393a75" category="paragraph">이는 가상 스토리지 풀과 해당 레이블의 강력한 성능을 긁는 것입니다.</block>
  <block id="c412f3b9b270250331aa1ef4102ef8c1" category="summary">여러 스토리지 구성을 동시에 사용할 수 있도록 하려는 경우 Astra Trident의 여러 인스턴스가 필요합니다. 여러 인스턴스의 핵심은 컨테이너형 플러그인에서 -alias 옵션을 사용하거나 호스트에서 Trident를 인스턴스화할 때 -volume-driver 옵션을 사용하여 다른 이름을 지정하는 것입니다.</block>
  <block id="4f07a71d2e33da91dec1396b7a204a40" category="doc">여러 Astra Trident 인스턴스를 관리합니다</block>
  <block id="8f327f2ceda84404290184a7454160ed" category="paragraph">여러 스토리지 구성을 동시에 사용할 수 있도록 하려는 경우 Trident의 여러 인스턴스가 필요합니다. 여러 인스턴스의 핵심은 컨테이너형 플러그인과 함께 '- alias' 옵션을 사용하거나 호스트에서 Trident를 인스턴스화할 때 '- volume-driver' 옵션을 사용하여 다른 이름을 지정하는 것입니다.</block>
  <block id="52ef1c6ffefaba3249f208369424635d" category="section-title">Docker 관리 플러그인 단계(버전 1.13/17.03 이상)</block>
  <block id="547c4a5f7c863aad85f5265c03ed72ea" category="list-text">별칭 및 구성 파일을 지정하는 첫 번째 인스턴스를 시작합니다.</block>
  <block id="991ac134f22efa2bb955362d95827ae5" category="list-text">다른 별칭과 구성 파일을 지정하여 두 번째 인스턴스를 시작합니다.</block>
  <block id="aa0dc0ac69e69c434317798e1aa9842b" category="list-text">별칭을 드라이버 이름으로 지정하는 볼륨을 생성합니다.</block>
  <block id="5ae25a45ab76de161f87fc41a84f746d" category="paragraph">예를 들어 금괴 볼륨의 경우:</block>
  <block id="6dab7c53f6e3de2eae52e928dfe5b861" category="paragraph">예를 들어, 은 볼륨의 경우:</block>
  <block id="67754cb209925946943e297b3a8be344" category="section-title">기존(버전 1.12 이하) 단계</block>
  <block id="cbd128765e82966ed5e454a99b22e688" category="list-text">사용자 지정 드라이버 ID를 사용하여 NFS 구성으로 플러그인을 시작합니다.</block>
  <block id="51c923daa4caf6aea6d24201b73871b6" category="list-text">사용자 지정 드라이버 ID를 사용하여 iSCSI 구성으로 플러그인을 시작합니다.</block>
  <block id="dd72ade865d731ba8f6a6fc4c8ccd86f" category="list-text">각 드라이버 인스턴스에 Docker 볼륨 프로비저닝:</block>
  <block id="8e2044cc9d4e8f515ad4809a68d75465" category="paragraph">예를 들어, NFS의 경우:</block>
  <block id="d39eb6e4299503c5d451d19b9645be42" category="paragraph">예를 들어 iSCSI의 경우:</block>
  <block id="b928e0aee19c1e2cc91c85e8a0856936" category="summary">Astra Trident를 설치 및 사용하는 동안 발생할 수 있는 문제를 해결하려면 여기에 제공된 포인터를 사용하십시오.</block>
  <block id="231cf4c70d866b616c21baddaeed0696" category="doc">문제 해결</block>
  <block id="8ef0ab9bbedaa7608c9abed7c7213218" category="admonition">Astra Trident에 대한 도움을 받으려면 'tridentctl logs-a-n tri덴트'를 사용하여 지원 번들을 생성한 후 'NetApp Support&lt;Getting Help&gt;'로 보내십시오.</block>
  <block id="40e41fb2db11266b8f751c0d5c67cba0" category="inline-link">NetApp Knowledgebase(로그인 필요)</block>
  <block id="01005ecf4349194d1ec13d0ba516c9e5" category="admonition">문제 해결 문서의 전체 목록을 보려면 을 참조하십시오<block ref="57f5c759ada931c6a2051314ca6ee99e" category="inline-link-rx"></block>. Astra와 관련된 문제 해결에 대한 정보도 찾을 수 있습니다<block ref="695f48b1d8b7348c0e2828947d24161e" category="inline-link-rx"></block>.</block>
  <block id="163fb9eb00818e2c7109900db1a3cc82" category="section-title">일반 문제 해결</block>
  <block id="f504c27d1ad305a988958b64f34468cb" category="list-text">Trident 포드가 제대로 표시되지 않으면(예: 두 개 미만의 준비된 컨테이너로 'ContainerCreating' 단계에 Trident 포드가 들러붙은 경우) kubeck-n trident t덴트 설명 배포 트리덴트를 실행하고 'kebctl-n trident tor stand' kudl-********** 를 실행합니다 이 밖에도 많은 정보를 얻을 수 있습니다. 쿠벨렛 로그(예: 저널링ctl-xeu kubelet)를 얻는 것도 도움이 될 수 있습니다.</block>
  <block id="05d68d1b7214c73141ed12aaed0c2ab5" category="list-text">Trident 로그에 충분한 정보가 없으면 설치 옵션에 따라 설치 매개 변수에 '-d' 플래그를 전달하여 Trident에 대한 디버그 모드를 활성화할 수 있습니다.</block>
  <block id="bc6de9cad530a57dba08ff711f4a6b5f" category="paragraph">그런 다음 디버그가 "./tridentctl logs -n triment"를 사용하여 설정되었는지 확인하고 로그에서 level=debug msg를 검색합니다.</block>
  <block id="8e95ae46f32b05cf983c93e608530e36" category="list-text">운영자와 함께 설치됩니다</block>
  <block id="6a304a6cf7cd8c90bac892ab0fb9c134" category="paragraph">Astra Trident 20.07 및 20.10의 경우 Torc 대신 tprov를 사용합니다.</block>
  <block id="79b91d0489c081de6794796638793787" category="list-text">헬름과 함께 설치</block>
  <block id="d356d628089d439d75e3f85564372658" category="list-text">tridentctl과 함께 설치됩니다</block>
  <block id="87248f7afe198418bdbedd919695631e" category="list-text">또한 백엔드 정의에 debugTraceFlags를 포함하여 각 백엔드에 대한 디버그 로그를 얻을 수 있습니다. 예를 들어, debugTraceFlags:{"API":true, "method":true,}"를 포함하여 Trident 로그에 API 호출 및 메서드 트래버스된 메서드를 가져옵니다. 기존 백엔드는 tridentctl 백엔드 업데이트로 debugTraceFlags를 구성할 수 있습니다.</block>
  <block id="6cc37a0664d7f97f87d34eadef23dbad" category="list-text">RedHat CoreOS를 사용할 때는 작업자 노드에서 iscsid가 활성화되어 있고 기본적으로 시작되는지 확인합니다. 이 작업은 OpenShift MachineConfigs를 사용하거나 점화 템플릿을 수정하여 수행할 수 있습니다.</block>
  <block id="4582245538a41243a95713a7d0c21b64" category="list-text">에서 Trident를 사용할 때 일반적으로 발생할 수 있는 문제입니다<block ref="4568986ef6397d7c901269fc0e190ede" category="inline-link-rx"></block> 테넌트 및 클라이언트 암호가 권한이 부족한 앱 등록에서 나오는 경우 입니다. Trident 요구사항의 전체 목록은 를 참조하십시오 <block ref="c09112d17e34405b7a5c3d246f91583f" category="inline-link-macro-rx"></block> 구성.</block>
  <block id="7f0ecdfa510b31b01d331c2760643b83" category="list-text">PV를 컨테이너에 마운트하는 데 문제가 있는 경우 rpcbind가 설치되어 실행되고 있는지 확인합니다. 호스트 OS에 필요한 패키지 관리자를 사용하고 rpcbind가 실행 중인지 확인합니다. 'stemctl status rpcbind' 또는 이와 동등한 기능을 실행하여 rpcbind 서비스의 상태를 확인할 수 있습니다.</block>
  <block id="78aeadc89feb4cf244398a7d35a0d656" category="list-text">Trident 백엔드가 이전에 작업을 수행했음에도 불구하고 "실패" 상태에 있다고 보고할 경우 백엔드와 연결된 SVM/관리 자격 증명을 변경하면 원인일 수 있습니다. 'tridentctl update backend'를 사용하여 백엔드 정보를 업데이트하거나 Trident POD를 바운딩하면 이 문제가 해결됩니다.</block>
  <block id="dd5955dd3991dcacca2b395215df8ecd" category="list-text">베타 볼륨 스냅샷을 사용하도록 Kubernetes 클러스터 및/또는 Trident를 업그레이드할 경우 기존의 모든 알파 스냅샷 CRS가 완전히 제거되었는지 확인합니다. 그런 다음 "tridentctl oblividate alpha-snapshot-crd" 명령을 사용하여 알파 스냅샷 CRD를 삭제할 수 있습니다. 을 참조하십시오<block ref="f3109660248c628e79ddf256944df58b" category="inline-link-rx"></block> 알파 스냅샷 마이그레이션 단계를 이해합니다.</block>
  <block id="b851cfc28cd6e5cb9aaf87bdb59a68aa" category="list-text">Docker를 컨테이너 런타임으로 사용하여 Trident를 설치할 때 권한 문제가 발생하면 '--in cluster=false' 플래그를 사용하여 Trident를 설치해 보십시오. 설치자 포드는 사용하지 않고 설치자 이용으로 인한 권한 문제를 피한다.</block>
  <block id="6f7d49547ff47cfaf1fd93d134b603be" category="list-text">실패한 실행 후 정리 작업을 위해 'uninstall parameter &lt;uninstall Trident&gt;'를 사용합니다. 기본적으로 이 스크립트는 Trident에서 만든 CRD를 제거하지 않으므로 실행 중인 구축에서도 안전하게 제거한 후 다시 설치할 수 있습니다.</block>
  <block id="f1112223b41fddc71fd6a626582dfb78" category="inline-link">Trident 버전</block>
  <block id="c731d984dfa8e536efa9efa455347faa" category="list-text">Trident의 이전 버전으로 다운그레이드하려는 경우 먼저 'tridenctl uninstall' 명령을 실행하여 Trident를 제거합니다. 원하는 를 다운로드합니다<block ref="f3d78353f8dac3e49bbefeb5f6a2383b" category="inline-link-rx"></block> tridentctl install 명령을 사용하여 설치합니다. 새로 생성된 PVS가 없고 기존 PVS/백엔드/스토리지 클래스가 변경되지 않은 경우에만 다운그레이드를 고려하십시오. Trident는 이제 CRD를 사용하여 상태를 유지하므로 생성된 모든 스토리지 엔터티(백엔드, 스토리지 클래스, PVS 및 볼륨 스냅샷)에는 이전 버전의 Trident에서 사용한 PV에 기록된 데이터 대신 연결된 CRD 객체 &lt;Kubernetes CustomResourceDefinition Objects&gt;"가 있습니다. * 이전 버전으로 되돌릴 때 새로 생성된 PVS를 사용할 수 없습니다. * * 다운그레이드 시 백엔드, PVS, 스토리지 클래스 및 볼륨 스냅샷(생성/업데이트/삭제)과 같은 객체에 대한 변경 사항은 Trident에 표시되지 않습니다 *. 설치된 Trident의 이전 버전에서 사용된 PV는 여전히 Trident에 표시됩니다. 이전 버전으로 돌아가면 업그레이드되지 않은 경우 이전 릴리즈를 사용하여 이미 생성된 PVS에 대한 액세스가 중단되지 않습니다.</block>
  <block id="7dc9f8824c461c84d9bb1563a0615526" category="list-text">Trident를 완전히 제거하려면 'tridentctl oblividate CRD' 명령을 실행합니다. 그러면 모든 CRD 객체가 제거되고 CRD의 정의가 해제됩니다. Trident는 이미 프로비저닝한 PVS를 더 이상 관리하지 않습니다.</block>
  <block id="e7fc3eac0c0cea530e0f52e3ddf37079" category="admonition">이 후 Trident를 처음부터 다시 구성해야 합니다.</block>
  <block id="51748ba3d16ecfd8c45c7ebf2043b738" category="list-text">설치가 성공적으로 완료된 후 PVC가 보류 단계에 고착되면 kubeck tl t설명해 PVC를 실행하면 Trident가 이 PVC에 대한 PV를 프로비저닝하지 못한 이유에 대한 추가 정보가 제공됩니다.</block>
  <block id="a900bd1dbd5690f78a30ca74d138d0b7" category="section-title">연산자를 사용하여 실패한 Trident 배포 문제 해결</block>
  <block id="0e89989064bf4afdc37fd5a7be4f607d" category="paragraph">연산자를 사용하여 Trident를 배포하는 경우 트리펜터터의 상태가 Installing에서 Installed로 변경됩니다. 'Failed(실패)' 상태를 확인하고 운용자가 자체적으로 복구할 수 없는 경우 다음 명령어를 실행해 운용자의 로그를 확인해야 한다.</block>
  <block id="df9771dbb13da45493e576499910c0b4" category="paragraph">삼원 운영자 컨테이너의 로그를 뒤로하면 문제가 있는 위치를 가리킬 수 있습니다. 예를 들어, 이러한 문제 중 하나는 Airgapped 환경의 업스트림 등록부에서 필요한 컨테이너 이미지를 가져올 수 없는 것일 수 있습니다.</block>
  <block id="0fd4c6187c561958bc76052df7774593" category="paragraph">Trident의 설치가 실패한 이유를 이해하려면 '트리엔트오케스트레이터' 상태를 살펴보아야 합니다.</block>
  <block id="1e054f4c292a5388d6318461fe73d749" category="paragraph">이 오류는 Trident를 설치하는 데 사용된 '트리엔오케스트레이터'가 이미 있음을 나타냅니다. 각 Kubernetes 클러스터에는 Trident의 인스턴스가 하나만 있을 수 있으므로 운영자는 언제든지 생성할 수 있는 활성 'Trident Orchestrator'가 하나만 존재하도록 합니다.</block>
  <block id="568fcf9beb0dbd37c57dff251a3164ed" category="paragraph">또한 Trident Pod의 상태를 관찰하면 무언가 잘못되었음을 나타내는 경우가 많습니다.</block>
  <block id="f89c17ddb9f8bdaf5c95a466d5f6a500" category="paragraph">하나 이상의 컨테이너 이미지를 가져오지 않았기 때문에 포드를 완전히 초기화할 수 없다는 것을 분명히 알 수 있습니다.</block>
  <block id="d57d1a6de03b2ddf3ee54f680152e2b6" category="paragraph">이 문제를 해결하려면 트리엔오케스트레이터 CR을 편집해야 합니다. 또는 '트리엔오케스트레이터'를 삭제하고 수정되고 정확한 정의를 가진 새 정의를 만들 수 있습니다.</block>
  <block id="a8ee4098038ba3eb2d8c3093ddfe6536" category="section-title">tridentctl을 사용하여 Trident 배포가 성공하지 못한 문제 해결</block>
  <block id="021e9ae5361eb14975bf9a30f99770f5" category="paragraph">무엇이 잘못되었는지 알 수 있도록 디버그 모드를 켜고 무엇이 문제인지 이해하는 데 도움이 되는 ''-d' 인수를 사용하여 설치 프로그램을 다시 실행할 수 있습니다.</block>
  <block id="01539f4f1fd20792cbbae6bb0506cc20" category="paragraph">이 문제를 해결한 후 다음과 같이 설치를 정리한 다음 'tridentctl install' 명령을 다시 실행할 수 있습니다.</block>
  <block id="d327e8f24b63b83e091dccdc48dd7b1b" category="sidebar">Astra Trident 문서</block>
  <block id="7d0ee6fed10d3d4e5c9ee496729ab519" category="sidebar">릴리스 정보</block>
  <block id="93168a8084b3e838d2932c4734bd234e" category="sidebar">이전 버전</block>
  <block id="0629fb104936d0fb60cc736b6cb01caa" category="sidebar">Astra Trident 요구사항</block>
  <block id="33871b6190a8d5adbe8b15282054766c" category="sidebar">새로운 소식</block>
  <block id="1fe917b01f9a3f87fa2d7d3b7643fac1" category="sidebar">FAQ 를 참조하십시오</block>
  <block id="312b0dc38b01ff32c1b2f5f81ee1ab2d" category="sidebar">Trident 연산자를 사용하여 배포합니다</block>
  <block id="6a693eb5cd23e4e5743663c7edc37aed" category="sidebar">Docker를 위한 Astra Trident 구축</block>
  <block id="386307d41b3f4169a1e6e046a727cdd2" category="sidebar">Trident 연산자를 사용하여 업그레이드합니다</block>
  <block id="eb1f347fa6176ae2c9175df3bc414954" category="sidebar">Astra Trident를 사용해 보십시오</block>
  <block id="81a123ccab93cd947289b672b0e50348" category="sidebar">데모 자습서</block>
  <block id="28348a71bed382b86fa6de4d3a307715" category="sidebar">Astra Trident 비디오</block>
  <block id="813011e2103649bb71f124adedcc10ea" category="sidebar">블로그 커뮤니티</block>
  <block id="6394eceb2639574114b02e6e817eb19a" category="sidebar">Astra 블로그</block>
  <block id="874d8a5301794a9ca2aba132ac2460f3" category="sidebar">쿠버네티스 허브</block>
  <block id="d59c00abbeaf33a9a094b3a69c563405" category="sidebar">NetApp.IO를 참조하십시오</block>
  <block id="0460583622f03a52d7693094d6fa2452" category="sidebar">개념</block>
  <block id="c949166d6970748c0094c800daa3324a" category="sidebar">Astra Trident 관리</block>
  <block id="a20f982d79c3dd66d244ffe0f7d940ee" category="sidebar">모범 사례 및 권장사항</block>
  <block id="c91cf7abea9584bc1edbc8ff4948ada0" category="sidebar">Astra Trident 통합</block>
  <block id="58eaebf972358f1cf03d386a4ade1a0f" category="sidebar">다음 단계</block>
  <block id="cc4a0df2c635530d752308ab5a1c4b89" category="sidebar">ANF 백엔드를 구성합니다</block>
  <block id="63d5049791d9d79d86e9a108b0a999ca" category="sidebar">참조하십시오</block>
  <block id="324fb1352ffffb105d10013810c42896" category="sidebar">Kubernetes 및 Astra Trident 오브젝트</block>
  <block id="f14894e4c400a400c02367258a93029a" category="sidebar">Docker를 위한 Astra Trident</block>
  <block id="e08bfc79c5202517b3814efd6e82fb2c" category="sidebar">Trident 업그레이드 또는 제거</block>
  <block id="cf282b9c05ab0f84b1690e644cd3f68e" category="list-text">ONTAP-NAS-Flexgroup 드라이버의 경우 각 PV(Persistent Volume)가 FlexGroup에 매핑됩니다. 따라서 볼륨 스냅샷이 NetApp FlexGroup 스냅샷으로 생성됩니다. NetApp의 스냅샷 기술은 경쟁 스냅샷 기술보다 뛰어난 안정성, 확장성, 복구 가능성 및 성능을 제공합니다. 이러한 스냅샷 복사본은 생성하는 데 필요한 시간과 스토리지 공간 모두에서 매우 효율적입니다.</block>
  <block id="ba9e76e1be4705136fd15fd947717d07" category="paragraph">현재 ONTAP-NAS, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN-이코노미, 졸idfire-SAN의 온디맨드 스냅샷 지원을 이용할 수 있습니다. AWS-CV, GCP-CV, Azure-NetApp-파일 백엔드 드라이버</block>
  <block id="b89df534de66f446ec6482f9d7898bb2" category="cell">'controllerPluginNodeSelector'</block>
  <block id="15cfc4bea44cee69551eb577fb0dcd8a" category="cell">Trident 컨트롤러 CSI 플러그인을 실행하는 Pod용 추가 노드 선택기. pod.spec.nodeSelector 과 동일한 형식을 따릅니다.</block>
  <block id="8d414af35aeb82413205fa45551a5545" category="cell">기본값 없음, 선택 사항</block>
  <block id="df1f367efe879ec0030f43610e29c5af" category="cell">'컨트롤러 PluginTolerations'</block>
  <block id="2fba8e7843d1d343f2fe29feeca4b34d" category="cell">Trident 컨트롤러 CSI 플러그인을 실행하는 Pod의 허용 설정을 재정의합니다. pod.spec.Tolerations와 같은 형식을 따릅니다.</block>
  <block id="47a441037628a3c0f0edb0daccb33f99" category="cell">노드플러거노드 선택기</block>
  <block id="109ef057002ce8b5901039ee5b81df88" category="cell">Trident Node CSI 플러그인을 실행하는 Pod용 추가 노드 선택기 pod.spec.nodeSelector 과 동일한 형식을 따릅니다.</block>
  <block id="f297db5a937924105908a365d9d4c4ff" category="cell">노드 PluginTolerations</block>
  <block id="01fae47efea3407f5bc27a09eea8709c" category="cell">Trident Node CSI 플러그인을 실행하는 Pod의 허용 설정을 재정의합니다. pod.spec.Tolerations와 같은 형식을 따릅니다.</block>
  <block id="4352a1b4e004cf57ac04661a18de43aa" category="inline-link-macro">노드에 Pod 할당</block>
  <block id="b3b67fd79d24b4873c8164c750c21798" category="admonition">포드 매개 변수 포맷에 대한 자세한 내용은 을 참조하십시오 <block ref="7b3a69fdac08c769183925679da4c365" category="inline-link-macro-rx"></block>.</block>
  <block id="d6601a8eb863a49ea065281f70a5956b" category="summary">Astra Trident는 NetApp이 Astra 제품군의 일부로 유지 관리하는 완전히 지원되는 오픈 소스 프로젝트입니다. 컨테이너 스토리지 인터페이스(CSI)와 같은 업계 표준 인터페이스를 사용하여 컨테이너화된 애플리케이션의 지속성 요구를 충족하도록 설계되었습니다.</block>
  <block id="bb453665f57f6823950856f7a9bad0c3" category="inline-link-macro">Astra 제품군</block>
  <block id="9f469e7cb13566d8a664e8ab4d46f9e1" category="paragraph">Astra Trident는 NetApp이 의 일부로 유지 관리하는 완전히 지원되는 오픈 소스 프로젝트입니다 <block ref="a1650a2308dbba03b9ca704756a5a37d" category="inline-link-macro-rx"></block>. 컨테이너 스토리지 인터페이스(CSI)와 같은 업계 표준 인터페이스를 사용하여 컨테이너화된 애플리케이션의 지속성 요구를 충족하도록 설계되었습니다.</block>
  <block id="fdc319eb193763016bf0bff75d0c0abc" category="paragraph">Astra Trident는 Kubernetes 클러스터에 Pod로 구축하고 Kubernetes 워크로드에 동적 스토리지 오케스트레이션 서비스를 제공합니다. 컨테이너화된 애플리케이션을 통해 ONTAP(AFF/FAS/Select/Cloud/Amazon FSx for NetApp ONTAP), Element 소프트웨어(NetApp HCI/SolidFire), Astra Data Store, Azure NetApp Files 서비스, Cloud Volumes Service on Google Cloud 및 Cloud Volumes Service on AWS를 비롯한 NetApp의 광범위한 포트폴리오에서 영구 스토리지를 빠르고 쉽게 사용할 수 있습니다.</block>
  <block id="165fe4b78b5877cf8db8ac6361e5c85a" category="paragraph">Astra 페이지에서 무료 평가판을 신청하실 수 있습니다.</block>
  <block id="d13de4a83d7b44c2e65495def8ef1c7b" category="section-title">를 참조하십시오</block>
  <block id="fa80e31eb77798b8dd995ddd9553be6e" category="inline-link">NetApp Astra 제품군</block>
  <block id="ed394f5572d8e7df474126557b3288f8" category="list-text"><block ref="ed394f5572d8e7df474126557b3288f8" category="inline-link-rx"></block></block>
  <block id="ef22ff17624b3faeed227ce5c717eb5f" category="inline-link">Astra Control Service 문서</block>
  <block id="0ae0ea6967e9321db008cee4ad5f290c" category="list-text"><block ref="0ae0ea6967e9321db008cee4ad5f290c" category="inline-link-rx"></block></block>
  <block id="3a4b2c66d4bdac6ce0e3340c71a39eda" category="inline-link">Astra Control Center 문서</block>
  <block id="ea643bf7aaf130341a17f697a7009368" category="list-text"><block ref="ea643bf7aaf130341a17f697a7009368" category="inline-link-rx"></block></block>
  <block id="9d6ffa6ef31bd0b92876314219f18ef5" category="inline-link">Astra API 설명서</block>
  <block id="9c2cf0e947812ecb3fc0bfccaa8b3c61" category="list-text"><block ref="9c2cf0e947812ecb3fc0bfccaa8b3c61" category="inline-link-rx"></block></block>
  <block id="4546bbd46f06879787b5670b13277b28" category="paragraph">이 단계의 일부로, 21.10.0 Trident 운영자는 기존 Astra Trident 설치를 식별하고 운영자와 동일한 버전으로 업그레이드합니다.</block>
  <block id="9f687b4e8cbf2fbb623b26b30fd92717" category="admonition">21.07 이전 릴리스의 경우 레거시 문서 사이트로 리디렉션됩니다.</block>
  <block id="a93e9e44b7a375a4236260f5ff2b251e" category="inline-link">Astra Trident 21.07</block>
  <block id="3830d427e146a8a64454dc373d9b1502" category="list-text"><block ref="3830d427e146a8a64454dc373d9b1502" category="inline-link-rx"></block></block>
  <block id="e088e1f9fcd6d6a9509bd529db24c8f3" category="admonition">Trident의 네임스페이스를 아직 만들지 않은 경우 '--create-namespace' 매개 변수를 'helm install' 명령에 추가할 수 있습니다. 그런 다음 Helm이 자동으로 네임스페이스를 만듭니다.</block>
  <block id="8035d5d39b2b48f6ec1a3133b688513c" category="list-text">Astra 데이터 저장소</block>
  <block id="af7c8216a3289efe1a298a19c00b8b8c" category="section-title">호스트 운영 체제를 테스트했습니다</block>
  <block id="57b3e1695eb7d16642702fbce3837b86" category="paragraph">기본적으로 Astra Trident는 컨테이너에서 실행되므로 모든 Linux 작업자에서 실행됩니다. 그러나 이러한 작업자들은 표준 NFS 클라이언트 또는 iSCSI 이니시에이터를 사용하여 Astra Trident가 제공하는 볼륨을 사용 중인 백엔드에 따라 마운트할 수 있어야 합니다.</block>
  <block id="814a65adc75608da31ab5685f9b1c1ce" category="paragraph">Astra Trident는 공식적으로 특정 운영 체제를 "지원"하지 않지만 다음과 같은 Linux 배포판이 작동하는 것으로 알려져 있습니다.</block>
  <block id="dc5ac69fee94d861f0bed64729b712cf" category="paragraph">Astra Trident는 백엔드 구성에서 사용하기 전에 스토리지 시스템을 일부 변경해야 할 수 있습니다. 을 참조하십시오 <block ref="49641f5ab61d7a6ce07b1b6ba31204f8" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="b0b4b8e52878f03279584f43bc961472" category="list-text">K8s.GCR.IO/SIG-스토리지/CSI-공급자:v2.2.2</block>
  <block id="3c8910d4db724229b566887801de96bb" category="list-text">k8s.gcr.io/sig-storage/scsi-resizer: v1.3.0</block>
  <block id="681d715b456f6d29a501b8f132e941a1" category="cell">v1.22.0</block>
  <block id="c0227cef6f07a8cd2ac72f2945b031aa" category="section-title">오픈 소스</block>
  <block id="0172b29a9f5d94dc62ee592a98183f3b" category="paragraph">각 릴리스의 공지 파일에서 Astra Trident용 NetApp 소프트웨어에 사용된 타사 저작권 및 라이센스를 검토할 수 있습니다<block ref="4a3c8c5a408c6db1c44c04391a8a0a2f" category="inline-link-rx"></block>.</block>
  <block id="29db8b676d0a02f8179869506102c8ce" category="doc">ONTAP 또는 Cloud Volumes ONTAP SAN 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="133184f8c608809bdc057abf1397d10d" category="paragraph">ONTAP 및 Cloud Volumes ONTAP SAN 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="879d65b9b2cc663b2ff6a01cfe8d4c72" category="paragraph">Astra Trident의 20.01 릴리즈부터 Kubernetes 계층에서 PVS의 스냅샷을 생성할 수 있습니다. 이러한 스냅샷을 사용하여 Astra Trident에서 생성한 볼륨의 시점 복사본을 유지하고 추가 볼륨(클론) 생성을 예약할 수 있습니다. 볼륨 스냅샷은 'ONTAP-NAS', 'ONTAP-SAN', 'ONTAP-SAN-이코노미', 'olidfire-SAN', 'AWS-CV'에서 지원됩니다. GCP-CV와 Azure-NetApp-files의 드라이버입니다.</block>
  <block id="311847a44163ac40ccf470fcf81e74fb" category="admonition">GKE 환경에서 필요 시 볼륨 스냅샷을 설정하는 경우 스냅샷-컨트롤러를 생성하지 마십시오. GKE는 내장된 숨겨진 스냅샷 컨트롤러를 사용합니다.</block>
  <block id="75419edaab27be09afdb3415e83d93f6" category="paragraph">'SUDO mpathconf - -enable - -with_multipathd y - -find_multiprohs n'</block>
  <block id="60c268e00db3206011b54b01705d7211" category="admonition">etc/multipath.conf에 debrofs 아래에 find_multiprohs no가 포함되어 있는지 확인합니다.</block>
  <block id="b85c80e2af7e3d7dd06b874ed048d430" category="paragraph">'sudo tee /etc/multipath.conf&lt;-'EOF' 기본값 {user_friendly_names yes find_multipath no} EOF sudo systemctl enable--now multipath-tools.service sudo service multipath-tools restart'입니다</block>
  <block id="a3610578ce54198653d7e0b2cc53c05d" category="inline-link-macro">ONTAP 또는 Cloud Volumes ONTAP NAS 드라이버를 사용하여 백엔드를 구성합니다</block>
  <block id="f4f833852bac4217eff92d53c1bd24dc" category="list-text"><block ref="f4f833852bac4217eff92d53c1bd24dc" category="inline-link-macro-rx"></block></block>
  <block id="df7d9b009cdb0a2623872cb3f905e161" category="list-text"><block ref="df7d9b009cdb0a2623872cb3f905e161" category="inline-link-macro-rx"></block></block>
  <block id="4d80e2460d711b841338dfbeea2ca8c1" category="paragraph">ONTAP 및 Cloud Volumes ONTAP NAS 드라이버를 사용하여 ONTAP 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="3381a309aeefac050f7f5319f6757afe" category="summary">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위해 ADS(Astra Data Store) 백엔드를 구성하는 방법에 대해 알아보십시오.</block>
  <block id="83caf3e7a6bf2dcce3d7d6eab3c8905c" category="doc">Astra Data Store 백엔드를 구성합니다</block>
  <block id="0b1c01b976c493a4217d6f4b772849b0" category="paragraph">제공된 샘플 구성을 사용하여 Astra Trident 설치를 위한 ADS(Astra Data Store) 백엔드를 구성하는 방법을 알아보십시오.</block>
  <block id="efd5e8dbeec263f783a6cd6ac036c6a9" category="paragraph">를 구성하고 사용합니다<block ref="a026c15058b831feb6de8c4c836387ae" category="inline-link-rx"></block> 백엔드, 다음이 필요합니다.</block>
  <block id="0033a0be965b04e889c13f8699fa52ca" category="inline-link-macro">Astra Data Store 미리 보기 문서</block>
  <block id="44353297d28e56e03a6c2fa8ed4c436d" category="list-text">지원되는 ADS 스토리지 시스템입니다. 을 참조하십시오 <block ref="a495e7dcf960e6114a66e71691c841e9" category="inline-link-macro-rx"></block> 를 참조하십시오.</block>
  <block id="c7f6917a3ac9bd1d4133a82dc3260748" category="list-text">ADS를 호스팅하는 Kubernetes 클러스터의 자격 증명. ADS를 호스팅하는 Kubernetes 클러스터에는 이 Astra Trident 백엔드에서 만들고 관리할 볼륨, 스냅샷 및 엑스포트 정책 리소스 전용 네임스페이스가 있어야 합니다. 다음을 지원하는 ADS를 호스팅하는 Kubernetes 클러스터에는 "kubecononfig"를 사용할 수 있어야 합니다.</block>
  <block id="cebbe731acfa0b8c520f355bcbfa6dd1" category="list-text">Astrads-system 네임스페이스의 모든 오브젝트를 읽습니다</block>
  <block id="cb90bccb2cf5bc16b37e39d379d5a5ea" category="list-text">이 Astra Trident 백엔드의 사용을 위해 생성된 네임스페이스에서 오브젝트 읽기/쓰기</block>
  <block id="2f191460bd4d4750f88513ea54101bed" category="list-text">모든 클러스터 네임스페이스 나열</block>
  <block id="e269f9fe19f18e73c77815dddc019d7b" category="cell">"Astrads - NAS"</block>
  <block id="5b4fc65310144922f0384b20a00bd6ae" category="cell">ADS 클러스터 이름</block>
  <block id="65e18a0bb1868a9c1e181302d4733dba" category="cell">"클러스터"</block>
  <block id="d24ec3d66e6303208e4767ec5cccbc76" category="cell">AstraDSCluster 리소스의 이름입니다</block>
  <block id="a4c39aafd14948aacfcc4f9c6374a875" category="cell">Astra Trident가 모든 ADS 사용자 지정 리소스를 생성하는 네임스페이스입니다</block>
  <block id="995c6425a4a00f961b0c8a2000c5497c" category="cell">쿠베코무화과다</block>
  <block id="dc37fa78a7cf3d9ae1dbf70f4430a142" category="cell">ADS Kubernetes 클러스터(Base64 컴팩트 JSON)용 자격 증명</block>
  <block id="e5f77e38f271802a5a75ecdffe577104" category="cell">"서버 = 4.1"</block>
  <block id="2949ef191693d444cc1f96962c1fd8ae" category="cell">'autoExportPolicy'가 설정된 경우 Kubernetes 노드 IP를 필터링하기 위한 CIDR 목록입니다</block>
  <block id="1abbe16b7053d16fb89efaebd94484be" category="cell">["0.0.0.0/0","::/0"]</block>
  <block id="857a0a2e6dd17cb6e0022d80855b338a" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: {"api":false, "method":true}</block>
  <block id="0ffdeb640d4a5fc9f33736feec8d274f" category="admonition">YAML에서 kubecononfig 값을 컴팩트 JSON 형식으로 변환한 다음 백엔드 구성에 포함시키기 전에 Base64 형식으로 변환해야 합니다.</block>
  <block id="5ef844cc326d7b10c0f674ac9b2b3c74" category="paragraph">각 백엔드는 ADS를 호스팅하는 Kubernetes 클러스터의 단일 네임스페이스로 볼륨을 프로비저닝합니다. 다른 네임스페이스에서 볼륨을 만들려면 추가 백엔드를 정의할 수 있습니다. ADS 볼륨은 호스팅 클러스터, 기타 Kubernetes 클러스터 또는 NFS 공유를 마운트할 수 있는 다른 모든 네임스페이스에 연결할 수 있습니다.</block>
  <block id="f2319c1b13782c7170018cdd5fb7fd49" category="paragraph">구성 파일의 특수 섹션에서 이러한 옵션을 사용하여 각 볼륨의 기본 프로비저닝을 제어할 수 있습니다.</block>
  <block id="77c62856cfaac230e7c2fd8139d7c2c8" category="paragraph">아래의 구성 예를 참조하십시오.</block>
  <block id="ef616ce0e78a1254437e682f723bb5e6" category="cell">새 볼륨의 모드는 8진이어야 하며 "0"으로 시작해야 합니다.</block>
  <block id="6474dd374337126fa99c86e653ebfd64" category="cell">"0777"</block>
  <block id="5964a48430cb8e8190dbd855a8514a0c" category="cell">"5"</block>
  <block id="115261f04e7f7d964bc608b63a82b482" category="cell">생성된 볼륨에 할당할 QoS 정책</block>
  <block id="9d4568c009d203ab10e33ea9953a0264" category="cell">""</block>
  <block id="cf04ead37df0a76237b27de327c0cd03" category="admonition">ADS 백엔드에서 생성된 모든 볼륨에 대해 Astra Trident는 스토리지 풀에 있는 모든 레이블을 프로비저닝할 때 스토리지 볼륨으로 복사합니다. 스토리지 관리자는 스토리지 풀별로 레이블을 정의하고 스토리지 풀별로 생성된 모든 볼륨을 그룹화할 수 있습니다. 이를 통해 백엔드 구성 파일에 제공되는 사용자 지정 가능한 레이블 세트를 기반으로 볼륨을 쉽게 구별할 수 있습니다.</block>
  <block id="b53453343f074fd64ef7129def93f57d" category="section-title">예 1: 최소 백엔드 구성</block>
  <block id="8f3db75549f212e0fdab2c542531a95e" category="paragraph">이 예에서는 Astra Trident에서 생성한 모든 스토리지에 동일한 측면을 적용하는 백엔드 파일을 보여 줍니다.</block>
  <block id="a2c81e41622f2e2616b33a689e229c72" category="paragraph">다음 StorageClass 정의는 위의 스토리지 풀을 참조합니다. "parameters.selector` 필드를 사용하여 각 StorageClass에 볼륨을 호스팅하는 데 사용되는 가상 풀을 지정할 수 있습니다. 선택한 가상 풀에 볼륨이 정의되어 있습니다.</block>
  <block id="7072ec708b0ea7e3243747d8b79c0d20" category="admonition">이전 Trident 릴리스에서 업그레이드하고 Azure NetApp Files를 사용하는 경우 이제 ''location'' config 매개 변수는 필수 싱글톤 필드입니다.</block>
  <block id="b956e1f58f802db57dd9f871ac59ed6c" category="paragraph">중복된 리소스 이름을 허용하고 작업을 단일 위치로 제한하도록 ANF 드라이버를 수정했습니다.</block>
  <block id="851679bec9b3e6c8e6284128fb750b1e" category="list-text">Kubernetes의 향상된 기능:</block>
  <block id="2767b461b2b49786f390c9e0509d2d12" category="list-text">Kubernetes 1.23 지원 추가.</block>
  <block id="7f10502f6f15537f180f07f0c89d2642" category="inline-link-macro">GitHub 문제 #651</block>
  <block id="2ff7a365e7c341f8f381cd7c2a4e15f6" category="list-text">Trident Operator 또는 Hrom을 통해 설치된 Trident Pod에 대한 예약 옵션을 추가합니다. (<block ref="15fbe6dcd60762941b28bc5990803bde" category="inline-link-macro-rx"></block>)</block>
  <block id="90fdd892e78b26eb18a250c9c1bc19ff" category="inline-link-macro">GitHub 문제 #633</block>
  <block id="3ff8e54aa1f3735deb64771c4c65c420" category="list-text">GCP 드라이버에서 지역 간 볼륨을 허용합니다. (<block ref="efd445659801b6abfdba2997e23e5f4f" category="inline-link-macro-rx"></block>)</block>
  <block id="fef8c75d6cd00955b0f1c84d40af01aa" category="inline-link-macro">GitHub 문제 #666</block>
  <block id="9f81aabbbba9f61bfecaf1340c407ed1" category="list-text">ANF 볼륨에 'unixPermissions' 옵션에 대한 지원이 추가되었습니다. (<block ref="b2ee1a79cce917ad1d60b3bec442914a" category="inline-link-macro-rx"></block>)</block>
  <block id="a4233200da50a08b295311036bb03ac1" category="section-title">사용 중단</block>
  <block id="de6284c149d2e011da3909f1ef2af627" category="paragraph">Trident REST 인터페이스는 127.0.0.1 또는 [::1] 주소에서만 수신 및 제공할 수 있습니다</block>
  <block id="b4ffe37e7e4ec63b5a66f2d1ecdbf6c0" category="section-title">Astra Trident 21.10.1의 변경 사항</block>
  <block id="cdb544a92bee555749f43046d53ef34e" category="admonition">v21.10.0 릴리즈에는 노드를 제거한 다음 Kubernetes 클러스터에 다시 추가할 때 Trident 컨트롤러를 CrashLoopBackOff 상태로 전환할 수 있는 문제가 있습니다. 이 문제는 v21.10.1(GitHub 문제 669)에서 해결되었습니다.</block>
  <block id="cd1bf2431d703fd3c62a278b9c812d56" category="list-text">GCP CVS 백엔드에서 볼륨을 가져올 때 잠재적인 경쟁 조건이 수정되어 가져오지 못했습니다.</block>
  <block id="8e1e1dad95de3dc781f25f58483acdf3" category="list-text">노드를 제거할 때 Trident 컨트롤러를 CrashLoopBackOff 상태로 전환할 수 있는 문제를 해결한 다음 Kubernetes 클러스터(GitHub 문제 669)에 다시 추가되었습니다.</block>
  <block id="d7c32cb5ff2be4aaff3a8eaea9d18e0d" category="list-text">SVM 이름이 지정되지 않은 경우 SVM이 더 이상 검색되지 않는 문제 해결(GitHub 문제 612)</block>
  <block id="f306ba062619a23c0afe1a50a50799f6" category="section-title">21.10.0 변경(Astra Trident 21.07 이후)</block>
  <block id="2f1ab5b99f1893144b69718c274415f4" category="paragraph">있습니다 <block ref="a3b750e7ac33c9792c64627692f306aa" category="inline-link-macro-rx"></block> 는 Astra Trident의 REST API와 상호 작용하는 가장 쉬운 방법이며, 원할 경우 REST 엔드포인트를 직접 사용할 수 있습니다.</block>
  <block id="a55b7ee69c26277a1088efc103e15297" category="paragraph">사용 가능한 명령 및 전역 옵션은 다음과 같습니다.</block>
  <block id="94912f7fb206038e8527957b44dfbf25" category="paragraph">그러면 모든 Trident 포드가 다시 시작됩니다. 이 작업은 몇 초 정도 걸릴 수 있습니다. 'kubeck get pod-n trident'의 출력에서 '나이' 열을 관찰하여 이를 확인할 수 있습니다.</block>
  <block id="498784627f42c14468b84a1a351bd462" category="sidebar">ADS 백엔드를 구성합니다</block>
  <block id="fe3b4c5750a12d7254dee5e87c55bb40" category="list-text">Kubernetes 1.17 이상(최신: 1.23)</block>
  <block id="10ae2729ec6b89f9c276ab2da5409336" category="list-text">OpenShift 4.7, 4.8, 4.9</block>
  <block id="f2f0da9b50bd2001bc802c121fc76254" category="admonition">Red Hat OpenShift Container Platform 사용자는 4.6.8 이하의 버전을 사용하는 경우 initiatorname.iscsi 파일이 비어 있는 것을 관찰할 수 있습니다. 이는 RedHat에서 OpenShift 4.6.8로 해결된 버그로, 자세한 내용은 다음을 참조하십시오<block ref="ac064f2337a2fc6c16c562bc9e386352" category="inline-link-rx"></block>. OpenShift 4.6.8 이상에서 Astra Trident를 사용하는 것이 좋습니다.</block>
  <block id="0f6e0df69462b7a5d101ec1a3fa8a376" category="list-text">NetApp HCI/Element 소프트웨어 11 이상</block>
  <block id="597a56086e1f9d7ca5e8f55c40a0153a" category="list-text">OpenShift Container Platform에서 지원하는 RedHat CoreOS(RHCOS) 버전</block>
  <block id="0e3db22955e0ef2a04155e743fdcd843" category="list-text">NetApp/트리덴트 - AutoSupport: 22.01</block>
  <block id="52d5de12f37c2ff6a4de253d20947ca2" category="list-text">K8s.GCR.IO/SIG-storage/CSI-attacher:v3.4.0</block>
  <block id="f86452b351d644230a6ab4c2d580e193" category="list-text">K8s.GCR.IO/SIG-storage/CSI-node-driver-registrar: v2.4.0</block>
  <block id="ad9d572821da9bfff3397f2d3260509d" category="list-text">K8s.GCR.IO/SIG-스토리지/CSI-공급자:v3.1.0</block>
  <block id="73e93ad328287e5ce4c06228cfdba2bf" category="cell">v1.23.0</block>
  <block id="08ee53e1d5cefb7967a295e98036598e" category="cell">스냅샷 디렉터리의 표시 여부를 제어합니다</block>
  <block id="9837781971083d3fe119b0217014d301" category="list-text">하나 이상의 Azure 위치가 있다<block ref="c5f14b2142014dc234282a513132bad4" category="inline-link-rx"></block>. Trident 22.01부터 "location" 매개 변수는 백엔드 구성 파일의 최상위 수준에 있는 필수 필드입니다. 가상 풀에 지정된 위치 값은 무시됩니다.</block>
  <block id="3d1c87b616fe621310b766603b6c175d" category="admonition">참고: Astra Trident는 수동 QoS 용량 풀을 지원하지 않습니다.</block>
  <block id="016a4b469916e37291cfe2f7fab49aaf" category="cell">[재치 단체</block>
  <block id="66d09fbe1165f3d10b368cbe0cc029f4" category="cell">검색된 자원을 필터링하기 위한 자원 그룹 목록입니다</block>
  <block id="36cbcb8a57112362b05d06b9fe037a6e" category="cell">"[]"(필터 없음)</block>
  <block id="d4b4343f054233d7d339bb1501425fd4" category="cell">'netap계정'</block>
  <block id="61476ef20a8015760b9cb3c1bd0ea435" category="cell">검색된 리소스를 필터링하기 위한 NetApp 계정의 목록입니다</block>
  <block id="722c7b4409fa4d1fe6aaa2902ae66473" category="cell">용량풀</block>
  <block id="225abbb59bc0bbaa2a5852ada333b31b" category="cell">검색된 리소스를 필터링하기 위한 용량 풀 목록입니다</block>
  <block id="f2a5b99a63a463017b3e5f5848444d9a" category="cell">"[]"(필터 없음, 임의)</block>
  <block id="91b3c29beb3641dce2fcf3d2382fac4f" category="cell">문제 해결 시 사용할 디버그 플래그입니다. 예: "\{"api":false, "method":true, "discovery":true}". 문제 해결 중이 아니며 자세한 로그 덤프가 필요한 경우가 아니면 이 방법을 사용하지 마십시오.</block>
  <block id="b025cb91ea905e0ae1a879fe81e5ff18" category="admonition">NFS 버전 4.1을 사용하여 볼륨을 마운트하려는 경우 쉼표로 구분된 마운트 옵션 목록에 ''nfsvers=4'를 포함하여 NFS v4.1을 선택할 수 있습니다. 스토리지 클래스에 설정된 마운트 옵션은 백엔드 구성 파일에 설정된 마운트 옵션을 재정의합니다.</block>
  <block id="eaea97dbd365f00421eb397e8eabeebf" category="paragraph">"소스 그룹", "넷계정", "용량 풀", "virtualNetwork" 및 "ubnet"의 값은 짧은 이름 또는 정규화된 이름을 사용하여 지정할 수 있습니다. 짧은 이름은 이름이 같은 여러 리소스와 일치할 수 있으므로 대부분의 경우 정규화된 이름을 사용하는 것이 좋습니다. "소스 그룹", "netap계정" 및 "용량 풀" 값은 검색된 리소스 세트를 이 스토리지 백엔드에서 사용할 수 있는 리소스로 제한하며 어떤 조합으로도 지정할 수 있는 필터입니다. 정규화된 이름은 다음 형식입니다.</block>
  <block id="520d0db389f362bf79ef56ca0af3dcab" category="cell">형식</block>
  <block id="dde92bca1b59f0db813ef42a2688752e" category="cell">리소스 그룹</block>
  <block id="671e72ca3ef632233f4c27dfef1ec109" category="cell">리소스 그룹&gt;</block>
  <block id="ac252743de820aac9183d9f76d4bed67" category="cell">NetApp 계정</block>
  <block id="2bf2783c6d0d867a9fe629138b38bd84" category="cell">리소스 그룹&gt;/&lt;NetApp 계정&gt;</block>
  <block id="9eea1c08013c37f1499f428378764a08" category="cell">용량 풀</block>
  <block id="01c656d6b97f45a90022ee307283ae01" category="cell">리소스 그룹&gt;/&lt;NetApp 계정&gt;/&lt;용량 풀&gt;</block>
  <block id="bf76cafc47141522dca89c4d6e25b822" category="cell">가상 네트워크</block>
  <block id="8c9309282517a29ad09b10443d825c7c" category="cell">리소스 그룹&gt;/&lt;가상 네트워크&gt;</block>
  <block id="9770c6469e9d27585d6c0c389ede7bc3" category="cell">서브넷</block>
  <block id="7addf9faaab78a084548d05b695cd2e2" category="cell">리소스 그룹&gt;/&lt;가상 네트워크&gt;/&lt;서브넷&gt;</block>
  <block id="3e71a01ee522f366b6eeb2990e170fde" category="cell">새 볼륨의 UNIX 사용 권한(8진수 4자리)</block>
  <block id="976a6dc52dbcabb541efa0a91e922604" category="cell">""(미리보기 기능, 가입 시 화이트리스트 필요)</block>
  <block id="54042b89155d99a3568a196cb5ff1da8" category="paragraph">이는 절대적인 최소 백엔드 구성입니다. 이 구성을 통해 Astra Trident는 구성된 위치에서 ANF에 위임된 모든 NetApp 계정, 용량 풀 및 서브넷을 검색하고 해당 풀 및 서브넷 중 하나에 무작위로 새 볼륨을 배치합니다.</block>
  <block id="a78703e6fcb2511d5a565496df5b2082" category="section-title">예 2: 용량 풀 필터를 사용하는 특정 서비스 수준 구성</block>
  <block id="6da664b0342ea1be008211c33f1eb020" category="paragraph">이 백엔드 구성은 Azure의 "eastus" 위치에 볼륨을 "Ultra" 용량 풀에 배치합니다. Astra Trident는 해당 위치의 ANF에 위임된 모든 서브넷을 자동으로 검색하여 그 중 하나에 무작위로 새 볼륨을 배치합니다.</block>
  <block id="b0f4f0ac7ea6be4c3047dd422c23539b" category="paragraph">Astra Trident 22.01을 실행하지 않는 경우 이전 릴리스에 대한 문서를 사용할 수 있습니다.</block>
  <block id="cce172403b73af5c2a4e93081affcc7f" category="inline-link">Astra Trident 21.10</block>
  <block id="606b9e83fb467a43b3065d4fd5037094" category="list-text"><block ref="606b9e83fb467a43b3065d4fd5037094" category="inline-link-rx"></block></block>
  <block id="ee50d481128d1543f9945b4a4f3fbe9d" category="paragraph">공기 박형 설치의 경우 다음 목록은 Astra Trident를 설치하는 데 필요한 컨테이너 이미지의 참조입니다. tridentctl images 명령을 사용하여 필요한 컨테이너 영상의 목록을 확인합니다.</block>
  <block id="ec3f9af8f611100a0182ffb9ab2e5ef8" category="paragraph">ONTAP 내에서 Trident 드라이버가 사용할 수 있는 보다 제한적인 역할을 만들 수 있지만 권장하지 않습니다. Trident의 대부분의 새로운 릴리즈에서는 추가 API를 호출하므로 업그레이드가 어렵고 오류가 발생하기 쉽습니다.</block>
  <block id="ee50ce7340da5b018abe62c8e613cae0" category="summary">Astra Trident는 Trident Orchestrator를 위한 여러 명령줄 옵션을 공개하고 특정 포트를 통해 통신합니다.</block>
  <block id="94efe0c9471991c69d2a3b0970a56744" category="paragraph">Astra Trident는 Trident Orchestrator를 위한 여러 명령줄 옵션을 제공합니다. 이러한 옵션을 사용하여 배포를 수정할 수 있습니다.</block>
  <block id="be1c3d3113c4023e29e8dd947523c711" category="inline-link">Astra Data Store 문서</block>
  <block id="c54241e3258a450b02a723d6d751a4f1" category="list-text"><block ref="c54241e3258a450b02a723d6d751a4f1" category="inline-link-rx"></block></block>
  <block id="55f3fc550e9a03a95334f3a19f0920cc" category="cell">solidfire-SAN, ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN-이코노미, eseries-iSCSI가 있습니다</block>
  <block id="6add71a247c8f4513060920be14857bc" category="cell">allowVolumeExpansion</block>
  <block id="84e2c64f38f78ba3ea5c905ab5a2da27" category="cell">부울</block>
  <block id="675e3f37a9adfd7ab6433906c490fa06" category="cell">PVC 크기 증가에 대한 지원을 활성화 또는 비활성화합니다</block>
  <block id="c791531450eeeb073b30215d9c306a00" category="cell">1.11+</block>
  <block id="086b513e7d83c4cf32a8bd3550679276" category="cell">볼륨BindingMode 를 선택합니다</block>
  <block id="fd656a4f359aa12808a6d0ceb5792342" category="cell">Immediate, WaitForFirstConsumer입니다</block>
  <block id="5e7777e1f9cfa3a93159ee44cf3f1f5a" category="cell">볼륨 바인딩 및 동적 프로비저닝이 수행될 시기를 선택합니다</block>
  <block id="9c26b95cff78678b07389bb95544c7b6" category="cell">1.17+</block>
  <block id="8264769021597389583b0a7d1fa7e076" category="inline-link-macro">Kubernetes: Pod 또는 컨테이너의 보안 컨텍스트를 구성합니다</block>
  <block id="dca8809f382a96564d64ae1525b39048" category="list-text">'fsType' 매개 변수는 SAN LUN에 대해 원하는 파일 시스템 유형을 제어하는 데 사용됩니다. 또한 Kubernetes는 스토리지 클래스에 'fsType'이 있음을 사용하여 파일 시스템이 있음을 나타냅니다. fsType이 설정된 경우에만 POD의 fsGroup 보안 컨텍스트를 사용하여 볼륨 소유권을 제어할 수 있습니다. 을 참조하십시오 <block ref="7940a62969e5aeae7f6e32b04e7a11e3" category="inline-link-macro-rx"></block> 'fsGroup' 컨텍스트를 사용하여 볼륨 소유권을 설정하는 방법에 대한 개요를 제공합니다. Kubernetes는 다음과 같은 경우에만 'fsGroup' 값을 적용합니다.</block>
  <block id="6dd29ca7439e52dcf2fbc569066b3d67" category="list-text">스토리지 클래스에 fsType이 설정되어 있습니다.</block>
  <block id="45d2174daba36b76955e69d2eddf26ca" category="list-text">PVC 액세스 모드는 RWO입니다.</block>
  <block id="ba5b62efad4f90a8f4bb806cba4a3ea4" category="paragraph">NFS 스토리지 드라이버의 경우 파일 시스템이 NFS 내보내기의 일부로 이미 존재합니다. fsGroup을 사용하려면 스토리지 클래스가 여전히 fsType을 지정해야 합니다. NFS 또는 null이 아닌 값으로 설정할 수 있습니다.</block>
  <block id="4811aaaf5eedea1ea9f703353903b5b5" category="list-text">을 참조하십시오 <block ref="c35b155baa39b6aa36cf9bc59eea88f3" category="inline-link-macro-rx"></block> 볼륨 확장에 대한 자세한 내용은 를 참조하십시오.</block>
  <block id="853119066470e5145f87024e7c6accdb" category="cell">ONTAP-NAS, ONTAP-NAS-이코노미, ONTAP-NAS-Flexgroup, ONTAP-SAN, ONTAP-SAN-이코노미, solidfire-SAN, AWS-CV, GCP-CV, Azure-NetApp 파일</block>
  <block id="23038d88eea805ac06a26959fc129ca5" category="admonition">NetApp Aggregate Encryption(NAE)은 현재 Trident에서 지원되지 않습니다.</block>
  <block id="18cf072964a583150dd247485ba75b92" category="admonition-title">ONTAP용 Amazon FSx</block>
  <block id="fa8bc73a8436dd2f79aafaa731d248e4" category="list-text">limitAggregateUsage 매개변수는 vsadmin과 fsxadmin 사용자 계정에서는 작동하지 않습니다. 이 매개 변수를 지정하면 구성 작업이 실패합니다.</block>
  <block id="c7e012baf676feb8d925d8f535c01c02" category="list-text">NetApp ONTAP 볼륨용 Amazon FSx는 SnapMirror와 함께 사전 구성되어 제공됩니다. Trident는 수정하거나 분리할 수 없습니다. PVC를 삭제하려면 PV 및 FSx for NetApp ONTAP 볼륨을 수동으로 삭제해야 합니다.</block>
  <block id="7b3ecf601e0eee1c9d097083281abafa" category="example-title">예를 확장합니다</block>
  <block id="76df2d4e2a105a35b5db1ce7b060bbe1" category="list-text">Anthos On-Premise(VMware) 및 Anthos의 Bare Metal 1.8, 1.9, 1.10</block>
  <block id="9c99c91edd7eddead4f870a324f880bd" category="list-text">Trident의 제어 리포지토리 추가:</block>
  <block id="b9baa6fa560066bf0c9e87d66d1c0664" category="doc">Astra Trident 22.01.1 문서</block>
  <block id="583a5308ed42c99426f964d094ea527d" category="list-text">NetApp/트리덴트: 22.01.1</block>
  <block id="e2393935037062665875a528ef53dd36" category="list-text">NetApp/트리덴트 - 운영자: 22.01.1(선택 사항)</block>
  <block id="6e7239a6c6cfd378a1e55314b7490e32" category="section-title">22.01.1의 새로운 기능</block>
  <block id="368b120a3b5f53a49dc3ab96ec9b8dbd" category="paragraph">NetApp은 제품과 서비스를 지속적으로 개선 및 개선하고 있습니다. Astra Trident의 최신 기능 몇 가지를 소개합니다. 이전 릴리스는 를 참조하십시오<block ref="25da125dffad1d6323c21354bccf0203" category="inline-link-rx"></block>.</block>
  <block id="a98b2ebbcbb381d3abc81e2ecfb2054c" category="inline-link-macro">GitHub 문제 #691</block>
  <block id="61465c1d4383dd4afdf168925e15e767" category="list-text">삭제된 노드에서 볼륨 게시를 취소하는 문제 해결 (<block ref="5fee6ab43e8008edba54375694a29266" category="inline-link-macro-rx"></block>)</block>
  <block id="e50f1057ba4b67b255c98fa09c5ba6f8" category="list-text">ONTAP API 응답에서 공간 집계에 대한 nil 필드에 액세스할 때 패닉이 수정되었습니다.</block>
  <block id="f064e09978a6df920139de5d0ebddd77" category="section-title">22.01.0 변경(22.10.1 이후)</block>
  <block id="3c72f47eeb46270dd13a77b32ec10dd3" category="list-text">* Kubernetes: * 대규모 클러스터의 노드 등록 백오프 재시도 시간을 늘립니다.</block>
  <block id="0ef48234390855900384d0bc8a0a8a24" category="list-text">동일한 이름의 여러 리소스가 Azure-NetApp-files 드라이버를 혼동할 수 있는 문제 해결</block>
  <block id="7eaa7391130c13b3bf9a7e4ae755d908" category="list-text">ONTAP SAN IPv6 데이터 LIF는 이제 대괄호와 함께 지정된 경우 작동합니다.</block>
  <block id="404cef2e43cb97ccef52692419ad6f6b" category="inline-link-macro">GitHub 문제 #489</block>
  <block id="7213ed07f5b718aa66cfac350f023a77" category="list-text">이미 가져온 볼륨을 가져오려고 하면 PVC가 보류 상태로 남겨둔 EOF가 반환되는 문제가 해결되었습니다. (<block ref="b9a2290d6389b9a605883cda4e717749" category="inline-link-macro-rx"></block>)</block>
  <block id="c28d8c94f865f3ef7e4b01a157510ef6" category="list-text">SolidFire 볼륨에 32개 이상의 스냅샷을 생성할 때 Astra Trident 성능이 느려지는 문제를 해결했습니다.</block>
  <block id="d0aaca968285d0d47ea0c5a0f7b9bab5" category="list-text">SHA-1을 SSL 인증서 생성에서 SHA-256으로 교체했습니다.</block>
  <block id="92e6030d252cfd43e0567e282a0d2c9b" category="paragraph">Astra Trident는 을 사용하여 Kubernetes 클러스터에 있는 노드를 선택적으로 생성하여 연결할 수 있습니다<block ref="80b9a4f4a1bc9851317207ee3477041a" category="inline-link-rx"></block>. CSI 토폴로지 기능을 사용하면 지역 및 가용성 영역에 따라 볼륨에 대한 액세스가 노드의 하위 집합으로 제한될 수 있습니다. 오늘날의 클라우드 공급자는 Kubernetes 관리자가 영역 기반의 노드를 생성할 수 있습니다. 노드는 지역 내 또는 여러 지역의 여러 가용성 영역에 위치할 수 있습니다. Astra Trident는 다중 영역 아키텍처에서 워크로드용 볼륨 프로비저닝을 지원하기 위해 CSI 토폴로지를 사용합니다.</block>
  <block id="d293f031e5664526b25f3a65012401b7" category="cell">'IPv6'</block>
  <block id="82ac2196255f9b53a51cdc28bcf73966" category="paragraph">다음은 노드 선택기를 사용하여 Trident를 구축하는 방법을 보여 주는 또 다른 예입니다.</block>
  <block id="997cff957213b9212a22d7cac2b4275d" category="list-text">생성된 인증서를 사용하여 인증을 테스트합니다. ONTAP 관리 LIF&gt; 및 &lt;SVM 이름&gt;을 관리 LIF IP 및 SVM 이름으로 바꿉니다. LIF의 서비스 정책이 'default-data-management'로 설정되어 있는지 확인해야 합니다.</block>
</blocks>